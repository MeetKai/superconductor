var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all6) => {
  for (var name10 in all6)
    __defProp(target, name10, { get: all6[name10], enumerable: true });
};
var __copyProps = (to, from5, except, desc) => {
  if (from5 && typeof from5 === "object" || typeof from5 === "function") {
    for (let key of __getOwnPropNames(from5))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from5[key], enumerable: !(desc = __getOwnPropDesc(from5, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target, mod2));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// node_modules/process/browser.js
var require_browser = __commonJS({
  "node_modules/process/browser.js"(exports2, module2) {
    init_globals();
    var process5 = module2.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process5.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process5.title = "browser";
    process5.browser = true;
    process5.env = {};
    process5.argv = [];
    process5.version = "";
    process5.versions = {};
    function noop2() {
    }
    process5.on = noop2;
    process5.addListener = noop2;
    process5.once = noop2;
    process5.off = noop2;
    process5.removeListener = noop2;
    process5.removeAllListeners = noop2;
    process5.emit = noop2;
    process5.prependListener = noop2;
    process5.prependOnceListener = noop2;
    process5.listeners = function(name10) {
      return [];
    };
    process5.binding = function(name10) {
      throw new Error("process.binding is not supported");
    };
    process5.cwd = function() {
      return "/";
    };
    process5.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process5.umask = function() {
      return 0;
    };
  }
});

// globals.js
var global, process;
var init_globals = __esm({
  "globals.js"() {
    global = window;
    process = require_browser();
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "node_modules/merge-options/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name10, value) => Object.defineProperty(object, name10, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports2;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys2 = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys2.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol of symbols) {
          if (propertyIsEnumerable.call(value, symbol)) {
            keys2.push(symbol);
          }
        }
      }
      return keys2;
    };
    function clone(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone(array[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys2, config2) => {
      keys2.forEach((key) => {
        if (typeof source[key] === "undefined" && config2.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge5(merged[key], source[key], config2));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config2) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config2);
      });
      return result;
    };
    function merge5(merged, source, config2) {
      if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config2);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
    }
    module2.exports = function(...options) {
      const config2 = merge5(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge5(merged, { _: option }, config2);
      }
      return merged._;
    };
  }
});

// node_modules/is-electron/index.js
var require_is_electron = __commonJS({
  "node_modules/is-electron/index.js"(exports2, module2) {
    init_globals();
    function isElectron() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    module2.exports = isElectron;
  }
});

// node_modules/ipfs-utils/src/env.js
var require_env = __commonJS({
  "node_modules/ipfs-utils/src/env.js"(exports2, module2) {
    "use strict";
    init_globals();
    var isElectron = require_is_electron();
    var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
    var IS_ELECTRON = isElectron();
    var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
    var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
    var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
    var IS_NODE = typeof __require === "function" && typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !IS_ELECTRON;
    var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    var IS_TEST = typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env.NODE_ENV === "test";
    var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    module2.exports = {
      isTest: IS_TEST,
      isElectron: IS_ELECTRON,
      isElectronMain: IS_ELECTRON_MAIN,
      isElectronRenderer: IS_ELECTRON_RENDERER,
      isNode: IS_NODE,
      isBrowser: IS_BROWSER,
      isWebWorker: IS_WEBWORKER,
      isEnvWithDom: IS_ENV_WITH_DOM,
      isReactNative: IS_REACT_NATIVE
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    init_globals();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name10) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name10 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    init_globals();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce3;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace3) {
        let hash2 = 0;
        for (let i = 0; i < namespace3.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace3.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace3) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug50(...args) {
          if (!debug50.enabled) {
            return;
          }
          const self2 = debug50;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug50.namespace = namespace3;
        debug50.useColors = createDebug.useColors();
        debug50.color = createDebug.selectColor(namespace3);
        debug50.extend = extend;
        debug50.destroy = createDebug.destroy;
        Object.defineProperty(debug50, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace3);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug50);
        }
        return debug50;
      }
      function extend(namespace3, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace3);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace3) => "-" + namespace3)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name10) {
        if (name10[name10.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name10)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name10)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce3(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    init_globals();
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code13, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code13 === "object") {
        props = code13;
        code13 = "";
      }
      if (code13) {
        props.code = code13;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve11, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve11.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    init_globals();
    var base643 = exports2;
    base643.length = function length5(string3) {
      var p = string3.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string3.charAt(p) === "=")
        ++n;
      return Math.ceil(string3.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base643.encode = function encode19(buffer3, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer3[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base643.decode = function decode22(string3, buffer3, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string3.length; ) {
        var c = string3.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer3[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer3[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer3[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base643.test = function test(string3) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string3);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = EventEmitter4;
    function EventEmitter4() {
      this._listeners = {};
    }
    EventEmitter4.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter4.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter4.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf3, pos) {
            f32[0] = val;
            buf3[pos] = f8b[0];
            buf3[pos + 1] = f8b[1];
            buf3[pos + 2] = f8b[2];
            buf3[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf3, pos) {
            f32[0] = val;
            buf3[pos] = f8b[3];
            buf3[pos + 1] = f8b[2];
            buf3[pos + 2] = f8b[1];
            buf3[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf3, pos) {
            f8b[0] = buf3[pos];
            f8b[1] = buf3[pos + 1];
            f8b[2] = buf3[pos + 2];
            f8b[3] = buf3[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf3, pos) {
            f8b[3] = buf3[pos];
            f8b[2] = buf3[pos + 1];
            f8b[1] = buf3[pos + 2];
            f8b[0] = buf3[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf3, pos) {
            var sign3 = val < 0 ? 1 : 0;
            if (sign3)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? 0 : 2147483648, buf3, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf3, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign3 << 31 | 2139095040) >>> 0, buf3, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign3 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf3, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign3 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf3, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf3, pos) {
            var uint = readUint(buf3, pos), sign3 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 1401298464324817e-60 * mantissa : sign3 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf3, pos) {
            f64[0] = val;
            buf3[pos] = f8b[0];
            buf3[pos + 1] = f8b[1];
            buf3[pos + 2] = f8b[2];
            buf3[pos + 3] = f8b[3];
            buf3[pos + 4] = f8b[4];
            buf3[pos + 5] = f8b[5];
            buf3[pos + 6] = f8b[6];
            buf3[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf3, pos) {
            f64[0] = val;
            buf3[pos] = f8b[7];
            buf3[pos + 1] = f8b[6];
            buf3[pos + 2] = f8b[5];
            buf3[pos + 3] = f8b[4];
            buf3[pos + 4] = f8b[3];
            buf3[pos + 5] = f8b[2];
            buf3[pos + 6] = f8b[1];
            buf3[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf3, pos) {
            f8b[0] = buf3[pos];
            f8b[1] = buf3[pos + 1];
            f8b[2] = buf3[pos + 2];
            f8b[3] = buf3[pos + 3];
            f8b[4] = buf3[pos + 4];
            f8b[5] = buf3[pos + 5];
            f8b[6] = buf3[pos + 6];
            f8b[7] = buf3[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf3, pos) {
            f8b[7] = buf3[pos];
            f8b[6] = buf3[pos + 1];
            f8b[5] = buf3[pos + 2];
            f8b[4] = buf3[pos + 3];
            f8b[3] = buf3[pos + 4];
            f8b[2] = buf3[pos + 5];
            f8b[1] = buf3[pos + 6];
            f8b[0] = buf3[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf3, pos) {
            var sign3 = val < 0 ? 1 : 0;
            if (sign3)
              val = -val;
            if (val === 0) {
              writeUint(0, buf3, pos + off0);
              writeUint(1 / val > 0 ? 0 : 2147483648, buf3, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf3, pos + off0);
              writeUint(2146959360, buf3, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf3, pos + off0);
              writeUint((sign3 << 31 | 2146435072) >>> 0, buf3, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf3, pos + off0);
                writeUint((sign3 << 31 | mantissa / 4294967296) >>> 0, buf3, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf3, pos + off0);
                writeUint((sign3 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf3, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf3, pos) {
            var lo = readUint(buf3, pos + off0), hi = readUint(buf3, pos + off1);
            var sign3 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 5e-324 * mantissa : sign3 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf3, pos) {
      buf3[pos] = val & 255;
      buf3[pos + 1] = val >>> 8 & 255;
      buf3[pos + 2] = val >>> 16 & 255;
      buf3[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf3, pos) {
      buf3[pos] = val >>> 24;
      buf3[pos + 1] = val >>> 16 & 255;
      buf3[pos + 2] = val >>> 8 & 255;
      buf3[pos + 3] = val & 255;
    }
    function readUintLE(buf3, pos) {
      return (buf3[pos] | buf3[pos + 1] << 8 | buf3[pos + 2] << 16 | buf3[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf3, pos) {
      return (buf3[pos] << 24 | buf3[pos + 1] << 16 | buf3[pos + 2] << 8 | buf3[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    init_globals();
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    init_globals();
    var utf8 = exports2;
    utf8.length = function utf8_length(string3) {
      var len = 0, c = 0;
      for (var i = 0; i < string3.length; ++i) {
        c = string3.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string3.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer3, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer3[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer3[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer3[start++] & 63) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string3, buffer3, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string3.length; ++i) {
        c1 = string3.charCodeAt(i);
        if (c1 < 128) {
          buffer3[offset++] = c1;
        } else if (c1 < 2048) {
          buffer3[offset++] = c1 >> 6 | 192;
          buffer3[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string3.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer3[offset++] = c1 >> 18 | 240;
          buffer3[offset++] = c1 >> 12 & 63 | 128;
          buffer3[offset++] = c1 >> 6 & 63 | 128;
          buffer3[offset++] = c1 & 63 | 128;
        } else {
          buffer3[offset++] = c1 >> 12 | 224;
          buffer3[offset++] = c1 >> 6 & 63 | 128;
          buffer3[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = pool;
    function pool(alloc3, slice3, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc3(size2);
        if (offset + size2 > SIZE) {
          slab = alloc3(SIZE);
          offset = 0;
        }
        var buf3 = slice3.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf3;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign3 = value < 0;
      if (sign3)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign3) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from5(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits((charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0, (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0);
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length5() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    init_globals();
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util.isInteger = Number.isInteger || function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge5(dst, src3, ifNotSet) {
      for (var keys2 = Object.keys(src3), i = 0; i < keys2.length; ++i)
        if (dst[keys2[i]] === void 0 || !ifNotSet)
          dst[keys2[i]] = src3[keys2[i]];
      return dst;
    }
    util.merge = merge5;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name10) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge5(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name10;
      } });
      CustomError.prototype.toString = function toString6() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys2 = Object.keys(this), i2 = keys2.length - 1; i2 > -1; --i2)
          if (fieldMap[keys2[i2]] === 1 && this[keys2[i2]] !== void 0 && this[keys2[i2]] !== null)
            return keys2[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name10) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name10)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base643 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create9 = function create10() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create9();
    Writer.alloc = function alloc3(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf3, pos) {
      buf3[pos] = val & 255;
    }
    function writeVarint32(val, buf3, pos) {
      while (val > 127) {
        buf3[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf3[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf3, pos) {
      while (val.hi) {
        buf3[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf3[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf3[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf3, pos) {
      buf3[pos] = val & 255;
      buf3[pos + 1] = val >>> 8 & 255;
      buf3[pos + 2] = val >>> 16 & 255;
      buf3[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf3, pos) {
      buf3.set(val, pos);
    } : function writeBytes_for(val, buf3, pos) {
      for (var i = 0; i < val.length; ++i)
        buf3[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf3 = Writer.alloc(len = base643.length(value));
        base643.decode(value, buf3, 0);
        value = buf3;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf3 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf3, pos);
        pos += head.len;
        head = head.next;
      }
      return buf3;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create9();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf3, pos) {
        buf3.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf3, pos) {
        if (val.copy)
          val.copy(buf3, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf3[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf3, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf3, pos);
      else if (buf3.utf8Write)
        buf3.utf8Write(val, pos);
      else
        buf3.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer3) {
      this.buf = buffer3;
      this.pos = 0;
      this.len = buffer3.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer3) {
      if (buffer3 instanceof Uint8Array || Array.isArray(buffer3))
        return new Reader(buffer3);
      throw Error("illegal buffer");
    } : function create_array2(buffer3) {
      if (Array.isArray(buffer3))
        return new Reader(buffer3);
      throw Error("illegal buffer");
    };
    var create9 = function create10() {
      return util.Buffer ? function create_buffer_setup(buffer3) {
        return (Reader.create = function create_buffer(buffer4) {
          return util.Buffer.isBuffer(buffer4) ? new BufferReader(buffer4) : create_array(buffer4);
        })(buffer3);
      } : create_array;
    };
    Reader.create = create9();
    Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf3, end) {
      return (buf3[end - 4] | buf3[end - 3] << 8 | buf3[end - 2] << 16 | buf3[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length5 = this.uint32(), start = this.pos, end = this.pos + length5;
      if (end > this.len)
        throw indexOutOfRange(this, length5);
      this.pos += length5;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes2 = this.bytes();
      return utf8.read(bytes2, 0, bytes2.length);
    };
    Reader.prototype.skip = function skip(length5) {
      if (typeof length5 === "number") {
        if (this.pos + length5 > this.len)
          throw indexOutOfRange(this, length5);
        this.pos += length5;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create9();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : "toNumber";
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer3) {
      Reader.call(this, buffer3);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = Service2;
    var util = require_minimal();
    (Service2.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service2;
    function Service2(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service2.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
          if (err) {
            self2.emit("error", err, method);
            return callback(err);
          }
          if (response === null) {
            self2.end(true);
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
          }
          self2.emit("data", response, method);
          return callback(null, response);
        });
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service2.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    init_globals();
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    init_globals();
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure2;
    function configure2() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure2();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = require_index_minimal();
  }
});

// node_modules/multiformats/esm/vendor/varint.js
function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode.bytes = offset - oldOffset + 1;
  return out;
}
function read(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var encode_1, MSB, REST, MSBALL, INT, decode, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
var init_varint = __esm({
  "node_modules/multiformats/esm/vendor/varint.js"() {
    init_globals();
    encode_1 = encode;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});

// node_modules/multiformats/esm/src/varint.js
var decode2, encodeTo, encodingLength;
var init_varint2 = __esm({
  "node_modules/multiformats/esm/src/varint.js"() {
    init_globals();
    init_varint();
    decode2 = (data) => {
      const code13 = varint_default.decode(data);
      return [
        code13,
        varint_default.decode.bytes
      ];
    };
    encodeTo = (int, target, offset = 0) => {
      varint_default.encode(int, target, offset);
      return target;
    };
    encodingLength = (int) => {
      return varint_default.encodingLength(int);
    };
  }
});

// node_modules/multiformats/esm/src/bytes.js
var bytes_exports = {};
__export(bytes_exports, {
  coerce: () => coerce,
  empty: () => empty,
  equals: () => equals,
  fromHex: () => fromHex,
  fromString: () => fromString,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString
});
var empty, toHex, fromHex, equals, coerce, isBinary, fromString, toString;
var init_bytes = __esm({
  "node_modules/multiformats/esm/src/bytes.js"() {
    init_globals();
    empty = new Uint8Array(0);
    toHex = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
    fromHex = (hex) => {
      const hexes = hex.match(/../g);
      return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty;
    };
    equals = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    isBinary = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
    fromString = (str) => new TextEncoder().encode(str);
    toString = (b) => new TextDecoder().decode(b);
  }
});

// node_modules/multiformats/esm/src/hashes/digest.js
var digest_exports = {};
__export(digest_exports, {
  Digest: () => Digest,
  create: () => create,
  decode: () => decode3,
  equals: () => equals2
});
var create, decode3, equals2, Digest;
var init_digest = __esm({
  "node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_globals();
    init_bytes();
    init_varint2();
    create = (code13, digest3) => {
      const size = digest3.byteLength;
      const sizeOffset = encodingLength(code13);
      const digestOffset = sizeOffset + encodingLength(size);
      const bytes2 = new Uint8Array(digestOffset + size);
      encodeTo(code13, bytes2, 0);
      encodeTo(size, bytes2, sizeOffset);
      bytes2.set(digest3, digestOffset);
      return new Digest(code13, size, digest3, bytes2);
    };
    decode3 = (multihash) => {
      const bytes2 = coerce(multihash);
      const [code13, sizeOffset] = decode2(bytes2);
      const [size, digestOffset] = decode2(bytes2.subarray(sizeOffset));
      const digest3 = bytes2.subarray(sizeOffset + digestOffset);
      if (digest3.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest(code13, size, digest3, bytes2);
    };
    equals2 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
      }
    };
    Digest = class {
      constructor(code13, size, digest3, bytes2) {
        this.code = code13;
        this.size = size;
        this.digest = digest3;
        this.bytes = bytes2;
      }
    };
  }
});

// node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name10) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode19(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length5 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length5) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      pbegin++;
    }
    var it2 = size - length5;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length5 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length5) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length5;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode22(string3) {
    var buffer3 = decodeUnsafe(string3);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name10} character`);
  }
  return {
    encode: encode19,
    decodeUnsafe,
    decode: decode22
  };
}
var src, _brrp__multiformats_scope_baseX, base_x_default;
var init_base_x = __esm({
  "node_modules/multiformats/esm/vendor/base-x.js"() {
    init_globals();
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});

// node_modules/multiformats/esm/src/bases/base.js
var Encoder, Decoder, ComposedDecoder, or, Codec, from, baseX, decode4, encode2, rfc4648;
var init_base = __esm({
  "node_modules/multiformats/esm/src/bases/base.js"() {
    init_globals();
    init_base_x();
    init_bytes();
    Encoder = class {
      constructor(name10, prefix, baseEncode) {
        this.name = name10;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder = class {
      constructor(name10, prefix, baseDecode) {
        this.name = name10;
        this.prefix = prefix;
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          switch (text[0]) {
            case this.prefix: {
              return this.baseDecode(text.slice(1));
            }
            default: {
              throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
          }
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or(this, decoder);
      }
    };
    ComposedDecoder = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or = (left, right) => new ComposedDecoder({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    Codec = class {
      constructor(name10, prefix, baseEncode, baseDecode) {
        this.name = name10;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name10, prefix, baseEncode);
        this.decoder = new Decoder(name10, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    from = ({ name: name10, prefix, encode: encode19, decode: decode22 }) => new Codec(name10, prefix, encode19, decode22);
    baseX = ({ prefix, name: name10, alphabet }) => {
      const { encode: encode19, decode: decode22 } = base_x_default(alphabet, name10);
      return from({
        prefix,
        name: name10,
        encode: encode19,
        decode: (text) => coerce(decode22(text))
      });
    };
    decode4 = (string3, alphabet, bitsPerChar, name10) => {
      const codes = {};
      for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
      }
      let end = string3.length;
      while (string3[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer3 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string3[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name10} character`);
        }
        buffer3 = buffer3 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer3 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer3 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode2 = (data, alphabet, bitsPerChar) => {
      const pad = alphabet[alphabet.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer3 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer3 = buffer3 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask & buffer3 >> bits];
        }
      }
      if (bits) {
        out += alphabet[mask & buffer3 << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc4648 = ({ name: name10, prefix, bitsPerChar, alphabet }) => {
      return from({
        prefix,
        name: name10,
        encode(input) {
          return encode2(input, alphabet, bitsPerChar);
        },
        decode(input) {
          return decode4(input, alphabet, bitsPerChar, name10);
        }
      });
    };
  }
});

// node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc, base58flickr;
var init_base58 = __esm({
  "node_modules/multiformats/esm/src/bases/base58.js"() {
    init_globals();
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
var init_base32 = __esm({
  "node_modules/multiformats/esm/src/bases/base32.js"() {
    init_globals();
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// node_modules/multiformats/esm/src/cid.js
var cid_exports = {};
__export(cid_exports, {
  CID: () => CID
});
var CID, parseCIDtoBytes, toStringV0, toStringV1, DAG_PB_CODE, SHA_256_CODE, encodeCID, cidSymbol, readonly, hidden, version, deprecate, IS_CID_DEPRECATION;
var init_cid = __esm({
  "node_modules/multiformats/esm/src/cid.js"() {
    init_globals();
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID = class {
      constructor(version4, code13, multihash, bytes2) {
        this.code = code13;
        this.version = version4;
        this.multihash = multihash;
        this.bytes = bytes2;
        this.byteOffset = bytes2.byteOffset;
        this.byteLength = bytes2.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code13, multihash } = this;
            if (code13 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code13, digest: digest3 } = this.multihash;
            const multihash = create(code13, digest3);
            return CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base4) {
        const { bytes: bytes2, version: version4, _baseCache } = this;
        switch (version4) {
          case 0:
            return toStringV0(bytes2, _baseCache, base4 || base58btc.encoder);
          default:
            return toStringV1(bytes2, _baseCache, base4 || base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version4, code: code13, multihash, bytes: bytes2 } = value;
          return new CID(version4, code13, multihash, bytes2 || encodeCID(version4, code13, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version4, multihash, code: code13 } = value;
          const digest3 = decode3(multihash);
          return CID.create(version4, code13, digest3);
        } else {
          return null;
        }
      }
      static create(version4, code13, digest3) {
        if (typeof code13 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version4) {
          case 0: {
            if (code13 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new CID(version4, code13, digest3, digest3.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID(version4, code13, digest3.bytes);
            return new CID(version4, code13, digest3, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest3) {
        return CID.create(0, DAG_PB_CODE, digest3);
      }
      static createV1(code13, digest3) {
        return CID.create(1, code13, digest3);
      }
      static decode(bytes2) {
        const [cid, remainder] = CID.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes2) {
        const specs = CID.inspectBytes(bytes2);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest3 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest3) : CID.createV1(specs.codec, digest3);
        return [
          cid,
          bytes2.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length5] = decode2(initialBytes.subarray(offset));
          offset += length5;
          return i;
        };
        let version4 = next();
        let codec = DAG_PB_CODE;
        if (version4 === 18) {
          version4 = 0;
          offset = 0;
        } else if (version4 === 1) {
          codec = next();
        }
        if (version4 !== 0 && version4 !== 1) {
          throw new RangeError(`Invalid CID version ${version4}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version4,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base4) {
        const [prefix, bytes2] = parseCIDtoBytes(source, base4);
        const cid = CID.decode(bytes2);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    parseCIDtoBytes = (source, base4) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base4 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder = base4 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base32.prefix: {
          const decoder = base4 || base32;
          return [
            base32.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base4 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base4.decode(source)
          ];
        }
      }
    };
    toStringV0 = (bytes2, cache2, base4) => {
      const { prefix } = base4;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
      }
      const cid = cache2.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes2).slice(1);
        cache2.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV1 = (bytes2, cache2, base4) => {
      const { prefix } = base4;
      const cid = cache2.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes2);
        cache2.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    encodeCID = (version4, code13, multihash) => {
      const codeOffset = encodingLength(version4);
      const hashOffset = codeOffset + encodingLength(code13);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version4, bytes2, 0);
      encodeTo(code13, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version = "0.0.0-dev";
    deprecate = (range, message) => {
      if (range.test(version)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});

// node_modules/cborg/esm/lib/is.js
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf2 = typeof value;
  if (typeofs.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
var typeofs, objectTypeNames;
var init_is = __esm({
  "node_modules/cborg/esm/lib/is.js"() {
    init_globals();
    typeofs = [
      "string",
      "number",
      "bigint",
      "symbol"
    ];
    objectTypeNames = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/cborg/esm/lib/token.js
var Type, Token;
var init_token = __esm({
  "node_modules/cborg/esm/lib/token.js"() {
    init_globals();
    Type = class {
      constructor(major, name10, terminal) {
        this.major = major;
        this.majorEncoded = major << 5;
        this.name = name10;
        this.terminal = terminal;
      }
      toString() {
        return `Type[${this.major}].${this.name}`;
      }
      compare(typ) {
        return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
      }
    };
    Type.uint = new Type(0, "uint", true);
    Type.negint = new Type(1, "negint", true);
    Type.bytes = new Type(2, "bytes", true);
    Type.string = new Type(3, "string", true);
    Type.array = new Type(4, "array", false);
    Type.map = new Type(5, "map", false);
    Type.tag = new Type(6, "tag", false);
    Type.float = new Type(7, "float", true);
    Type.false = new Type(7, "false", true);
    Type.true = new Type(7, "true", true);
    Type.null = new Type(7, "null", true);
    Type.undefined = new Type(7, "undefined", true);
    Type.break = new Type(7, "break", true);
    Token = class {
      constructor(type, value, encodedLength) {
        this.type = type;
        this.value = value;
        this.encodedLength = encodedLength;
        this.encodedBytes = void 0;
        this.byteValue = void 0;
      }
      toString() {
        return `Token[${this.type}].${this.value}`;
      }
    };
  }
});

// node_modules/cborg/esm/lib/byte-utils.js
function isBuffer2(buf3) {
  return useBuffer && globalThis.Buffer.isBuffer(buf3);
}
function asU8A(buf3) {
  if (!(buf3 instanceof Uint8Array)) {
    return Uint8Array.from(buf3);
  }
  return isBuffer2(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
}
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string3, units = Infinity) {
  let codePoint;
  const length5 = string3.length;
  let leadSurrogate = null;
  const bytes2 = [];
  for (let i = 0; i < length5; ++i) {
    codePoint = string3.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i + 1 === length5) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function utf8Slice(buf3, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf3[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf3[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          fourthByte = buf3[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
var useBuffer, textDecoder2, textEncoder3, toString2, fromString2, fromArray, slice, concat, alloc, MAX_ARGUMENTS_LENGTH;
var init_byte_utils = __esm({
  "node_modules/cborg/esm/lib/byte-utils.js"() {
    init_globals();
    useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
    textDecoder2 = new TextDecoder();
    textEncoder3 = new TextEncoder();
    toString2 = useBuffer ? (bytes2, start, end) => {
      return end - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end)).toString("utf8") : utf8Slice(bytes2, start, end);
    } : (bytes2, start, end) => {
      return end - start > 64 ? textDecoder2.decode(bytes2.subarray(start, end)) : utf8Slice(bytes2, start, end);
    };
    fromString2 = useBuffer ? (string3) => {
      return string3.length > 64 ? globalThis.Buffer.from(string3) : utf8ToBytes(string3);
    } : (string3) => {
      return string3.length > 64 ? textEncoder3.encode(string3) : utf8ToBytes(string3);
    };
    fromArray = (arr) => {
      return Uint8Array.from(arr);
    };
    slice = useBuffer ? (bytes2, start, end) => {
      if (isBuffer2(bytes2)) {
        return new Uint8Array(bytes2.subarray(start, end));
      }
      return bytes2.slice(start, end);
    } : (bytes2, start, end) => {
      return bytes2.slice(start, end);
    };
    concat = useBuffer ? (chunks, length5) => {
      chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
      return asU8A(globalThis.Buffer.concat(chunks, length5));
    } : (chunks, length5) => {
      const out = new Uint8Array(length5);
      let off = 0;
      for (let b of chunks) {
        if (off + b.length > out.length) {
          b = b.subarray(0, out.length - off);
        }
        out.set(b, off);
        off += b.length;
      }
      return out;
    };
    alloc = useBuffer ? (size) => {
      return globalThis.Buffer.allocUnsafe(size);
    } : (size) => {
      return new Uint8Array(size);
    };
    MAX_ARGUMENTS_LENGTH = 4096;
  }
});

// node_modules/cborg/esm/lib/bl.js
var defaultChunkSize, Bl;
var init_bl = __esm({
  "node_modules/cborg/esm/lib/bl.js"() {
    init_globals();
    init_byte_utils();
    defaultChunkSize = 256;
    Bl = class {
      constructor(chunkSize2 = defaultChunkSize) {
        this.chunkSize = chunkSize2;
        this.cursor = 0;
        this.maxCursor = -1;
        this.chunks = [];
        this._initReuseChunk = null;
      }
      reset() {
        this.cursor = 0;
        this.maxCursor = -1;
        if (this.chunks.length) {
          this.chunks = [];
        }
        if (this._initReuseChunk !== null) {
          this.chunks.push(this._initReuseChunk);
          this.maxCursor = this._initReuseChunk.length - 1;
        }
      }
      push(bytes2) {
        let topChunk = this.chunks[this.chunks.length - 1];
        const newMax = this.cursor + bytes2.length;
        if (newMax <= this.maxCursor + 1) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          topChunk.set(bytes2, chunkPos);
        } else {
          if (topChunk) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            if (chunkPos < topChunk.length) {
              this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
              this.maxCursor = this.cursor - 1;
            }
          }
          if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
            topChunk = alloc(this.chunkSize);
            this.chunks.push(topChunk);
            this.maxCursor += topChunk.length;
            if (this._initReuseChunk === null) {
              this._initReuseChunk = topChunk;
            }
            topChunk.set(bytes2, 0);
          } else {
            this.chunks.push(bytes2);
            this.maxCursor += bytes2.length;
          }
        }
        this.cursor += bytes2.length;
      }
      toBytes(reset = false) {
        let byts;
        if (this.chunks.length === 1) {
          const chunk = this.chunks[0];
          if (reset && this.cursor > chunk.length / 2) {
            byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
            this._initReuseChunk = null;
            this.chunks = [];
          } else {
            byts = slice(chunk, 0, this.cursor);
          }
        } else {
          byts = concat(this.chunks, this.cursor);
        }
        if (reset) {
          this.reset();
        }
        return byts;
      }
    };
  }
});

// node_modules/cborg/esm/lib/common.js
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
var decodeErrPrefix, encodeErrPrefix, uintMinorPrefixBytes;
var init_common = __esm({
  "node_modules/cborg/esm/lib/common.js"() {
    init_globals();
    decodeErrPrefix = "CBOR decode error:";
    encodeErrPrefix = "CBOR encode error:";
    uintMinorPrefixBytes = [];
    uintMinorPrefixBytes[23] = 1;
    uintMinorPrefixBytes[24] = 2;
    uintMinorPrefixBytes[25] = 3;
    uintMinorPrefixBytes[26] = 5;
    uintMinorPrefixBytes[27] = 9;
  }
});

// node_modules/cborg/esm/lib/0uint.js
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf3, token) {
  return encodeUintValue(buf3, 0, token.value);
}
function encodeUintValue(buf3, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf3.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf3.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf3.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf3.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set2 = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set2[8] = lo & 255;
      lo = lo >> 8;
      set2[7] = lo & 255;
      lo = lo >> 8;
      set2[6] = lo & 255;
      lo = lo >> 8;
      set2[5] = lo & 255;
      set2[4] = hi & 255;
      hi = hi >> 8;
      set2[3] = hi & 255;
      hi = hi >> 8;
      set2[2] = hi & 255;
      hi = hi >> 8;
      set2[1] = hi & 255;
      buf3.push(set2);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
var uintBoundaries;
var init_uint = __esm({
  "node_modules/cborg/esm/lib/0uint.js"() {
    init_globals();
    init_token();
    init_common();
    uintBoundaries = [
      24,
      256,
      65536,
      4294967296,
      BigInt("18446744073709551616")
    ];
    encodeUint.encodedSize = function encodedSize(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    encodeUintValue.encodedSize = function encodedSize2(uint) {
      if (uint < uintBoundaries[0]) {
        return 1;
      }
      if (uint < uintBoundaries[1]) {
        return 2;
      }
      if (uint < uintBoundaries[2]) {
        return 3;
      }
      if (uint < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeUint.compareTokens = function compareTokens(tok1, tok2) {
      return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
    };
  }
});

// node_modules/cborg/esm/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf3, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf3, token.type.majorEncoded, unsigned);
}
var neg1b, pos1b;
var init_negint = __esm({
  "node_modules/cborg/esm/lib/1negint.js"() {
    init_globals();
    init_token();
    init_uint();
    init_common();
    neg1b = BigInt(-1);
    pos1b = BigInt(1);
    encodeNegint.encodedSize = function encodedSize3(token) {
      const negint = token.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
      if (unsigned < uintBoundaries[0]) {
        return 1;
      }
      if (unsigned < uintBoundaries[1]) {
        return 2;
      }
      if (unsigned < uintBoundaries[2]) {
        return 3;
      }
      if (unsigned < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
      return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
    };
  }
});

// node_modules/cborg/esm/lib/2bytes.js
function toToken(data, pos, prefix, length5) {
  assertEnoughData(data, pos, prefix + length5);
  const buf3 = slice(data, pos + prefix, pos + prefix + length5);
  return new Token(Type.bytes, buf3, prefix + length5);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes2(buf3, token) {
  const bytes2 = tokenBytes(token);
  encodeUintValue(buf3, token.type.majorEncoded, bytes2.length);
  buf3.push(bytes2);
}
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}
var init_bytes2 = __esm({
  "node_modules/cborg/esm/lib/2bytes.js"() {
    init_globals();
    init_token();
    init_common();
    init_uint();
    init_byte_utils();
    encodeBytes2.encodedSize = function encodedSize4(token) {
      const bytes2 = tokenBytes(token);
      return encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
    };
    encodeBytes2.compareTokens = function compareTokens3(tok1, tok2) {
      return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
    };
  }
});

// node_modules/cborg/esm/lib/3string.js
function toToken2(data, pos, prefix, length5, options) {
  const totLength = prefix + length5;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString2(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString;
var init_string = __esm({
  "node_modules/cborg/esm/lib/3string.js"() {
    init_globals();
    init_token();
    init_common();
    init_uint();
    init_bytes2();
    init_byte_utils();
    encodeString = encodeBytes2;
  }
});

// node_modules/cborg/esm/lib/4array.js
function toToken3(_data, _pos, prefix, length5) {
  return new Token(Type.array, length5, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf3, token) {
  encodeUintValue(buf3, Type.array.majorEncoded, token.value);
}
var init_array = __esm({
  "node_modules/cborg/esm/lib/4array.js"() {
    init_globals();
    init_token();
    init_uint();
    init_common();
    encodeArray.compareTokens = encodeUint.compareTokens;
    encodeArray.encodedSize = function encodedSize5(token) {
      return encodeUintValue.encodedSize(token.value);
    };
  }
});

// node_modules/cborg/esm/lib/5map.js
function toToken4(_data, _pos, prefix, length5) {
  return new Token(Type.map, length5, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf3, token) {
  encodeUintValue(buf3, Type.map.majorEncoded, token.value);
}
var init_map = __esm({
  "node_modules/cborg/esm/lib/5map.js"() {
    init_globals();
    init_token();
    init_uint();
    init_common();
    encodeMap.compareTokens = encodeUint.compareTokens;
    encodeMap.encodedSize = function encodedSize6(token) {
      return encodeUintValue.encodedSize(token.value);
    };
  }
});

// node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf3, token) {
  encodeUintValue(buf3, Type.tag.majorEncoded, token.value);
}
var init_tag = __esm({
  "node_modules/cborg/esm/lib/6tag.js"() {
    init_globals();
    init_token();
    init_uint();
    encodeTag.compareTokens = encodeUint.compareTokens;
    encodeTag.encodedSize = function encodedSize7(token) {
      return encodeUintValue.encodedSize(token.value);
    };
  }
});

// node_modules/cborg/esm/lib/7float.js
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes2);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf3, token, options) {
  const float = token.value;
  if (float === false) {
    buf3.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf3.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf3.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf3.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf3.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf3.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf3.push(ui8a.slice(0, 9));
    }
  }
}
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a3, pos) {
  if (ui8a3.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a3, pos) {
  if (ui8a3.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a3, pos) {
  if (ui8a3.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 8).getFloat64(0, false);
}
var MINOR_FALSE, MINOR_TRUE, MINOR_NULL, MINOR_UNDEFINED, buffer, dataView, ui8a;
var init_float = __esm({
  "node_modules/cborg/esm/lib/7float.js"() {
    init_globals();
    init_token();
    init_common();
    init_uint();
    MINOR_FALSE = 20;
    MINOR_TRUE = 21;
    MINOR_NULL = 22;
    MINOR_UNDEFINED = 23;
    encodeFloat.encodedSize = function encodedSize8(token, options) {
      const float = token.value;
      if (float === false || float === true || float === null || float === void 0) {
        return 1;
      }
      if (!options || options.float64 !== true) {
        encodeFloat16(float);
        let decoded = readFloat16(ui8a, 1);
        if (float === decoded || Number.isNaN(float)) {
          return 3;
        }
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          return 5;
        }
      }
      return 9;
    };
    buffer = new ArrayBuffer(9);
    dataView = new DataView(buffer, 1);
    ui8a = new Uint8Array(buffer, 0);
    encodeFloat.compareTokens = encodeUint.compareTokens;
  }
});

// node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}
var jump, quick;
var init_jump = __esm({
  "node_modules/cborg/esm/lib/jump.js"() {
    init_globals();
    init_token();
    init_uint();
    init_negint();
    init_bytes2();
    init_string();
    init_array();
    init_map();
    init_tag();
    init_float();
    init_common();
    init_byte_utils();
    jump = [];
    for (let i = 0; i <= 23; i++) {
      jump[i] = invalidMinor;
    }
    jump[24] = decodeUint8;
    jump[25] = decodeUint16;
    jump[26] = decodeUint32;
    jump[27] = decodeUint64;
    jump[28] = invalidMinor;
    jump[29] = invalidMinor;
    jump[30] = invalidMinor;
    jump[31] = invalidMinor;
    for (let i = 32; i <= 55; i++) {
      jump[i] = invalidMinor;
    }
    jump[56] = decodeNegint8;
    jump[57] = decodeNegint16;
    jump[58] = decodeNegint32;
    jump[59] = decodeNegint64;
    jump[60] = invalidMinor;
    jump[61] = invalidMinor;
    jump[62] = invalidMinor;
    jump[63] = invalidMinor;
    for (let i = 64; i <= 87; i++) {
      jump[i] = decodeBytesCompact;
    }
    jump[88] = decodeBytes8;
    jump[89] = decodeBytes16;
    jump[90] = decodeBytes32;
    jump[91] = decodeBytes64;
    jump[92] = invalidMinor;
    jump[93] = invalidMinor;
    jump[94] = invalidMinor;
    jump[95] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 96; i <= 119; i++) {
      jump[i] = decodeStringCompact;
    }
    jump[120] = decodeString8;
    jump[121] = decodeString16;
    jump[122] = decodeString32;
    jump[123] = decodeString64;
    jump[124] = invalidMinor;
    jump[125] = invalidMinor;
    jump[126] = invalidMinor;
    jump[127] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 128; i <= 151; i++) {
      jump[i] = decodeArrayCompact;
    }
    jump[152] = decodeArray8;
    jump[153] = decodeArray16;
    jump[154] = decodeArray32;
    jump[155] = decodeArray64;
    jump[156] = invalidMinor;
    jump[157] = invalidMinor;
    jump[158] = invalidMinor;
    jump[159] = decodeArrayIndefinite;
    for (let i = 160; i <= 183; i++) {
      jump[i] = decodeMapCompact;
    }
    jump[184] = decodeMap8;
    jump[185] = decodeMap16;
    jump[186] = decodeMap32;
    jump[187] = decodeMap64;
    jump[188] = invalidMinor;
    jump[189] = invalidMinor;
    jump[190] = invalidMinor;
    jump[191] = decodeMapIndefinite;
    for (let i = 192; i <= 215; i++) {
      jump[i] = decodeTagCompact;
    }
    jump[216] = decodeTag8;
    jump[217] = decodeTag16;
    jump[218] = decodeTag32;
    jump[219] = decodeTag64;
    jump[220] = invalidMinor;
    jump[221] = invalidMinor;
    jump[222] = invalidMinor;
    jump[223] = invalidMinor;
    for (let i = 224; i <= 243; i++) {
      jump[i] = errorer("simple values are not supported");
    }
    jump[244] = invalidMinor;
    jump[245] = invalidMinor;
    jump[246] = invalidMinor;
    jump[247] = decodeUndefined;
    jump[248] = errorer("simple values are not supported");
    jump[249] = decodeFloat16;
    jump[250] = decodeFloat32;
    jump[251] = decodeFloat64;
    jump[252] = invalidMinor;
    jump[253] = invalidMinor;
    jump[254] = invalidMinor;
    jump[255] = decodeBreak;
    quick = [];
    for (let i = 0; i < 24; i++) {
      quick[i] = new Token(Type.uint, i, 1);
    }
    for (let i = -1; i >= -24; i--) {
      quick[31 - i] = new Token(Type.negint, i, 1);
    }
    quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
    quick[96] = new Token(Type.string, "", 1);
    quick[128] = new Token(Type.array, 0, 1);
    quick[160] = new Token(Type.map, 0, 1);
    quick[244] = new Token(Type.false, false, 1);
    quick[245] = new Token(Type.true, true, 1);
    quick[246] = new Token(Type.null, null, 1);
  }
});

// node_modules/cborg/esm/lib/encode.js
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes2;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries2, options) {
  if (options.mapSorter) {
    entries2.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf3, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf3, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf3, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf3 = new Bl(size);
      encoder(buf3, tokens, options);
      if (buf3.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf3.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode4(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}
var defaultEncodeOptions, cborEncoders, buf, Ref, simpleTokens, typeEncoders;
var init_encode = __esm({
  "node_modules/cborg/esm/lib/encode.js"() {
    init_globals();
    init_is();
    init_token();
    init_bl();
    init_common();
    init_jump();
    init_byte_utils();
    init_uint();
    init_negint();
    init_bytes2();
    init_string();
    init_array();
    init_map();
    init_tag();
    init_float();
    defaultEncodeOptions = {
      float64: false,
      mapSorter,
      quickEncodeToken
    };
    cborEncoders = makeCborEncoders();
    buf = new Bl();
    Ref = class {
      constructor(obj, parent2) {
        this.obj = obj;
        this.parent = parent2;
      }
      includes(obj) {
        let p = this;
        do {
          if (p.obj === obj) {
            return true;
          }
        } while (p = p.parent);
        return false;
      }
      static createCheck(stack, obj) {
        if (stack && stack.includes(obj)) {
          throw new Error(`${encodeErrPrefix} object contains circular references`);
        }
        return new Ref(obj, stack);
      }
    };
    simpleTokens = {
      null: new Token(Type.null, null),
      undefined: new Token(Type.undefined, void 0),
      true: new Token(Type.true, true),
      false: new Token(Type.false, false),
      emptyArray: new Token(Type.array, 0),
      emptyMap: new Token(Type.map, 0)
    };
    typeEncoders = {
      number(obj, _typ, _options, _refStack) {
        if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
          return new Token(Type.float, obj);
        } else if (obj >= 0) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      bigint(obj, _typ, _options, _refStack) {
        if (obj >= BigInt(0)) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      Uint8Array(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, obj);
      },
      string(obj, _typ, _options, _refStack) {
        return new Token(Type.string, obj);
      },
      boolean(obj, _typ, _options, _refStack) {
        return obj ? simpleTokens.true : simpleTokens.false;
      },
      null(_obj, _typ, _options, _refStack) {
        return simpleTokens.null;
      },
      undefined(_obj, _typ, _options, _refStack) {
        return simpleTokens.undefined;
      },
      ArrayBuffer(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj));
      },
      DataView(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
      },
      Array(obj, _typ, options, refStack) {
        if (!obj.length) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens.emptyArray,
              new Token(Type.break)
            ];
          }
          return simpleTokens.emptyArray;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries2 = [];
        let i = 0;
        for (const e of obj) {
          entries2[i++] = objectToTokens(e, options, refStack);
        }
        if (options.addBreakTokens) {
          return [
            new Token(Type.array, obj.length),
            entries2,
            new Token(Type.break)
          ];
        }
        return [
          new Token(Type.array, obj.length),
          entries2
        ];
      },
      Object(obj, typ, options, refStack) {
        const isMap = typ !== "Object";
        const keys2 = isMap ? obj.keys() : Object.keys(obj);
        const length5 = isMap ? obj.size : keys2.length;
        if (!length5) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens.emptyMap,
              new Token(Type.break)
            ];
          }
          return simpleTokens.emptyMap;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries2 = [];
        let i = 0;
        for (const key of keys2) {
          entries2[i++] = [
            objectToTokens(key, options, refStack),
            objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
          ];
        }
        sortMapEntries(entries2, options);
        if (options.addBreakTokens) {
          return [
            new Token(Type.map, length5),
            entries2,
            new Token(Type.break)
          ];
        }
        return [
          new Token(Type.map, length5),
          entries2
        ];
      }
    };
    typeEncoders.Map = typeEncoders.Object;
    typeEncoders.Buffer = typeEncoders.Uint8Array;
    for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
      typeEncoders[`${typ}Array`] = typeEncoders.DataView;
    }
  }
});

// node_modules/cborg/esm/lib/decode.js
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode6(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
var defaultDecodeOptions, Tokeniser, DONE, BREAK;
var init_decode = __esm({
  "node_modules/cborg/esm/lib/decode.js"() {
    init_globals();
    init_common();
    init_token();
    init_jump();
    defaultDecodeOptions = {
      strict: false,
      allowIndefinite: true,
      allowUndefined: true,
      allowBigInt: true
    };
    Tokeniser = class {
      constructor(data, options = {}) {
        this.pos = 0;
        this.data = data;
        this.options = options;
      }
      done() {
        return this.pos >= this.data.length;
      }
      next() {
        const byt = this.data[this.pos];
        let token = quick[byt];
        if (token === void 0) {
          const decoder = jump[byt];
          if (!decoder) {
            throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
          }
          const minor = byt & 31;
          token = decoder(this.data, this.pos, minor, this.options);
        }
        this.pos += token.encodedLength;
        return token;
      }
    };
    DONE = Symbol.for("DONE");
    BREAK = Symbol.for("BREAK");
  }
});

// node_modules/cborg/esm/cborg.js
var init_cborg = __esm({
  "node_modules/cborg/esm/cborg.js"() {
    init_globals();
    init_encode();
    init_decode();
    init_token();
  }
});

// node_modules/multiformats/esm/src/hashes/hasher.js
var from2, Hasher;
var init_hasher = __esm({
  "node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_globals();
    init_digest();
    from2 = ({ name: name10, code: code13, encode: encode19 }) => new Hasher(name10, code13, encode19);
    Hasher = class {
      constructor(name10, code13, encode19) {
        this.name = name10;
        this.code = code13;
        this.encode = encode19;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then((digest3) => create(this.code, digest3));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// node_modules/multiformats/esm/src/index.js
var init_src = __esm({
  "node_modules/multiformats/esm/src/index.js"() {
    init_globals();
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});

// node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64, base64pad, base64url, base64urlpad;
var init_base64 = __esm({
  "node_modules/multiformats/esm/src/bases/base64.js"() {
    init_globals();
    init_base();
    base64 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// node_modules/dag-jose/lib/utils.js
var require_utils = __commonJS({
  "node_modules/dag-jose/lib/utils.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromBase64url = exports2.toBase64url = void 0;
    var base64_1 = (init_base64(), __toCommonJS(base64_exports));
    function toBase64url(b) {
      return base64_1.base64url.encode(b).slice(1);
    }
    exports2.toBase64url = toBase64url;
    function fromBase64url(s) {
      return base64_1.base64url.decode(`u${s}`);
    }
    exports2.fromBase64url = fromBase64url;
  }
});

// node_modules/dag-jose/lib/signing.js
var require_signing = __commonJS({
  "node_modules/dag-jose/lib/signing.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils();
    var cid_1 = (init_cid(), __toCommonJS(cid_exports));
    function fromSplit(split) {
      const [protectedHeader, payload, signature] = split;
      return {
        payload,
        signatures: [{ protected: protectedHeader, signature }],
        link: cid_1.CID.decode(utils_1.fromBase64url(payload))
      };
    }
    function encodeSignature(signature) {
      const encoded = {
        signature: utils_1.fromBase64url(signature.signature)
      };
      if (signature.header)
        encoded.header = signature.header;
      if (signature.protected)
        encoded.protected = utils_1.fromBase64url(signature.protected);
      return encoded;
    }
    function encode19(jws) {
      const payload = utils_1.fromBase64url(jws.payload);
      try {
        cid_1.CID.decode(payload);
      } catch (e) {
        throw new Error("Not a valid DagJWS");
      }
      const encodedJws = {
        payload,
        signatures: jws.signatures.map(encodeSignature)
      };
      return encodedJws;
    }
    function decodeSignature(encoded) {
      const sign3 = {
        signature: utils_1.toBase64url(encoded.signature)
      };
      if (encoded.header)
        sign3.header = encoded.header;
      if (encoded.protected)
        sign3.protected = utils_1.toBase64url(encoded.protected);
      return sign3;
    }
    function decode22(encoded) {
      const decoded = {
        payload: utils_1.toBase64url(encoded.payload),
        signatures: encoded.signatures.map(decodeSignature)
      };
      decoded.link = cid_1.CID.decode(new Uint8Array(encoded.payload));
      return decoded;
    }
    exports2.default = {
      fromSplit,
      encode: encode19,
      decode: decode22
    };
  }
});

// node_modules/dag-jose/lib/encryption.js
var require_encryption = __commonJS({
  "node_modules/dag-jose/lib/encryption.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils();
    function fromSplit(split) {
      const [protectedHeader, encrypted_key, iv, ciphertext, tag] = split;
      const jwe = {
        ciphertext,
        iv,
        protected: protectedHeader,
        tag
      };
      if (encrypted_key)
        jwe.recipients = [{ encrypted_key }];
      return jwe;
    }
    function encodeRecipient(recipient) {
      const encRec = {};
      if (recipient.encrypted_key)
        encRec.encrypted_key = utils_1.fromBase64url(recipient.encrypted_key);
      if (recipient.header)
        encRec.header = recipient.header;
      return encRec;
    }
    function encode19(jwe) {
      const encJwe = {
        ciphertext: utils_1.fromBase64url(jwe.ciphertext),
        protected: utils_1.fromBase64url(jwe.protected),
        iv: utils_1.fromBase64url(jwe.iv),
        tag: utils_1.fromBase64url(jwe.tag)
      };
      if (jwe.aad)
        encJwe.aad = utils_1.fromBase64url(jwe.aad);
      if (jwe.recipients)
        encJwe.recipients = jwe.recipients.map(encodeRecipient);
      if (jwe.unprotected)
        encJwe.unprotected = jwe.unprotected;
      return encJwe;
    }
    function decodeRecipient(encoded) {
      const recipient = {};
      if (encoded.encrypted_key)
        recipient.encrypted_key = utils_1.toBase64url(encoded.encrypted_key);
      if (encoded.header)
        recipient.header = encoded.header;
      return recipient;
    }
    function decode22(encoded) {
      const jwe = {
        ciphertext: utils_1.toBase64url(encoded.ciphertext),
        protected: utils_1.toBase64url(encoded.protected),
        iv: utils_1.toBase64url(encoded.iv),
        tag: utils_1.toBase64url(encoded.tag)
      };
      if (encoded.aad)
        jwe.aad = utils_1.toBase64url(encoded.aad);
      if (encoded.recipients)
        jwe.recipients = encoded.recipients.map(decodeRecipient);
      if (encoded.unprotected)
        jwe.unprotected = encoded.unprotected;
      return jwe;
    }
    exports2.default = {
      fromSplit,
      decode: decode22,
      encode: encode19
    };
  }
});

// node_modules/@ipld/dag-cbor/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  code: () => code4,
  decode: () => decode10,
  encode: () => encode8,
  name: () => name4
});
function cidEncoder3(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG2),
    new Token(Type.bytes, bytes2)
  ];
}
function undefinedEncoder3() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder3(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function cidDecoder2(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
var CID_CBOR_TAG2, encodeOptions3, decodeOptions3, name4, code4, encode8, decode10;
var init_esm = __esm({
  "node_modules/@ipld/dag-cbor/esm/index.js"() {
    init_globals();
    init_cborg();
    init_cid();
    CID_CBOR_TAG2 = 42;
    encodeOptions3 = {
      float64: true,
      typeEncoders: {
        Object: cidEncoder3,
        undefined: undefinedEncoder3,
        number: numberEncoder3
      }
    };
    decodeOptions3 = {
      allowIndefinite: false,
      allowUndefined: false,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      strict: true,
      useMaps: false,
      tags: []
    };
    decodeOptions3.tags[CID_CBOR_TAG2] = cidDecoder2;
    name4 = "dag-cbor";
    code4 = 113;
    encode8 = (node) => encode4(node, encodeOptions3);
    decode10 = (data) => decode6(data, decodeOptions3);
  }
});

// node_modules/dag-jose/lib/index.js
var require_lib = __commonJS({
  "node_modules/dag-jose/lib/index.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = exports2.toGeneral = exports2.code = exports2.name = void 0;
    var signing_1 = __importDefault(require_signing());
    var encryption_1 = __importDefault(require_encryption());
    var cbor = __importStar((init_esm(), __toCommonJS(esm_exports3)));
    exports2.name = "dag-jose";
    exports2.code = 133;
    function isDagJWS(jose) {
      return "payload" in jose && typeof jose.payload === "string" && "signatures" in jose && Array.isArray(jose.signatures);
    }
    function isEncodedJWS(jose) {
      return "payload" in jose && jose.payload instanceof Uint8Array && "signatures" in jose && Array.isArray(jose.signatures);
    }
    function isEncodedJWE(jose) {
      return "ciphertext" in jose && jose.ciphertext instanceof Uint8Array && "iv" in jose && jose.iv instanceof Uint8Array && "protected" in jose && jose.protected instanceof Uint8Array && "tag" in jose && jose.tag instanceof Uint8Array;
    }
    function isDagJWE(jose) {
      return "ciphertext" in jose && typeof jose.ciphertext === "string" && "iv" in jose && typeof jose.iv === "string" && "protected" in jose && typeof jose.protected === "string" && "tag" in jose && typeof jose.tag === "string";
    }
    function toGeneral(jose) {
      if (typeof jose === "string") {
        const split = jose.split(".");
        if (split.length === 3) {
          return signing_1.default.fromSplit(split);
        } else if (split.length === 5) {
          return encryption_1.default.fromSplit(split);
        }
        throw new Error("Not a valid JOSE string");
      }
      if (isDagJWS(jose) || isDagJWE(jose)) {
        return jose;
      }
      throw new Error("Not a valid unencoded JOSE object");
    }
    exports2.toGeneral = toGeneral;
    function encode19(obj) {
      if (typeof obj === "string") {
        obj = toGeneral(obj);
      }
      let encodedJose;
      if (isDagJWS(obj)) {
        encodedJose = signing_1.default.encode(obj);
      } else if (isDagJWE(obj)) {
        encodedJose = encryption_1.default.encode(obj);
      } else {
        throw new Error("Not a valid JOSE object");
      }
      return new Uint8Array(cbor.encode(encodedJose));
    }
    exports2.encode = encode19;
    function decode22(data) {
      let encoded;
      try {
        encoded = cbor.decode(data);
      } catch (e) {
        throw new Error("Not a valid DAG-JOSE object");
      }
      if (isEncodedJWS(encoded)) {
        return signing_1.default.decode(encoded);
      } else if (isEncodedJWE(encoded)) {
        return encryption_1.default.decode(encoded);
      } else {
        throw new Error("Not a valid DAG-JOSE object");
      }
    }
    exports2.decode = decode22;
  }
});

// node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var code5, name5, encode9, digest, identity;
var init_identity = __esm({
  "node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_globals();
    init_bytes();
    init_digest();
    code5 = 0;
    name5 = "identity";
    encode9 = coerce;
    digest = (input) => create(code5, encode9(input));
    identity = {
      code: code5,
      name: name5,
      encode: encode9,
      digest
    };
  }
});

// node_modules/multiformats/esm/src/bases/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var identity2;
var init_identity2 = __esm({
  "node_modules/multiformats/esm/src/bases/identity.js"() {
    init_globals();
    init_base();
    init_bytes();
    identity2 = from({
      prefix: "\0",
      name: "identity",
      encode: (buf3) => toString(buf3),
      decode: (str) => fromString(str)
    });
  }
});

// node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2;
var init_base2 = __esm({
  "node_modules/multiformats/esm/src/bases/base2.js"() {
    init_globals();
    init_base();
    base2 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});

// node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8;
var init_base8 = __esm({
  "node_modules/multiformats/esm/src/bases/base8.js"() {
    init_globals();
    init_base();
    base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});

// node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10;
var init_base10 = __esm({
  "node_modules/multiformats/esm/src/bases/base10.js"() {
    init_globals();
    init_base();
    base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16, base16upper;
var init_base16 = __esm({
  "node_modules/multiformats/esm/src/bases/base16.js"() {
    init_globals();
    init_base();
    base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});

// node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36, base36upper;
var init_base36 = __esm({
  "node_modules/multiformats/esm/src/bases/base36.js"() {
    init_globals();
    init_base();
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var sha, sha256, sha512;
var init_sha2_browser = __esm({
  "node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
    init_globals();
    init_hasher();
    sha = (name10) => async (data) => new Uint8Array(await crypto.subtle.digest(name10, data));
    sha256 = from2({
      name: "sha2-256",
      code: 18,
      encode: sha("SHA-256")
    });
    sha512 = from2({
      name: "sha2-512",
      code: 19,
      encode: sha("SHA-512")
    });
  }
});

// node_modules/multiformats/esm/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code6,
  decode: () => decode11,
  encode: () => encode10,
  name: () => name6
});
var name6, code6, encode10, decode11;
var init_raw = __esm({
  "node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_globals();
    init_bytes();
    name6 = "raw";
    code6 = 85;
    encode10 = (node) => coerce(node);
    decode11 = (data) => coerce(data);
  }
});

// node_modules/multiformats/esm/src/codecs/json.js
var json_exports2 = {};
__export(json_exports2, {
  code: () => code7,
  decode: () => decode12,
  encode: () => encode11,
  name: () => name7
});
var textEncoder4, textDecoder3, name7, code7, encode11, decode12;
var init_json = __esm({
  "node_modules/multiformats/esm/src/codecs/json.js"() {
    init_globals();
    textEncoder4 = new TextEncoder();
    textDecoder3 = new TextDecoder();
    name7 = "json";
    code7 = 512;
    encode11 = (node) => textEncoder4.encode(JSON.stringify(node));
    decode12 = (data) => JSON.parse(textDecoder3.decode(data));
  }
});

// node_modules/multiformats/esm/src/basics.js
var bases, hashes, codecs;
var init_basics = __esm({
  "node_modules/multiformats/esm/src/basics.js"() {
    init_globals();
    init_identity2();
    init_base2();
    init_base8();
    init_base10();
    init_base16();
    init_base32();
    init_base36();
    init_base58();
    init_base64();
    init_sha2_browser();
    init_identity();
    init_raw();
    init_json();
    init_src();
    bases = {
      ...identity_exports2,
      ...base2_exports,
      ...base8_exports,
      ...base10_exports,
      ...base16_exports,
      ...base32_exports,
      ...base36_exports,
      ...base58_exports,
      ...base64_exports
    };
    hashes = {
      ...sha2_browser_exports,
      ...identity_exports
    };
    codecs = {
      raw: raw_exports,
      json: json_exports2
    };
  }
});

// node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name10, prefix, encode19, decode22) {
  return {
    name: name10,
    prefix,
    encoder: {
      name: name10,
      prefix,
      encode: encode19
    },
    decoder: { decode: decode22 }
  };
}
var string, ascii, BASES, bases_default;
var init_bases = __esm({
  "node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_globals();
    init_basics();
    string = createCodec("utf8", "u", (buf3) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf3);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    ascii = createCodec("ascii", "a", (buf3) => {
      let string3 = "a";
      for (let i = 0; i < buf3.length; i++) {
        string3 += String.fromCharCode(buf3[i]);
      }
      return string3;
    }, (str) => {
      str = str.substring(1);
      const buf3 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        buf3[i] = str.charCodeAt(i);
      }
      return buf3;
    });
    BASES = {
      utf8: string,
      "utf-8": string,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...bases
    };
    bases_default = BASES;
  }
});

// node_modules/uint8arrays/esm/src/from-string.js
var from_string_exports = {};
__export(from_string_exports, {
  fromString: () => fromString3
});
function fromString3(string3, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base4.decoder.decode(`${base4.prefix}${string3}`);
}
var init_from_string = __esm({
  "node_modules/uint8arrays/esm/src/from-string.js"() {
    init_globals();
    init_bases();
  }
});

// node_modules/ip-regex/index.js
var require_ip_regex = __commonJS({
  "node_modules/ip-regex/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var word = "[a-fA-F\\d:]";
    var b = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
    var v4exact = new RegExp(`^${v4}$`);
    var v6exact = new RegExp(`^${v6}$`);
    var ip = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, "g");
    ip.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, "g");
    ip.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, "g");
    module2.exports = ip;
  }
});

// node_modules/is-ip/index.js
var require_is_ip = __commonJS({
  "node_modules/is-ip/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var ipRegex = require_ip_regex();
    var isIp = (string3) => ipRegex({ exact: true }).test(string3);
    isIp.v4 = (string3) => ipRegex.v4({ exact: true }).test(string3);
    isIp.v6 = (string3) => ipRegex.v6({ exact: true }).test(string3);
    isIp.version = (string3) => isIp(string3) ? isIp.v4(string3) ? 4 : 6 : void 0;
    module2.exports = isIp;
  }
});

// node_modules/uint8arrays/esm/src/to-string.js
var to_string_exports = {};
__export(to_string_exports, {
  toString: () => toString3
});
function toString3(array, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base4.encoder.encode(array).substring(1);
}
var init_to_string = __esm({
  "node_modules/uint8arrays/esm/src/to-string.js"() {
    init_globals();
    init_bases();
  }
});

// node_modules/multiaddr/src/ip.js
var require_ip = __commonJS({
  "node_modules/multiaddr/src/ip.js"(exports2, module2) {
    "use strict";
    init_globals();
    var isIp = require_is_ip();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var isIP = isIp;
    var isV4 = isIp.v4;
    var isV6 = isIp.v6;
    var toBytes2 = function(ip, buff, offset) {
      offset = ~~offset;
      let result;
      if (isV4(ip)) {
        result = buff || new Uint8Array(offset + 4);
        ip.split(/\./g).map(function(byte) {
          result[offset++] = parseInt(byte, 10) & 255;
        });
      } else if (isV6(ip)) {
        const sections = ip.split(":", 8);
        let i;
        for (i = 0; i < sections.length; i++) {
          const isv4 = isV4(sections[i]);
          let v4Buffer;
          if (isv4) {
            v4Buffer = toBytes2(sections[i]);
            sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), "base16");
          }
          if (v4Buffer && ++i < 8) {
            sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), "base16"));
          }
        }
        if (sections[0] === "") {
          while (sections.length < 8)
            sections.unshift("0");
        } else if (sections[sections.length - 1] === "") {
          while (sections.length < 8)
            sections.push("0");
        } else if (sections.length < 8) {
          for (i = 0; i < sections.length && sections[i] !== ""; i++)
            ;
          const argv = [i, "1"];
          for (i = 9 - sections.length; i > 0; i--) {
            argv.push("0");
          }
          sections.splice.apply(sections, argv);
        }
        result = buff || new Uint8Array(offset + 16);
        for (i = 0; i < sections.length; i++) {
          const word = parseInt(sections[i], 16);
          result[offset++] = word >> 8 & 255;
          result[offset++] = word & 255;
        }
      }
      if (!result) {
        throw Error("Invalid ip address: " + ip);
      }
      return result;
    };
    var toString6 = function(buff, offset, length5) {
      offset = ~~offset;
      length5 = length5 || buff.length - offset;
      const result = [];
      let string3;
      const view = new DataView(buff.buffer);
      if (length5 === 4) {
        for (let i = 0; i < length5; i++) {
          result.push(buff[offset + i]);
        }
        string3 = result.join(".");
      } else if (length5 === 16) {
        for (let i = 0; i < length5; i += 2) {
          result.push(view.getUint16(offset + i).toString(16));
        }
        string3 = result.join(":");
        string3 = string3.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
        string3 = string3.replace(/:{3,4}/, "::");
      }
      return string3;
    };
    module2.exports = {
      isIP,
      isV4,
      isV6,
      toBytes: toBytes2,
      toString: toString6
    };
  }
});

// node_modules/multiaddr/src/protocols-table.js
var require_protocols_table = __commonJS({
  "node_modules/multiaddr/src/protocols-table.js"(exports2, module2) {
    "use strict";
    init_globals();
    function Protocols2(proto) {
      if (typeof proto === "number") {
        if (Protocols2.codes[proto]) {
          return Protocols2.codes[proto];
        }
        throw new Error("no protocol with code: " + proto);
      } else if (typeof proto === "string") {
        if (Protocols2.names[proto]) {
          return Protocols2.names[proto];
        }
        throw new Error("no protocol with name: " + proto);
      }
      throw new Error("invalid protocol id type: " + proto);
    }
    var V = -1;
    Protocols2.lengthPrefixedVarSize = V;
    Protocols2.V = V;
    Protocols2.table = [
      [4, 32, "ip4"],
      [6, 16, "tcp"],
      [33, 16, "dccp"],
      [41, 128, "ip6"],
      [42, V, "ip6zone"],
      [53, V, "dns", "resolvable"],
      [54, V, "dns4", "resolvable"],
      [55, V, "dns6", "resolvable"],
      [56, V, "dnsaddr", "resolvable"],
      [132, 16, "sctp"],
      [273, 16, "udp"],
      [275, 0, "p2p-webrtc-star"],
      [276, 0, "p2p-webrtc-direct"],
      [277, 0, "p2p-stardust"],
      [290, 0, "p2p-circuit"],
      [301, 0, "udt"],
      [302, 0, "utp"],
      [400, V, "unix", false, "path"],
      [421, V, "ipfs"],
      [421, V, "p2p"],
      [443, 0, "https"],
      [444, 96, "onion"],
      [445, 296, "onion3"],
      [446, V, "garlic64"],
      [460, 0, "quic"],
      [477, 0, "ws"],
      [478, 0, "wss"],
      [479, 0, "p2p-websocket-star"],
      [480, 0, "http"],
      [777, V, "memory"]
    ];
    Protocols2.names = {};
    Protocols2.codes = {};
    Protocols2.table.map((row) => {
      const proto = p.apply(null, row);
      Protocols2.codes[proto.code] = proto;
      Protocols2.names[proto.name] = proto;
      return null;
    });
    Protocols2.object = p;
    function p(code13, size, name10, resolvable, path) {
      return {
        code: code13,
        size,
        name: name10,
        resolvable: Boolean(resolvable),
        path: Boolean(path)
      };
    }
    module2.exports = Protocols2;
  }
});

// node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/varint/encode.js"(exports2, module2) {
    init_globals();
    module2.exports = encode19;
    var MSB3 = 128;
    var REST3 = 127;
    var MSBALL3 = ~REST3;
    var INT3 = Math.pow(2, 31);
    function encode19(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode19.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT3) {
        out[offset++] = num & 255 | MSB3;
        num /= 128;
      }
      while (num & MSBALL3) {
        out[offset++] = num & 255 | MSB3;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode19.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/varint/decode.js"(exports2, module2) {
    init_globals();
    module2.exports = read3;
    var MSB3 = 128;
    var REST3 = 127;
    function read3(buf3, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
      do {
        if (counter >= l || shift > 49) {
          read3.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf3[counter++];
        res += shift < 28 ? (b & REST3) << shift : (b & REST3) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB3);
      read3.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/varint/length.js"(exports2, module2) {
    init_globals();
    var N13 = Math.pow(2, 7);
    var N23 = Math.pow(2, 14);
    var N33 = Math.pow(2, 21);
    var N43 = Math.pow(2, 28);
    var N53 = Math.pow(2, 35);
    var N63 = Math.pow(2, 42);
    var N73 = Math.pow(2, 49);
    var N83 = Math.pow(2, 56);
    var N93 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/varint/index.js"(exports2, module2) {
    init_globals();
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/uint8arrays/esm/src/concat.js
var concat_exports = {};
__export(concat_exports, {
  concat: () => concat2
});
function concat2(arrays, length5) {
  if (!length5) {
    length5 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = new Uint8Array(length5);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return output;
}
var init_concat = __esm({
  "node_modules/uint8arrays/esm/src/concat.js"() {
    init_globals();
  }
});

// node_modules/multiaddr/src/convert.js
var require_convert = __commonJS({
  "node_modules/multiaddr/src/convert.js"(exports2, module2) {
    "use strict";
    init_globals();
    var ip = require_ip();
    var protocols = require_protocols_table();
    var { CID: CID3 } = (init_cid(), __toCommonJS(cid_exports));
    var { base32: base323 } = (init_base32(), __toCommonJS(base32_exports));
    var { base58btc: base58btc3 } = (init_base58(), __toCommonJS(base58_exports));
    var Digest3 = (init_digest(), __toCommonJS(digest_exports));
    var varint7 = require_varint();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    module2.exports = Convert;
    function Convert(proto, a) {
      if (a instanceof Uint8Array) {
        return Convert.toString(proto, a);
      } else {
        return Convert.toBytes(proto, a);
      }
    }
    Convert.toString = function convertToString(proto, buf3) {
      const protocol = protocols(proto);
      switch (protocol.code) {
        case 4:
        case 41:
          return bytes2ip(buf3);
        case 6:
        case 273:
        case 33:
        case 132:
          return bytes2port(buf3).toString();
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 777:
          return bytes2str(buf3);
        case 421:
          return bytes2mh(buf3);
        case 444:
          return bytes2onion(buf3);
        case 445:
          return bytes2onion(buf3);
        default:
          return uint8ArrayToString(buf3, "base16");
      }
    };
    Convert.toBytes = function convertToBytes(proto, str) {
      const protocol = protocols(proto);
      switch (protocol.code) {
        case 4:
          return ip2bytes(str);
        case 41:
          return ip2bytes(str);
        case 6:
        case 273:
        case 33:
        case 132:
          return port2bytes(parseInt(str, 10));
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 777:
          return str2bytes(str);
        case 421:
          return mh2bytes(str);
        case 444:
          return onion2bytes(str);
        case 445:
          return onion32bytes(str);
        default:
          return uint8ArrayFromString(str, "base16");
      }
    };
    function ip2bytes(ipString) {
      if (!ip.isIP(ipString)) {
        throw new Error("invalid ip address");
      }
      return ip.toBytes(ipString);
    }
    function bytes2ip(ipBuff) {
      const ipString = ip.toString(ipBuff);
      if (!ipString || !ip.isIP(ipString)) {
        throw new Error("invalid ip address");
      }
      return ipString;
    }
    function port2bytes(port) {
      const buf3 = new ArrayBuffer(2);
      const view = new DataView(buf3);
      view.setUint16(0, port);
      return new Uint8Array(buf3);
    }
    function bytes2port(buf3) {
      const view = new DataView(buf3.buffer);
      return view.getUint16(buf3.byteOffset);
    }
    function str2bytes(str) {
      const buf3 = uint8ArrayFromString(str);
      const size = Uint8Array.from(varint7.encode(buf3.length));
      return uint8ArrayConcat([size, buf3], size.length + buf3.length);
    }
    function bytes2str(buf3) {
      const size = varint7.decode(buf3);
      buf3 = buf3.slice(varint7.decode.bytes);
      if (buf3.length !== size) {
        throw new Error("inconsistent lengths");
      }
      return uint8ArrayToString(buf3);
    }
    function mh2bytes(hash2) {
      let mh;
      if (hash2[0] === "Q" || hash2[0] === "1") {
        mh = Digest3.decode(base58btc3.decode(`z${hash2}`)).bytes;
      } else {
        mh = CID3.parse(hash2).multihash.bytes;
      }
      const size = Uint8Array.from(varint7.encode(mh.length));
      return uint8ArrayConcat([size, mh], size.length + mh.length);
    }
    function bytes2mh(buf3) {
      const size = varint7.decode(buf3);
      const address = buf3.slice(varint7.decode.bytes);
      if (address.length !== size) {
        throw new Error("inconsistent lengths");
      }
      return uint8ArrayToString(address, "base58btc");
    }
    function onion2bytes(str) {
      const addr = str.split(":");
      if (addr.length !== 2) {
        throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
      }
      if (addr[0].length !== 16) {
        throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion address.");
      }
      const buf3 = base323.decode("b" + addr[0]);
      const port = parseInt(addr[1], 10);
      if (port < 1 || port > 65536) {
        throw new Error("Port number is not in range(1, 65536)");
      }
      const portBuf = port2bytes(port);
      return uint8ArrayConcat([buf3, portBuf], buf3.length + portBuf.length);
    }
    function onion32bytes(str) {
      const addr = str.split(":");
      if (addr.length !== 2) {
        throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
      }
      if (addr[0].length !== 56) {
        throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion3 address.");
      }
      const buf3 = base323.decode("b" + addr[0]);
      const port = parseInt(addr[1], 10);
      if (port < 1 || port > 65536) {
        throw new Error("Port number is not in range(1, 65536)");
      }
      const portBuf = port2bytes(port);
      return uint8ArrayConcat([buf3, portBuf], buf3.length + portBuf.length);
    }
    function bytes2onion(buf3) {
      const addrBytes = buf3.slice(0, buf3.length - 2);
      const portBytes = buf3.slice(buf3.length - 2);
      const addr = uint8ArrayToString(addrBytes, "base32");
      const port = bytes2port(portBytes);
      return addr + ":" + port;
    }
  }
});

// node_modules/multiaddr/src/codec.js
var require_codec = __commonJS({
  "node_modules/multiaddr/src/codec.js"(exports2, module2) {
    "use strict";
    init_globals();
    var convert = require_convert();
    var protocols = require_protocols_table();
    var varint7 = require_varint();
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    module2.exports = {
      stringToStringTuples,
      stringTuplesToString,
      tuplesToStringTuples,
      stringTuplesToTuples,
      bytesToTuples,
      tuplesToBytes,
      bytesToString,
      stringToBytes,
      fromString: fromString7,
      fromBytes: fromBytes2,
      validateBytes,
      isValidBytes,
      cleanPath,
      ParseError,
      protoFromTuple,
      sizeForAddr
    };
    function stringToStringTuples(str) {
      const tuples = [];
      const parts = str.split("/").slice(1);
      if (parts.length === 1 && parts[0] === "") {
        return [];
      }
      for (let p = 0; p < parts.length; p++) {
        const part = parts[p];
        const proto = protocols(part);
        if (proto.size === 0) {
          tuples.push([part]);
          continue;
        }
        p++;
        if (p >= parts.length) {
          throw ParseError("invalid address: " + str);
        }
        if (proto.path) {
          tuples.push([
            part,
            cleanPath(parts.slice(p).join("/"))
          ]);
          break;
        }
        tuples.push([part, parts[p]]);
      }
      return tuples;
    }
    function stringTuplesToString(tuples) {
      const parts = [];
      tuples.map((tup) => {
        const proto = protoFromTuple(tup);
        parts.push(proto.name);
        if (tup.length > 1) {
          parts.push(tup[1]);
        }
        return null;
      });
      return cleanPath(parts.join("/"));
    }
    function stringTuplesToTuples(tuples) {
      return tuples.map((tup) => {
        if (!Array.isArray(tup)) {
          tup = [tup];
        }
        const proto = protoFromTuple(tup);
        if (tup.length > 1) {
          return [proto.code, convert.toBytes(proto.code, tup[1])];
        }
        return [proto.code];
      });
    }
    function tuplesToStringTuples(tuples) {
      return tuples.map((tup) => {
        const proto = protoFromTuple(tup);
        if (tup[1]) {
          return [proto.code, convert.toString(proto.code, tup[1])];
        }
        return [proto.code];
      });
    }
    function tuplesToBytes(tuples) {
      return fromBytes2(uint8ArrayConcat(tuples.map((tup) => {
        const proto = protoFromTuple(tup);
        let buf3 = Uint8Array.from(varint7.encode(proto.code));
        if (tup.length > 1) {
          buf3 = uint8ArrayConcat([buf3, tup[1]]);
        }
        return buf3;
      })));
    }
    function sizeForAddr(p, addr) {
      if (p.size > 0) {
        return p.size / 8;
      } else if (p.size === 0) {
        return 0;
      } else {
        const size = varint7.decode(addr);
        return size + varint7.decode.bytes;
      }
    }
    function bytesToTuples(buf3) {
      const tuples = [];
      let i = 0;
      while (i < buf3.length) {
        const code13 = varint7.decode(buf3, i);
        const n = varint7.decode.bytes;
        const p = protocols(code13);
        const size = sizeForAddr(p, buf3.slice(i + n));
        if (size === 0) {
          tuples.push([code13]);
          i += n;
          continue;
        }
        const addr = buf3.slice(i + n, i + n + size);
        i += size + n;
        if (i > buf3.length) {
          throw ParseError("Invalid address Uint8Array: " + uint8ArrayToString(buf3, "base16"));
        }
        tuples.push([code13, addr]);
      }
      return tuples;
    }
    function bytesToString(buf3) {
      const a = bytesToTuples(buf3);
      const b = tuplesToStringTuples(a);
      return stringTuplesToString(b);
    }
    function stringToBytes(str) {
      str = cleanPath(str);
      const a = stringToStringTuples(str);
      const b = stringTuplesToTuples(a);
      return tuplesToBytes(b);
    }
    function fromString7(str) {
      return stringToBytes(str);
    }
    function fromBytes2(buf3) {
      const err = validateBytes(buf3);
      if (err)
        throw err;
      return Uint8Array.from(buf3);
    }
    function validateBytes(buf3) {
      try {
        bytesToTuples(buf3);
      } catch (err) {
        return err;
      }
    }
    function isValidBytes(buf3) {
      return validateBytes(buf3) === void 0;
    }
    function cleanPath(str) {
      return "/" + str.trim().split("/").filter((a) => a).join("/");
    }
    function ParseError(str) {
      return new Error("Error parsing address: " + str);
    }
    function protoFromTuple(tup) {
      const proto = protocols(tup[0]);
      return proto;
    }
  }
});

// node_modules/uint8arrays/esm/src/equals.js
var equals_exports = {};
__export(equals_exports, {
  equals: () => equals3
});
function equals3(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
var init_equals = __esm({
  "node_modules/uint8arrays/esm/src/equals.js"() {
    init_globals();
  }
});

// node_modules/multiaddr/src/index.js
var require_src = __commonJS({
  "node_modules/multiaddr/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var codec = require_codec();
    var protocols = require_protocols_table();
    var varint7 = require_varint();
    var { CID: CID3 } = (init_cid(), __toCommonJS(cid_exports));
    var { base58btc: base58btc3 } = (init_base58(), __toCommonJS(base58_exports));
    var errCode69 = require_err_code();
    var inspect = Symbol.for("nodejs.util.inspect.custom");
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var resolvers3 = /* @__PURE__ */ new Map();
    var symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
    var Multiaddr22 = class {
      constructor(addr) {
        if (addr == null) {
          addr = "";
        }
        Object.defineProperty(this, symbol, { value: true });
        if (addr instanceof Uint8Array) {
          this.bytes = codec.fromBytes(addr);
        } else if (typeof addr === "string") {
          if (addr.length > 0 && addr.charAt(0) !== "/") {
            throw new Error(`multiaddr "${addr}" must start with a "/"`);
          }
          this.bytes = codec.fromString(addr);
        } else if (Multiaddr22.isMultiaddr(addr)) {
          this.bytes = codec.fromBytes(addr.bytes);
        } else {
          throw new Error("addr must be a string, Buffer, or another Multiaddr");
        }
      }
      toString() {
        return codec.bytesToString(this.bytes);
      }
      toJSON() {
        return this.toString();
      }
      toOptions() {
        const opts = {};
        const parsed = this.toString().split("/");
        opts.family = parsed[1] === "ip4" ? 4 : 6;
        opts.host = parsed[2];
        opts.transport = parsed[3];
        opts.port = parseInt(parsed[4]);
        return opts;
      }
      protos() {
        return this.protoCodes().map((code13) => Object.assign({}, protocols(code13)));
      }
      protoCodes() {
        const codes = [];
        const buf3 = this.bytes;
        let i = 0;
        while (i < buf3.length) {
          const code13 = varint7.decode(buf3, i);
          const n = varint7.decode.bytes;
          const p = protocols(code13);
          const size = codec.sizeForAddr(p, buf3.slice(i + n));
          i += size + n;
          codes.push(code13);
        }
        return codes;
      }
      protoNames() {
        return this.protos().map((proto) => proto.name);
      }
      tuples() {
        return codec.bytesToTuples(this.bytes);
      }
      stringTuples() {
        const t = codec.bytesToTuples(this.bytes);
        return codec.tuplesToStringTuples(t);
      }
      encapsulate(addr) {
        addr = new Multiaddr22(addr);
        return new Multiaddr22(this.toString() + addr.toString());
      }
      decapsulate(addr) {
        const addrString = addr.toString();
        const s = this.toString();
        const i = s.lastIndexOf(addrString);
        if (i < 0) {
          throw new Error("Address " + this + " does not contain subaddress: " + addr);
        }
        return new Multiaddr22(s.slice(0, i));
      }
      decapsulateCode(code13) {
        const tuples = this.tuples();
        for (let i = tuples.length - 1; i >= 0; i--) {
          if (tuples[i][0] === code13) {
            return new Multiaddr22(codec.tuplesToBytes(tuples.slice(0, i)));
          }
        }
        return this;
      }
      getPeerId() {
        try {
          const tuples = this.stringTuples().filter((tuple2) => {
            if (tuple2[0] === protocols.names.ipfs.code) {
              return true;
            }
            return false;
          });
          const tuple = tuples.pop();
          if (tuple && tuple[1]) {
            const peerIdStr = tuple[1];
            if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
              return uint8ArrayToString(base58btc3.decode(`z${peerIdStr}`), "base58btc");
            }
            return uint8ArrayToString(CID3.parse(peerIdStr).multihash.bytes, "base58btc");
          }
          return null;
        } catch (e) {
          return null;
        }
      }
      getPath() {
        let path = null;
        try {
          path = this.stringTuples().filter((tuple) => {
            const proto = protocols(tuple[0]);
            if (proto.path) {
              return true;
            }
            return false;
          })[0][1];
          if (!path) {
            path = null;
          }
        } catch (e) {
          path = null;
        }
        return path;
      }
      equals(addr) {
        return uint8ArrayEquals(this.bytes, addr.bytes);
      }
      async resolve() {
        const resolvableProto = this.protos().find((p) => p.resolvable);
        if (!resolvableProto) {
          return [this];
        }
        const resolver = resolvers3.get(resolvableProto.name);
        if (!resolver) {
          throw errCode69(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
        }
        const addresses = await resolver(this);
        return addresses.map((a) => new Multiaddr22(a));
      }
      nodeAddress() {
        const codes = this.protoCodes();
        const names = this.protoNames();
        const parts = this.toString().split("/").slice(1);
        if (parts.length < 4) {
          throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');
        } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {
          throw new Error(`no protocol with name: "'${names[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);
        } else if (parts[2] !== "tcp" && parts[2] !== "udp") {
          throw new Error(`no protocol with name: "'${names[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
        }
        return {
          family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,
          address: parts[1],
          port: parseInt(parts[3])
        };
      }
      isThinWaistAddress(addr) {
        const protos = (addr || this).protos();
        if (protos.length !== 2) {
          return false;
        }
        if (protos[0].code !== 4 && protos[0].code !== 41) {
          return false;
        }
        if (protos[1].code !== 6 && protos[1].code !== 273) {
          return false;
        }
        return true;
      }
      static fromNodeAddress(addr, transport) {
        if (!addr) {
          throw new Error("requires node address object");
        }
        if (!transport) {
          throw new Error("requires transport protocol");
        }
        let ip;
        switch (addr.family) {
          case 4:
            ip = "ip4";
            break;
          case 6:
            ip = "ip6";
            break;
          default:
            throw Error(`Invalid addr family. Got '${addr.family}' instead of 4 or 6`);
        }
        return new Multiaddr22("/" + [ip, addr.address, transport, addr.port].join("/"));
      }
      static isName(addr) {
        if (!Multiaddr22.isMultiaddr(addr)) {
          return false;
        }
        return addr.protos().some((proto) => proto.resolvable);
      }
      static isMultiaddr(value) {
        return value instanceof Multiaddr22 || Boolean(value && value[symbol]);
      }
      [inspect]() {
        return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
      }
      inspect() {
        return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
      }
    };
    Multiaddr22.protocols = protocols;
    Multiaddr22.resolvers = resolvers3;
    function multiaddr(addr) {
      return new Multiaddr22(addr);
    }
    module2.exports = { Multiaddr: Multiaddr22, multiaddr, protocols, resolvers: resolvers3 };
  }
});

// node_modules/mafmt/src/index.js
var require_src2 = __commonJS({
  "node_modules/mafmt/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Multiaddr: Multiaddr22 } = require_src();
    var DNS4 = base4("dns4");
    var DNS6 = base4("dns6");
    var DNSADDR = base4("dnsaddr");
    var DNS = or3(base4("dns"), DNSADDR, DNS4, DNS6);
    var IP = or3(base4("ip4"), base4("ip6"));
    var TCP = or3(and(IP, base4("tcp")), and(DNS, base4("tcp")));
    var UDP = and(IP, base4("udp"));
    var UTP = and(UDP, base4("utp"));
    var QUIC = and(UDP, base4("quic"));
    var WebSockets = or3(and(TCP, base4("ws")), and(DNS, base4("ws")));
    var WebSocketsSecure = or3(and(TCP, base4("wss")), and(DNS, base4("wss")));
    var HTTP5 = or3(and(TCP, base4("http")), and(IP, base4("http")), and(DNS, base4("http")));
    var HTTPS = or3(and(TCP, base4("https")), and(IP, base4("https")), and(DNS, base4("https")));
    var WebRTCStar2 = or3(and(WebSockets, base4("p2p-webrtc-star"), base4("p2p")), and(WebSocketsSecure, base4("p2p-webrtc-star"), base4("p2p")), and(WebSockets, base4("p2p-webrtc-star")), and(WebSocketsSecure, base4("p2p-webrtc-star")));
    var WebSocketStar = or3(and(WebSockets, base4("p2p-websocket-star"), base4("p2p")), and(WebSocketsSecure, base4("p2p-websocket-star"), base4("p2p")), and(WebSockets, base4("p2p-websocket-star")), and(WebSocketsSecure, base4("p2p-websocket-star")));
    var WebRTCDirect = or3(and(HTTP5, base4("p2p-webrtc-direct"), base4("p2p")), and(HTTPS, base4("p2p-webrtc-direct"), base4("p2p")), and(HTTP5, base4("p2p-webrtc-direct")), and(HTTPS, base4("p2p-webrtc-direct")));
    var Reliable = or3(WebSockets, WebSocketsSecure, HTTP5, HTTPS, WebRTCStar2, WebRTCDirect, TCP, UTP, QUIC, DNS);
    var Stardust = or3(and(Reliable, base4("p2p-stardust"), base4("p2p")), and(Reliable, base4("p2p-stardust")));
    var _P2P = or3(and(Reliable, base4("p2p")), WebRTCStar2, WebRTCDirect, base4("p2p"));
    var _Circuit = or3(and(_P2P, base4("p2p-circuit"), _P2P), and(_P2P, base4("p2p-circuit")), and(base4("p2p-circuit"), _P2P), and(Reliable, base4("p2p-circuit")), and(base4("p2p-circuit"), Reliable), base4("p2p-circuit"));
    var CircuitRecursive = () => or3(and(_Circuit, CircuitRecursive), _Circuit);
    var Circuit = CircuitRecursive();
    var P2P = or3(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
    module2.exports = {
      DNS,
      DNS4,
      DNS6,
      DNSADDR,
      IP,
      TCP,
      UDP,
      QUIC,
      UTP,
      HTTP: HTTP5,
      HTTPS,
      WebSockets,
      WebSocketsSecure,
      WebSocketStar,
      WebRTCStar: WebRTCStar2,
      WebRTCDirect,
      Reliable,
      Stardust,
      Circuit,
      P2P,
      IPFS: P2P
    };
    function makeMatchesFunction(partialMatch) {
      function matches(a) {
        if (!Multiaddr22.isMultiaddr(a)) {
          try {
            a = new Multiaddr22(a);
          } catch (err) {
            return false;
          }
        }
        const out = partialMatch(a.protoNames());
        if (out === null) {
          return false;
        }
        if (out === true || out === false) {
          return out;
        }
        return out.length === 0;
      }
      return matches;
    }
    function and(...args) {
      function partialMatch(a) {
        if (a.length < args.length) {
          return null;
        }
        let out = a;
        args.some((arg) => {
          out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
          if (Array.isArray(out)) {
            a = out;
          }
          if (out === null) {
            return true;
          }
          return false;
        });
        return out;
      }
      return {
        toString: function() {
          return "{ " + args.join(" ") + " }";
        },
        input: args,
        matches: makeMatchesFunction(partialMatch),
        partialMatch
      };
    }
    function or3(...args) {
      function partialMatch(a) {
        let out = null;
        args.some((arg) => {
          const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
          if (res) {
            out = res;
            return true;
          }
          return false;
        });
        return out;
      }
      const result = {
        toString: function() {
          return "{ " + args.join(" ") + " }";
        },
        input: args,
        matches: makeMatchesFunction(partialMatch),
        partialMatch
      };
      return result;
    }
    function base4(n) {
      const name10 = n;
      function matches(a) {
        let ma;
        if (typeof a === "string" || a instanceof Uint8Array) {
          try {
            ma = new Multiaddr22(a);
          } catch (err) {
            return false;
          }
        } else {
          ma = a;
        }
        const pnames = ma.protoNames();
        if (pnames.length === 1 && pnames[0] === name10) {
          return true;
        }
        return false;
      }
      function partialMatch(protos) {
        if (protos.length === 0) {
          return null;
        }
        if (protos[0] === name10) {
          return protos.slice(1);
        }
        return null;
      }
      return {
        toString: function() {
          return name10;
        },
        matches,
        partialMatch
      };
    }
  }
});

// node_modules/iso-url/src/url-browser.js
var require_url_browser = __commonJS({
  "node_modules/iso-url/src/url-browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    function getDefaultBase() {
      if (isReactNative) {
        return "http://localhost";
      }
      if (!self.location) {
        return "";
      }
      return self.location.protocol + "//" + self.location.host;
    }
    var URL2 = self.URL;
    var defaultBase = getDefaultBase();
    var URLWithLegacySupport = class {
      constructor(url = "", base4 = defaultBase) {
        this.super = new URL2(url, base4);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ":" + this.password : null;
        this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
      }
      get hash() {
        return this.super.hash;
      }
      get host() {
        return this.super.host;
      }
      get hostname() {
        return this.super.hostname;
      }
      get href() {
        return this.super.href;
      }
      get origin() {
        return this.super.origin;
      }
      get password() {
        return this.super.password;
      }
      get pathname() {
        return this.super.pathname;
      }
      get port() {
        return this.super.port;
      }
      get protocol() {
        return this.super.protocol;
      }
      get search() {
        return this.super.search;
      }
      get searchParams() {
        return this.super.searchParams;
      }
      get username() {
        return this.super.username;
      }
      set hash(hash2) {
        this.super.hash = hash2;
      }
      set host(host) {
        this.super.host = host;
      }
      set hostname(hostname) {
        this.super.hostname = hostname;
      }
      set href(href) {
        this.super.href = href;
      }
      set password(password) {
        this.super.password = password;
      }
      set pathname(pathname) {
        this.super.pathname = pathname;
      }
      set port(port) {
        this.super.port = port;
      }
      set protocol(protocol) {
        this.super.protocol = protocol;
      }
      set search(search) {
        this.super.search = search;
      }
      set username(username) {
        this.super.username = username;
      }
      static createObjectURL(o) {
        return URL2.createObjectURL(o);
      }
      static revokeObjectURL(o) {
        URL2.revokeObjectURL(o);
      }
      toJSON() {
        return this.super.toJSON();
      }
      toString() {
        return this.super.toString();
      }
      format() {
        return this.toString();
      }
    };
    function format(obj) {
      if (typeof obj === "string") {
        const url = new URL2(obj);
        return url.toString();
      }
      if (!(obj instanceof URL2)) {
        const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
        const auth = obj.auth ? obj.auth + "@" : "";
        const port = obj.port ? ":" + obj.port : "";
        const protocol = obj.protocol ? obj.protocol + "//" : "";
        const host = obj.host || "";
        const hostname = obj.hostname || "";
        const search = obj.search || (obj.query ? "?" + obj.query : "");
        const hash2 = obj.hash || "";
        const pathname = obj.pathname || "";
        const path = obj.path || pathname + search;
        return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash2}`;
      }
    }
    module2.exports = {
      URLWithLegacySupport,
      URLSearchParams: self.URLSearchParams,
      defaultBase,
      format
    };
  }
});

// node_modules/iso-url/src/relative.js
var require_relative = __commonJS({
  "node_modules/iso-url/src/relative.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { URLWithLegacySupport, format } = require_url_browser();
    module2.exports = (url, location2 = {}, protocolMap = {}, defaultProtocol) => {
      let protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
      protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
      let urlParsed;
      try {
        urlParsed = new URLWithLegacySupport(url);
      } catch (err) {
        urlParsed = {};
      }
      const base4 = Object.assign({}, location2, {
        protocol: protocol || urlParsed.protocol,
        host: location2.host || urlParsed.host
      });
      return new URLWithLegacySupport(url, format(base4)).toString();
    };
  }
});

// node_modules/iso-url/index.js
var require_iso_url = __commonJS({
  "node_modules/iso-url/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var {
      URLWithLegacySupport,
      format,
      URLSearchParams: URLSearchParams2,
      defaultBase
    } = require_url_browser();
    var relative = require_relative();
    module2.exports = {
      URL: URLWithLegacySupport,
      URLSearchParams: URLSearchParams2,
      format,
      relative,
      defaultBase
    };
  }
});

// node_modules/is-ipfs/src/index.js
var require_src3 = __commonJS({
  "node_modules/is-ipfs/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { base58btc: base58btc3 } = (init_base58(), __toCommonJS(base58_exports));
    var { base32: base323 } = (init_base32(), __toCommonJS(base32_exports));
    var Digest3 = (init_digest(), __toCommonJS(digest_exports));
    var { Multiaddr: Multiaddr22 } = require_src();
    var mafmt2 = require_src2();
    var { CID: CID3 } = (init_cid(), __toCommonJS(cid_exports));
    var { URL: URL2 } = require_iso_url();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var pathGatewayPattern = /^https?:\/\/[^/]+\/(ip[fn]s)\/([^/?#]+)/;
    var pathPattern = /^\/(ip[fn]s)\/([^/?#]+)/;
    var defaultProtocolMatch = 1;
    var defaultHashMath = 2;
    var subdomainGatewayPattern = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/;
    var subdomainIdMatch = 1;
    var subdomainProtocolMatch = 2;
    var fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
    function isMultihash(hash2) {
      const formatted = convertToString(hash2);
      try {
        Digest3.decode(base58btc3.decode("z" + formatted));
      } catch {
        return false;
      }
      return true;
    }
    function isBase32EncodedMultibase(hash2) {
      try {
        base323.decode(hash2);
      } catch {
        return false;
      }
      return true;
    }
    function isCID(hash2) {
      try {
        if (typeof hash2 === "string") {
          return Boolean(CID3.parse(hash2));
        }
        if (hash2 instanceof Uint8Array) {
          return Boolean(CID3.decode(hash2));
        }
        return Boolean(CID3.asCID(hash2));
      } catch (e) {
        return false;
      }
    }
    function isMultiaddr(input) {
      if (!input)
        return false;
      if (Multiaddr22.isMultiaddr(input))
        return true;
      try {
        new Multiaddr22(input);
        return true;
      } catch (e) {
        return false;
      }
    }
    function isPeerMultiaddr(input) {
      return isMultiaddr(input) && mafmt2.P2P.matches(input);
    }
    function isIpfs4(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
      const formatted = convertToString(input);
      if (!formatted) {
        return false;
      }
      const match = formatted.match(pattern);
      if (!match) {
        return false;
      }
      if (match[protocolMatch] !== "ipfs") {
        return false;
      }
      let hash2 = match[hashMatch];
      if (hash2 && pattern === subdomainGatewayPattern) {
        hash2 = hash2.toLowerCase();
      }
      return isCID(hash2);
    }
    function isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
      const formatted = convertToString(input);
      if (!formatted) {
        return false;
      }
      const match = formatted.match(pattern);
      if (!match) {
        return false;
      }
      if (match[protocolMatch] !== "ipns") {
        return false;
      }
      let ipnsId = match[hashMatch];
      if (ipnsId && pattern === subdomainGatewayPattern) {
        ipnsId = ipnsId.toLowerCase();
        if (isCID(ipnsId))
          return true;
        try {
          if (!ipnsId.includes(".") && ipnsId.includes("-")) {
            ipnsId = ipnsId.replace(/--/g, "@").replace(/-/g, ".").replace(/@/g, "-");
          }
          const { hostname } = new URL2(`http://${ipnsId}`);
          return fqdnWithTld.test(hostname);
        } catch (e) {
          return false;
        }
      }
      return true;
    }
    function isString(input) {
      return typeof input === "string";
    }
    function convertToString(input) {
      if (input instanceof Uint8Array) {
        return uint8ArrayToString(input, "base58btc");
      }
      if (isString(input)) {
        return input;
      }
      return false;
    }
    var ipfsSubdomain = (url2) => isIpfs4(url2, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);
    var ipnsSubdomain = (url2) => isIpns(url2, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);
    var subdomain = (url2) => ipfsSubdomain(url2) || ipnsSubdomain(url2);
    var ipfsUrl = (url2) => isIpfs4(url2, pathGatewayPattern) || ipfsSubdomain(url2);
    var ipnsUrl = (url2) => isIpns(url2, pathGatewayPattern) || ipnsSubdomain(url2);
    var url = (url2) => ipfsUrl(url2) || ipnsUrl(url2) || subdomain(url2);
    var path = (path2) => isIpfs4(path2, pathPattern) || isIpns(path2, pathPattern);
    module2.exports = {
      multihash: isMultihash,
      multiaddr: isMultiaddr,
      peerMultiaddr: isPeerMultiaddr,
      cid: isCID,
      base32cid: (cid) => isBase32EncodedMultibase(cid) && isCID(cid),
      ipfsSubdomain,
      ipnsSubdomain,
      subdomain,
      subdomainGatewayPattern,
      ipfsUrl,
      ipnsUrl,
      url,
      pathGatewayPattern,
      ipfsPath: (path2) => isIpfs4(path2, pathPattern),
      ipnsPath: (path2) => isIpns(path2, pathPattern),
      path,
      pathPattern,
      urlOrPath: (x) => url(x) || path(x),
      cidPath: (path2) => isString(path2) && !isCID(path2) && isIpfs4(`/ipfs/${path2}`, pathPattern)
    };
  }
});

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet;
var init_url_alphabet = __esm({
  "node_modules/nanoid/url-alphabet/index.js"() {
    init_globals();
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  }
});

// node_modules/nanoid/index.browser.js
var index_browser_exports = {};
__export(index_browser_exports, {
  customAlphabet: () => customAlphabet,
  customRandom: () => customRandom,
  nanoid: () => nanoid,
  random: () => random,
  urlAlphabet: () => urlAlphabet
});
var random, customRandom, customAlphabet, nanoid;
var init_index_browser = __esm({
  "node_modules/nanoid/index.browser.js"() {
    init_globals();
    init_url_alphabet();
    random = (bytes2) => crypto.getRandomValues(new Uint8Array(bytes2));
    customRandom = (alphabet, defaultSize, getRandom) => {
      let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      let step = -~(1.6 * mask * defaultSize / alphabet.length);
      return (size = defaultSize) => {
        let id = "";
        while (true) {
          let bytes2 = getRandom(step);
          let j = step;
          while (j--) {
            id += alphabet[bytes2[j] & mask] || "";
            if (id.length === size)
              return id;
          }
        }
      };
    };
    customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);
    nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
      byte &= 63;
      if (byte < 36) {
        id += byte.toString(36);
      } else if (byte < 62) {
        id += (byte - 26).toString(36).toUpperCase();
      } else if (byte > 62) {
        id += "-";
      } else {
        id += "_";
      }
      return id;
    }, "");
  }
});

// node_modules/interface-datastore/esm/src/key.js
var key_exports = {};
__export(key_exports, {
  Key: () => Key
});
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}
var pathSepS, pathSepB, pathSep, Key;
var init_key = __esm({
  "node_modules/interface-datastore/esm/src/key.js"() {
    init_globals();
    init_index_browser();
    init_to_string();
    init_from_string();
    pathSepS = "/";
    pathSepB = new TextEncoder().encode(pathSepS);
    pathSep = pathSepB[0];
    Key = class {
      constructor(s, clean) {
        if (typeof s === "string") {
          this._buf = fromString3(s);
        } else if (s instanceof Uint8Array) {
          this._buf = s;
        } else {
          throw new Error("Invalid key, should be String of Uint8Array");
        }
        if (clean == null) {
          clean = true;
        }
        if (clean) {
          this.clean();
        }
        if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
          throw new Error("Invalid key");
        }
      }
      toString(encoding = "utf8") {
        return toString3(this._buf, encoding);
      }
      uint8Array() {
        return this._buf;
      }
      get [Symbol.toStringTag]() {
        return `Key(${this.toString()})`;
      }
      static withNamespaces(list) {
        return new Key(list.join(pathSepS));
      }
      static random() {
        return new Key(nanoid().replace(/-/g, ""));
      }
      static asKey(other) {
        if (other instanceof Uint8Array || typeof other === "string") {
          return new Key(other);
        }
        if (other.uint8Array) {
          return new Key(other.uint8Array());
        }
        return null;
      }
      clean() {
        if (!this._buf || this._buf.byteLength === 0) {
          this._buf = pathSepB;
        }
        if (this._buf[0] !== pathSep) {
          const bytes2 = new Uint8Array(this._buf.byteLength + 1);
          bytes2.fill(pathSep, 0, 1);
          bytes2.set(this._buf, 1);
          this._buf = bytes2;
        }
        while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
          this._buf = this._buf.subarray(0, -1);
        }
      }
      less(key) {
        const list1 = this.list();
        const list2 = key.list();
        for (let i = 0; i < list1.length; i++) {
          if (list2.length < i + 1) {
            return false;
          }
          const c1 = list1[i];
          const c2 = list2[i];
          if (c1 < c2) {
            return true;
          } else if (c1 > c2) {
            return false;
          }
        }
        return list1.length < list2.length;
      }
      reverse() {
        return Key.withNamespaces(this.list().slice().reverse());
      }
      namespaces() {
        return this.list();
      }
      baseNamespace() {
        const ns = this.namespaces();
        return ns[ns.length - 1];
      }
      list() {
        return this.toString().split(pathSepS).slice(1);
      }
      type() {
        return namespaceType(this.baseNamespace());
      }
      name() {
        return namespaceValue(this.baseNamespace());
      }
      instance(s) {
        return new Key(this.toString() + ":" + s);
      }
      path() {
        let p = this.parent().toString();
        if (!p.endsWith(pathSepS)) {
          p += pathSepS;
        }
        p += this.type();
        return new Key(p);
      }
      parent() {
        const list = this.list();
        if (list.length === 1) {
          return new Key(pathSepS);
        }
        return new Key(list.slice(0, -1).join(pathSepS));
      }
      child(key) {
        if (this.toString() === pathSepS) {
          return key;
        } else if (key.toString() === pathSepS) {
          return this;
        }
        return new Key(this.toString() + key.toString(), false);
      }
      isAncestorOf(other) {
        if (other.toString() === this.toString()) {
          return false;
        }
        return other.toString().startsWith(this.toString());
      }
      isDecendantOf(other) {
        if (other.toString() === this.toString()) {
          return false;
        }
        return this.toString().startsWith(other.toString());
      }
      isTopLevel() {
        return this.list().length === 1;
      }
      concat(...keys2) {
        return Key.withNamespaces([
          ...this.namespaces(),
          ...flatten(keys2.map((key) => key.namespaces()))
        ]);
      }
    };
  }
});

// node_modules/retimer/time-browser.js
var require_time_browser = __commonJS({
  "node_modules/retimer/time-browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = function getTime() {
      return Date.now();
    };
  }
});

// node_modules/retimer/retimer.js
var require_retimer = __commonJS({
  "node_modules/retimer/retimer.js"(exports2, module2) {
    "use strict";
    init_globals();
    var getTime = require_time_browser();
    var Retimer = class {
      constructor(callback, timeout, args) {
        const that = this;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._args = args;
        this._triggered = false;
        this._timerWrapper = () => {
          if (that._rescheduled > 0) {
            that._scheduled = that._rescheduled - (getTime() - that._started);
            that._schedule(that._scheduled);
          } else {
            that._triggered = true;
            callback.apply(null, that._args);
          }
        };
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      reschedule(timeout) {
        if (!timeout) {
          timeout = this._scheduled;
        }
        const now = getTime();
        if (now + timeout - (this._started + this._scheduled) < 0) {
          clearTimeout(this._timer);
          this._schedule(timeout);
        } else if (!this._triggered) {
          this._started = now;
          this._rescheduled = timeout;
        } else {
          this._schedule(timeout);
        }
      }
      _schedule(timeout) {
        this._triggered = false;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      clear() {
        clearTimeout(this._timer);
      }
    };
    function retimer() {
      if (typeof arguments[0] !== "function") {
        throw new Error("callback needed");
      }
      if (typeof arguments[1] !== "number") {
        throw new Error("timeout needed");
      }
      let args;
      if (arguments.length > 0) {
        args = new Array(arguments.length - 2);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 2];
        }
      }
      return new Retimer(arguments[0], arguments[1], args);
    }
    module2.exports = retimer;
  }
});

// node_modules/timeout-abort-controller/index.js
var require_timeout_abort_controller = __commonJS({
  "node_modules/timeout-abort-controller/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { AbortController: AbortController2 } = globalThis;
    var retimer = require_retimer();
    var TimeoutController3 = class extends AbortController2 {
      constructor(ms) {
        super();
        this._ms = ms;
        this._timer = retimer(() => this.abort(), ms);
        Object.setPrototypeOf(this, TimeoutController3.prototype);
      }
      abort() {
        this._timer.clear();
        return super.abort();
      }
      clear() {
        this._timer.clear();
      }
      reset() {
        this._timer.clear();
        this._timer = retimer(() => this.abort(), this._ms);
      }
    };
    module2.exports = {
      TimeoutController: TimeoutController3
    };
  }
});

// node_modules/any-signal/index.js
var require_any_signal = __commonJS({
  "node_modules/any-signal/index.js"(exports2, module2) {
    init_globals();
    function anySignal5(signals) {
      const controller = new globalThis.AbortController();
      function onAbort() {
        controller.abort();
        for (const signal of signals) {
          if (!signal || !signal.removeEventListener)
            continue;
          signal.removeEventListener("abort", onAbort);
        }
      }
      for (const signal of signals) {
        if (!signal || !signal.addEventListener)
          continue;
        if (signal.aborted) {
          onAbort();
          break;
        }
        signal.addEventListener("abort", onAbort);
      }
      return controller.signal;
    }
    module2.exports = anySignal5;
    module2.exports.anySignal = anySignal5;
  }
});

// node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports2, module2) {
    init_globals();
    module2.exports = function(max) {
      if (!max)
        throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache2 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value) {
        cache2[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache2;
          cache2 = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache2[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache2[key] !== void 0)
            cache2[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache2[key];
          if (v !== void 0)
            return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache2[key] !== void 0)
            cache2[key] = value;
          else
            update(key, value);
        },
        clear: function() {
          cache2 = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter4() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter4.prototype.eventNames = function eventNames() {
      var names = [], events2, name10;
      if (this._eventsCount === 0)
        return names;
      for (name10 in events2 = this._events) {
        if (has.call(events2, name10))
          names.push(prefix ? name10.slice(1) : name10);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter4.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter4.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter4.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length5 = listeners.length, j;
        for (i = 0; i < length5; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter4.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter4.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter4.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length5 = listeners.length; i < length5; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter4.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter4.prototype.off = EventEmitter4.prototype.removeListener;
    EventEmitter4.prototype.addListener = EventEmitter4.prototype.on;
    EventEmitter4.prefixed = prefix;
    EventEmitter4.EventEmitter = EventEmitter4;
    if (typeof module2 !== "undefined") {
      module2.exports = EventEmitter4;
    }
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then((val) => new Promise((resolve11) => {
        resolve11(onFinally());
      }).then(() => val), (err) => new Promise((resolve11) => {
        resolve11(onFinally());
      }).then(() => {
        throw err;
      }));
    };
  }
});

// node_modules/p-queue/node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/p-queue/node_modules/p-timeout/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var pFinally = require_p_finally();
    var TimeoutError2 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve11, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve11(promise);
        return;
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve11(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError2(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally(promise.then(resolve11, reject), () => {
        clearTimeout(timer);
      });
    });
    module2.exports = pTimeout;
    module2.exports.default = pTimeout;
    module2.exports.TimeoutError = TimeoutError2;
  }
});

// node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS({
  "node_modules/p-queue/dist/lower-bound.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function lowerBound(array, value, comparator) {
      let first4 = 0;
      let count = array.length;
      while (count > 0) {
        const step = count / 2 | 0;
        let it = first4 + step;
        if (comparator(array[it], value) <= 0) {
          first4 = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first4;
    }
    exports2.default = lowerBound;
  }
});

// node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/p-queue/dist/priority-queue.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var lower_bound_1 = require_lower_bound();
    var PriorityQueue = class {
      constructor() {
        this._queue = [];
      }
      enqueue(run, options) {
        options = Object.assign({ priority: 0 }, options);
        const element = {
          priority: options.priority,
          run
        };
        if (this.size && this._queue[this.size - 1].priority >= options.priority) {
          this._queue.push(element);
          return;
        }
        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
        this._queue.splice(index, 0, element);
      }
      dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
      }
      filter(options) {
        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
      }
      get size() {
        return this._queue.length;
      }
    };
    exports2.default = PriorityQueue;
  }
});

// node_modules/p-queue/dist/index.js
var require_dist = __commonJS({
  "node_modules/p-queue/dist/index.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var EventEmitter4 = require_eventemitter3();
    var p_timeout_1 = require_p_timeout();
    var priority_queue_1 = require_priority_queue();
    var empty3 = () => {
    };
    var timeoutError = new p_timeout_1.TimeoutError();
    var PQueue4 = class extends EventEmitter4 {
      constructor(options) {
        var _a, _b, _c, _d;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty3;
        this._resolveIdle = empty3;
        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
        if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
          throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
          throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty3;
        if (this._pendingCount === 0) {
          this._resolveIdle();
          this._resolveIdle = empty3;
          this.emit("idle");
        }
      }
      _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        const now = Date.now();
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now;
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval();
              }, delay);
            }
            return true;
          }
        }
        return false;
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = void 0;
          this._resolvePromises();
          return false;
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused();
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            const job = this._queue.dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded();
            }
            return true;
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return;
        }
        this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
      }
      _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        this._processQueue();
      }
      _processQueue() {
        while (this._tryToStartAnother()) {
        }
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this._concurrency = newConcurrency;
        this._processQueue();
      }
      async add(fn, options = {}) {
        return new Promise((resolve11, reject) => {
          const run = async () => {
            this._pendingCount++;
            this._intervalCount++;
            try {
              const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
                if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                  reject(timeoutError);
                }
                return void 0;
              });
              resolve11(await operation);
            } catch (error) {
              reject(error);
            }
            this._next();
          };
          this._queue.enqueue(run, options);
          this._tryToStartAnother();
          this.emit("add");
        });
      }
      async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
      }
      start() {
        if (!this._isPaused) {
          return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
      }
      pause() {
        this._isPaused = true;
      }
      clear() {
        this._queue = new this._queueClass();
      }
      async onEmpty() {
        if (this._queue.size === 0) {
          return;
        }
        return new Promise((resolve11) => {
          const existingResolve = this._resolveEmpty;
          this._resolveEmpty = () => {
            existingResolve();
            resolve11();
          };
        });
      }
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return;
        }
        return new Promise((resolve11) => {
          const existingResolve = this._resolveIdle;
          this._resolveIdle = () => {
            existingResolve();
            resolve11();
          };
        });
      }
      get size() {
        return this._queue.size;
      }
      sizeBy(options) {
        return this._queue.filter(options).length;
      }
      get pending() {
        return this._pendingCount;
      }
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      set timeout(milliseconds) {
        this._timeout = milliseconds;
      }
    };
    exports2.default = PQueue4;
  }
});

// node_modules/ipfs-utils/src/http/error.js
var require_error = __commonJS({
  "node_modules/ipfs-utils/src/http/error.js"(exports2) {
    "use strict";
    init_globals();
    var TimeoutError2 = class extends Error {
      constructor(message = "Request timed out") {
        super(message);
        this.name = "TimeoutError";
      }
    };
    exports2.TimeoutError = TimeoutError2;
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted.") {
        super(message);
        this.name = "AbortError";
      }
    };
    exports2.AbortError = AbortError;
    var HTTPError2 = class extends Error {
      constructor(response) {
        super(response.statusText);
        this.name = "HTTPError";
        this.response = response;
      }
    };
    exports2.HTTPError = HTTPError2;
  }
});

// (disabled):node_modules/electron-fetch/lib/index.js
var require_lib2 = __commonJS({
  "(disabled):node_modules/electron-fetch/lib/index.js"() {
    init_globals();
  }
});

// node_modules/node-fetch/browser.js
var require_browser3 = __commonJS({
  "node_modules/node-fetch/browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global2 !== "undefined") {
        return global2;
      }
      throw new Error("unable to locate global object");
    };
    var global2 = getGlobal();
    module2.exports = exports2 = global2.fetch;
    if (global2.fetch) {
      exports2.default = global2.fetch.bind(global2);
    }
    exports2.Headers = global2.Headers;
    exports2.Request = global2.Request;
    exports2.Response = global2.Response;
  }
});

// node_modules/native-fetch/src/index.js
var require_src4 = __commonJS({
  "node_modules/native-fetch/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
      module2.exports = {
        default: globalThis.fetch,
        Headers: globalThis.Headers,
        Request: globalThis.Request,
        Response: globalThis.Response
      };
    } else {
      module2.exports = {
        default: require_browser3().default,
        Headers: require_browser3().Headers,
        Request: require_browser3().Request,
        Response: require_browser3().Response
      };
    }
  }
});

// node_modules/ipfs-utils/src/fetch.js
var require_fetch = __commonJS({
  "node_modules/ipfs-utils/src/fetch.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { isElectronMain } = require_env();
    if (isElectronMain) {
      module2.exports = require_lib2();
    } else {
      module2.exports = require_src4();
    }
  }
});

// node_modules/ipfs-utils/src/http/fetch.browser.js
var require_fetch_browser = __commonJS({
  "node_modules/ipfs-utils/src/http/fetch.browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { TimeoutError: TimeoutError2, AbortError } = require_error();
    var { Response: Response2, Request, Headers, default: fetch } = require_fetch();
    var fetchWithProgress = (url, options = {}) => {
      const request = new XMLHttpRequest();
      request.open(options.method || "GET", url.toString(), true);
      const { timeout, headers } = options;
      if (timeout && timeout > 0 && timeout < Infinity) {
        request.timeout = timeout;
      }
      if (options.overrideMimeType != null) {
        request.overrideMimeType(options.overrideMimeType);
      }
      if (headers) {
        for (const [name10, value] of new Headers(headers)) {
          request.setRequestHeader(name10, value);
        }
      }
      if (options.signal) {
        options.signal.onabort = () => request.abort();
      }
      if (options.onUploadProgress) {
        request.upload.onprogress = options.onUploadProgress;
      }
      request.responseType = "arraybuffer";
      return new Promise((resolve11, reject) => {
        const handleEvent = (event) => {
          switch (event.type) {
            case "error": {
              resolve11(Response2.error());
              break;
            }
            case "load": {
              resolve11(new ResponseWithURL(request.responseURL, request.response, {
                status: request.status,
                statusText: request.statusText,
                headers: parseHeaders(request.getAllResponseHeaders())
              }));
              break;
            }
            case "timeout": {
              reject(new TimeoutError2());
              break;
            }
            case "abort": {
              reject(new AbortError());
              break;
            }
            default: {
              break;
            }
          }
        };
        request.onerror = handleEvent;
        request.onload = handleEvent;
        request.ontimeout = handleEvent;
        request.onabort = handleEvent;
        request.send(options.body);
      });
    };
    var fetchWithStreaming = fetch;
    var fetchWith = (url, options = {}) => options.onUploadProgress != null ? fetchWithProgress(url, options) : fetchWithStreaming(url, options);
    var parseHeaders = (input) => {
      const headers = new Headers();
      for (const line of input.trim().split(/[\r\n]+/)) {
        const index = line.indexOf(": ");
        if (index > 0) {
          headers.set(line.slice(0, index), line.slice(index + 1));
        }
      }
      return headers;
    };
    var ResponseWithURL = class extends Response2 {
      constructor(url, body, options) {
        super(body, options);
        Object.defineProperty(this, "url", { value: url });
      }
    };
    module2.exports = {
      fetch: fetchWith,
      Request,
      Headers
    };
  }
});

// node_modules/ipfs-utils/src/http.js
var require_http = __commonJS({
  "node_modules/ipfs-utils/src/http.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { fetch, Request, Headers } = require_fetch_browser();
    var { TimeoutError: TimeoutError2, HTTPError: HTTPError2 } = require_error();
    var merge5 = require_merge_options().bind({ ignoreUndefined: true });
    var { URL: URL2, URLSearchParams: URLSearchParams2 } = require_iso_url();
    var anySignal5 = require_any_signal();
    var timeout = (promise, ms, abortController) => {
      if (ms === void 0) {
        return promise;
      }
      const start = Date.now();
      const timedOut = () => {
        const time = Date.now() - start;
        return time >= ms;
      };
      return new Promise((resolve11, reject) => {
        const timeoutID = setTimeout(() => {
          if (timedOut()) {
            reject(new TimeoutError2());
            abortController.abort();
          }
        }, ms);
        const after = (next) => {
          const fn = (res) => {
            clearTimeout(timeoutID);
            if (timedOut()) {
              reject(new TimeoutError2());
              return;
            }
            next(res);
          };
          return fn;
        };
        promise.then(after(resolve11), after(reject));
      });
    };
    var defaults = {
      throwHttpErrors: true,
      credentials: "same-origin"
    };
    var HTTP5 = class {
      constructor(options = {}) {
        this.opts = merge5(defaults, options);
      }
      async fetch(resource, options = {}) {
        const opts = merge5(this.opts, options);
        const headers = new Headers(opts.headers);
        if (typeof resource !== "string" && !(resource instanceof URL2 || resource instanceof Request)) {
          throw new TypeError("`resource` must be a string, URL, or Request");
        }
        const url = new URL2(resource.toString(), opts.base);
        const {
          searchParams,
          transformSearchParams,
          json
        } = opts;
        if (searchParams) {
          if (typeof transformSearchParams === "function") {
            url.search = transformSearchParams(new URLSearchParams2(opts.searchParams));
          } else {
            url.search = new URLSearchParams2(opts.searchParams);
          }
        }
        if (json) {
          opts.body = JSON.stringify(opts.json);
          headers.set("content-type", "application/json");
        }
        const abortController = new AbortController();
        const signal = anySignal5([abortController.signal, opts.signal]);
        const response = await timeout(fetch(url.toString(), {
          ...opts,
          signal,
          timeout: void 0,
          headers
        }), opts.timeout, abortController);
        if (!response.ok && opts.throwHttpErrors) {
          if (opts.handleError) {
            await opts.handleError(response);
          }
          throw new HTTPError2(response);
        }
        response.iterator = function() {
          return fromStream(response.body);
        };
        response.ndjson = async function* () {
          for await (const chunk of ndjson(response.iterator())) {
            if (options.transform) {
              yield options.transform(chunk);
            } else {
              yield chunk;
            }
          }
        };
        return response;
      }
      post(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "POST" });
      }
      get(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "GET" });
      }
      put(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "PUT" });
      }
      delete(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "DELETE" });
      }
      options(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "OPTIONS" });
      }
    };
    var ndjson = async function* (source) {
      const decoder = new TextDecoder();
      let buf3 = "";
      for await (const chunk of source) {
        buf3 += decoder.decode(chunk, { stream: true });
        const lines = buf3.split(/\r?\n/);
        for (let i = 0; i < lines.length - 1; i++) {
          const l = lines[i].trim();
          if (l.length > 0) {
            yield JSON.parse(l);
          }
        }
        buf3 = lines[lines.length - 1];
      }
      buf3 += decoder.decode();
      buf3 = buf3.trim();
      if (buf3.length !== 0) {
        yield JSON.parse(buf3);
      }
    };
    var fromStream = (source) => {
      if (isNodeReadableStream(source)) {
        const iter = source[Symbol.asyncIterator]();
        return {
          [Symbol.asyncIterator]() {
            return {
              next: iter.next.bind(iter),
              return(value) {
                source.destroy();
                if (typeof iter.return === "function") {
                  return iter.return();
                }
                return Promise.resolve({ done: true, value });
              }
            };
          }
        };
      }
      if (isWebReadableStream(source)) {
        const reader = source.getReader();
        return async function* () {
          try {
            while (true) {
              const { done, value } = await reader.read();
              if (done)
                return;
              if (value) {
                yield value;
              }
            }
          } finally {
            reader.releaseLock();
          }
        }();
      }
      if (isAsyncIterable2(source)) {
        return source;
      }
      throw new TypeError("Body can't be converted to AsyncIterable");
    };
    var isAsyncIterable2 = (value) => {
      return typeof value === "object" && value !== null && typeof value[Symbol.asyncIterator] === "function";
    };
    var isWebReadableStream = (value) => {
      return value && typeof value.getReader === "function";
    };
    var isNodeReadableStream = (value) => Object.prototype.hasOwnProperty.call(value, "readable") && Object.prototype.hasOwnProperty.call(value, "writable");
    HTTP5.HTTPError = HTTPError2;
    HTTP5.TimeoutError = TimeoutError2;
    HTTP5.streamToAsyncIterator = fromStream;
    HTTP5.post = (resource, options) => new HTTP5(options).post(resource, options);
    HTTP5.get = (resource, options) => new HTTP5(options).get(resource, options);
    HTTP5.put = (resource, options) => new HTTP5(options).put(resource, options);
    HTTP5.delete = (resource, options) => new HTTP5(options).delete(resource, options);
    HTTP5.options = (resource, options) => new HTTP5(options).options(resource, options);
    module2.exports = HTTP5;
  }
});

// node_modules/libp2p-crypto/src/keys/keys.js
var require_keys = __commonJS({
  "node_modules/libp2p-crypto/src/keys/keys.js"(exports2, module2) {
    "use strict";
    init_globals();
    var $protobuf12 = require_minimal2();
    var $Reader11 = $protobuf12.Reader;
    var $Writer11 = $protobuf12.Writer;
    var $util11 = $protobuf12.util;
    var $root11 = $protobuf12.roots["libp2p-crypto-keys"] || ($protobuf12.roots["libp2p-crypto-keys"] = {});
    $root11.KeyType = function() {
      var valuesById = {}, values2 = Object.create(valuesById);
      values2[valuesById[0] = "RSA"] = 0;
      values2[valuesById[1] = "Ed25519"] = 1;
      values2[valuesById[2] = "Secp256k1"] = 2;
      return values2;
    }();
    $root11.PublicKey = function() {
      function PublicKey(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      PublicKey.prototype.Type = 0;
      PublicKey.prototype.Data = $util11.newBuffer([]);
      PublicKey.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        w.uint32(8).int32(m.Type);
        w.uint32(18).bytes(m.Data);
        return w;
      };
      PublicKey.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.PublicKey();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Type = r.int32();
              break;
            case 2:
              m.Data = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Type"))
          throw $util11.ProtocolError("missing required 'Type'", { instance: m });
        if (!m.hasOwnProperty("Data"))
          throw $util11.ProtocolError("missing required 'Data'", { instance: m });
        return m;
      };
      PublicKey.fromObject = function fromObject(d) {
        if (d instanceof $root11.PublicKey)
          return d;
        var m = new $root11.PublicKey();
        switch (d.Type) {
          case "RSA":
          case 0:
            m.Type = 0;
            break;
          case "Ed25519":
          case 1:
            m.Type = 1;
            break;
          case "Secp256k1":
          case 2:
            m.Type = 2;
            break;
        }
        if (d.Data != null) {
          if (typeof d.Data === "string")
            $util11.base64.decode(d.Data, m.Data = $util11.newBuffer($util11.base64.length(d.Data)), 0);
          else if (d.Data.length)
            m.Data = d.Data;
        }
        return m;
      };
      PublicKey.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.Type = o.enums === String ? "RSA" : 0;
          if (o.bytes === String)
            d.Data = "";
          else {
            d.Data = [];
            if (o.bytes !== Array)
              d.Data = $util11.newBuffer(d.Data);
          }
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root11.KeyType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util11.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        return d;
      };
      PublicKey.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      return PublicKey;
    }();
    $root11.PrivateKey = function() {
      function PrivateKey(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      PrivateKey.prototype.Type = 0;
      PrivateKey.prototype.Data = $util11.newBuffer([]);
      PrivateKey.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        w.uint32(8).int32(m.Type);
        w.uint32(18).bytes(m.Data);
        return w;
      };
      PrivateKey.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.PrivateKey();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Type = r.int32();
              break;
            case 2:
              m.Data = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Type"))
          throw $util11.ProtocolError("missing required 'Type'", { instance: m });
        if (!m.hasOwnProperty("Data"))
          throw $util11.ProtocolError("missing required 'Data'", { instance: m });
        return m;
      };
      PrivateKey.fromObject = function fromObject(d) {
        if (d instanceof $root11.PrivateKey)
          return d;
        var m = new $root11.PrivateKey();
        switch (d.Type) {
          case "RSA":
          case 0:
            m.Type = 0;
            break;
          case "Ed25519":
          case 1:
            m.Type = 1;
            break;
          case "Secp256k1":
          case 2:
            m.Type = 2;
            break;
        }
        if (d.Data != null) {
          if (typeof d.Data === "string")
            $util11.base64.decode(d.Data, m.Data = $util11.newBuffer($util11.base64.length(d.Data)), 0);
          else if (d.Data.length)
            m.Data = d.Data;
        }
        return m;
      };
      PrivateKey.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.Type = o.enums === String ? "RSA" : 0;
          if (o.bytes === String)
            d.Data = "";
          else {
            d.Data = [];
            if (o.bytes !== Array)
              d.Data = $util11.newBuffer(d.Data);
          }
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root11.KeyType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util11.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        return d;
      };
      PrivateKey.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      return PrivateKey;
    }();
    module2.exports = $root11;
  }
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "node_modules/node-forge/lib/forge.js"(exports2, module2) {
    init_globals();
    module2.exports = {
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    init_globals();
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet, maxline) {
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet);
      } else {
        var i = 0;
        var base4 = alphabet.length;
        var first4 = alphabet.charAt(0);
        var digits = [0];
        for (i = 0; i < input.length; ++i) {
          for (var j = 0, carry = input[i]; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base4;
            carry = carry / base4 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base4);
            carry = carry / base4 | 0;
          }
        }
        for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
          output += first4;
        }
        for (i = digits.length - 1; i >= 0; --i) {
          output += alphabet[digits[i]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet];
      if (!table) {
        table = _reverseAlphabets[alphabet] = [];
        for (var i = 0; i < alphabet.length; ++i) {
          table[alphabet.charCodeAt(i)] = i;
        }
      }
      input = input.replace(/\s/g, "");
      var base4 = alphabet.length;
      var first4 = alphabet.charAt(0);
      var bytes2 = [0];
      for (var i = 0; i < input.length; i++) {
        var value = table[input.charCodeAt(i)];
        if (value === void 0) {
          return;
        }
        for (var j = 0, carry = value; j < bytes2.length; ++j) {
          carry += bytes2[j] * base4;
          bytes2[j] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes2.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k = 0; input[k] === first4 && k < input.length - 1; ++k) {
        bytes2.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes2.reverse());
      }
      return new Uint8Array(bytes2.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet) {
      var i = 0;
      var base4 = alphabet.length;
      var first4 = alphabet.charAt(0);
      var digits = [0];
      for (i = 0; i < input.length(); ++i) {
        for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base4;
          carry = carry / base4 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base4);
          carry = carry / base4 | 0;
        }
      }
      var output = "";
      for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
        output += first4;
      }
      for (i = digits.length - 1; i >= 0; --i) {
        output += alphabet[digits[i]];
      }
      return output;
    }
  }
});

// node_modules/node-forge/lib/util.js
var require_util = __commonJS({
  "node_modules/node-forge/lib/util.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    var baseN = require_baseN();
    var util = module2.exports = forge.util = forge.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util.setImmediate = setImmediate;
        } else {
          util.setImmediate = util.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util.setImmediate;
        util.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util.nextTick = util.setImmediate;
    })();
    util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util.globalScope = function() {
      if (util.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    };
    util.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
    };
    util.isArrayBufferView = function(x) {
      return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
    };
    function _checkBitsParam(n) {
      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
      }
    }
    util.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b) {
      this.data = "";
      this.read = 0;
      if (typeof b === "string") {
        this.data = b;
      } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
        if (typeof Buffer !== "undefined" && b instanceof Buffer) {
          this.data = b.toString("binary");
        } else {
          var arr = new Uint8Array(b);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e) {
            for (var i = 0; i < arr.length; ++i) {
              this.putByte(arr[i]);
            }
          }
        }
      } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
        this.data = b.data;
        this.read = b.read;
      }
      this._constructedStringLength = 0;
    }
    util.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.ByteStringBuffer.prototype.putByte = function(b) {
      return this.putBytes(String.fromCharCode(b));
    };
    util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
      b = String.fromCharCode(b);
      var d = this.data;
      while (n > 0) {
        if (n & 1) {
          d += b;
        }
        n >>>= 1;
        if (n > 0) {
          b += b;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n);
      return this;
    };
    util.ByteStringBuffer.prototype.putBytes = function(bytes2) {
      this.data += bytes2;
      this._optimizeConstructedString(bytes2.length);
      return this;
    };
    util.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util.encodeUtf8(str));
    };
    util.ByteStringBuffer.prototype.putInt16 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
    };
    util.ByteStringBuffer.prototype.putInt24 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
    };
    util.ByteStringBuffer.prototype.putInt32 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
    };
    util.ByteStringBuffer.prototype.putInt16Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255));
    };
    util.ByteStringBuffer.prototype.putInt24Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255));
    };
    util.ByteStringBuffer.prototype.putInt32Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255));
    };
    util.ByteStringBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      var bytes2 = "";
      do {
        n -= 8;
        bytes2 += String.fromCharCode(i >> n & 255);
      } while (n > 0);
      return this.putBytes(bytes2);
    };
    util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.ByteStringBuffer.prototype.putBuffer = function(buffer3) {
      return this.putBytes(buffer3.getBytes());
    };
    util.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.ByteStringBuffer.prototype.at = function(i) {
      return this.data.charCodeAt(this.read + i);
    };
    util.ByteStringBuffer.prototype.setAt = function(i, b) {
      this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
      return this;
    };
    util.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util.ByteStringBuffer.prototype.copy = function() {
      var c = util.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.length; ++i) {
        var b = this.data.charCodeAt(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.toString = function() {
      return util.decodeUtf8(this.bytes());
    };
    function DataBuffer(b, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer = util.isArrayBuffer(b);
      var isArrayBufferView = util.isArrayBufferView(b);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b);
        } else {
          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b !== null && b !== void 0) {
        this.putBytes(b);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util.DataBuffer = DataBuffer;
    util.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src3 = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src3);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util.DataBuffer.prototype.putByte = function(b) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b);
      return this;
    };
    util.DataBuffer.prototype.fillWithByte = function(b, n) {
      this.accommodate(n);
      for (var i = 0; i < n; ++i) {
        this.data.setUint8(b);
      }
      return this;
    };
    util.DataBuffer.prototype.putBytes = function(bytes2, encoding) {
      if (util.isArrayBufferView(bytes2)) {
        var src3 = new Uint8Array(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
        var len = src3.byteLength - src3.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src3);
        this.write += len;
        return this;
      }
      if (util.isArrayBuffer(bytes2)) {
        var src3 = new Uint8Array(bytes2);
        this.accommodate(src3.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src3, this.write);
        this.write += src3.byteLength;
        return this;
      }
      if (bytes2 instanceof util.DataBuffer || typeof bytes2 === "object" && typeof bytes2.read === "number" && typeof bytes2.write === "number" && util.isArrayBufferView(bytes2.data)) {
        var src3 = new Uint8Array(bytes2.data.byteLength, bytes2.read, bytes2.length());
        this.accommodate(src3.byteLength);
        var dst = new Uint8Array(bytes2.data.byteLength, this.write);
        dst.set(src3);
        this.write += src3.byteLength;
        return this;
      }
      if (bytes2 instanceof util.ByteStringBuffer) {
        bytes2 = bytes2.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes2 === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes2.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.hex.decode(bytes2, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes2.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.base64.decode(bytes2, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes2 = util.encodeUtf8(bytes2);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes2.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes2.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes2);
    };
    util.DataBuffer.prototype.putBuffer = function(buffer3) {
      this.putBytes(buffer3);
      buffer3.clear();
      return this;
    };
    util.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util.DataBuffer.prototype.putInt16 = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24 = function(i) {
      this.accommodate(3);
      this.data.setInt16(this.write, i >> 8 & 65535);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32 = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt16Le = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i, true);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24Le = function(i) {
      this.accommodate(3);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.data.setInt16(this.write, i >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32Le = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i, true);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, i >> n & 255);
      } while (n > 0);
      return this;
    };
    util.DataBuffer.prototype.putSignedInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.DataBuffer.prototype.at = function(i) {
      return this.data.getUint8(this.read + i);
    };
    util.DataBuffer.prototype.setAt = function(i, b) {
      this.data.setUint8(i, b);
      return this;
    };
    util.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util.DataBuffer.prototype.copy = function() {
      return new util.DataBuffer(this);
    };
    util.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src3 = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src3.byteLength);
        dst.set(src3);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.byteLength; ++i) {
        var b = this.data.getUint8(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util.encodeUtf8(input);
      }
      return new util.ByteBuffer(input);
    };
    util.fillString = function(c, n) {
      var s = "";
      while (n > 0) {
        if (n & 1) {
          s += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s;
    };
    util.xorBytes = function(s1, s2, n) {
      var s3 = "";
      var b = "";
      var t = "";
      var i = 0;
      var c = 0;
      for (; n > 0; --n, ++i) {
        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
        if (c >= 10) {
          s3 += t;
          t = "";
          c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util.hexToBytes = function(hex) {
      var rval = "";
      var i = 0;
      if (hex.length & true) {
        i = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i < hex.length; i += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
      return rval;
    };
    util.bytesToHex = function(bytes2) {
      return util.createBuffer(bytes2).toHex();
    };
    util.int32ToBytes = function(i) {
      return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      62,
      -1,
      -1,
      -1,
      63,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.length) {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i = 0;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util.binary.raw.encode = function(bytes2) {
      return String.fromCharCode.apply(null, bytes2);
    };
    util.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util.binary.hex.encode = util.bytesToHex;
    util.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i = 0, j = offset;
      if (hex.length & 1) {
        i = 1;
        out[j++] = parseInt(hex[0], 16);
      }
      for (; i < hex.length; i += 2) {
        out[j++] = parseInt(hex.substr(i, 2), 16);
      }
      return output ? j - offset : out;
    };
    util.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.byteLength) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i = 0, j = offset;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        out[j++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j - offset : out.subarray(0, j);
    };
    util.binary.base58.encode = function(input, maxline) {
      return util.binary.baseN.encode(input, _base58, maxline);
    };
    util.binary.base58.decode = function(input, maxline) {
      return util.binary.baseN.decode(input, _base58, maxline);
    };
    util.text = {
      utf8: {},
      utf16: {}
    };
    util.text.utf8.encode = function(str, output, offset) {
      str = util.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util.text.utf8.decode = function(bytes2) {
      return util.decodeUtf8(String.fromCharCode.apply(null, bytes2));
    };
    util.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i = 0; i < str.length; ++i) {
        view[k++] = str.charCodeAt(i);
        j += 2;
      }
      return output ? j - offset : out;
    };
    util.text.utf16.decode = function(bytes2) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes2.buffer));
    };
    util.deflate = function(api, bytes2, raw) {
      bytes2 = util.decode64(api.deflate(util.encode64(bytes2)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes2.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes2 = bytes2.substring(start, bytes2.length - 4);
      }
      return bytes2;
    };
    util.inflate = function(api, bytes2, raw) {
      var rval = api.inflate(util.encode64(bytes2)).rval;
      return rval === null ? null : util.decode64(rval);
    };
    var _setStorageObject = function(api, id, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    };
    var _getItem = function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty3 = true;
        for (var prop in obj) {
          empty3 = false;
          break;
        }
        if (empty3) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    };
    var _clearItems = function(api, id) {
      _setStorageObject(api, id, null);
    };
    var _callStorageFunction = function(func, args, location2) {
      var rval = null;
      if (typeof location2 === "undefined") {
        location2 = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location2) {
        type = location2[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util.setItem = function(api, id, key, data, location2) {
      _callStorageFunction(_setItem, arguments, location2);
    };
    util.getItem = function(api, id, key, location2) {
      return _callStorageFunction(_getItem, arguments, location2);
    };
    util.removeItem = function(api, id, key, location2) {
      _callStorageFunction(_removeItem, arguments, location2);
    };
    util.clearItems = function(api, id, location2) {
      _callStorageFunction(_clearItems, arguments, location2);
    };
    util.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util.format = function(format) {
      var re = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last15 = 0;
      while (match = re.exec(format)) {
        part = format.substring(last15, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last15 = re.lastIndex;
        var code13 = match[0][1];
        switch (code13) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code13 + "?>");
        }
      }
      parts.push(format.substring(last15));
      return parts.join("");
    };
    util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
      var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
      var j = i.length > 3 ? i.length % 3 : 0;
      return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
    };
    util.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util.bytesFromIPv6(ip);
      }
      return null;
    };
    util.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b = util.createBuffer();
      for (var i = 0; i < ip.length; ++i) {
        var num = parseInt(ip[i], 10);
        if (isNaN(num)) {
          return null;
        }
        b.putByte(num);
      }
      return b.getBytes();
    };
    util.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e) {
        if (e.length === 0)
          ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b = util.createBuffer();
      for (var i = 0; i < 8; ++i) {
        if (!ip[i] || ip[i].length === 0) {
          b.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes2 = util.hexToBytes(ip[i]);
        if (bytes2.length < 2) {
          b.putByte(0);
        }
        b.putBytes(bytes2);
      }
      return b.getBytes();
    };
    util.bytesToIP = function(bytes2) {
      if (bytes2.length === 4) {
        return util.bytesToIPv4(bytes2);
      }
      if (bytes2.length === 16) {
        return util.bytesToIPv6(bytes2);
      }
      return null;
    };
    util.bytesToIPv4 = function(bytes2) {
      if (bytes2.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i = 0; i < bytes2.length; ++i) {
        ip.push(bytes2.charCodeAt(i));
      }
      return ip.join(".");
    };
    util.bytesToIPv6 = function(bytes2) {
      if (bytes2.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i = 0; i < bytes2.length; i += 2) {
        var hex = util.bytesToHex(bytes2[i] + bytes2[i + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last15 = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last15 || idx !== last15.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last15.end = idx;
            if (last15.end - last15.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util && !options.update) {
        return callback(null, util.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util.cores = navigator.hardwareConcurrency;
        return callback(null, util.cores);
      }
      if (typeof Worker === "undefined") {
        util.cores = 1;
        return callback(null, util.cores);
      }
      if (typeof Blob === "undefined") {
        util.cores = 2;
        return callback(null, util.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e) {
            var st = Date.now();
            var et = st + 4;
            while (Date.now() < et)
              ;
            self.postMessage({ st, et });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x) {
            return avg2 + x;
          }, 0) / max.length);
          util.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util.cores);
        }
        map12(numWorkers, function(err, results) {
          max.push(reduce2(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map12(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i = 0; i < numWorkers; ++i) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i2 = 0; i2 < numWorkers; ++i2) {
                workers[i2].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].postMessage(i);
        }
      }
      function reduce2(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i = 0; i < numWorkers; ++i) {
            if (n === i) {
              continue;
            }
            var r2 = results[i];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "node_modules/node-forge/lib/oids.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    forge.pki = forge.pki || {};
    var oids = module2.exports = forge.pki.oids = forge.oids = forge.oids || {};
    function _IN(id, name10) {
      oids[id] = name10;
      oids[name10] = id;
    }
    function _I_(id, name10) {
      oids[id] = name10;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_util();
    require_oids();
    var asn1 = module2.exports = forge.asn1 = forge.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value, options) {
      if (forge.util.isArray(value)) {
        var tmp = [];
        for (var i = 0; i < value.length; ++i) {
          if (value[i] !== void 0) {
            tmp.push(value[i]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge.util.isArray(value),
        value
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy;
      if (forge.util.isArray(obj)) {
        copy = [];
        for (var i = 0; i < obj.length; ++i) {
          copy.push(asn1.copy(obj[i], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge.util.isArray(obj1)) {
        if (!forge.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i = 0; i < obj1.length; ++i) {
          if (!asn1.equals(obj1[i], obj2[i])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b) {
      var b2 = b.getByte();
      if (b2 === 128) {
        return void 0;
      }
      var length5;
      var longForm = b2 & 128;
      if (!longForm) {
        length5 = b2;
      } else {
        length5 = b.getInt((b2 & 127) << 3);
      }
      return length5;
    };
    function _checkBufferLength(bytes2, remaining, n) {
      if (n > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes2.length();
        error.remaining = remaining;
        error.requested = n;
        throw error;
      }
    }
    var _getValueLength = function(bytes2, remaining) {
      var b2 = bytes2.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length5;
      var longForm = b2 & 128;
      if (!longForm) {
        length5 = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes2, remaining, longFormBytes);
        length5 = bytes2.getInt(longFormBytes << 3);
      }
      if (length5 < 0) {
        throw new Error("Negative length: " + length5);
      }
      return length5;
    };
    asn1.fromDer = function(bytes2, options) {
      if (options === void 0) {
        options = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("parseAllBytes" in options)) {
        options.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes2 === "string") {
        bytes2 = forge.util.createBuffer(bytes2);
      }
      var byteCount = bytes2.length();
      var value = _fromDer(bytes2, bytes2.length(), 0, options);
      if (options.parseAllBytes && bytes2.length() !== 0) {
        var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error.byteCount = byteCount;
        error.remaining = bytes2.length();
        throw error;
      }
      return value;
    };
    function _fromDer(bytes2, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes2, remaining, 2);
      var b1 = bytes2.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes2.length();
      var length5 = _getValueLength(bytes2, remaining);
      remaining -= start - bytes2.length();
      if (length5 !== void 0 && length5 > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes2.length();
          error.remaining = remaining;
          error.requested = length5;
          throw error;
        }
        length5 = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length5 === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes2, remaining, 2);
            if (bytes2.bytes(2) === String.fromCharCode(0, 0)) {
              bytes2.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes2.length();
            value.push(_fromDer(bytes2, remaining, depth + 1, options));
            remaining -= start - bytes2.length();
          }
        } else {
          while (length5 > 0) {
            start = bytes2.length();
            value.push(_fromDer(bytes2, length5, depth + 1, options));
            remaining -= start - bytes2.length();
            length5 -= start - bytes2.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes2.bytes(length5);
      }
      if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length5 > 1) {
        var savedRead = bytes2.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes2, remaining, 1);
          unused = bytes2.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes2.length();
            var subOptions = {
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes2, remaining, depth + 1, subOptions);
            var used = start - bytes2.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length5 && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes2.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length5 === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length5 = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value = "";
          for (; length5 > 0; length5 -= 2) {
            _checkBufferLength(bytes2, remaining, 2);
            value += String.fromCharCode(bytes2.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes2.getBytes(length5);
          remaining -= length5;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value, asn1Options);
    }
    asn1.toDer = function(obj) {
      var bytes2 = forge.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            value.putBuffer(asn1.toDer(obj.value[i]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i = 0; i < obj.value.length; ++i) {
            value.putInt16(obj.value.charCodeAt(i));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes2.putByte(b1);
      if (value.length() <= 127) {
        bytes2.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes2.putByte(lenBytes.length | 128);
        for (var i = lenBytes.length - 1; i >= 0; --i) {
          bytes2.putByte(lenBytes.charCodeAt(i));
        }
      }
      bytes2.putBuffer(value);
      return bytes2;
    };
    asn1.oidToDer = function(oid) {
      var values2 = oid.split(".");
      var bytes2 = forge.util.createBuffer();
      bytes2.putByte(40 * parseInt(values2[0], 10) + parseInt(values2[1], 10));
      var last15, valueBytes, value, b;
      for (var i = 2; i < values2.length; ++i) {
        last15 = true;
        valueBytes = [];
        value = parseInt(values2[i], 10);
        do {
          b = value & 127;
          value = value >>> 7;
          if (!last15) {
            b |= 128;
          }
          valueBytes.push(b);
          last15 = false;
        } while (value > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes2.putByte(valueBytes[n]);
        }
      }
      return bytes2;
    };
    asn1.derToOid = function(bytes2) {
      var oid;
      if (typeof bytes2 === "string") {
        bytes2 = forge.util.createBuffer(bytes2);
      }
      var b = bytes2.getByte();
      oid = Math.floor(b / 40) + "." + b % 40;
      var value = 0;
      while (bytes2.length() > 0) {
        b = bytes2.getByte();
        value = value << 7;
        if (b & 128) {
          value += b & 127;
        } else {
          oid += "." + (value + b);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== "+" && c !== "-") {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c = gentime.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push(("" + date.getUTCFullYear()).substr(2));
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += "0";
        }
        rval += format[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push("" + date.getUTCFullYear());
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += "0";
        }
        rval += format[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge.util.createBuffer();
      if (x >= -128 && x < 128) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -32768 && x < 32768) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -8388608 && x < 8388608) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -2147483648 && x < 2147483648) {
        return rval.putSignedInt(x, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x;
      throw error;
    };
    asn1.derToInteger = function(bytes2) {
      if (typeof bytes2 === "string") {
        bytes2 = forge.util.createBuffer(bytes2);
      }
      var n = bytes2.length() * 8;
      if (n > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes2.getSignedInt(n);
    };
    asn1.validate = function(obj, v, capture, errors2) {
      var rval = false;
      if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
        if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
          rval = true;
          if (v.value && forge.util.isArray(v.value)) {
            var j = 0;
            for (var i = 0; rval && i < v.value.length; ++i) {
              rval = v.value[i].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v.value[i], capture, errors2);
                if (rval) {
                  ++j;
                } else if (v.value[i].optional) {
                  rval = true;
                }
              }
              if (!rval && errors2) {
                errors2.push("[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"');
              }
            }
          }
          if (rval && capture) {
            if (v.capture) {
              capture[v.capture] = obj.value;
            }
            if (v.captureAsn1) {
              capture[v.captureAsn1] = obj;
            }
            if (v.captureBitStringContents && "bitStringContents" in obj) {
              capture[v.captureBitStringContents] = obj.bitStringContents;
            }
            if (v.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error("captureBitStringValue only supported for zero unused bits");
                }
                capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors2) {
          errors2.push("[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"');
        }
      } else if (errors2) {
        if (obj.tagClass !== v.tagClass) {
          errors2.push("[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"');
        }
        if (obj.type !== v.type) {
          errors2.push("[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"');
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i = 0; i < level * indentation; ++i) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
            if (i + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge.pki && forge.pki.oids) {
            if (oid in forge.pki.oids) {
              rval += " (" + forge.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge.util.decodeUtf8(obj.value);
          } catch (e) {
            if (e.message === "URI malformed") {
              rval += "0x" + forge.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_util();
    module2.exports = forge.cipher = forge.cipher || {};
    forge.cipher.algorithms = forge.cipher.algorithms || {};
    forge.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge.cipher.registerAlgorithm = function(name10, algorithm) {
      name10 = name10.toUpperCase();
      forge.cipher.algorithms[name10] = algorithm;
    };
    forge.cipher.getAlgorithm = function(name10) {
      name10 = name10.toUpperCase();
      if (name10 in forge.cipher.algorithms) {
        return forge.cipher.algorithms[name10];
      }
      return null;
    };
    var BlockCipher = forge.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge.util.createBuffer();
      this.output = options.output || forge.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_util();
    forge.cipher = forge.cipher || {};
    var modes = module2.exports = forge.cipher.modes = forge.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._prev[i] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._prev[i] ^ this._outBlock[i]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
          output.putInt32(this._inBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
        this._partialOutput.putInt32(this._partialBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
          output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
          this._inBlock[i] = this._outBlock[i];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._outBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
        }
        this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._outBlock[i] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i = 0; i < this._ints; ++i) {
        this.tag.putInt32(this._s[i] ^ tag[i]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y) {
      var z_i = [0, 0, 0, 0];
      var v_i = y.slice(0);
      for (var i = 0; i < 128; ++i) {
        var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i = 3; i > 0; --i) {
        out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z = [0, 0, 0, 0];
      for (var i = 0; i < 32; ++i) {
        var idx = i / 8 | 0;
        var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
        var ah = this._m[i][x_i];
        z[0] ^= ah[0];
        z[1] ^= ah[1];
        z[2] ^= ah[2];
        z[3] ^= ah[3];
      }
      return z;
    };
    modes.gcm.prototype.ghash = function(h, y, x) {
      y[0] ^= x[0];
      y[1] ^= x[1];
      y[2] ^= x[2];
      y[3] ^= x[3];
      return this.tableMultiply(y);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m = new Array(size);
      for (var i = 0; i < size; ++i) {
        var tmp = [0, 0, 0, 0];
        var idx = i / perInt | 0;
        var shft = (perInt - 1 - i % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
      }
      return m;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m = new Array(size);
      m[half] = mid.slice(0);
      var i = half >>> 1;
      while (i > 0) {
        this.pow(m[2 * i], m[i] = []);
        i >>= 1;
      }
      i = 2;
      while (i < half) {
        for (var j = 1; j < i; ++j) {
          var m_i = m[i];
          var m_j = m[j];
          m[i + j] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i *= 2;
      }
      m[0] = [0, 0, 0, 0];
      for (i = half + 1; i < size; ++i) {
        var c = m[i ^ half];
        m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge.util.createBuffer(iv);
      }
      if (forge.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          iv.putByte(tmp[i]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
      }
      if (!forge.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i = 0; i < blocks; ++i) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "node_modules/node-forge/lib/aes.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge.aes = forge.aes || {};
    forge.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.aes.Algorithm = function(name10, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name10;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge.util.createBuffer(key);
      } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }
      if (!forge.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i = 0; i < len; ++i) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge.aes._expandKey = function(key, decrypt2) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt2);
    };
    forge.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
    function registerAlgorithm(name10, mode) {
      var factory = function() {
        return new forge.aes.Algorithm(name10, mode);
      };
      forge.cipher.registerAlgorithm(name10, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i = 0; i < 128; ++i) {
        xtime[i] = i << 1;
        xtime[i + 128] = i + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i = 0; i < 4; ++i) {
        mix[i] = new Array(256);
        imix[i] = new Array(256);
      }
      var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
      for (var i = 0; i < 256; ++i) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me;
          imix[n][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key, decrypt2) {
      var w = key.slice(0);
      var temp, iNk = 1;
      var Nk = w.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i = Nk; i < end; ++i) {
        temp = w[i - 1];
        if (i % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w[i] = w[i - Nk] ^ temp;
      }
      if (decrypt2) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w.slice(0);
        end = w.length;
        for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
          if (i === 0 || i === end - Nb) {
            wnew[i] = w[wi];
            wnew[i + 1] = w[wi + 3];
            wnew[i + 2] = w[wi + 2];
            wnew[i + 3] = w[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w[wi + n];
              wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w = wnew;
      }
      return w;
    }
    function _updateBlock(w, input, output, decrypt2) {
      var Nr = w.length / 4 - 1;
      var m0, m1, m2, m3, sub;
      if (decrypt2) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a, b, c, d, a2, b2, c2;
      a = input[0] ^ w[0];
      b = input[decrypt2 ? 3 : 1] ^ w[1];
      c = input[2] ^ w[2];
      d = input[decrypt2 ? 1 : 3] ^ w[3];
      var i = 3;
      for (var round = 1; round < Nr; ++round) {
        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
        a = a2;
        b = b2;
        c = c2;
      }
      output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
      output[decrypt2 ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
      output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
      output[decrypt2 ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "node_modules/node-forge/lib/des.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge.des = forge.des || {};
    forge.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.des.Algorithm = function(name10, mode) {
      var self2 = this;
      self2.name = name10;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
    function registerAlgorithm(name10, mode) {
      var factory = function() {
        return new forge.des.Algorithm(name10, mode);
      };
      forge.cipher.registerAlgorithm(name10, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys2 = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0, tmp;
      for (var j = 0; j < iterations; j++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i = 0; i < shifts.length; ++i) {
          if (shifts[i]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys2[n++] = lefttmp ^ tmp;
          keys2[n++] = righttmp ^ tmp << 16;
        }
      }
      return keys2;
    }
    function _updateBlock(keys2, input, output, decrypt2) {
      var iterations = keys2.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt2 ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt2 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i = looping[j]; i != endloop; i += loopinc) {
          var right1 = right ^ keys2[i];
          var right2 = (right >>> 4 | right << 28) ^ keys2[i + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "node_modules/node-forge/lib/md.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    module2.exports = forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
  }
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_md();
    require_util();
    var hmac = module2.exports = forge.hmac = forge.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge.md.algorithms) {
              _md = forge.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge.util.createBuffer(key);
          } else if (forge.util.isArray(key)) {
            var tmp = key;
            key = forge.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              key.putByte(tmp[i]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge.util.createBuffer();
          _opadding = forge.util.createBuffer();
          keylen = key.length();
          for (var i = 0; i < keylen; ++i) {
            var tmp = key.at(i);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i = 0; i < tmp; ++i) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes2) {
        _md.update(bytes2);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
    init_globals();
  }
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_hmac();
    require_md();
    require_util();
    var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
    var crypto6;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
      crypto6 = require_crypto();
    }
    module2.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto6.pbkdf2 && (md === null || typeof md !== "object") && (crypto6.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p = Buffer.from(p, "binary");
        s = Buffer.from(s, "binary");
        if (!callback) {
          if (crypto6.pbkdf2Sync.length === 4) {
            return crypto6.pbkdf2Sync(p, s, c, dkLen).toString("binary");
          }
          return crypto6.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
        }
        if (crypto6.pbkdf2Sync.length === 4) {
          return crypto6.pbkdf2(p, s, c, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto6.pbkdf2(p, s, c, dkLen, md, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r = dkLen - (len - 1) * hLen;
      var prf = forge.hmac.create();
      prf.start(md, p);
      var dk = "";
      var xor2, u_c, u_c1;
      if (!callback) {
        for (var i = 1; i <= len; ++i) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge.util.int32ToBytes(i));
          xor2 = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor2 = forge.util.xorBytes(xor2, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i < len ? xor2 : xor2.substr(0, r);
        }
        return dk;
      }
      var i = 1, j;
      function outer() {
        if (i > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge.util.int32ToBytes(i));
        xor2 = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor2 = forge.util.xorBytes(xor2, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge.util.setImmediate(inner);
        }
        dk += i < len ? xor2 : xor2.substr(0, r);
        ++i;
        outer();
      }
      outer();
    };
  }
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "node_modules/node-forge/lib/pem.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_util();
    var pem = module2.exports = forge.pem = forge.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i = 0; i < msg.headers.length; ++i) {
          rval += foldHeader(msg.headers[i]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var type = match[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values2 = match[2].split(",");
            for (var vi = 0; vi < values2.length; ++vi) {
              header.values.push(ltrim(values2[vi]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values2[0], type: values2[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values2[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values2[0], parameters: values2[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values2 = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i = 0; i < header.values.length; ++i) {
        values2.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values2.join(",") + "\r\n";
      var length5 = 0;
      var candidate = -1;
      for (var i = 0; i < rval.length; ++i, ++length5) {
        if (length5 > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length5 = i - candidate - 1;
          candidate = -1;
          ++i;
        } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
          candidate = i;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_md();
    require_util();
    var sha2563 = module2.exports = forge.sha256 = forge.sha256 || {};
    forge.md.sha256 = forge.md.algorithms.sha256 = sha2563;
    sha2563.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s, w, bytes2) {
      var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
      var len = bytes2.length();
      while (len >= 64) {
        for (i = 0; i < 16; ++i) {
          w[i] = bytes2.getInt32();
        }
        for (; i < 64; ++i) {
          t1 = w[i - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w[i - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
        }
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        f = s.h5;
        g = s.h6;
        h = s.h7;
        for (i = 0; i < 64; ++i) {
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ch = g ^ e & (f ^ g);
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          maj = a & b | c & (a ^ b);
          t1 = h + s1 + ch + _k[i] + w[i];
          t2 = s0 + maj;
          h = g;
          g = f;
          f = e;
          e = d + t1 >>> 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 >>> 0;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        s.h5 = s.h5 + f | 0;
        s.h6 = s.h6 + g | 0;
        s.h7 = s.h7 + h | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "node_modules/node-forge/lib/prng.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_util();
    var _crypto = null;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto();
    }
    var prng = module2.exports = forge.prng = forge.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        reseeds: 0,
        generated: 0,
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i = 0; i < 32; ++i) {
        pools[i] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b = forge.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b.length() >= count) {
            return callback(null, b.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes2 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes2.length;
          b.putBytes(bytes2);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b = forge.util.createBuffer();
        while (b.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes2 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes2.length;
          b.putBytes(bytes2);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes2) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes2);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k = 0; k < 32; ++k) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k].digest().getBytes());
            ctx.pools[k].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b = forge.util.createBuffer();
        if (getRandomValues) {
          while (b.length() < needed) {
            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i2 = 0; i2 < entropy.length; ++i2) {
                b.putInt32(entropy[i2]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b.length() < needed) {
          var hi, lo, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b.length() < needed) {
            lo = 16807 * (seed & 65535);
            hi = 16807 * (seed >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed = lo & 4294967295;
            for (var i2 = 0; i2 < 3; ++i2) {
              next = seed >>> (i2 << 3);
              next ^= Math.floor(Math.random() * 256);
              b.putByte(next & 255);
            }
          }
        }
        return b.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes2) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes2.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes2) {
        var count = bytes2.length;
        for (var i2 = 0; i2 < count; ++i2) {
          ctx.pools[ctx.pool].update(bytes2.substr(i2, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i2, n) {
        var bytes2 = "";
        for (var x = 0; x < n; x += 8) {
          bytes2 += String.fromCharCode(i2 >> x & 255);
        }
        ctx.collect(bytes2);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes2) {
                worker.postMessage({ forge: { prng: { err, bytes: bytes2 } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "node_modules/node-forge/lib/random.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_aes();
    require_sha256();
    require_prng();
    require_util();
    (function() {
      if (forge.random && forge.random.getBytes) {
        module2.exports = forge.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge.md.sha256;
        function spawnPrng() {
          var ctx = forge.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e) {
              _ctx.collectInt(e.clientX, 16);
              _ctx.collectInt(e.clientY, 16);
            });
            jQuery2().keypress(function(e) {
              _ctx.collectInt(e.charCode, 8);
            });
          }
        }
        if (!forge.random) {
          forge.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge.random[key] = _ctx[key];
          }
        }
        forge.random.createInstance = spawnPrng;
        module2.exports = forge.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_util();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    };
    var ror = function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    };
    module2.exports = forge.rc2 = forge.rc2 || {};
    forge.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L = key;
      var T = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i;
      for (i = T; i < 128; i++) {
        L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i = 127 - T8; i >= 0; i--) {
        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
      }
      return L;
    };
    var createCipher = function(key, bits, encrypt2) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i, j, K = [];
      key = forge.rc2.expandKey(key, bits);
      for (i = 0; i < 64; i++) {
        K.push(key.getInt16Le());
      }
      if (encrypt2) {
        mixRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            R[i] = rol(R[i], s[i]);
            j++;
          }
        };
        mashRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[R[(i + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] = ror(R[i], s[i]);
            R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            j--;
          }
        };
        mashRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] -= K[R[(i + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R = [];
        for (i = 0; i < 4; i++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt2) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R.push(val & 65535);
        }
        j = encrypt2 ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R);
          }
        }
        for (i = 0; i < 4; i++) {
          if (_iv !== null) {
            if (encrypt2) {
              _iv.putInt16Le(R[i]);
            } else {
              R[i] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i]);
        }
      };
      var cipher = null;
      cipher = {
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge.util.createBuffer();
          _output = output || new forge.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        finish: function(pad) {
          var rval = true;
          if (encrypt2) {
            if (pad) {
              rval = pad(8, _input, !encrypt2);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt2) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt2);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher(key, bits, true);
    };
    forge.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher(key, bits, false);
    };
  }
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    module2.exports = forge.jsbn = forge.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      this.data = [];
      if (a != null)
        if (typeof a == "number")
          this.fromNumber(a, b, c);
        else if (b == null && typeof a != "string")
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    forge.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this.data[i++] + w.data[j] + c;
        c = Math.floor(v / 67108864);
        w.data[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i] & 32767;
        var h = this.data[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w.data[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i] & 16383;
        var h = this.data[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w.data[j++] = l & 268435455;
      }
      return c;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i)
        r.data[i] = this.data[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this.data[0] = x;
      else if (x < -1)
        this.data[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this.data[i] & (1 << p) - 1) << k - p;
            d |= this.data[--i] >> (p += this.DB - k);
          } else {
            d = this.data[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i >= 0)
        if ((r = this.data[i] - a.data[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i)
        r.data[i + n] = this.data[i];
      for (i = n - 1; i >= 0; --i)
        r.data[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i)
        r.data[i - n] = this.data[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1; i >= 0; --i) {
        r.data[i + ds + 1] = this.data[i] >> cbs | c;
        c = (this.data[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i)
        r.data[i] = 0;
      r.data[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r.data[0] = this.data[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
        r.data[i - ds] = this.data[i] >> bs;
      }
      if (bs > 0)
        r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] - a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r.data[i++] = this.DV + c;
      else if (c > 0)
        r.data[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < y.t; ++i)
        r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
        if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r.data[i + x.t] -= x.DV;
          r.data[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y.data[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j = i - ys, t = q == null ? nbi() : q;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r.data[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys)
        y.data[y.t++] = 0;
      while (--j >= 0) {
        var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
        if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r.data[i] < --qd)
            r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms)
          BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this.data[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x.data[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z.sqrTo(r, r2);
        if ((e & 1 << i) > 0)
          z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven())
        z = new Classic(m);
      else
        z = new Montgomery(m);
      return this.exp(e, z);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if (typeof b == "number") {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0)
          x[0] &= (1 << t) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (this.data[i] & (1 << p) - 1) << 8 - p;
            d |= this.data[--i] >> (p += this.DB - 8);
          } else {
            d = this.data[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i, f, m = Math.min(a.t, this.t);
      for (i = 0; i < m; ++i)
        r.data[i] = op(this.data[i], a.data[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m; i < this.t; ++i)
          r.data[i] = op(this.data[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m; i < a.t; ++i)
          r.data[i] = op(f, a.data[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i)
        r.data[i] = this.DM & ~this.data[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this.data[i] != 0)
          return i * this.DB + lbit(this.data[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i)
        r += cbit(this.data[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this.data[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] + a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r.data[i++] = c;
      else if (c < -1)
        r.data[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this.data[this.t++] = 0;
      this.data[w] += n;
      while (this.data[w] >= this.DV) {
        this.data[w] -= this.DV;
        if (++w >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r.data[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i)
        r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i)
        this.am(0, a.data[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = e.data[j] >> i - k1 & km;
        else {
          w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w |= e.data[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e.data[j] & 1 << i) == 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this.data[0] % n;
        else
          for (var i = this.t - 1; i >= 0; --i)
            r = (d * r + this.data[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x.data[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a;
      for (var i = 0; i < t; ++i) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        nextBytes: function(x) {
          for (var i = 0; i < x.length; ++i) {
            x[i] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// node_modules/node-forge/lib/sha1.js
var require_sha1 = __commonJS({
  "node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_md();
    require_util();
    var sha1 = module2.exports = forge.sha1 = forge.sha1 || {};
    forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s, w, bytes2) {
      var t, a, b, c, d, e, f, i;
      var len = bytes2.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        for (i = 0; i < 16; ++i) {
          t = bytes2.getInt32();
          w[i] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 20; ++i) {
          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
          t = t << 1 | t >>> 31;
          w[i] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 32; ++i) {
          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
          t = t << 1 | t >>> 31;
          w[i] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 40; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 60; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f = b & c | d & (b ^ c);
          t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 80; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_util();
    require_random();
    require_sha1();
    var pkcs1 = module2.exports = forge.pkcs1 = forge.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message, options) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i = 0; i < PS_length; i++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === void 0) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = y !== "\0";
      for (var i = 0; i < md.digestLength; ++i) {
        error |= lHash.charAt(i) !== lHashPrime.charAt(i);
      }
      var in_ps = 1;
      var index = md.digestLength;
      for (var j = md.digestLength; j < db.length; j++) {
        var code13 = db.charCodeAt(j);
        var is_0 = code13 & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code13 & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash2) {
      if (!hash2) {
        hash2 = forge.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash2.digestLength);
      for (var i = 0; i < count; ++i) {
        var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
        hash2.start();
        hash2.update(seed + c);
        t += hash2.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "node_modules/node-forge/lib/prime.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_util();
    require_jsbn();
    require_random();
    (function() {
      if (forge.prime) {
        module2.exports = forge.prime;
        return;
      }
      var prime = module2.exports = forge.prime = forge.prime || {};
      var BigInteger = forge.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x, y) {
        return x | y;
      };
      prime.generateProbablePrime = function(bits, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge.random;
        var rng = {
          nextBytes: function(x) {
            var b = prng.getBytesSync(x.length);
            for (var i = 0; i < x.length; ++i) {
              x[i] = b.charCodeAt(i);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
        var num = generateRandom(bits, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
        forge.util.setImmediate(function() {
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
        }
        var num = generateRandom(bits, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i = 0; i < numWorkers; ++i) {
            workers[i] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e) {
            if (found) {
              return;
            }
            --running;
            var data = e.data;
            if (data.found) {
              for (var i2 = 0; i2 < workers.length; ++i2) {
                workers[i2].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            var hex = num.toString(16);
            e.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
        }
      }
      function generateRandom(bits, rng) {
        var num = new BigInteger(bits, rng);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100)
          return 27;
        if (bits <= 150)
          return 18;
        if (bits <= 200)
          return 15;
        if (bits <= 250)
          return 12;
        if (bits <= 300)
          return 9;
        if (bits <= 350)
          return 8;
        if (bits <= 400)
          return 7;
        if (bits <= 500)
          return 6;
        if (bits <= 600)
          return 5;
        if (bits <= 800)
          return 4;
        if (bits <= 1250)
          return 3;
        return 2;
      }
    })();
  }
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge.util.isNodejs ? require_crypto() : null;
    var asn1 = forge.asn1;
    var util = forge.util;
    forge.pki = forge.pki || {};
    module2.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
    var pki = forge.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki.oids) {
        oid = pki.oids[md.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
      digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ""));
      var digest3 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest3);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x, key, pub) {
      if (pub) {
        return x.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r;
      do {
        r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);
      } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      var xp = x.mod(key.p).modPow(key.dP, key.p);
      var xq = x.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y = y.multiply(r.modInverse(key.n)).mod(key.n);
      return y;
    };
    pki.rsa.encrypt = function(m, key, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m, key, bt);
      } else {
        eb = forge.util.createBuffer();
        eb.putBytes(m);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y = _modPow(x, key, pub);
      var yhex = y.toString(16);
      var ed = forge.util.createBuffer();
      var zeros = k - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0);
        --zeros;
      }
      ed.putBytes(forge.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki.rsa.decrypt = function(ed, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed.length;
        error.expected = k;
        throw error;
      }
      var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
      if (y.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x = _modPow(y, key, pub);
      var xhex = x.toString(16);
      var eb = forge.util.createBuffer();
      var zeros = k - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge.random;
      var rng = {
        nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x, y) {
        return x | y;
      };
      var t1 = +new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e === "function") {
            callback = e;
            e = void 0;
          } else if (typeof e !== "number") {
            options = e;
            e = void 0;
          }
        } else {
          options = bits;
          callback = e;
          bits = void 0;
          e = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e;
          e = void 0;
        }
      }
      options = options || {};
      if (bits === void 0) {
        bits = options.bits || 2048;
      }
      if (e === void 0) {
        e = options.e || 65537;
      }
      if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e2) {
              var pair = e2.target.result;
              var exportOp = util.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
              exportOp.oncomplete = function(e3) {
                var pkcs8 = e3.target.result;
                var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair.privateKey),
              publicKey: pki.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
      var key = {
        n,
        e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m, key2, pub) {
              return _encodePkcs1_v1_5(m, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m, key2) {
              return forge.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e3) {
            return e3;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e2 = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e2, key, true);
      };
      key.verify = function(digest3, signature, scheme, options) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options === void 0) {
          options = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options)) {
          options._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest4, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              var obj = asn1.fromDer(d2, {
                parseAllBytes: options._parseAllDigestBytes
              });
              var capture = {};
              var errors2 = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors2)) {
                var error = new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");
                error.errors = errors2;
                throw error;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids["sha512-224"] || oid === forge.oids["sha512-256"])) {
                var error = new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");
                error.oid = oid;
                throw error;
              }
              if (oid === forge.oids.md2 || oid === forge.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.");
                }
              }
              return digest4 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest4, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              return digest4 === d2;
            }
          };
        }
        var d = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest3, d, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
      var key = {
        n,
        e,
        d,
        p,
        q,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d2 = pki.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d3, key2) {
              return forge.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d3) {
            return d3;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d2, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt = 1;
        }
        var d2 = scheme.encode(md, key.n.bitLength());
        return pki.rsa.encrypt(d2, key, bt);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors2)) {
        obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors2 = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors2;
        throw error;
      }
      var n, e, d, p, q, dP, dQ, qInv;
      n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors2)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors2 = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors2;
        throw error;
      }
      var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))
      ]);
    };
    function _encodePkcs1_v1_5(m, key, bt) {
      var eb = forge.util.createBuffer();
      var k = Math.ceil(key.n.bitLength() / 8);
      if (m.length > k - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m.length;
        error.max = k - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k - 3 - m.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i = 0; i < padNum; ++i) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge.random.getBytes(padNum);
          for (var i = 0; i < padNum; ++i) {
            padByte = padBytes.charCodeAt(i);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      var eb = forge.util.createBuffer(em);
      var first4 = eb.getByte();
      var bt = eb.getByte();
      if (first4 !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k - 3 - ml;
        for (var i = 0; i < padNum; ++i) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback2) {
        forge.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b) {
      var hex = b.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes2 = forge.util.hexToBytes(hex);
      if (bytes2.length > 1 && (bytes2.charCodeAt(0) === 0 && (bytes2.charCodeAt(1) & 128) === 0 || bytes2.charCodeAt(0) === 255 && (bytes2.charCodeAt(1) & 128) === 128)) {
        return bytes2.substr(1);
      }
      return bytes2;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
    function _detectNodeCrypto(fn) {
      return forge.util.isNodejs && typeof _crypto[fn] === "function";
    }
    function _detectSubtleCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
    }
    function _detectSubtleMsCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
    }
    function _intToUint8Array(x) {
      var bytes2 = forge.util.hexToBytes(x.toString(16));
      var buffer3 = new Uint8Array(bytes2.length);
      for (var i = 0; i < bytes2.length; ++i) {
        buffer3[i] = bytes2.charCodeAt(i);
      }
      return buffer3;
    }
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "node_modules/node-forge/lib/pbe.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    module2.exports = pki.pbe = forge.pbe = forge.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()),
              params
            ]),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)
            ])
          ])
        ]);
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
          ])
        ]);
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        encryptionAlgorithm,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)
      ]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
      var j, l;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge.md.sha1.create();
      }
      var u = md.digestLength;
      var v = md.blockLength;
      var result = new forge.util.ByteBuffer();
      var passBuf = new forge.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p = passBuf.length();
      var s = salt.length();
      var D = new forge.util.ByteBuffer();
      D.fillWithByte(id, v);
      var Slen = v * Math.ceil(s / v);
      var S = new forge.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S.putByte(salt.at(l % s));
      }
      var Plen = v * Math.ceil(p / v);
      var P = new forge.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p));
      }
      var I = S;
      I.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i = 1; i <= c; i++) {
        var buf3 = new forge.util.ByteBuffer();
        buf3.putBytes(D.bytes());
        buf3.putBytes(I.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf3.getBytes());
          buf3 = md.digest();
        }
        var B = new forge.util.ByteBuffer();
        for (l = 0; l < v; l++) {
          B.putByte(buf3.at(l % u));
        }
        var k = Math.ceil(s / v) + Math.ceil(p / v);
        var Inew = new forge.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge.util.ByteBuffer(I.getBytes(v));
          var x = 511;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 255);
          }
          Inew.putBuffer(chunk);
        }
        I = Inew;
        result.putBuffer(buf3);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids["pkcs5PBES2"]:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors2)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors2)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      var salt = forge.util.createBuffer(capture.salt);
      var count = forge.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge.des.startDecrypting;
          break;
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key2, iv2) {
            var cipher = forge.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash2(md, password + salt)];
      for (var length5 = 16, i = 1; length5 < dkLen; ++i, length5 += 16) {
        digests.push(hash2(md, digests[i - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash2(md, bytes2) {
      return md.start().update(bytes2).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]));
      }
      return params;
    }
  }
});

// node_modules/libp2p-crypto/src/webcrypto.js
var require_webcrypto = __commonJS({
  "node_modules/libp2p-crypto/src/webcrypto.js"(exports2) {
    "use strict";
    init_globals();
    exports2.get = (win = globalThis) => {
      const nativeCrypto = win.crypto;
      if (!nativeCrypto || !nativeCrypto.subtle) {
        throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
      }
      return nativeCrypto;
    };
  }
});

// node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js
var require_aes_gcm_browser = __commonJS({
  "node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { concat: concat5 } = (init_concat(), __toCommonJS(concat_exports));
    var { fromString: fromString7 } = (init_from_string(), __toCommonJS(from_string_exports));
    var webcrypto = require_webcrypto();
    function create9({
      algorithm = "AES-GCM",
      nonceLength = 12,
      keyLength = 16,
      digest: digest3 = "SHA-256",
      saltLength = 16,
      iterations = 32767
    } = {}) {
      const crypto6 = webcrypto.get();
      keyLength *= 8;
      async function encrypt2(data, password) {
        const salt = crypto6.getRandomValues(new Uint8Array(saltLength));
        const nonce = crypto6.getRandomValues(new Uint8Array(nonceLength));
        const aesGcm = { name: algorithm, iv: nonce };
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest3 } };
        const rawKey = await crypto6.subtle.importKey("raw", fromString7(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
        const cryptoKey = await crypto6.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
        const ciphertext = await crypto6.subtle.encrypt(aesGcm, cryptoKey, data);
        return concat5([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
      }
      async function decrypt2(data, password) {
        const salt = data.slice(0, saltLength);
        const nonce = data.slice(saltLength, saltLength + nonceLength);
        const ciphertext = data.slice(saltLength + nonceLength);
        const aesGcm = { name: algorithm, iv: nonce };
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest3 } };
        const rawKey = await crypto6.subtle.importKey("raw", fromString7(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
        const cryptoKey = await crypto6.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
        const plaintext = await crypto6.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
        return new Uint8Array(plaintext);
      }
      return {
        encrypt: encrypt2,
        decrypt: decrypt2
      };
    }
    module2.exports = {
      create: create9
    };
  }
});

// node_modules/libp2p-crypto/src/keys/importer.js
var require_importer = __commonJS({
  "node_modules/libp2p-crypto/src/keys/importer.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { base64: base643 } = (init_base64(), __toCommonJS(base64_exports));
    var ciphers = require_aes_gcm_browser();
    module2.exports = {
      import: async function(privateKey, password) {
        const encryptedKey = base643.decode(privateKey);
        const cipher = ciphers.create();
        return await cipher.decrypt(encryptedKey, password);
      }
    };
  }
});

// node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_md();
    require_util();
    var sha5123 = module2.exports = forge.sha512 = forge.sha512 || {};
    forge.md.sha512 = forge.md.algorithms.sha512 = sha5123;
    var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
    sha384.create = function() {
      return sha5123.create("SHA-384");
    };
    forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
    forge.sha512.sha256 = forge.sha512.sha256 || {
      create: function() {
        return sha5123.create("SHA-512/256");
      }
    };
    forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
    forge.sha512.sha224 = forge.sha512.sha224 || {
      create: function() {
        return sha5123.create("SHA-512/224");
      }
    };
    forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
    sha5123.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _h = new Array(_state.length);
        for (var i = 0; i < _state.length; ++i) {
          _h[i] = _state[i].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h = new Array(_h.length);
        for (var i = 0; i < _h.length; ++i) {
          h[i] = _h[i].slice(0);
        }
        _update(h, _w, finalBlock);
        var rval = forge.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h.length;
        } else if (algorithm === "SHA-384") {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i = 0; i < hlen; ++i) {
          rval.putInt32(h[i][0]);
          if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h[i][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s, w, bytes2) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i, hi, lo, w2, w7, w15, w16;
      var len = bytes2.length();
      while (len >= 128) {
        for (i = 0; i < 16; ++i) {
          w[i][0] = bytes2.getInt32() >>> 0;
          w[i][1] = bytes2.getInt32() >>> 0;
        }
        for (; i < 80; ++i) {
          w2 = w[i - 2];
          hi = w2[0];
          lo = w2[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w[i - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w[i - 7];
          w16 = w[i - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w[i][1] = lo >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i = 0; i < 80; ++i) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s[0][1] + a_lo;
        s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[0][1] = lo >>> 0;
        lo = s[1][1] + b_lo;
        s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[1][1] = lo >>> 0;
        lo = s[2][1] + c_lo;
        s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[2][1] = lo >>> 0;
        lo = s[3][1] + d_lo;
        s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[3][1] = lo >>> 0;
        lo = s[4][1] + e_lo;
        s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[4][1] = lo >>> 0;
        lo = s[5][1] + f_lo;
        s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[5][1] = lo >>> 0;
        lo = s[6][1] + g_lo;
        s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[6][1] = lo >>> 0;
        lo = s[7][1] + h_lo;
        s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
});

// node_modules/iso-random-stream/src/random.browser.js
var require_random_browser = __commonJS({
  "node_modules/iso-random-stream/src/random.browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    var MAX_BYTES = 65536;
    function randomBytes(size) {
      const bytes2 = new Uint8Array(size);
      let generated = 0;
      if (size > 0) {
        if (size > MAX_BYTES) {
          while (generated < size) {
            if (generated + MAX_BYTES > size) {
              crypto.getRandomValues(bytes2.subarray(generated, generated + (size - generated)));
              generated += size - generated;
            } else {
              crypto.getRandomValues(bytes2.subarray(generated, generated + MAX_BYTES));
              generated += MAX_BYTES;
            }
          }
        } else {
          crypto.getRandomValues(bytes2);
        }
      }
      return bytes2;
    }
    module2.exports = randomBytes;
  }
});

// node_modules/libp2p-crypto/src/random-bytes.js
var require_random_bytes = __commonJS({
  "node_modules/libp2p-crypto/src/random-bytes.js"(exports2, module2) {
    "use strict";
    init_globals();
    var randomBytes = require_random_browser();
    var errcode17 = require_err_code();
    module2.exports = function(length5) {
      if (isNaN(length5) || length5 <= 0) {
        throw errcode17(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
      }
      return randomBytes(length5);
    };
  }
});

// node_modules/libp2p-crypto/src/util.js
var require_util2 = __commonJS({
  "node_modules/libp2p-crypto/src/util.js"(exports2) {
    "use strict";
    init_globals();
    require_util();
    require_jsbn();
    var forge = require_forge();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    exports2.bigIntegerToUintBase64url = (num, len) => {
      let buf3 = Uint8Array.from(num.abs().toByteArray());
      buf3 = buf3[0] === 0 ? buf3.slice(1) : buf3;
      if (len != null) {
        if (buf3.length > len)
          throw new Error("byte array longer than desired length");
        buf3 = uint8ArrayConcat([new Uint8Array(len - buf3.length), buf3]);
      }
      return uint8ArrayToString(buf3, "base64url");
    };
    exports2.base64urlToBigInteger = (str) => {
      const buf3 = exports2.base64urlToBuffer(str);
      return new forge.jsbn.BigInteger(uint8ArrayToString(buf3, "base16"), 16);
    };
    exports2.base64urlToBuffer = (str, len) => {
      let buf3 = uint8ArrayFromString(str, "base64urlpad");
      if (len != null) {
        if (buf3.length > len)
          throw new Error("byte array longer than desired length");
        buf3 = uint8ArrayConcat([new Uint8Array(len - buf3.length), buf3]);
      }
      return buf3;
    };
  }
});

// node_modules/libp2p-crypto/src/keys/rsa-utils.js
var require_rsa_utils = __commonJS({
  "node_modules/libp2p-crypto/src/keys/rsa-utils.js"(exports2) {
    "use strict";
    init_globals();
    require_asn1();
    require_rsa();
    var forge = require_forge();
    var { bigIntegerToUintBase64url, base64urlToBigInteger } = require_util2();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    exports2.pkcs1ToJwk = function(bytes2) {
      const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes2, "ascii"));
      const privateKey = forge.pki.privateKeyFromAsn1(asn1);
      return {
        kty: "RSA",
        n: bigIntegerToUintBase64url(privateKey.n),
        e: bigIntegerToUintBase64url(privateKey.e),
        d: bigIntegerToUintBase64url(privateKey.d),
        p: bigIntegerToUintBase64url(privateKey.p),
        q: bigIntegerToUintBase64url(privateKey.q),
        dp: bigIntegerToUintBase64url(privateKey.dP),
        dq: bigIntegerToUintBase64url(privateKey.dQ),
        qi: bigIntegerToUintBase64url(privateKey.qInv),
        alg: "RS256",
        kid: "2011-04-29"
      };
    };
    exports2.jwkToPkcs1 = function(jwk) {
      const asn1 = forge.pki.privateKeyToAsn1({
        n: base64urlToBigInteger(jwk.n),
        e: base64urlToBigInteger(jwk.e),
        d: base64urlToBigInteger(jwk.d),
        p: base64urlToBigInteger(jwk.p),
        q: base64urlToBigInteger(jwk.q),
        dP: base64urlToBigInteger(jwk.dp),
        dQ: base64urlToBigInteger(jwk.dq),
        qInv: base64urlToBigInteger(jwk.qi)
      });
      return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), "ascii");
    };
    exports2.pkixToJwk = function(bytes2) {
      const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes2, "ascii"));
      const publicKey = forge.pki.publicKeyFromAsn1(asn1);
      return {
        kty: "RSA",
        n: bigIntegerToUintBase64url(publicKey.n),
        e: bigIntegerToUintBase64url(publicKey.e),
        alg: "RS256",
        kid: "2011-04-29"
      };
    };
    exports2.jwkToPkix = function(jwk) {
      const asn1 = forge.pki.publicKeyToAsn1({
        n: base64urlToBigInteger(jwk.n),
        e: base64urlToBigInteger(jwk.e)
      });
      return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), "ascii");
    };
  }
});

// node_modules/libp2p-crypto/src/keys/jwk2pem.js
var require_jwk2pem = __commonJS({
  "node_modules/libp2p-crypto/src/keys/jwk2pem.js"(exports2, module2) {
    "use strict";
    init_globals();
    require_rsa();
    var forge = require_forge();
    var { base64urlToBigInteger } = require_util2();
    function convert(key, types3) {
      return types3.map((t) => base64urlToBigInteger(key[t]));
    }
    function jwk2priv(key) {
      return forge.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
    }
    function jwk2pub(key) {
      return forge.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
    }
    module2.exports = {
      jwk2pub,
      jwk2priv
    };
  }
});

// node_modules/libp2p-crypto/src/keys/rsa-browser.js
var require_rsa_browser = __commonJS({
  "node_modules/libp2p-crypto/src/keys/rsa-browser.js"(exports2) {
    "use strict";
    init_globals();
    var webcrypto = require_webcrypto();
    var randomBytes = require_random_bytes();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    exports2.utils = require_rsa_utils();
    exports2.generateKey = async function(bits) {
      const pair = await webcrypto.get().subtle.generateKey({
        name: "RSASSA-PKCS1-v1_5",
        modulusLength: bits,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: { name: "SHA-256" }
      }, true, ["sign", "verify"]);
      const keys2 = await exportKey(pair);
      return {
        privateKey: keys2[0],
        publicKey: keys2[1]
      };
    };
    exports2.unmarshalPrivateKey = async function(key) {
      const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, true, ["sign"]);
      const pair = [
        privateKey,
        await derivePublicFromPrivate(key)
      ];
      const keys2 = await exportKey({
        privateKey: pair[0],
        publicKey: pair[1]
      });
      return {
        privateKey: keys2[0],
        publicKey: keys2[1]
      };
    };
    exports2.getRandomValues = randomBytes;
    exports2.hashAndSign = async function(key, msg) {
      const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, false, ["sign"]);
      const sig = await webcrypto.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
      return new Uint8Array(sig, sig.byteOffset, sig.byteLength);
    };
    exports2.hashAndVerify = async function(key, sig, msg) {
      const publicKey = await webcrypto.get().subtle.importKey("jwk", key, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, false, ["verify"]);
      return webcrypto.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
    };
    function exportKey(pair) {
      return Promise.all([
        webcrypto.get().subtle.exportKey("jwk", pair.privateKey),
        webcrypto.get().subtle.exportKey("jwk", pair.publicKey)
      ]);
    }
    function derivePublicFromPrivate(jwKey) {
      return webcrypto.get().subtle.importKey("jwk", {
        kty: jwKey.kty,
        n: jwKey.n,
        e: jwKey.e
      }, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, true, ["verify"]);
    }
    var { jwk2pub, jwk2priv } = require_jwk2pem();
    function convertKey(key, pub, msg, handle) {
      const fkey = pub ? jwk2pub(key) : jwk2priv(key);
      const fmsg = uint8ArrayToString(Uint8Array.from(msg), "ascii");
      const fomsg = handle(fmsg, fkey);
      return uint8ArrayFromString(fomsg, "ascii");
    }
    exports2.encrypt = function(key, msg) {
      return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
    };
    exports2.decrypt = function(key, msg) {
      return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
    };
  }
});

// node_modules/libp2p-crypto/src/keys/exporter.js
var require_exporter = __commonJS({
  "node_modules/libp2p-crypto/src/keys/exporter.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { base64: base643 } = (init_base64(), __toCommonJS(base64_exports));
    var ciphers = require_aes_gcm_browser();
    module2.exports = {
      export: async function(privateKey, password) {
        const cipher = ciphers.create();
        const encryptedKey = await cipher.encrypt(privateKey, password);
        return base643.encode(encryptedKey);
      }
    };
  }
});

// node_modules/libp2p-crypto/src/keys/rsa-class.js
var require_rsa_class = __commonJS({
  "node_modules/libp2p-crypto/src/keys/rsa-class.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    var errcode17 = require_err_code();
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    require_sha512();
    var forge = require_forge();
    var crypto6 = require_rsa_browser();
    var pbm = require_keys();
    var exporter3 = require_exporter();
    var RsaPublicKey = class {
      constructor(key) {
        this._key = key;
      }
      async verify(data, sig) {
        return crypto6.hashAndVerify(this._key, sig, data);
      }
      marshal() {
        return crypto6.utils.jwkToPkix(this._key);
      }
      get bytes() {
        return pbm.PublicKey.encode({
          Type: pbm.KeyType.RSA,
          Data: this.marshal()
        }).finish();
      }
      encrypt(bytes2) {
        return crypto6.encrypt(this._key, bytes2);
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes: bytes2 } = await sha2563.digest(this.bytes);
        return bytes2;
      }
    };
    var RsaPrivateKey = class {
      constructor(key, publicKey) {
        this._key = key;
        this._publicKey = publicKey;
      }
      genSecret() {
        return crypto6.getRandomValues(16);
      }
      async sign(message) {
        return crypto6.hashAndSign(this._key, message);
      }
      get public() {
        if (!this._publicKey) {
          throw errcode17(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
        }
        return new RsaPublicKey(this._publicKey);
      }
      decrypt(bytes2) {
        return crypto6.decrypt(this._key, bytes2);
      }
      marshal() {
        return crypto6.utils.jwkToPkcs1(this._key);
      }
      get bytes() {
        return pbm.PrivateKey.encode({
          Type: pbm.KeyType.RSA,
          Data: this.marshal()
        }).finish();
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes: bytes2 } = await sha2563.digest(this.bytes);
        return bytes2;
      }
      async id() {
        const hash2 = await this.public.hash();
        return uint8ArrayToString(hash2, "base58btc");
      }
      async export(password, format = "pkcs-8") {
        if (format === "pkcs-8") {
          const buffer3 = new forge.util.ByteBuffer(this.marshal());
          const asn1 = forge.asn1.fromDer(buffer3);
          const privateKey = forge.pki.privateKeyFromAsn1(asn1);
          const options = {
            algorithm: "aes256",
            count: 1e4,
            saltSize: 128 / 8,
            prfAlgorithm: "sha512"
          };
          return forge.pki.encryptRsaPrivateKey(privateKey, password, options);
        } else if (format === "libp2p-key") {
          return exporter3.export(this.bytes, password);
        } else {
          throw errcode17(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
        }
      }
    };
    async function unmarshalRsaPrivateKey(bytes2) {
      const jwk = crypto6.utils.pkcs1ToJwk(bytes2);
      const keys2 = await crypto6.unmarshalPrivateKey(jwk);
      return new RsaPrivateKey(keys2.privateKey, keys2.publicKey);
    }
    function unmarshalRsaPublicKey(bytes2) {
      const jwk = crypto6.utils.pkixToJwk(bytes2);
      return new RsaPublicKey(jwk);
    }
    async function fromJwk(jwk) {
      const keys2 = await crypto6.unmarshalPrivateKey(jwk);
      return new RsaPrivateKey(keys2.privateKey, keys2.publicKey);
    }
    async function generateKeyPair(bits) {
      const keys2 = await crypto6.generateKey(bits);
      return new RsaPrivateKey(keys2.privateKey, keys2.publicKey);
    }
    module2.exports = {
      RsaPublicKey,
      RsaPrivateKey,
      unmarshalRsaPublicKey,
      unmarshalRsaPrivateKey,
      generateKeyPair,
      fromJwk
    };
  }
});

// node_modules/@noble/ed25519/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@noble/ed25519/lib/index.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.utils = exports2.curve25519 = exports2.getSharedSecret = exports2.verify = exports2.sign = exports2.getPublicKey = exports2.Signature = exports2.Point = exports2.RistrettoPoint = exports2.ExtendedPoint = exports2.CURVE = void 0;
    var crypto_1 = __importDefault(require_crypto());
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _255n = BigInt(255);
    var CURVE_ORDER = _2n ** BigInt(252) + BigInt("27742317777372353535851937790883648493");
    var CURVE = {
      a: BigInt(-1),
      d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
      P: _2n ** _255n - BigInt(19),
      l: CURVE_ORDER,
      n: CURVE_ORDER,
      h: BigInt(8),
      Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
      Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
    };
    exports2.CURVE = CURVE;
    var MAX_256B = _2n ** BigInt(256);
    var SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    var SQRT_D = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
    var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    var ExtendedPoint = class {
      constructor(x, y, z, t) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.t = t;
      }
      static fromAffine(p) {
        if (!(p instanceof Point)) {
          throw new TypeError("ExtendedPoint#fromAffine: expected Point");
        }
        if (p.equals(Point.ZERO))
          return ExtendedPoint.ZERO;
        return new ExtendedPoint(p.x, p.y, _1n, mod2(p.x * p.y));
      }
      static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
      }
      static normalizeZ(points) {
        return this.toAffineBatch(points).map(this.fromAffine);
      }
      equals(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const X1Z2 = mod2(X1 * Z2);
        const X2Z1 = mod2(X2 * Z1);
        const Y1Z2 = mod2(Y1 * Z2);
        const Y2Z1 = mod2(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      negate() {
        return new ExtendedPoint(mod2(-this.x), this.y, this.z, mod2(-this.t));
      }
      double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const { a } = CURVE;
        const A = mod2(X1 ** _2n);
        const B = mod2(Y1 ** _2n);
        const C = mod2(_2n * mod2(Z1 ** _2n));
        const D = mod2(a * A);
        const E = mod2(mod2((X1 + Y1) ** _2n) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = mod2(E * F);
        const Y3 = mod2(G * H);
        const T3 = mod2(E * H);
        const Z3 = mod2(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
      }
      add(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1, t: T1 } = this;
        const { x: X2, y: Y2, z: Z2, t: T2 } = other;
        const A = mod2((Y1 - X1) * (Y2 + X2));
        const B = mod2((Y1 + X1) * (Y2 - X2));
        const F = mod2(B - A);
        if (F === _0n)
          return this.double();
        const C = mod2(Z1 * _2n * T2);
        const D = mod2(T1 * _2n * Z2);
        const E = D + C;
        const G = B + A;
        const H = D - C;
        const X3 = mod2(E * F);
        const Y3 = mod2(G * H);
        const T3 = mod2(E * H);
        const Z3 = mod2(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      precomputeWindow(W) {
        const windows = 1 + 256 / W;
        const points = [];
        let p = this;
        let base4 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base4 = p;
          points.push(base4);
          for (let i = 1; i < 2 ** (W - 1); i++) {
            base4 = base4.add(p);
            points.push(base4);
          }
          p = base4.double();
        }
        return points;
      }
      wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(ExtendedPoint.BASE))
          affinePoint = Point.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) {
          throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
          precomputes = this.precomputeWindow(W);
          if (affinePoint && W !== 1) {
            precomputes = ExtendedPoint.normalizeZ(precomputes);
            pointPrecomputes.set(affinePoint, precomputes);
          }
        }
        let p = ExtendedPoint.ZERO;
        let f = ExtendedPoint.ZERO;
        const windows = 1 + 256 / W;
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n;
          }
          if (wbits === 0) {
            let pr = precomputes[offset];
            if (window2 % 2)
              pr = pr.negate();
            f = f.add(pr);
          } else {
            let cached = precomputes[offset + Math.abs(wbits) - 1];
            if (wbits < 0)
              cached = cached.negate();
            p = p.add(cached);
          }
        }
        return ExtendedPoint.normalizeZ([p, f])[0];
      }
      multiply(scalar, affinePoint) {
        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
      }
      multiplyUnsafe(scalar) {
        let n = normalizeScalar(scalar, CURVE.l, false);
        const G = ExtendedPoint.BASE;
        const P0 = ExtendedPoint.ZERO;
        if (n === _0n)
          return P0;
        if (this.equals(P0) || n === _1n)
          return this;
        if (this.equals(G))
          return this.wNAF(n);
        let p = P0;
        let d = this;
        while (n > _0n) {
          if (n & _1n)
            p = p.add(d);
          d = d.double();
          n >>= _1n;
        }
        return p;
      }
      isSmallOrder() {
        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
      }
      isTorsionFree() {
        return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);
      }
      toAffine(invZ = invert(this.z)) {
        const { x, y, z } = this;
        const ax = mod2(x * invZ);
        const ay = mod2(y * invZ);
        const zz = mod2(z * invZ);
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return new Point(ax, ay);
      }
      fromRistrettoBytes() {
        legacyRist();
      }
      toRistrettoBytes() {
        legacyRist();
      }
      fromRistrettoHash() {
        legacyRist();
      }
    };
    exports2.ExtendedPoint = ExtendedPoint;
    ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod2(CURVE.Gx * CURVE.Gy));
    ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
    function assertExtPoint(other) {
      if (!(other instanceof ExtendedPoint))
        throw new TypeError("ExtendedPoint expected");
    }
    function assertRstPoint(other) {
      if (!(other instanceof RistrettoPoint))
        throw new TypeError("RistrettoPoint expected");
    }
    function legacyRist() {
      throw new Error("Legacy method: switch to RistrettoPoint");
    }
    var RistrettoPoint = class {
      constructor(ep) {
        this.ep = ep;
      }
      static calcElligatorRistrettoMap(r0) {
        const { d } = CURVE;
        const r = mod2(SQRT_M1 * r0 * r0);
        const Ns = mod2((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod2((c - d * r) * mod2(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod2(s * r0);
        if (!edIsNegative(s_))
          s_ = mod2(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod2(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod2((s + s) * D);
        const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod2(_1n - s2);
        const W3 = mod2(_1n + s2);
        return new ExtendedPoint(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
      }
      static hashToCurve(hex) {
        hex = ensureBytes(hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = this.calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = this.calcElligatorRistrettoMap(r2);
        return new RistrettoPoint(R1.add(R2));
      }
      static fromHex(hex) {
        hex = ensureBytes(hex, 32);
        const { a, d } = CURVE;
        const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
        const s = bytes255ToNumberLE(hex);
        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))
          throw new Error(emsg);
        const s2 = mod2(s * s);
        const u1 = mod2(_1n + a * s2);
        const u2 = mod2(_1n - a * s2);
        const u1_2 = mod2(u1 * u1);
        const u2_2 = mod2(u2 * u2);
        const v = mod2(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod2(v * u2_2));
        const Dx = mod2(I * u2);
        const Dy = mod2(I * Dx * v);
        let x = mod2((s + s) * Dx);
        if (edIsNegative(x))
          x = mod2(-x);
        const y = mod2(u1 * Dy);
        const t = mod2(x * y);
        if (!isValid || edIsNegative(t) || y === _0n)
          throw new Error(emsg);
        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));
      }
      toRawBytes() {
        let { x, y, z, t } = this.ep;
        const u1 = mod2(mod2(z + y) * mod2(z - y));
        const u2 = mod2(x * y);
        const { value: invsqrt } = invertSqrt(mod2(u1 * u2 ** _2n));
        const D1 = mod2(invsqrt * u1);
        const D2 = mod2(invsqrt * u2);
        const zInv = mod2(D1 * D2 * t);
        let D;
        if (edIsNegative(t * zInv)) {
          let _x = mod2(y * SQRT_M1);
          let _y = mod2(x * SQRT_M1);
          x = _x;
          y = _y;
          D = mod2(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }
        if (edIsNegative(x * zInv))
          y = mod2(-y);
        let s = mod2((z - y) * D);
        if (edIsNegative(s))
          s = mod2(-s);
        return numberTo32BytesLE(s);
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
      toString() {
        return this.toHex();
      }
      equals(other) {
        assertRstPoint(other);
        const a = this.ep;
        const b = other.ep;
        const one = mod2(a.x * b.y) === mod2(a.y * b.x);
        const two = mod2(a.y * b.y) === mod2(a.x * b.x);
        return one || two;
      }
      add(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.add(other.ep));
      }
      subtract(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return new RistrettoPoint(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
      }
    };
    exports2.RistrettoPoint = RistrettoPoint;
    RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
    RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var Point = class {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      static fromHex(hex, strict = true) {
        const { d, P } = CURVE;
        hex = ensureBytes(hex, 32);
        const normed = hex.slice();
        normed[31] = hex[31] & ~128;
        const y = bytesToNumberLE(normed);
        if (strict && y >= P)
          throw new Error("Expected 0 < hex < P");
        if (!strict && y >= MAX_256B)
          throw new Error("Expected 0 < hex < 2**256");
        const y2 = mod2(y * y);
        const u = mod2(y2 - _1n);
        const v = mod2(d * y2 + _1n);
        let { isValid, value: x } = uvRatio(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n) === _1n;
        const isLastByteOdd = (hex[31] & 128) !== 0;
        if (isLastByteOdd !== isXOdd) {
          x = mod2(-x);
        }
        return new Point(x, y);
      }
      static async fromPrivateKey(privateKey) {
        return (await getExtendedPublicKey(privateKey)).point;
      }
      toRawBytes() {
        const bytes2 = numberTo32BytesLE(this.y);
        bytes2[31] |= this.x & _1n ? 128 : 0;
        return bytes2;
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
      toX25519() {
        const { y } = this;
        const u = mod2((_1n + y) * invert(_1n - y));
        return numberTo32BytesLE(u);
      }
      isTorsionFree() {
        return ExtendedPoint.fromAffine(this).isTorsionFree();
      }
      equals(other) {
        return this.x === other.x && this.y === other.y;
      }
      negate() {
        return new Point(mod2(-this.x), this.y);
      }
      add(other) {
        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
    };
    exports2.Point = Point;
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
    Point.ZERO = new Point(_0n, _1n);
    var Signature = class {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromHex(hex) {
        const bytes2 = ensureBytes(hex, 64);
        const r = Point.fromHex(bytes2.slice(0, 32), false);
        const s = bytesToNumberLE(bytes2.slice(32, 64));
        return new Signature(r, s);
      }
      assertValidity() {
        const { r, s } = this;
        if (!(r instanceof Point))
          throw new Error("Expected Point instance");
        normalizeScalar(s, CURVE.l, false);
        return this;
      }
      toRawBytes() {
        const u8 = new Uint8Array(64);
        u8.set(this.r.toRawBytes());
        u8.set(numberTo32BytesLE(this.s), 32);
        return u8;
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
    };
    exports2.Signature = Signature;
    function concatBytes(...arrays) {
      if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error("Expected Uint8Array list");
      if (arrays.length === 1)
        return arrays[0];
      const length5 = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length5);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
      }
      return hex;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    function numberTo32BytesBE(num) {
      const length5 = 32;
      const hex = num.toString(16).padStart(length5 * 2, "0");
      return hexToBytes(hex);
    }
    function numberTo32BytesLE(num) {
      return numberTo32BytesBE(num).reverse();
    }
    function edIsNegative(num) {
      return (mod2(num) & _1n) === _1n;
    }
    function bytesToNumberLE(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      return BigInt("0x" + bytesToHex(Uint8Array.from(uint8a).reverse()));
    }
    function bytes255ToNumberLE(bytes2) {
      return mod2(bytesToNumberLE(bytes2) & _2n ** _255n - _1n);
    }
    function mod2(a, b = CURVE.P) {
      const res = a % b;
      return res >= _0n ? res : b + res;
    }
    function invert(number, modulo = CURVE.P) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod2(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod2(x, modulo);
    }
    function invertBatch(nums, p = CURVE.P) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (num === _0n)
          return acc;
        tmp[i] = acc;
        return mod2(acc * num, p);
      }, _1n);
      const inverted = invert(lastMultiplied, p);
      nums.reduceRight((acc, num, i) => {
        if (num === _0n)
          return acc;
        tmp[i] = mod2(acc * tmp[i], p);
        return mod2(acc * num, p);
      }, inverted);
      return tmp;
    }
    function pow2(x, power) {
      const { P } = CURVE;
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= P;
      }
      return res;
    }
    function pow_2_252_3(x) {
      const { P } = CURVE;
      const _5n = BigInt(5);
      const _10n = BigInt(10);
      const _20n = BigInt(20);
      const _40n = BigInt(40);
      const _80n = BigInt(80);
      const x2 = x * x % P;
      const b2 = x2 * x % P;
      const b4 = pow2(b2, _2n) * b2 % P;
      const b5 = pow2(b4, _1n) * x % P;
      const b10 = pow2(b5, _5n) * b5 % P;
      const b20 = pow2(b10, _10n) * b10 % P;
      const b40 = pow2(b20, _20n) * b20 % P;
      const b80 = pow2(b40, _40n) * b40 % P;
      const b160 = pow2(b80, _80n) * b80 % P;
      const b240 = pow2(b160, _80n) * b80 % P;
      const b250 = pow2(b240, _10n) * b10 % P;
      const pow_p_5_8 = pow2(b250, _2n) * x % P;
      return { pow_p_5_8, b2 };
    }
    function uvRatio(u, v) {
      const v3 = mod2(v * v * v);
      const v7 = mod2(v3 * v3 * v);
      const pow = pow_2_252_3(u * v7).pow_p_5_8;
      let x = mod2(u * v3 * pow);
      const vx2 = mod2(v * x * x);
      const root1 = x;
      const root2 = mod2(x * SQRT_M1);
      const useRoot1 = vx2 === u;
      const useRoot2 = vx2 === mod2(-u);
      const noRoot = vx2 === mod2(-u * SQRT_M1);
      if (useRoot1)
        x = root1;
      if (useRoot2 || noRoot)
        x = root2;
      if (edIsNegative(x))
        x = mod2(-x);
      return { isValid: useRoot1 || useRoot2, value: x };
    }
    function invertSqrt(number) {
      return uvRatio(_1n, number);
    }
    async function sha512ModqLE(...args) {
      const hash2 = await exports2.utils.sha512(concatBytes(...args));
      const value = bytesToNumberLE(hash2);
      return mod2(value, CURVE.l);
    }
    function equalBytes(b1, b2) {
      if (b1.length !== b2.length) {
        return false;
      }
      for (let i = 0; i < b1.length; i++) {
        if (b1[i] !== b2[i]) {
          return false;
        }
      }
      return true;
    }
    function ensureBytes(hex, expectedLength) {
      const bytes2 = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
      if (typeof expectedLength === "number" && bytes2.length !== expectedLength)
        throw new Error(`Expected ${expectedLength} bytes`);
      return bytes2;
    }
    function normalizeScalar(num, max, strict = true) {
      if (!max)
        throw new TypeError("Specify max value");
      if (typeof num === "number" && Number.isSafeInteger(num))
        num = BigInt(num);
      if (typeof num === "bigint" && num < max) {
        if (strict) {
          if (_0n < num)
            return num;
        } else {
          if (_0n <= num)
            return num;
        }
      }
      throw new TypeError("Expected valid scalar: 0 < scalar < max");
    }
    function adjustBytes25519(bytes2) {
      bytes2[0] &= 248;
      bytes2[31] &= 127;
      bytes2[31] |= 64;
      return bytes2;
    }
    function decodeScalar25519(n) {
      return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));
    }
    async function getExtendedPublicKey(key) {
      key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar(key, MAX_256B)) : ensureBytes(key);
      if (key.length !== 32)
        throw new Error(`Expected 32 bytes`);
      const hashed = await exports2.utils.sha512(key);
      const head = adjustBytes25519(hashed.slice(0, 32));
      const prefix = hashed.slice(32, 64);
      const scalar = mod2(bytesToNumberLE(head), CURVE.l);
      const point = Point.BASE.multiply(scalar);
      const pointBytes = point.toRawBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    async function getPublicKey(privateKey) {
      return (await getExtendedPublicKey(privateKey)).pointBytes;
    }
    exports2.getPublicKey = getPublicKey;
    async function sign3(message, privateKey) {
      message = ensureBytes(message);
      const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
      const r = await sha512ModqLE(prefix, message);
      const R = Point.BASE.multiply(r);
      const k = await sha512ModqLE(R.toRawBytes(), pointBytes, message);
      const s = mod2(r + k * scalar, CURVE.l);
      return new Signature(R, s).toRawBytes();
    }
    exports2.sign = sign3;
    async function verify2(sig, message, publicKey) {
      message = ensureBytes(message);
      if (!(publicKey instanceof Point))
        publicKey = Point.fromHex(publicKey, false);
      const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
      const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
      const k = await sha512ModqLE(r.toRawBytes(), publicKey.toRawBytes(), message);
      const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
      const RkA = ExtendedPoint.fromAffine(r).add(kA);
      return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
    }
    exports2.verify = verify2;
    async function getSharedSecret(privateKey, publicKey) {
      const { head } = await getExtendedPublicKey(privateKey);
      const u = Point.fromHex(publicKey).toX25519();
      return exports2.curve25519.scalarMult(head, u);
    }
    exports2.getSharedSecret = getSharedSecret;
    Point.BASE._setWindowSize(8);
    function cswap(swap, x_2, x_3) {
      const dummy = mod2(swap * (x_2 - x_3));
      x_2 = mod2(x_2 - dummy);
      x_3 = mod2(x_3 + dummy);
      return [x_2, x_3];
    }
    function montgomeryLadder(pointU, scalar) {
      const { P } = CURVE;
      const u = normalizeScalar(pointU, P);
      const k = normalizeScalar(scalar, P);
      const a24 = BigInt(121665);
      const x_1 = u;
      let x_2 = _1n;
      let z_2 = _0n;
      let x_3 = u;
      let z_3 = _1n;
      let swap = _0n;
      let sw;
      for (let t = BigInt(255 - 1); t >= _0n; t--) {
        const k_t = k >> t & _1n;
        swap ^= k_t;
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        swap = k_t;
        const A = x_2 + z_2;
        const AA = mod2(A * A);
        const B = x_2 - z_2;
        const BB = mod2(B * B);
        const E = AA - BB;
        const C = x_3 + z_3;
        const D = x_3 - z_3;
        const DA = mod2(D * A);
        const CB = mod2(C * B);
        x_3 = mod2((DA + CB) ** _2n);
        z_3 = mod2(x_1 * (DA - CB) ** _2n);
        x_2 = mod2(AA * BB);
        z_2 = mod2(E * (AA + mod2(a24 * E)));
      }
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      const { pow_p_5_8, b2 } = pow_2_252_3(z_2);
      const xp2 = mod2(pow2(pow_p_5_8, BigInt(3)) * b2);
      return mod2(x_2 * xp2);
    }
    function encodeUCoordinate(u) {
      return numberTo32BytesLE(mod2(u, CURVE.P));
    }
    function decodeUCoordinate(uEnc) {
      const u = ensureBytes(uEnc, 32);
      u[31] &= 127;
      return bytesToNumberLE(u);
    }
    exports2.curve25519 = {
      BASE_POINT_U: "0900000000000000000000000000000000000000000000000000000000000000",
      scalarMult(privateKey, publicKey) {
        const u = decodeUCoordinate(publicKey);
        const p = decodeScalar25519(privateKey);
        const pu = montgomeryLadder(u, p);
        if (pu === _0n)
          throw new Error("Invalid private or public key received");
        return encodeUCoordinate(pu);
      },
      scalarMultBase(privateKey) {
        return exports2.curve25519.scalarMult(privateKey, exports2.curve25519.BASE_POINT_U);
      }
    };
    var crypto6 = {
      node: crypto_1.default,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
    exports2.utils = {
      TORSION_SUBGROUP: [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ],
      bytesToHex,
      getExtendedPublicKey,
      mod: mod2,
      invert,
      hashToPrivateScalar: (hash2) => {
        hash2 = ensureBytes(hash2);
        if (hash2.length < 40 || hash2.length > 1024)
          throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
        const num = mod2(bytesToNumberLE(hash2), CURVE.l);
        if (num === _0n || num === _1n)
          throw new Error("Invalid private key");
        return num;
      },
      randomBytes: (bytesLength = 32) => {
        if (crypto6.web) {
          return crypto6.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto6.node) {
          const { randomBytes } = crypto6.node;
          return new Uint8Array(randomBytes(bytesLength).buffer);
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      },
      randomPrivateKey: () => {
        return exports2.utils.randomBytes(32);
      },
      sha512: async (message) => {
        if (crypto6.web) {
          const buffer3 = await crypto6.web.subtle.digest("SHA-512", message.buffer);
          return new Uint8Array(buffer3);
        } else if (crypto6.node) {
          return Uint8Array.from(crypto6.node.createHash("sha512").update(message).digest());
        } else {
          throw new Error("The environment doesn't have sha512 function");
        }
      },
      precompute(windowSize = 8, point = Point.BASE) {
        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_2n);
        return cached;
      }
    };
  }
});

// node_modules/libp2p-crypto/src/keys/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/libp2p-crypto/src/keys/ed25519.js"(exports2) {
    "use strict";
    init_globals();
    var ed = require_lib3();
    var PUBLIC_KEY_BYTE_LENGTH = 32;
    var PRIVATE_KEY_BYTE_LENGTH = 64;
    var KEYS_BYTE_LENGTH = 32;
    exports2.publicKeyLength = PUBLIC_KEY_BYTE_LENGTH;
    exports2.privateKeyLength = PRIVATE_KEY_BYTE_LENGTH;
    exports2.generateKey = async function() {
      const privateKeyRaw = ed.utils.randomPrivateKey();
      const publicKey = await ed.getPublicKey(privateKeyRaw);
      const privateKey = concatKeys(privateKeyRaw, publicKey);
      return {
        privateKey,
        publicKey
      };
    };
    exports2.generateKeyFromSeed = async function(seed) {
      if (seed.length !== KEYS_BYTE_LENGTH) {
        throw new TypeError('"seed" must be 32 bytes in length.');
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
      }
      const privateKeyRaw = seed;
      const publicKey = await ed.getPublicKey(privateKeyRaw);
      const privateKey = concatKeys(privateKeyRaw, publicKey);
      return {
        privateKey,
        publicKey
      };
    };
    exports2.hashAndSign = function(privateKey, msg) {
      const privateKeyRaw = privateKey.slice(0, KEYS_BYTE_LENGTH);
      return ed.sign(msg, privateKeyRaw);
    };
    exports2.hashAndVerify = function(publicKey, sig, msg) {
      return ed.verify(sig, msg, publicKey);
    };
    function concatKeys(privateKeyRaw, publicKey) {
      const privateKey = new Uint8Array(exports2.privateKeyLength);
      for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {
        privateKey[i] = privateKeyRaw[i];
        privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
      }
      return privateKey;
    }
  }
});

// node_modules/libp2p-crypto/src/keys/ed25519-class.js
var require_ed25519_class = __commonJS({
  "node_modules/libp2p-crypto/src/keys/ed25519-class.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errcode17 = require_err_code();
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    var { base58btc: base58btc3 } = (init_base58(), __toCommonJS(base58_exports));
    var { identity: identity5 } = (init_identity(), __toCommonJS(identity_exports));
    var crypto6 = require_ed25519();
    var pbm = require_keys();
    var exporter3 = require_exporter();
    var Ed25519PublicKey = class {
      constructor(key) {
        this._key = ensureKey(key, crypto6.publicKeyLength);
      }
      async verify(data, sig) {
        return crypto6.hashAndVerify(this._key, sig, data);
      }
      marshal() {
        return this._key;
      }
      get bytes() {
        return pbm.PublicKey.encode({
          Type: pbm.KeyType.Ed25519,
          Data: this.marshal()
        }).finish();
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes: bytes2 } = await sha2563.digest(this.bytes);
        return bytes2;
      }
    };
    var Ed25519PrivateKey = class {
      constructor(key, publicKey) {
        this._key = ensureKey(key, crypto6.privateKeyLength);
        this._publicKey = ensureKey(publicKey, crypto6.publicKeyLength);
      }
      async sign(message) {
        return crypto6.hashAndSign(this._key, message);
      }
      get public() {
        return new Ed25519PublicKey(this._publicKey);
      }
      marshal() {
        return this._key;
      }
      get bytes() {
        return pbm.PrivateKey.encode({
          Type: pbm.KeyType.Ed25519,
          Data: this.marshal()
        }).finish();
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes: bytes2 } = await sha2563.digest(this.bytes);
        return bytes2;
      }
      async id() {
        const encoding = await identity5.digest(this.public.bytes);
        return base58btc3.encode(encoding.bytes).substring(1);
      }
      async export(password, format = "libp2p-key") {
        if (format === "libp2p-key") {
          return exporter3.export(this.bytes, password);
        } else {
          throw errcode17(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
        }
      }
    };
    function unmarshalEd25519PrivateKey(bytes2) {
      if (bytes2.length > crypto6.privateKeyLength) {
        bytes2 = ensureKey(bytes2, crypto6.privateKeyLength + crypto6.publicKeyLength);
        const privateKeyBytes2 = bytes2.slice(0, crypto6.privateKeyLength);
        const publicKeyBytes2 = bytes2.slice(crypto6.privateKeyLength, bytes2.length);
        return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
      }
      bytes2 = ensureKey(bytes2, crypto6.privateKeyLength);
      const privateKeyBytes = bytes2.slice(0, crypto6.privateKeyLength);
      const publicKeyBytes = bytes2.slice(crypto6.publicKeyLength);
      return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
    }
    function unmarshalEd25519PublicKey(bytes2) {
      bytes2 = ensureKey(bytes2, crypto6.publicKeyLength);
      return new Ed25519PublicKey(bytes2);
    }
    async function generateKeyPair() {
      const { privateKey, publicKey } = await crypto6.generateKey();
      return new Ed25519PrivateKey(privateKey, publicKey);
    }
    async function generateKeyPairFromSeed(seed) {
      const { privateKey, publicKey } = await crypto6.generateKeyFromSeed(seed);
      return new Ed25519PrivateKey(privateKey, publicKey);
    }
    function ensureKey(key, length5) {
      key = Uint8Array.from(key || []);
      if (key.length !== length5) {
        throw errcode17(new Error(`Key must be a Uint8Array of length ${length5}, got ${key.length}`), "ERR_INVALID_KEY_TYPE");
      }
      return key;
    }
    module2.exports = {
      Ed25519PublicKey,
      Ed25519PrivateKey,
      unmarshalEd25519PrivateKey,
      unmarshalEd25519PublicKey,
      generateKeyPair,
      generateKeyPairFromSeed
    };
  }
});

// node_modules/@noble/secp256k1/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@noble/secp256k1/lib/index.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.utils = exports2.schnorr = exports2.verify = exports2.signSync = exports2.sign = exports2.getSharedSecret = exports2.recoverPublicKey = exports2.getPublicKey = exports2.Signature = exports2.Point = exports2.CURVE = void 0;
    var crypto_1 = __importDefault(require_crypto());
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _8n = BigInt(8);
    var POW_2_256 = _2n ** BigInt(256);
    var CURVE = {
      a: _0n,
      b: BigInt(7),
      P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),
      n: POW_2_256 - BigInt("432420386565659656852420866394968145599"),
      h: _1n,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
    };
    exports2.CURVE = CURVE;
    function weistrass(x) {
      const { a, b } = CURVE;
      const x2 = mod2(x * x);
      const x3 = mod2(x2 * x);
      return mod2(x3 + a * x + b);
    }
    var USE_ENDOMORPHISM = CURVE.a === _0n;
    var JacobianPoint = class {
      constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }
      static fromAffine(p) {
        if (!(p instanceof Point)) {
          throw new TypeError("JacobianPoint#fromAffine: expected Point");
        }
        return new JacobianPoint(p.x, p.y, _1n);
      }
      static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
      }
      static normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
      }
      equals(other) {
        if (!(other instanceof JacobianPoint))
          throw new TypeError("JacobianPoint expected");
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod2(Z1 ** _2n);
        const Z2Z2 = mod2(Z2 ** _2n);
        const U1 = mod2(X1 * Z2Z2);
        const U2 = mod2(X2 * Z1Z1);
        const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
        const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
      }
      negate() {
        return new JacobianPoint(this.x, mod2(-this.y), this.z);
      }
      double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A = mod2(X1 ** _2n);
        const B = mod2(Y1 ** _2n);
        const C = mod2(B ** _2n);
        const D = mod2(_2n * (mod2((X1 + B) ** _2n) - A - C));
        const E = mod2(_3n * A);
        const F = mod2(E ** _2n);
        const X3 = mod2(F - _2n * D);
        const Y3 = mod2(E * (D - X3) - _8n * C);
        const Z3 = mod2(_2n * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
      }
      add(other) {
        if (!(other instanceof JacobianPoint))
          throw new TypeError("JacobianPoint expected");
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n || Y2 === _0n)
          return this;
        if (X1 === _0n || Y1 === _0n)
          return other;
        const Z1Z1 = mod2(Z1 ** _2n);
        const Z2Z2 = mod2(Z2 ** _2n);
        const U1 = mod2(X1 * Z2Z2);
        const U2 = mod2(X2 * Z1Z1);
        const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
        const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
        const H = mod2(U2 - U1);
        const r = mod2(S2 - S1);
        if (H === _0n) {
          if (r === _0n) {
            return this.double();
          } else {
            return JacobianPoint.ZERO;
          }
        }
        const HH = mod2(H ** _2n);
        const HHH = mod2(H * HH);
        const V = mod2(U1 * HH);
        const X3 = mod2(r ** _2n - HHH - _2n * V);
        const Y3 = mod2(r * (V - X3) - S1 * HHH);
        const Z3 = mod2(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiplyUnsafe(scalar) {
        let n = normalizeScalar(scalar);
        const G = JacobianPoint.BASE;
        const P0 = JacobianPoint.ZERO;
        if (n === _0n)
          return P0;
        if (n === _1n)
          return this;
        if (!USE_ENDOMORPHISM) {
          let p = P0;
          let d2 = this;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d2);
            d2 = d2.double();
            n >>= _1n;
          }
          return p;
        }
        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
        let k1p = P0;
        let k2p = P0;
        let d = this;
        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n)
            k1p = k1p.add(d);
          if (k2 & _1n)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n;
          k2 >>= _1n;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new JacobianPoint(mod2(k2p.x * CURVE.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
      }
      precomputeWindow(W) {
        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        const points = [];
        let p = this;
        let base4 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base4 = p;
          points.push(base4);
          for (let i = 1; i < 2 ** (W - 1); i++) {
            base4 = base4.add(p);
            points.push(base4);
          }
          p = base4.double();
        }
        return points;
      }
      wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE))
          affinePoint = Point.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) {
          throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
          precomputes = this.precomputeWindow(W);
          if (affinePoint && W !== 1) {
            precomputes = JacobianPoint.normalizeZ(precomputes);
            pointPrecomputes.set(affinePoint, precomputes);
          }
        }
        let p = JacobianPoint.ZERO;
        let f = JacobianPoint.ZERO;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n;
          }
          if (wbits === 0) {
            let pr = precomputes[offset];
            if (window2 % 2)
              pr = pr.negate();
            f = f.add(pr);
          } else {
            let cached = precomputes[offset + Math.abs(wbits) - 1];
            if (wbits < 0)
              cached = cached.negate();
            p = p.add(cached);
          }
        }
        return { p, f };
      }
      multiply(scalar, affinePoint) {
        let n = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
          const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
          let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
          let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new JacobianPoint(mod2(k2p.x * CURVE.beta), k2p.y, k2p.z);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f } = this.wNAF(n, affinePoint);
          point = p;
          fake = f;
        }
        return JacobianPoint.normalizeZ([point, fake])[0];
      }
      toAffine(invZ = invert(this.z)) {
        const { x, y, z } = this;
        const iz1 = invZ;
        const iz2 = mod2(iz1 * iz1);
        const iz3 = mod2(iz2 * iz1);
        const ax = mod2(x * iz2);
        const ay = mod2(y * iz3);
        const zz = mod2(z * iz1);
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return new Point(ax, ay);
      }
    };
    JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
    JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var Point = class {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      static fromCompressedHex(bytes2) {
        const isShort = bytes2.length === 32;
        const x = bytesToNumber(isShort ? bytes2 : bytes2.subarray(1));
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weistrass(x);
        let y = sqrtMod(y2);
        const isYOdd = (y & _1n) === _1n;
        if (isShort) {
          if (isYOdd)
            y = mod2(-y);
        } else {
          const isFirstByteOdd = (bytes2[0] & 1) === 1;
          if (isFirstByteOdd !== isYOdd)
            y = mod2(-y);
        }
        const point = new Point(x, y);
        point.assertValidity();
        return point;
      }
      static fromUncompressedHex(bytes2) {
        const x = bytesToNumber(bytes2.subarray(1, 33));
        const y = bytesToNumber(bytes2.subarray(33, 65));
        const point = new Point(x, y);
        point.assertValidity();
        return point;
      }
      static fromHex(hex) {
        const bytes2 = ensureBytes(hex);
        const len = bytes2.length;
        const header = bytes2[0];
        if (len === 32 || len === 33 && (header === 2 || header === 3)) {
          return this.fromCompressedHex(bytes2);
        }
        if (len === 65 && header === 4)
          return this.fromUncompressedHex(bytes2);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);
      }
      static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normalizePrivateKey(privateKey));
      }
      static fromSignature(msgHash, signature, recovery) {
        msgHash = ensureBytes(msgHash);
        const h = truncateHash(msgHash);
        const { r, s } = normalizeSignature(signature);
        if (recovery !== 0 && recovery !== 1) {
          throw new Error("Cannot recover signature: invalid recovery bit");
        }
        if (h === _0n)
          throw new Error("Cannot recover signature: msgHash cannot be 0");
        const prefix = recovery & 1 ? "03" : "02";
        const R = Point.fromHex(prefix + numTo32bStr(r));
        const { n } = CURVE;
        const rinv = invert(r, n);
        const u1 = mod2(-h * rinv, n);
        const u2 = mod2(s * rinv, n);
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("Cannot recover signature: point at infinify");
        Q.assertValidity();
        return Q;
      }
      toRawBytes(isCompressed = false) {
        return hexToBytes(this.toHex(isCompressed));
      }
      toHex(isCompressed = false) {
        const x = numTo32bStr(this.x);
        if (isCompressed) {
          const prefix = this.y & _1n ? "03" : "02";
          return `${prefix}${x}`;
        } else {
          return `04${x}${numTo32bStr(this.y)}`;
        }
      }
      toHexX() {
        return this.toHex(true).slice(2);
      }
      toRawX() {
        return this.toRawBytes(true).slice(1);
      }
      assertValidity() {
        const msg = "Point is not on elliptic curve";
        const { x, y } = this;
        if (!isValidFieldElement(x) || !isValidFieldElement(y))
          throw new Error(msg);
        const left = mod2(y * y);
        const right = weistrass(x);
        if (mod2(left - right) !== _0n)
          throw new Error(msg);
      }
      equals(other) {
        return this.x === other.x && this.y === other.y;
      }
      negate() {
        return new Point(this.x, mod2(-this.y));
      }
      double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
      }
      add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const P = JacobianPoint.fromAffine(this);
        const aP = P.multiply(a);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
      }
    };
    exports2.Point = Point;
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
    Point.ZERO = new Point(_0n, _0n);
    function sliceDER(s) {
      return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
    }
    function parseDERInt(data) {
      if (data.length < 2 || data[0] !== 2) {
        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
      }
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len) {
        throw new Error(`Invalid signature integer: wrong length`);
      }
      if (res[0] === 0 && res[1] <= 127) {
        throw new Error("Invalid signature integer: trailing length");
      }
      return { data: bytesToNumber(res), left: data.subarray(len + 2) };
    }
    function parseDERSignature(data) {
      if (data.length < 2 || data[0] != 48) {
        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
      }
      if (data[1] !== data.length - 2) {
        throw new Error("Invalid signature: incorrect length");
      }
      const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
      const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
      if (rBytesLeft.length) {
        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
      }
      return { r, s };
    }
    var Signature = class {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromCompact(hex) {
        const arr = isUint8a(hex);
        const name10 = "Signature.fromCompact";
        if (typeof hex !== "string" && !arr)
          throw new TypeError(`${name10}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128)
          throw new Error(`${name10}: Expected 64-byte hex`);
        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
      }
      static fromDER(hex) {
        const arr = isUint8a(hex);
        if (typeof hex !== "string" && !arr)
          throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
        return new Signature(r, s);
      }
      static fromHex(hex) {
        return this.fromDER(hex);
      }
      assertValidity() {
        const { r, s } = this;
        if (!isWithinCurveOrder(r))
          throw new Error("Invalid Signature: r must be 0 < r < n");
        if (!isWithinCurveOrder(s))
          throw new Error("Invalid Signature: s must be 0 < s < n");
      }
      hasHighS() {
        const HALF = CURVE.n >> _1n;
        return this.s > HALF;
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;
      }
      toDERRawBytes(isCompressed = false) {
        return hexToBytes(this.toDERHex(isCompressed));
      }
      toDERHex(isCompressed = false) {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        if (isCompressed)
          return sHex;
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const rLen = numberToHexUnpadded(rHex.length / 2);
        const sLen = numberToHexUnpadded(sHex.length / 2);
        const length5 = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);
        return `30${length5}02${rLen}${rHex}02${sLen}${sHex}`;
      }
      toRawBytes() {
        return this.toDERRawBytes();
      }
      toHex() {
        return this.toDERHex();
      }
      toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
    };
    exports2.Signature = Signature;
    function concatBytes(...arrays) {
      if (!arrays.every(isUint8a))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length5 = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length5);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    function isUint8a(bytes2) {
      return bytes2 instanceof Uint8Array;
    }
    var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
      }
      return hex;
    }
    function numTo32bStr(num) {
      if (num > POW_2_256)
        throw new Error("Expected number < 2^256");
      return num.toString(16).padStart(64, "0");
    }
    function numTo32b(num) {
      return hexToBytes(numTo32bStr(num));
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToNumber: expected string, got " + typeof hex);
      }
      return BigInt(`0x${hex}`);
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    function bytesToNumber(bytes2) {
      return hexToNumber(bytesToHex(bytes2));
    }
    function ensureBytes(hex) {
      return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
    }
    function normalizeScalar(num) {
      if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
        return BigInt(num);
      if (typeof num === "bigint" && isWithinCurveOrder(num))
        return num;
      throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
    }
    function mod2(a, b = CURVE.P) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    function pow2(x, power) {
      const { P } = CURVE;
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= P;
      }
      return res;
    }
    function sqrtMod(x) {
      const { P } = CURVE;
      const _6n = BigInt(6);
      const _11n = BigInt(11);
      const _22n = BigInt(22);
      const _23n = BigInt(23);
      const _44n = BigInt(44);
      const _88n = BigInt(88);
      const b2 = x * x * x % P;
      const b3 = b2 * b2 * x % P;
      const b6 = pow2(b3, _3n) * b3 % P;
      const b9 = pow2(b6, _3n) * b3 % P;
      const b11 = pow2(b9, _2n) * b2 % P;
      const b22 = pow2(b11, _11n) * b11 % P;
      const b44 = pow2(b22, _22n) * b22 % P;
      const b88 = pow2(b44, _44n) * b44 % P;
      const b176 = pow2(b88, _88n) * b88 % P;
      const b220 = pow2(b176, _44n) * b44 % P;
      const b223 = pow2(b220, _3n) * b3 % P;
      const t1 = pow2(b223, _23n) * b22 % P;
      const t2 = pow2(t1, _6n) * b2 % P;
      return pow2(t2, _2n);
    }
    function invert(number, modulo = CURVE.P) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod2(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod2(x, modulo);
    }
    function invertBatch(nums, p = CURVE.P) {
      const scratch = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (num === _0n)
          return acc;
        scratch[i] = acc;
        return mod2(acc * num, p);
      }, _1n);
      const inverted = invert(lastMultiplied, p);
      nums.reduceRight((acc, num, i) => {
        if (num === _0n)
          return acc;
        scratch[i] = mod2(acc * scratch[i], p);
        return mod2(acc * num, p);
      }, inverted);
      return scratch;
    }
    var divNearest = (a, b) => (a + b / _2n) / b;
    var POW_2_128 = _2n ** BigInt(128);
    function splitScalarEndo(k) {
      const { n } = CURVE;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod2(k - c1 * a1 - c2 * a2, n);
      let k2 = mod2(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
    function truncateHash(hash2) {
      const { n } = CURVE;
      const byteLength = hash2.length;
      const delta = byteLength * 8 - 256;
      let h = bytesToNumber(hash2);
      if (delta > 0)
        h = h >> BigInt(delta);
      if (h >= n)
        h -= n;
      return h;
    }
    var HmacDrbg = class {
      constructor() {
        this.v = new Uint8Array(32).fill(1);
        this.k = new Uint8Array(32).fill(0);
        this.counter = 0;
      }
      hmac(...values2) {
        return exports2.utils.hmacSha256(this.k, ...values2);
      }
      hmacSync(...values2) {
        if (typeof exports2.utils.hmacSha256Sync !== "function")
          throw new Error("utils.hmacSha256Sync is undefined, you need to set it");
        const res = exports2.utils.hmacSha256Sync(this.k, ...values2);
        if (res instanceof Promise)
          throw new Error("To use sync sign(), ensure utils.hmacSha256 is sync");
        return res;
      }
      incr() {
        if (this.counter >= 1e3) {
          throw new Error("Tried 1,000 k values for sign(), all were invalid");
        }
        this.counter += 1;
      }
      async reseed(seed = new Uint8Array()) {
        this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
        this.v = await this.hmac(this.v);
        if (seed.length === 0)
          return;
        this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
        this.v = await this.hmac(this.v);
      }
      reseedSync(seed = new Uint8Array()) {
        this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
        this.v = this.hmacSync(this.v);
        if (seed.length === 0)
          return;
        this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
        this.v = this.hmacSync(this.v);
      }
      async generate() {
        this.incr();
        this.v = await this.hmac(this.v);
        return this.v;
      }
      generateSync() {
        this.incr();
        this.v = this.hmacSync(this.v);
        return this.v;
      }
    };
    function isWithinCurveOrder(num) {
      return _0n < num && num < CURVE.n;
    }
    function isValidFieldElement(num) {
      return _0n < num && num < CURVE.P;
    }
    function kmdToSig(kBytes, m, d) {
      const k = bytesToNumber(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const { n } = CURVE;
      const q = Point.BASE.multiply(k);
      const r = mod2(q.x, n);
      if (r === _0n)
        return;
      const s = mod2(invert(k, n) * mod2(m + d * r, n), n);
      if (s === _0n)
        return;
      const sig = new Signature(r, s);
      const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
      return { sig, recovery };
    }
    function normalizePrivateKey(key) {
      let num;
      if (typeof key === "bigint") {
        num = key;
      } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
        num = BigInt(key);
      } else if (typeof key === "string") {
        if (key.length !== 64)
          throw new Error("Expected 32 bytes of private key");
        num = hexToNumber(key);
      } else if (isUint8a(key)) {
        if (key.length !== 32)
          throw new Error("Expected 32 bytes of private key");
        num = bytesToNumber(key);
      } else {
        throw new TypeError("Expected valid private key");
      }
      if (!isWithinCurveOrder(num))
        throw new Error("Expected private key: 0 < key < n");
      return num;
    }
    function normalizePublicKey(publicKey) {
      if (publicKey instanceof Point) {
        publicKey.assertValidity();
        return publicKey;
      } else {
        return Point.fromHex(publicKey);
      }
    }
    function normalizeSignature(signature) {
      if (signature instanceof Signature) {
        signature.assertValidity();
        return signature;
      }
      try {
        return Signature.fromDER(signature);
      } catch (error) {
        return Signature.fromCompact(signature);
      }
    }
    function getPublicKey(privateKey, isCompressed = false) {
      return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    exports2.getPublicKey = getPublicKey;
    function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
      return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
    }
    exports2.recoverPublicKey = recoverPublicKey;
    function isPub(item) {
      const arr = isUint8a(item);
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === 33 || len === 65;
      if (str)
        return len === 66 || len === 130;
      if (item instanceof Point)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = false) {
      if (isPub(privateA))
        throw new TypeError("getSharedSecret: first arg must be private key");
      if (!isPub(publicB))
        throw new TypeError("getSharedSecret: second arg must be public key");
      const b = normalizePublicKey(publicB);
      b.assertValidity();
      return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
    }
    exports2.getSharedSecret = getSharedSecret;
    function bits2int(bytes2) {
      const slice3 = bytes2.length > 32 ? bytes2.slice(0, 32) : bytes2;
      return bytesToNumber(slice3);
    }
    function bits2octets(bytes2) {
      const z1 = bits2int(bytes2);
      const z2 = mod2(z1, CURVE.n);
      return int2octets(z2 < _0n ? z1 : z2);
    }
    function int2octets(num) {
      if (typeof num !== "bigint")
        throw new Error("Expected bigint");
      const hex = numTo32bStr(num);
      return hexToBytes(hex);
    }
    function initSigArgs(msgHash, privateKey, extraEntropy) {
      if (msgHash == null)
        throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
      const h1 = ensureBytes(msgHash);
      const d = normalizePrivateKey(privateKey);
      const seedArgs = [int2octets(d), bits2octets(h1)];
      if (extraEntropy != null) {
        if (extraEntropy === true)
          extraEntropy = exports2.utils.randomBytes(32);
        const e = ensureBytes(extraEntropy);
        if (e.length !== 32)
          throw new Error("sign: Expected 32 bytes of extra data");
        seedArgs.push(e);
      }
      const seed = concatBytes(...seedArgs);
      const m = bits2int(h1);
      return { seed, m, d };
    }
    function finalizeSig(recSig, opts) {
      let { sig, recovery } = recSig;
      const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);
      if (canonical && sig.hasHighS()) {
        sig = sig.normalizeS();
        recovery ^= 1;
      }
      const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
      return recovered ? [hashed, recovery] : hashed;
    }
    async function sign3(msgHash, privKey, opts = {}) {
      const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
      let sig;
      const drbg = new HmacDrbg();
      await drbg.reseed(seed);
      while (!(sig = kmdToSig(await drbg.generate(), m, d)))
        await drbg.reseed();
      return finalizeSig(sig, opts);
    }
    exports2.sign = sign3;
    function signSync(msgHash, privKey, opts = {}) {
      const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
      let sig;
      const drbg = new HmacDrbg();
      drbg.reseedSync(seed);
      while (!(sig = kmdToSig(drbg.generateSync(), m, d)))
        drbg.reseedSync();
      return finalizeSig(sig, opts);
    }
    exports2.signSync = signSync;
    var vopts = { strict: true };
    function verify2(signature, msgHash, publicKey, opts = vopts) {
      let sig;
      try {
        sig = normalizeSignature(signature);
        msgHash = ensureBytes(msgHash);
      } catch (error) {
        return false;
      }
      const { r, s } = sig;
      if (opts.strict && sig.hasHighS())
        return false;
      const h = truncateHash(msgHash);
      if (h === _0n)
        return false;
      let P;
      try {
        P = normalizePublicKey(publicKey);
      } catch (error) {
        return false;
      }
      const { n } = CURVE;
      const sinv = invert(s, n);
      const u1 = mod2(h * sinv, n);
      const u2 = mod2(r * sinv, n);
      const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
      if (!R)
        return false;
      const v = mod2(R.x, n);
      return v === r;
    }
    exports2.verify = verify2;
    async function taggedHash(tag, ...messages) {
      const tagB = new Uint8Array(tag.split("").map((c) => c.charCodeAt(0)));
      const tagH = await exports2.utils.sha256(tagB);
      const h = await exports2.utils.sha256(concatBytes(tagH, tagH, ...messages));
      return bytesToNumber(h);
    }
    async function createChallenge(x, P, message) {
      const rx = numTo32b(x);
      const t = await taggedHash("BIP0340/challenge", rx, P.toRawX(), message);
      return mod2(t, CURVE.n);
    }
    function hasEvenY(point) {
      return (point.y & _1n) === _0n;
    }
    var SchnorrSignature = class {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromHex(hex) {
        const bytes2 = ensureBytes(hex);
        if (bytes2.length !== 64)
          throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes2.length}`);
        const r = bytesToNumber(bytes2.subarray(0, 32));
        const s = bytesToNumber(bytes2.subarray(32, 64));
        return new SchnorrSignature(r, s);
      }
      assertValidity() {
        const { r, s } = this;
        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))
          throw new Error("Invalid signature");
      }
      toHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
      toRawBytes() {
        return hexToBytes(this.toHex());
      }
    };
    function schnorrGetPublicKey(privateKey) {
      return Point.fromPrivateKey(privateKey).toRawX();
    }
    async function schnorrSign(message, privateKey, auxRand = exports2.utils.randomBytes()) {
      if (message == null)
        throw new TypeError(`sign: Expected valid message, not "${message}"`);
      const { n } = CURVE;
      const m = ensureBytes(message);
      const d0 = normalizePrivateKey(privateKey);
      const rand = ensureBytes(auxRand);
      if (rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
      const P = Point.fromPrivateKey(d0);
      const d = hasEvenY(P) ? d0 : n - d0;
      const t0h = await taggedHash("BIP0340/aux", rand);
      const t = d ^ t0h;
      const k0h = await taggedHash("BIP0340/nonce", numTo32b(t), P.toRawX(), m);
      const k0 = mod2(k0h, n);
      if (k0 === _0n)
        throw new Error("sign: Creation of signature failed. k is zero");
      const R = Point.fromPrivateKey(k0);
      const k = hasEvenY(R) ? k0 : n - k0;
      const e = await createChallenge(R.x, P, m);
      const sig = new SchnorrSignature(R.x, mod2(k + e * d, n)).toRawBytes();
      const isValid = await schnorrVerify(sig, m, P.toRawX());
      if (!isValid)
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    async function schnorrVerify(signature, message, publicKey) {
      const raw = signature instanceof SchnorrSignature;
      let sig;
      try {
        sig = raw ? signature : SchnorrSignature.fromHex(signature);
        if (raw)
          sig.assertValidity();
      } catch (error) {
        return false;
      }
      const { r, s } = sig;
      const m = ensureBytes(message);
      let P;
      try {
        P = normalizePublicKey(publicKey);
      } catch (error) {
        return false;
      }
      const e = await createChallenge(r, P, m);
      const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod2(-e, CURVE.n));
      if (!R || !hasEvenY(R) || R.x !== r)
        return false;
      return true;
    }
    exports2.schnorr = {
      Signature: SchnorrSignature,
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify
    };
    Point.BASE._setWindowSize(8);
    var crypto6 = {
      node: crypto_1.default,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
    exports2.utils = {
      isValidPrivateKey(privateKey) {
        try {
          normalizePrivateKey(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      hashToPrivateKey: (hash2) => {
        hash2 = ensureBytes(hash2);
        if (hash2.length < 40 || hash2.length > 1024)
          throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
        const num = mod2(bytesToNumber(hash2), CURVE.n);
        if (num === _0n || num === _1n)
          throw new Error("Invalid private key");
        return numTo32b(num);
      },
      randomBytes: (bytesLength = 32) => {
        if (crypto6.web) {
          return crypto6.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto6.node) {
          const { randomBytes } = crypto6.node;
          return Uint8Array.from(randomBytes(bytesLength));
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      },
      randomPrivateKey: () => {
        return exports2.utils.hashToPrivateKey(exports2.utils.randomBytes(40));
      },
      bytesToHex,
      mod: mod2,
      sha256: async (message) => {
        if (crypto6.web) {
          const buffer3 = await crypto6.web.subtle.digest("SHA-256", message.buffer);
          return new Uint8Array(buffer3);
        } else if (crypto6.node) {
          const { createHash } = crypto6.node;
          return Uint8Array.from(createHash("sha256").update(message).digest());
        } else {
          throw new Error("The environment doesn't have sha256 function");
        }
      },
      hmacSha256: async (key, ...messages) => {
        if (crypto6.web) {
          const ckey = await crypto6.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
          const message = concatBytes(...messages);
          const buffer3 = await crypto6.web.subtle.sign("HMAC", ckey, message);
          return new Uint8Array(buffer3);
        } else if (crypto6.node) {
          const { createHmac } = crypto6.node;
          const hash2 = createHmac("sha256", key);
          messages.forEach((m) => hash2.update(m));
          return Uint8Array.from(hash2.digest());
        } else {
          throw new Error("The environment doesn't have hmac-sha256 function");
        }
      },
      sha256Sync: void 0,
      hmacSha256Sync: void 0,
      precompute(windowSize = 8, point = Point.BASE) {
        const cached = point === Point.BASE ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
      }
    };
  }
});

// node_modules/libp2p-crypto/src/keys/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/libp2p-crypto/src/keys/secp256k1.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errcode17 = require_err_code();
    var secp = require_lib4();
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    module2.exports = () => {
      const privateKeyLength = 32;
      function generateKey() {
        return secp.utils.randomPrivateKey();
      }
      async function hashAndSign(key, msg) {
        const { digest: digest3 } = await sha2563.digest(msg);
        try {
          return await secp.sign(digest3, key);
        } catch (err) {
          throw errcode17(err, "ERR_INVALID_INPUT");
        }
      }
      async function hashAndVerify(key, sig, msg) {
        try {
          const { digest: digest3 } = await sha2563.digest(msg);
          return secp.verify(sig, digest3, key);
        } catch (err) {
          throw errcode17(err, "ERR_INVALID_INPUT");
        }
      }
      function compressPublicKey(key) {
        const point = secp.Point.fromHex(key).toRawBytes(true);
        return point;
      }
      function decompressPublicKey(key) {
        const point = secp.Point.fromHex(key).toRawBytes(false);
        return point;
      }
      function validatePrivateKey(key) {
        try {
          secp.getPublicKey(key, true);
        } catch (err) {
          throw errcode17(err, "ERR_INVALID_PRIVATE_KEY");
        }
      }
      function validatePublicKey(key) {
        try {
          secp.Point.fromHex(key);
        } catch (err) {
          throw errcode17(err, "ERR_INVALID_PUBLIC_KEY");
        }
      }
      function computePublicKey(privateKey) {
        try {
          return secp.getPublicKey(privateKey, true);
        } catch (err) {
          throw errcode17(err, "ERR_INVALID_PRIVATE_KEY");
        }
      }
      return {
        generateKey,
        privateKeyLength,
        hashAndSign,
        hashAndVerify,
        compressPublicKey,
        decompressPublicKey,
        validatePrivateKey,
        validatePublicKey,
        computePublicKey
      };
    };
  }
});

// node_modules/libp2p-crypto/src/keys/secp256k1-class.js
var require_secp256k1_class = __commonJS({
  "node_modules/libp2p-crypto/src/keys/secp256k1-class.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    var errcode17 = require_err_code();
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var exporter3 = require_exporter();
    module2.exports = (keysProtobuf, randomBytes, crypto6) => {
      crypto6 = crypto6 || require_secp256k1()();
      class Secp256k1PublicKey {
        constructor(key) {
          crypto6.validatePublicKey(key);
          this._key = key;
        }
        verify(data, sig) {
          return crypto6.hashAndVerify(this._key, sig, data);
        }
        marshal() {
          return crypto6.compressPublicKey(this._key);
        }
        get bytes() {
          return keysProtobuf.PublicKey.encode({
            Type: keysProtobuf.KeyType.Secp256k1,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes: bytes2 } = await sha2563.digest(this.bytes);
          return bytes2;
        }
      }
      class Secp256k1PrivateKey {
        constructor(key, publicKey) {
          this._key = key;
          this._publicKey = publicKey || crypto6.computePublicKey(key);
          crypto6.validatePrivateKey(this._key);
          crypto6.validatePublicKey(this._publicKey);
        }
        sign(message) {
          return crypto6.hashAndSign(this._key, message);
        }
        get public() {
          return new Secp256k1PublicKey(this._publicKey);
        }
        marshal() {
          return this._key;
        }
        get bytes() {
          return keysProtobuf.PrivateKey.encode({
            Type: keysProtobuf.KeyType.Secp256k1,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes: bytes2 } = await sha2563.digest(this.bytes);
          return bytes2;
        }
        async id() {
          const hash2 = await this.public.hash();
          return uint8ArrayToString(hash2, "base58btc");
        }
        async export(password, format = "libp2p-key") {
          if (format === "libp2p-key") {
            return exporter3.export(this.bytes, password);
          } else {
            throw errcode17(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
          }
        }
      }
      function unmarshalSecp256k1PrivateKey(bytes2) {
        return new Secp256k1PrivateKey(bytes2);
      }
      function unmarshalSecp256k1PublicKey(bytes2) {
        return new Secp256k1PublicKey(bytes2);
      }
      async function generateKeyPair() {
        const privateKeyBytes = await crypto6.generateKey();
        return new Secp256k1PrivateKey(privateKeyBytes);
      }
      return {
        Secp256k1PublicKey,
        Secp256k1PrivateKey,
        unmarshalSecp256k1PrivateKey,
        unmarshalSecp256k1PublicKey,
        generateKeyPair
      };
    };
  }
});

// node_modules/libp2p-crypto/src/hmac/lengths.js
var require_lengths = __commonJS({
  "node_modules/libp2p-crypto/src/hmac/lengths.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      SHA1: 20,
      SHA256: 32,
      SHA512: 64
    };
  }
});

// node_modules/libp2p-crypto/src/hmac/index-browser.js
var require_index_browser = __commonJS({
  "node_modules/libp2p-crypto/src/hmac/index-browser.js"(exports2) {
    "use strict";
    init_globals();
    var webcrypto = require_webcrypto();
    var lengths = require_lengths();
    var hashTypes = {
      SHA1: "SHA-1",
      SHA256: "SHA-256",
      SHA512: "SHA-512"
    };
    var sign3 = async (key, data) => {
      const buf3 = await webcrypto.get().subtle.sign({ name: "HMAC" }, key, data);
      return new Uint8Array(buf3, buf3.byteOffset, buf3.byteLength);
    };
    exports2.create = async function(hashType, secret) {
      const hash2 = hashTypes[hashType];
      const key = await webcrypto.get().subtle.importKey("raw", secret, {
        name: "HMAC",
        hash: { name: hash2 }
      }, false, ["sign"]);
      return {
        async digest(data) {
          return sign3(key, data);
        },
        length: lengths[hashType]
      };
    };
  }
});

// node_modules/libp2p-crypto/src/keys/key-stretcher.js
var require_key_stretcher = __commonJS({
  "node_modules/libp2p-crypto/src/keys/key-stretcher.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errcode17 = require_err_code();
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var hmac = require_index_browser();
    var cipherMap = {
      "AES-128": {
        ivSize: 16,
        keySize: 16
      },
      "AES-256": {
        ivSize: 16,
        keySize: 32
      },
      Blowfish: {
        ivSize: 8,
        cipherKeySize: 32
      }
    };
    module2.exports = async (cipherType, hash2, secret) => {
      const cipher = cipherMap[cipherType];
      if (!cipher) {
        const allowed = Object.keys(cipherMap).join(" / ");
        throw errcode17(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), "ERR_INVALID_CIPHER_TYPE");
      }
      if (!hash2) {
        throw errcode17(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE");
      }
      const cipherKeySize = cipher.keySize;
      const ivSize = cipher.ivSize;
      const hmacKeySize = 20;
      const seed = uint8ArrayFromString("key expansion");
      const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
      const m = await hmac.create(hash2, secret);
      let a = await m.digest(seed);
      const result = [];
      let j = 0;
      while (j < resultLength) {
        const b = await m.digest(uint8ArrayConcat([a, seed]));
        let todo = b.length;
        if (j + todo > resultLength) {
          todo = resultLength - j;
        }
        result.push(b);
        j += todo;
        a = await m.digest(a);
      }
      const half = resultLength / 2;
      const resultBuffer = uint8ArrayConcat(result);
      const r1 = resultBuffer.slice(0, half);
      const r2 = resultBuffer.slice(half, resultLength);
      const createKey2 = (res) => ({
        iv: res.slice(0, ivSize),
        cipherKey: res.slice(ivSize, ivSize + cipherKeySize),
        macKey: res.slice(ivSize + cipherKeySize)
      });
      return {
        k1: createKey2(r1),
        k2: createKey2(r2)
      };
    };
  }
});

// node_modules/libp2p-crypto/src/keys/validate-curve-type.js
var require_validate_curve_type = __commonJS({
  "node_modules/libp2p-crypto/src/keys/validate-curve-type.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errcode17 = require_err_code();
    module2.exports = function(curveTypes, type) {
      if (!curveTypes.includes(type)) {
        const names = curveTypes.join(" / ");
        throw errcode17(new Error(`Unknown curve: ${type}. Must be ${names}`), "ERR_INVALID_CURVE");
      }
    };
  }
});

// node_modules/libp2p-crypto/src/keys/ecdh-browser.js
var require_ecdh_browser = __commonJS({
  "node_modules/libp2p-crypto/src/keys/ecdh-browser.js"(exports2) {
    "use strict";
    init_globals();
    var errcode17 = require_err_code();
    var webcrypto = require_webcrypto();
    var { base64urlToBuffer } = require_util2();
    var validateCurveType = require_validate_curve_type();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var bits = {
      "P-256": 256,
      "P-384": 384,
      "P-521": 521
    };
    exports2.generateEphmeralKeyPair = async function(curve) {
      validateCurveType(Object.keys(bits), curve);
      const pair = await webcrypto.get().subtle.generateKey({
        name: "ECDH",
        namedCurve: curve
      }, true, ["deriveBits"]);
      const genSharedKey = async (theirPub, forcePrivate) => {
        let privateKey;
        if (forcePrivate) {
          privateKey = await webcrypto.get().subtle.importKey("jwk", unmarshalPrivateKey(curve, forcePrivate), {
            name: "ECDH",
            namedCurve: curve
          }, false, ["deriveBits"]);
        } else {
          privateKey = pair.privateKey;
        }
        const keys2 = [
          await webcrypto.get().subtle.importKey("jwk", unmarshalPublicKey(curve, theirPub), {
            name: "ECDH",
            namedCurve: curve
          }, false, []),
          privateKey
        ];
        const buffer3 = await webcrypto.get().subtle.deriveBits({
          name: "ECDH",
          namedCurve: curve,
          public: keys2[0]
        }, keys2[1], bits[curve]);
        return new Uint8Array(buffer3, buffer3.byteOffset, buffer3.byteLength);
      };
      const publicKey = await webcrypto.get().subtle.exportKey("jwk", pair.publicKey);
      return {
        key: marshalPublicKey(publicKey),
        genSharedKey
      };
    };
    var curveLengths = {
      "P-256": 32,
      "P-384": 48,
      "P-521": 66
    };
    function marshalPublicKey(jwk) {
      const byteLen = curveLengths[jwk.crv];
      return uint8ArrayConcat([
        Uint8Array.from([4]),
        base64urlToBuffer(jwk.x, byteLen),
        base64urlToBuffer(jwk.y, byteLen)
      ], 1 + byteLen * 2);
    }
    function unmarshalPublicKey(curve, key) {
      const byteLen = curveLengths[curve];
      if (uint8ArrayEquals(!key.slice(0, 1), Uint8Array.from([4]))) {
        throw errcode17(new Error("Cannot unmarshal public key - invalid key format"), "ERR_INVALID_KEY_FORMAT");
      }
      return {
        kty: "EC",
        crv: curve,
        x: uint8ArrayToString(key.slice(1, byteLen + 1), "base64url"),
        y: uint8ArrayToString(key.slice(1 + byteLen), "base64url"),
        ext: true
      };
    }
    var unmarshalPrivateKey = (curve, key) => ({
      ...unmarshalPublicKey(curve, key.public),
      d: uint8ArrayToString(key.private, "base64url")
    });
  }
});

// node_modules/libp2p-crypto/src/keys/ephemeral-keys.js
var require_ephemeral_keys = __commonJS({
  "node_modules/libp2p-crypto/src/keys/ephemeral-keys.js"(exports2, module2) {
    "use strict";
    init_globals();
    var ecdh = require_ecdh_browser();
    module2.exports = async (curve) => ecdh.generateEphmeralKeyPair(curve);
  }
});

// node_modules/libp2p-crypto/src/keys/index.js
var require_keys2 = __commonJS({
  "node_modules/libp2p-crypto/src/keys/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var keysPBM = require_keys();
    require_asn1();
    require_pbe();
    var forge = require_forge();
    var errcode17 = require_err_code();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var importer2 = require_importer();
    var supportedKeys = {
      rsa: require_rsa_class(),
      ed25519: require_ed25519_class(),
      secp256k1: require_secp256k1_class()(keysPBM, require_random_bytes())
    };
    var ErrMissingSecp256K1 = {
      message: "secp256k1 support requires libp2p-crypto-secp256k1 package",
      code: "ERR_MISSING_PACKAGE"
    };
    function typeToKey(type) {
      const key = supportedKeys[type.toLowerCase()];
      if (!key) {
        const supported = Object.keys(supportedKeys).join(" / ");
        throw errcode17(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), "ERR_UNSUPPORTED_KEY_TYPE");
      }
      return key;
    }
    var generateKeyPair = async (type, bits) => {
      return typeToKey(type).generateKeyPair(bits);
    };
    var generateKeyPairFromSeed = async (type, seed, bits) => {
      const key = typeToKey(type);
      if (type.toLowerCase() !== "ed25519") {
        throw errcode17(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
      }
      return key.generateKeyPairFromSeed(seed, bits);
    };
    var unmarshalPublicKey = (buf3) => {
      const decoded = keysPBM.PublicKey.decode(buf3);
      const data = decoded.Data;
      switch (decoded.Type) {
        case keysPBM.KeyType.RSA:
          return supportedKeys.rsa.unmarshalRsaPublicKey(data);
        case keysPBM.KeyType.Ed25519:
          return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
        case keysPBM.KeyType.Secp256k1:
          if (supportedKeys.secp256k1) {
            return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
          } else {
            throw errcode17(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
          }
        default:
          typeToKey(decoded.Type);
      }
    };
    var marshalPublicKey = (key, type) => {
      type = (type || "rsa").toLowerCase();
      typeToKey(type);
      return key.bytes;
    };
    var unmarshalPrivateKey = async (buf3) => {
      const decoded = keysPBM.PrivateKey.decode(buf3);
      const data = decoded.Data;
      switch (decoded.Type) {
        case keysPBM.KeyType.RSA:
          return supportedKeys.rsa.unmarshalRsaPrivateKey(data);
        case keysPBM.KeyType.Ed25519:
          return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
        case keysPBM.KeyType.Secp256k1:
          if (supportedKeys.secp256k1) {
            return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
          } else {
            throw errcode17(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
          }
        default:
          typeToKey(decoded.Type);
      }
    };
    var marshalPrivateKey = (key, type) => {
      type = (type || "rsa").toLowerCase();
      typeToKey(type);
      return key.bytes;
    };
    var importKey = async (encryptedKey, password) => {
      try {
        const key2 = await importer2.import(encryptedKey, password);
        return unmarshalPrivateKey(key2);
      } catch (_) {
      }
      const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);
      if (key === null) {
        throw errcode17(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
      }
      let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));
      der = uint8ArrayFromString(der.getBytes(), "ascii");
      return supportedKeys.rsa.unmarshalRsaPrivateKey(der);
    };
    module2.exports = {
      supportedKeys,
      keysPBM,
      keyStretcher: require_key_stretcher(),
      generateEphemeralKeyPair: require_ephemeral_keys(),
      generateKeyPair,
      generateKeyPairFromSeed,
      unmarshalPublicKey,
      marshalPublicKey,
      unmarshalPrivateKey,
      marshalPrivateKey,
      import: importKey
    };
  }
});

// node_modules/class-is/index.js
var require_class_is = __commonJS({
  "node_modules/class-is/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    function withIs(Class, { className, symbolName }) {
      const symbol = Symbol.for(symbolName);
      const ClassIsWrapper = {
        [className]: class extends Class {
          constructor(...args) {
            super(...args);
            Object.defineProperty(this, symbol, { value: true });
          }
          get [Symbol.toStringTag]() {
            return className;
          }
        }
      }[className];
      ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);
      return ClassIsWrapper;
    }
    function withIsProto(Class, { className, symbolName, withoutNew }) {
      const symbol = Symbol.for(symbolName);
      const ClassIsWrapper = {
        [className]: function(...args) {
          if (withoutNew && !(this instanceof ClassIsWrapper)) {
            return new ClassIsWrapper(...args);
          }
          const _this = Class.call(this, ...args) || this;
          if (_this && !_this[symbol]) {
            Object.defineProperty(_this, symbol, { value: true });
          }
          return _this;
        }
      }[className];
      ClassIsWrapper.prototype = Object.create(Class.prototype);
      ClassIsWrapper.prototype.constructor = ClassIsWrapper;
      Object.defineProperty(ClassIsWrapper.prototype, Symbol.toStringTag, {
        get() {
          return className;
        }
      });
      ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);
      return ClassIsWrapper;
    }
    module2.exports = withIs;
    module2.exports.proto = withIsProto;
  }
});

// node_modules/peer-id/src/proto.js
var require_proto = __commonJS({
  "node_modules/peer-id/src/proto.js"(exports2, module2) {
    "use strict";
    init_globals();
    var $protobuf12 = require_minimal2();
    var $Reader11 = $protobuf12.Reader;
    var $Writer11 = $protobuf12.Writer;
    var $util11 = $protobuf12.util;
    var $root11 = $protobuf12.roots["libp2p-peer-id"] || ($protobuf12.roots["libp2p-peer-id"] = {});
    $root11.PeerIdProto = function() {
      function PeerIdProto(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      PeerIdProto.prototype.id = $util11.newBuffer([]);
      PeerIdProto.prototype.pubKey = $util11.newBuffer([]);
      PeerIdProto.prototype.privKey = $util11.newBuffer([]);
      PeerIdProto.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        w.uint32(10).bytes(m.id);
        if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
          w.uint32(18).bytes(m.pubKey);
        if (m.privKey != null && Object.hasOwnProperty.call(m, "privKey"))
          w.uint32(26).bytes(m.privKey);
        return w;
      };
      PeerIdProto.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.PeerIdProto();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.id = r.bytes();
              break;
            case 2:
              m.pubKey = r.bytes();
              break;
            case 3:
              m.privKey = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("id"))
          throw $util11.ProtocolError("missing required 'id'", { instance: m });
        return m;
      };
      PeerIdProto.fromObject = function fromObject(d) {
        if (d instanceof $root11.PeerIdProto)
          return d;
        var m = new $root11.PeerIdProto();
        if (d.id != null) {
          if (typeof d.id === "string")
            $util11.base64.decode(d.id, m.id = $util11.newBuffer($util11.base64.length(d.id)), 0);
          else if (d.id.length)
            m.id = d.id;
        }
        if (d.pubKey != null) {
          if (typeof d.pubKey === "string")
            $util11.base64.decode(d.pubKey, m.pubKey = $util11.newBuffer($util11.base64.length(d.pubKey)), 0);
          else if (d.pubKey.length)
            m.pubKey = d.pubKey;
        }
        if (d.privKey != null) {
          if (typeof d.privKey === "string")
            $util11.base64.decode(d.privKey, m.privKey = $util11.newBuffer($util11.base64.length(d.privKey)), 0);
          else if (d.privKey.length)
            m.privKey = d.privKey;
        }
        return m;
      };
      PeerIdProto.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.id = "";
          else {
            d.id = [];
            if (o.bytes !== Array)
              d.id = $util11.newBuffer(d.id);
          }
          if (o.bytes === String)
            d.pubKey = "";
          else {
            d.pubKey = [];
            if (o.bytes !== Array)
              d.pubKey = $util11.newBuffer(d.pubKey);
          }
          if (o.bytes === String)
            d.privKey = "";
          else {
            d.privKey = [];
            if (o.bytes !== Array)
              d.privKey = $util11.newBuffer(d.privKey);
          }
        }
        if (m.id != null && m.hasOwnProperty("id")) {
          d.id = o.bytes === String ? $util11.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;
        }
        if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
          d.pubKey = o.bytes === String ? $util11.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
        }
        if (m.privKey != null && m.hasOwnProperty("privKey")) {
          d.privKey = o.bytes === String ? $util11.base64.encode(m.privKey, 0, m.privKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.privKey) : m.privKey;
        }
        return d;
      };
      PeerIdProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      return PeerIdProto;
    }();
    module2.exports = $root11;
  }
});

// node_modules/peer-id/src/index.js
var require_src5 = __commonJS({
  "node_modules/peer-id/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { CID: CID3 } = (init_cid(), __toCommonJS(cid_exports));
    var b32 = (init_base32(), __toCommonJS(base32_exports));
    var b36 = (init_base36(), __toCommonJS(base36_exports));
    var b58 = (init_base58(), __toCommonJS(base58_exports));
    var b64 = (init_base64(), __toCommonJS(base64_exports));
    var { base58btc: base58btc3 } = (init_base58(), __toCommonJS(base58_exports));
    var { base32: base323 } = (init_base32(), __toCommonJS(base32_exports));
    var { base16: base163 } = (init_base16(), __toCommonJS(base16_exports));
    var Digest3 = (init_digest(), __toCommonJS(digest_exports));
    var cryptoKeys = require_keys2();
    var withIs = require_class_is();
    var { PeerIdProto } = require_proto();
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { identity: identity5 } = (init_identity(), __toCommonJS(identity_exports));
    var bases3 = {
      ...b32,
      ...b36,
      ...b58,
      ...b64
    };
    var baseDecoder = Object.keys(bases3).reduce((acc, curr) => acc.or(bases3[curr]), base323.decoder);
    var DAG_PB_CODE3 = 112;
    var LIBP2P_KEY_CODE = 114;
    var PeerId14 = class {
      constructor(id, privKey, pubKey) {
        if (!(id instanceof Uint8Array)) {
          throw new Error("invalid id provided");
        }
        if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {
          throw new Error("inconsistent arguments");
        }
        this._id = id;
        this._idB58String = base58btc3.encode(this.id).substring(1);
        this._privKey = privKey;
        this._pubKey = pubKey;
      }
      get id() {
        return this._id;
      }
      set id(val) {
        throw new Error("Id is immutable");
      }
      get privKey() {
        return this._privKey;
      }
      set privKey(privKey) {
        this._privKey = privKey;
      }
      get pubKey() {
        if (this._pubKey) {
          return this._pubKey;
        }
        if (this._privKey) {
          return this._privKey.public;
        }
        try {
          const decoded = Digest3.decode(this.id);
          if (decoded.code === identity5.code) {
            this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);
          }
        } catch (_) {
        }
        return this._pubKey;
      }
      set pubKey(pubKey) {
        this._pubKey = pubKey;
      }
      marshalPubKey() {
        if (this.pubKey) {
          return cryptoKeys.marshalPublicKey(this.pubKey);
        }
      }
      marshalPrivKey() {
        if (this.privKey) {
          return cryptoKeys.marshalPrivateKey(this.privKey);
        }
      }
      marshal(excludePriv) {
        return PeerIdProto.encode({
          id: this.toBytes(),
          pubKey: this.marshalPubKey(),
          privKey: excludePriv ? null : this.marshalPrivKey()
        }).finish();
      }
      toPrint() {
        let pid = this.toB58String();
        if (pid.startsWith("Qm")) {
          pid = pid.slice(2);
        }
        let maxRunes = 6;
        if (pid.length < maxRunes) {
          maxRunes = pid.length;
        }
        return "<peer.ID " + pid.substr(0, maxRunes) + ">";
      }
      toJSON() {
        return {
          id: this.toB58String(),
          privKey: toB64Opt(this.marshalPrivKey()),
          pubKey: toB64Opt(this.marshalPubKey())
        };
      }
      toHexString() {
        return base163.encode(this.id).substring(1);
      }
      toBytes() {
        return this.id;
      }
      toB58String() {
        return this._idB58String;
      }
      toString() {
        if (!this._idCIDString) {
          const cid = CID3.createV1(LIBP2P_KEY_CODE, Digest3.decode(this.id));
          Object.defineProperty(this, "_idCIDString", {
            value: cid.toString(),
            enumerable: false
          });
        }
        return this._idCIDString;
      }
      equals(id) {
        if (id instanceof Uint8Array) {
          return uint8ArrayEquals(this.id, id);
        } else if (id.id) {
          return uint8ArrayEquals(this.id, id.id);
        } else {
          throw new Error("not valid Id");
        }
      }
      isEqual(id) {
        return this.equals(id);
      }
      isValid() {
        return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes));
      }
      hasInlinePublicKey() {
        try {
          const decoded = Digest3.decode(this.id);
          if (decoded.code === identity5.code) {
            return true;
          }
        } catch (_) {
        }
        return false;
      }
    };
    var PeerIdWithIs = withIs(PeerId14, {
      className: "PeerId",
      symbolName: "@libp2p/js-peer-id/PeerId"
    });
    exports2 = module2.exports = PeerIdWithIs;
    var computeDigest = (pubKey) => {
      if (pubKey.bytes.length <= 42) {
        return Digest3.create(identity5.code, pubKey.bytes).bytes;
      } else {
        return pubKey.hash();
      }
    };
    var computePeerId = async (privKey, pubKey) => {
      const digest3 = await computeDigest(pubKey);
      return new PeerIdWithIs(digest3, privKey, pubKey);
    };
    exports2.create = async (opts) => {
      opts = opts || {};
      opts.bits = opts.bits || 2048;
      opts.keyType = opts.keyType || "RSA";
      const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits);
      return computePeerId(key, key.public);
    };
    exports2.createFromHexString = (str) => {
      return new PeerIdWithIs(base163.decode("f" + str));
    };
    exports2.createFromBytes = (buf3) => {
      try {
        const cid = CID3.decode(buf3);
        if (!validMulticodec(cid)) {
          throw new Error("Supplied PeerID CID is invalid");
        }
        return exports2.createFromCID(cid);
      } catch {
        const digest3 = Digest3.decode(buf3);
        if (digest3.code !== identity5.code) {
          throw new Error("Supplied PeerID CID is invalid");
        }
        return new PeerIdWithIs(buf3);
      }
    };
    exports2.createFromB58String = (str) => {
      return exports2.createFromBytes(base58btc3.decode("z" + str));
    };
    var validMulticodec = (cid) => {
      return cid.code === LIBP2P_KEY_CODE || cid.code === DAG_PB_CODE3;
    };
    exports2.createFromCID = (cid) => {
      cid = CID3.asCID(cid);
      if (!cid || !validMulticodec(cid)) {
        throw new Error("Supplied PeerID CID is invalid");
      }
      return new PeerIdWithIs(cid.multihash.bytes);
    };
    exports2.createFromPubKey = async (key) => {
      let buf3 = key;
      if (typeof buf3 === "string") {
        buf3 = uint8ArrayFromString(key, "base64pad");
      }
      if (!(buf3 instanceof Uint8Array)) {
        throw new Error("Supplied key is neither a base64 string nor a Uint8Array");
      }
      const pubKey = await cryptoKeys.unmarshalPublicKey(buf3);
      return computePeerId(void 0, pubKey);
    };
    exports2.createFromPrivKey = async (key) => {
      if (typeof key === "string") {
        key = uint8ArrayFromString(key, "base64pad");
      }
      if (!(key instanceof Uint8Array)) {
        throw new Error("Supplied key is neither a base64 string nor a Uint8Array");
      }
      const privKey = await cryptoKeys.unmarshalPrivateKey(key);
      return computePeerId(privKey, privKey.public);
    };
    exports2.createFromJSON = async (obj) => {
      const id = base58btc3.decode("z" + obj.id);
      const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, "base64pad");
      const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, "base64pad");
      const pub = rawPubKey && await cryptoKeys.unmarshalPublicKey(rawPubKey);
      if (!rawPrivKey) {
        return new PeerIdWithIs(id, void 0, pub);
      }
      const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey);
      const privDigest = await computeDigest(privKey.public);
      let pubDigest;
      if (pub) {
        pubDigest = await computeDigest(pub);
      }
      if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {
        throw new Error("Public and private key do not match");
      }
      if (id && !uint8ArrayEquals(privDigest, id)) {
        throw new Error("Id and private key do not match");
      }
      return new PeerIdWithIs(id, privKey, pub);
    };
    exports2.createFromProtobuf = async (buf3) => {
      if (typeof buf3 === "string") {
        buf3 = uint8ArrayFromString(buf3, "base16");
      }
      let { id, privKey, pubKey } = PeerIdProto.decode(buf3);
      privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false;
      pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false;
      let pubDigest;
      let privDigest;
      if (privKey) {
        privDigest = await computeDigest(privKey.public);
      }
      if (pubKey) {
        pubDigest = await computeDigest(pubKey);
      }
      if (privKey) {
        if (pubKey) {
          if (!uint8ArrayEquals(privDigest, pubDigest)) {
            throw new Error("Public and private key do not match");
          }
        }
        return new PeerIdWithIs(privDigest, privKey, privKey.public);
      }
      if (pubKey) {
        return new PeerIdWithIs(pubDigest, void 0, pubKey);
      }
      if (id) {
        return new PeerIdWithIs(id);
      }
      throw new Error("Protobuf did not contain any usable key material");
    };
    exports2.parse = (str) => {
      if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
        str = `z${str}`;
      }
      return exports2.createFromBytes(baseDecoder.decode(str));
    };
    exports2.isPeerId = (peerId) => {
      return Boolean(typeof peerId === "object" && peerId._id && peerId._idB58String);
    };
    function toB64Opt(val) {
      if (val) {
        return uint8ArrayToString(val, "base64pad");
      }
    }
  }
});

// node_modules/it-last/index.js
var require_it_last = __commonJS({
  "node_modules/it-last/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var last15 = async (source) => {
      let res;
      for await (const entry of source) {
        res = entry;
      }
      return res;
    };
    module2.exports = last15;
  }
});

// node_modules/datastore-core/esm/src/errors.js
var errors_exports = {};
__export(errors_exports, {
  abortedError: () => abortedError,
  dbDeleteFailedError: () => dbDeleteFailedError,
  dbOpenFailedError: () => dbOpenFailedError,
  dbWriteFailedError: () => dbWriteFailedError,
  notFoundError: () => notFoundError
});
function dbOpenFailedError(err) {
  err = err || new Error("Cannot open database");
  return (0, import_err_code6.default)(err, "ERR_DB_OPEN_FAILED");
}
function dbDeleteFailedError(err) {
  err = err || new Error("Delete failed");
  return (0, import_err_code6.default)(err, "ERR_DB_DELETE_FAILED");
}
function dbWriteFailedError(err) {
  err = err || new Error("Write failed");
  return (0, import_err_code6.default)(err, "ERR_DB_WRITE_FAILED");
}
function notFoundError(err) {
  err = err || new Error("Not Found");
  return (0, import_err_code6.default)(err, "ERR_NOT_FOUND");
}
function abortedError(err) {
  err = err || new Error("Aborted");
  return (0, import_err_code6.default)(err, "ERR_ABORTED");
}
var import_err_code6;
var init_errors = __esm({
  "node_modules/datastore-core/esm/src/errors.js"() {
    init_globals();
    import_err_code6 = __toESM(require_err_code(), 1);
  }
});

// node_modules/timestamp-nano/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/timestamp-nano/timestamp.js"(exports2, module2) {
    init_globals();
    var Timestamp = function() {
      if (typeof module2 !== "undefined")
        module2.exports = Timestamp2;
      var SEC_DAY = 24 * 3600;
      var YEAR_SLOT = 3200;
      var DAY_SLOT = (365 * 400 + 97) * YEAR_SLOT / 400;
      var SEC_SLOT = SEC_DAY * DAY_SLOT;
      var MSEC_SLOT = SEC_SLOT * 1e3;
      var MAX_MSEC = 1e3 * 1e4 * 1e4 * SEC_DAY;
      var BIT24 = 16777216;
      var BIT32 = 65536 * 65536;
      var DEC6 = 1e3 * 1e3;
      var DEC9 = 1e3 * 1e3 * 1e3;
      var ZERO9 = "000000000";
      var trunc = Math.trunc || Math_trunc;
      var P = Timestamp2.prototype;
      Timestamp2.fromDate = fromDate;
      Timestamp2.fromInt64BE = buildFromInt64(0, 1, 2, 3, 0, 4);
      Timestamp2.fromInt64LE = buildFromInt64(3, 2, 1, 0, 4, 0);
      Timestamp2.fromString = fromString7;
      Timestamp2.fromTimeT = fromTimeT;
      P.year = 0;
      P.time = 0;
      P.nano = 0;
      P.addNano = addNano;
      P.getNano = getNano;
      P.getTimeT = getTimeT;
      P.getYear = getYear;
      P.toDate = toDate;
      P.toJSON = toJSON;
      P.toString = toString6;
      P.writeInt64BE = buildWriteInt64(0, 1, 2, 3, 0, 4);
      P.writeInt64LE = buildWriteInt64(3, 2, 1, 0, 4, 0);
      var FMT_JSON = "%Y-%m-%dT%H:%M:%S.%NZ";
      var FMT_MONTH = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      var FMT_DAY = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      var FMT_STRING = {
        "%": "%",
        F: "%Y-%m-%d",
        n: "\n",
        R: "%H:%M",
        T: "%H:%M:%S",
        t: "	",
        X: "%T",
        Z: "GMT",
        z: "+0000"
      };
      return Timestamp2;
      function Timestamp2(time, nano, year) {
        var ts = this;
        if (!(ts instanceof Timestamp2))
          return new Timestamp2(time, nano, year);
        ts.time = +time || 0;
        ts.nano = +nano || 0;
        ts.year = +year || 0;
        normalize(ts);
      }
      function getYear() {
        var year = this.toDate().getUTCFullYear();
        return year + this.year;
      }
      function normalize(ts) {
        var year = ts.year;
        var time = ts.time;
        var nano = ts.nano;
        var changed;
        var slot;
        if (nano < 0 || DEC6 <= nano) {
          var n = Math.floor(nano / DEC6);
          nano -= n * DEC6;
          time += n;
          changed = 1;
        }
        var y = year % YEAR_SLOT;
        if (time < -MAX_MSEC || MAX_MSEC < time || y) {
          slot = trunc(time / MSEC_SLOT);
          if (slot) {
            year += slot * YEAR_SLOT;
            time -= slot * MSEC_SLOT;
          }
          var dt = newDate(time);
          dt.setUTCFullYear(y + dt.getUTCFullYear());
          year -= y;
          time = +dt;
          slot = trunc(year / YEAR_SLOT);
          var total = time + slot * MSEC_SLOT;
          if (slot && -MAX_MSEC <= total && total <= MAX_MSEC) {
            year -= slot * YEAR_SLOT;
            time = total;
          }
          changed = 1;
        }
        if (changed) {
          ts.year = year;
          ts.time = time;
          ts.nano = nano;
        }
        return ts;
      }
      function toDate() {
        var ts = normalize(this);
        return newDate(ts.time);
      }
      function newDate(time) {
        var dt = new Date(0);
        dt.setTime(time);
        return dt;
      }
      function addNano(nano) {
        this.nano += +nano || 0;
        return this;
      }
      function getNano() {
        var ts = normalize(this);
        return (ts.time % 1e3 * DEC6 + +ts.nano + DEC9) % DEC9;
      }
      function fromString7(string3) {
        var time;
        var ts = new Timestamp2();
        string3 += "";
        var array = string3.replace(/^\s*[+\-]?\d+/, function(match) {
          var year = +match;
          var y = 1970 + (year - 1970) % 400;
          ts.year = year - y;
          return y;
        }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(match, hour2, min) {
          if (hour2 < 0)
            min *= -1;
          time = (+hour2 * 60 + +min) * 6e4;
          return "";
        }).replace(/\.\d+$/, function(match) {
          ts.nano = +(match + ZERO9).substr(1, 9);
          return "";
        }).split(/\D+/);
        if (array.length > 1) {
          array[1]--;
        } else {
          array[1] = 0;
        }
        ts.time = time = Date.UTC.apply(Date, array) - (time || 0);
        if (isNaN(time)) {
          throw new TypeError("Invalid Date");
        }
        return normalize(ts);
      }
      function fromDate(date) {
        return new Timestamp2(+date);
      }
      function fromTimeT(time) {
        return fromTime(time, 0);
      }
      function fromTime(low, high) {
        high |= 0;
        high *= BIT32;
        low = +low || 0;
        var slot = trunc(high / SEC_SLOT) + trunc(low / SEC_SLOT);
        var second = high % SEC_SLOT + low % SEC_SLOT;
        var offset = trunc(second / SEC_SLOT);
        if (offset) {
          slot += offset;
          second -= offset * SEC_SLOT;
        }
        return new Timestamp2(second * 1e3, 0, slot * YEAR_SLOT);
      }
      function getTimeT() {
        var ts = normalize(this);
        var time = Math.floor(ts.time / 1e3);
        var year = ts.year;
        if (year)
          time += year * DAY_SLOT * SEC_DAY / YEAR_SLOT;
        return time;
      }
      function toJSON() {
        return this.toString().replace(/0{1,6}Z$/, "Z");
      }
      function toString6(format) {
        var ts = this;
        var dt = ts.toDate();
        var map12 = {
          H,
          L,
          M,
          N,
          S,
          Y,
          a,
          b,
          d,
          e,
          m
        };
        return strftime(format || FMT_JSON);
        function strftime(format2) {
          return format2.replace(/%./g, function(match) {
            var m2 = match[1];
            var c = FMT_STRING[m2];
            var f = map12[m2];
            return c ? strftime(c) : f ? f() : match;
          });
        }
        function Y() {
          var year = ts.getYear();
          if (year > 999999) {
            return "+" + year;
          } else if (year > 9999) {
            return "+" + pad(year, 6);
          } else if (year >= 0) {
            return pad(year, 4);
          } else if (year >= -999999) {
            return "-" + pad(-year, 6);
          } else {
            return year;
          }
        }
        function m() {
          return pad2(dt.getUTCMonth() + 1);
        }
        function d() {
          return pad2(dt.getUTCDate());
        }
        function e() {
          return padS(dt.getUTCDate());
        }
        function H() {
          return pad2(dt.getUTCHours());
        }
        function M() {
          return pad2(dt.getUTCMinutes());
        }
        function S() {
          return pad2(dt.getUTCSeconds());
        }
        function L() {
          return pad(dt.getUTCMilliseconds(), 3);
        }
        function N() {
          return pad(ts.getNano(), 9);
        }
        function a() {
          return FMT_DAY[dt.getUTCDay()];
        }
        function b() {
          return FMT_MONTH[dt.getUTCMonth()];
        }
      }
      function buildWriteInt64(pos0, pos1, pos2, pos3, posH, posL) {
        return writeInt64;
        function writeInt64(buffer3, offset) {
          var ts = normalize(this);
          if (!buffer3)
            buffer3 = new Array(8);
          checkRange(buffer3, offset |= 0);
          var second = Math.floor(ts.time / 1e3);
          var day = ts.year * (DAY_SLOT * SEC_DAY / YEAR_SLOT);
          var high = trunc(day / BIT32) + trunc(second / BIT32);
          var low = day % BIT32 + second % BIT32;
          var slot = Math.floor(low / BIT32);
          if (slot) {
            high += slot;
            low -= slot * BIT32;
          }
          writeUint32(buffer3, offset + posH, high);
          writeUint32(buffer3, offset + posL, low);
          return buffer3;
        }
        function writeUint32(buffer3, offset, value) {
          buffer3[offset + pos0] = value >> 24 & 255;
          buffer3[offset + pos1] = value >> 16 & 255;
          buffer3[offset + pos2] = value >> 8 & 255;
          buffer3[offset + pos3] = value & 255;
        }
      }
      function buildFromInt64(pos0, pos1, pos2, pos3, posH, posL) {
        return fromInt64;
        function fromInt64(buffer3, offset) {
          checkRange(buffer3, offset |= 0);
          var high = readUint323(buffer3, offset + posH);
          var low = readUint323(buffer3, offset + posL);
          return fromTime(low, high);
        }
        function readUint323(buffer3, offset) {
          return buffer3[offset + pos0] * BIT24 + (buffer3[offset + pos1] << 16 | buffer3[offset + pos2] << 8 | buffer3[offset + pos3]);
        }
      }
      function checkRange(buffer3, offset) {
        var last15 = buffer3 && buffer3.length;
        if (last15 == null)
          throw new TypeError("Invalid Buffer");
        if (last15 < offset + 8)
          throw new RangeError("Out of range");
      }
      function Math_trunc(x) {
        var n = x - x % 1;
        return n === 0 && (x < 0 || x === 0 && 1 / x !== 1 / 0) ? -0 : n;
      }
      function padS(v) {
        return (v > 9 ? "" : " ") + (v | 0);
      }
      function pad2(v) {
        return (v > 9 ? "" : "0") + (v | 0);
      }
      function pad(v, len) {
        return (ZERO9 + (v | 0)).substr(-len);
      }
    }();
  }
});

// node_modules/libp2p-crypto/src/aes/ciphers-browser.js
var require_ciphers_browser = __commonJS({
  "node_modules/libp2p-crypto/src/aes/ciphers-browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    require_aes();
    var forge = require_forge();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    module2.exports = {
      createCipheriv: (mode, key, iv) => {
        const cipher2 = forge.cipher.createCipher("AES-CTR", uint8ArrayToString(key, "ascii"));
        cipher2.start({ iv: uint8ArrayToString(iv, "ascii") });
        return {
          update: (data) => {
            cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, "ascii")));
            return uint8ArrayFromString(cipher2.output.getBytes(), "ascii");
          }
        };
      },
      createDecipheriv: (mode, key, iv) => {
        const cipher2 = forge.cipher.createDecipher("AES-CTR", uint8ArrayToString(key, "ascii"));
        cipher2.start({ iv: uint8ArrayToString(iv, "ascii") });
        return {
          update: (data) => {
            cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, "ascii")));
            return uint8ArrayFromString(cipher2.output.getBytes(), "ascii");
          }
        };
      }
    };
  }
});

// node_modules/libp2p-crypto/src/aes/cipher-mode.js
var require_cipher_mode = __commonJS({
  "node_modules/libp2p-crypto/src/aes/cipher-mode.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errcode17 = require_err_code();
    var CIPHER_MODES = {
      16: "aes-128-ctr",
      32: "aes-256-ctr"
    };
    module2.exports = function(key) {
      const mode = CIPHER_MODES[key.length];
      if (!mode) {
        const modes = Object.entries(CIPHER_MODES).map(([k, v]) => `${k} (${v})`).join(" / ");
        throw errcode17(new Error(`Invalid key length ${key.length} bytes. Must be ${modes}`), "ERR_INVALID_KEY_LENGTH");
      }
      return mode;
    };
  }
});

// node_modules/libp2p-crypto/src/aes/index.js
var require_aes2 = __commonJS({
  "node_modules/libp2p-crypto/src/aes/index.js"(exports2) {
    "use strict";
    init_globals();
    var ciphers = require_ciphers_browser();
    var cipherMode = require_cipher_mode();
    exports2.create = async function(key, iv) {
      const mode = cipherMode(key);
      const cipher = ciphers.createCipheriv(mode, key, iv);
      const decipher = ciphers.createDecipheriv(mode, key, iv);
      const res = {
        async encrypt(data) {
          return cipher.update(data);
        },
        async decrypt(data) {
          return decipher.update(data);
        }
      };
      return res;
    };
  }
});

// node_modules/libp2p-crypto/src/pbkdf2.js
var require_pbkdf22 = __commonJS({
  "node_modules/libp2p-crypto/src/pbkdf2.js"(exports2, module2) {
    "use strict";
    init_globals();
    var forgePbkdf2 = require_pbkdf2();
    var forgeUtil = require_util();
    var errcode17 = require_err_code();
    var hashName = {
      sha1: "sha1",
      "sha2-256": "sha256",
      "sha2-512": "sha512"
    };
    function pbkdf2(password, salt, iterations, keySize, hash2) {
      const hasher = hashName[hash2];
      if (!hasher) {
        const types3 = Object.keys(hashName).join(" / ");
        throw errcode17(new Error(`Hash '${hash2}' is unknown or not supported. Must be ${types3}`), "ERR_UNSUPPORTED_HASH_TYPE");
      }
      const dek = forgePbkdf2(password, salt, iterations, keySize, hasher);
      return forgeUtil.encode64(dek);
    }
    module2.exports = pbkdf2;
  }
});

// node_modules/libp2p-crypto/src/index.js
var require_src6 = __commonJS({
  "node_modules/libp2p-crypto/src/index.js"(exports2) {
    "use strict";
    init_globals();
    var hmac = require_index_browser();
    var aes = require_aes2();
    var keys2 = require_keys2();
    exports2.aes = aes;
    exports2.hmac = hmac;
    exports2.keys = keys2;
    exports2.randomBytes = require_random_bytes();
    exports2.pbkdf2 = require_pbkdf22();
  }
});

// node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/long/src/long.js"(exports2, module2) {
    init_globals();
    module2.exports = Long2;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long2(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long2.prototype.__isLong__;
    Object.defineProperty(Long2.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long2.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache2;
      if (unsigned) {
        value >>>= 0;
        if (cache2 = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache2)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache2 = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache2)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long2.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long2.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long2(lowBits, highBits, unsigned);
    }
    Long2.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString7(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString7(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long2.fromString = fromString7;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString7(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long2.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long2.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long2.UZERO = UZERO;
    var ONE = fromInt(1);
    Long2.ONE = ONE;
    var UONE = fromInt(1, true);
    Long2.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long2.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long2.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long2.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long2.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString6(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals6(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(other);
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(other) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(other) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare4(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log210 = Math.ceil(Math.log(approx) / Math.LN2), delta = log210 <= 48 ? 1 : pow_dbl(2, log210 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or3(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor2(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes2(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long2.fromBytes = function fromBytes2(bytes2, unsigned, le) {
      return le ? Long2.fromBytesLE(bytes2, unsigned) : Long2.fromBytesBE(bytes2, unsigned);
    };
    Long2.fromBytesLE = function fromBytesLE(bytes2, unsigned) {
      return new Long2(bytes2[0] | bytes2[1] << 8 | bytes2[2] << 16 | bytes2[3] << 24, bytes2[4] | bytes2[5] << 8 | bytes2[6] << 16 | bytes2[7] << 24, unsigned);
    };
    Long2.fromBytesBE = function fromBytesBE(bytes2, unsigned) {
      return new Long2(bytes2[4] << 24 | bytes2[5] << 16 | bytes2[6] << 8 | bytes2[7], bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3], unsigned);
    };
  }
});

// node_modules/it-all/index.js
var require_it_all = __commonJS({
  "node_modules/it-all/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var all6 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module2.exports = all6;
  }
});

// node_modules/datastore-core/esm/src/utils.js
var import_it_all, sortAll;
var init_utils = __esm({
  "node_modules/datastore-core/esm/src/utils.js"() {
    init_globals();
    import_it_all = __toESM(require_it_all(), 1);
    sortAll = (iterable, sorter) => {
      return async function* () {
        const values2 = await (0, import_it_all.default)(iterable);
        yield* values2.sort(sorter);
      }();
    };
  }
});

// node_modules/it-drain/index.js
var require_it_drain = __commonJS({
  "node_modules/it-drain/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var drain9 = async (source) => {
      for await (const _ of source) {
      }
    };
    module2.exports = drain9;
  }
});

// node_modules/it-filter/index.js
var require_it_filter = __commonJS({
  "node_modules/it-filter/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var filter10 = async function* (source, fn) {
      for await (const entry of source) {
        if (await fn(entry)) {
          yield entry;
        }
      }
    };
    module2.exports = filter10;
  }
});

// node_modules/it-take/index.js
var require_it_take = __commonJS({
  "node_modules/it-take/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var take5 = async function* (source, limit) {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    };
    module2.exports = take5;
  }
});

// node_modules/datastore-core/esm/src/base.js
var import_it_drain, import_it_filter, import_it_take, BaseDatastore;
var init_base3 = __esm({
  "node_modules/datastore-core/esm/src/base.js"() {
    init_globals();
    init_utils();
    import_it_drain = __toESM(require_it_drain(), 1);
    import_it_filter = __toESM(require_it_filter(), 1);
    import_it_take = __toESM(require_it_take(), 1);
    BaseDatastore = class {
      open() {
        return Promise.reject(new Error(".open is not implemented"));
      }
      close() {
        return Promise.reject(new Error(".close is not implemented"));
      }
      put(key, val, options) {
        return Promise.reject(new Error(".put is not implemented"));
      }
      get(key, options) {
        return Promise.reject(new Error(".get is not implemented"));
      }
      has(key, options) {
        return Promise.reject(new Error(".has is not implemented"));
      }
      delete(key, options) {
        return Promise.reject(new Error(".delete is not implemented"));
      }
      async *putMany(source, options = {}) {
        for await (const { key, value } of source) {
          await this.put(key, value, options);
          yield {
            key,
            value
          };
        }
      }
      async *getMany(source, options = {}) {
        for await (const key of source) {
          yield this.get(key, options);
        }
      }
      async *deleteMany(source, options = {}) {
        for await (const key of source) {
          await this.delete(key, options);
          yield key;
        }
      }
      batch() {
        let puts = [];
        let dels = [];
        return {
          put(key, value) {
            puts.push({
              key,
              value
            });
          },
          delete(key) {
            dels.push(key);
          },
          commit: async (options) => {
            await (0, import_it_drain.default)(this.putMany(puts, options));
            puts = [];
            await (0, import_it_drain.default)(this.deleteMany(dels, options));
            dels = [];
          }
        };
      }
      async *_all(q, options) {
        throw new Error("._all is not implemented");
      }
      async *_allKeys(q, options) {
        throw new Error("._allKeys is not implemented");
      }
      query(q, options) {
        let it = this._all(q, options);
        if (q.prefix != null) {
          it = (0, import_it_filter.default)(it, (e) => e.key.toString().startsWith(q.prefix));
        }
        if (Array.isArray(q.filters)) {
          it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
        }
        if (Array.isArray(q.orders)) {
          it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
        }
        if (q.offset != null) {
          let i = 0;
          it = (0, import_it_filter.default)(it, () => i++ >= q.offset);
        }
        if (q.limit != null) {
          it = (0, import_it_take.default)(it, q.limit);
        }
        return it;
      }
      queryKeys(q, options) {
        let it = this._allKeys(q, options);
        if (q.prefix != null) {
          it = (0, import_it_filter.default)(it, (key) => key.toString().startsWith(q.prefix));
        }
        if (Array.isArray(q.filters)) {
          it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
        }
        if (Array.isArray(q.orders)) {
          it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
        }
        if (q.offset != null) {
          let i = 0;
          it = (0, import_it_filter.default)(it, () => i++ >= q.offset);
        }
        if (q.limit != null) {
          it = (0, import_it_take.default)(it, q.limit);
        }
        return it;
      }
    };
  }
});

// node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS({
  "node_modules/fast-fifo/fixed-size.js"(exports2, module2) {
    init_globals();
    module2.exports = class FixedFIFO {
      constructor(hwm) {
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
          throw new Error("Max size for a FixedFIFO should be a power of two");
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
      }
      push(data) {
        if (this.buffer[this.top] !== void 0)
          return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
      }
      shift() {
        const last15 = this.buffer[this.btm];
        if (last15 === void 0)
          return void 0;
        this.buffer[this.btm] = void 0;
        this.btm = this.btm + 1 & this.mask;
        return last15;
      }
      peek() {
        return this.buffer[this.btm];
      }
      isEmpty() {
        return this.buffer[this.btm] === void 0;
      }
    };
  }
});

// node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS({
  "node_modules/fast-fifo/index.js"(exports2, module2) {
    init_globals();
    var FixedFIFO = require_fixed_size();
    module2.exports = class FastFIFO {
      constructor(hwm) {
        this.hwm = hwm || 16;
        this.head = new FixedFIFO(this.hwm);
        this.tail = this.head;
      }
      push(val) {
        if (!this.head.push(val)) {
          const prev = this.head;
          this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
          this.head.push(val);
        }
      }
      shift() {
        const val = this.tail.shift();
        if (val === void 0 && this.tail.next) {
          const next = this.tail.next;
          this.tail.next = null;
          this.tail = next;
          return this.tail.shift();
        }
        return val;
      }
      peek() {
        return this.tail.peek();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
    };
  }
});

// node_modules/it-pushable/index.js
var require_it_pushable = __commonJS({
  "node_modules/it-pushable/index.js"(exports2, module2) {
    init_globals();
    var FIFO = require_fast_fifo();
    module2.exports = (options) => {
      options = options || {};
      let onEnd;
      if (typeof options === "function") {
        onEnd = options;
        options = {};
      } else {
        onEnd = options.onEnd;
      }
      let buffer3 = new FIFO();
      let pushable5, onNext, ended;
      const waitNext = () => {
        if (!buffer3.isEmpty()) {
          if (options.writev) {
            let next2;
            const values2 = [];
            while (!buffer3.isEmpty()) {
              next2 = buffer3.shift();
              if (next2.error)
                throw next2.error;
              values2.push(next2.value);
            }
            return { done: next2.done, value: values2 };
          }
          const next = buffer3.shift();
          if (next.error)
            throw next.error;
          return next;
        }
        if (ended)
          return { done: true };
        return new Promise((resolve11, reject) => {
          onNext = (next) => {
            onNext = null;
            if (next.error) {
              reject(next.error);
            } else {
              if (options.writev && !next.done) {
                resolve11({ done: next.done, value: [next.value] });
              } else {
                resolve11(next);
              }
            }
            return pushable5;
          };
        });
      };
      const bufferNext = (next) => {
        if (onNext)
          return onNext(next);
        buffer3.push(next);
        return pushable5;
      };
      const bufferError = (err) => {
        buffer3 = new FIFO();
        if (onNext)
          return onNext({ error: err });
        buffer3.push({ error: err });
        return pushable5;
      };
      const push = (value) => {
        if (ended)
          return pushable5;
        return bufferNext({ done: false, value });
      };
      const end = (err) => {
        if (ended)
          return pushable5;
        ended = true;
        return err ? bufferError(err) : bufferNext({ done: true });
      };
      const _return = () => {
        buffer3 = new FIFO();
        end();
        return { done: true };
      };
      const _throw = (err) => {
        end(err);
        return { done: true };
      };
      pushable5 = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next: waitNext,
        return: _return,
        throw: _throw,
        push,
        end
      };
      if (!onEnd)
        return pushable5;
      const _pushable = pushable5;
      pushable5 = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next() {
          return _pushable.next();
        },
        throw(err) {
          _pushable.throw(err);
          if (onEnd) {
            onEnd(err);
            onEnd = null;
          }
          return { done: true };
        },
        return() {
          _pushable.return();
          if (onEnd) {
            onEnd();
            onEnd = null;
          }
          return { done: true };
        },
        push,
        end(err) {
          _pushable.end(err);
          if (onEnd) {
            onEnd(err);
            onEnd = null;
          }
          return pushable5;
        }
      };
      return pushable5;
    };
  }
});

// node_modules/datastore-core/esm/src/tiered.js
var import_debug6, import_it_pushable, import_it_drain2, log6, TieredDatastore;
var init_tiered = __esm({
  "node_modules/datastore-core/esm/src/tiered.js"() {
    init_globals();
    init_base3();
    init_errors();
    import_debug6 = __toESM(require_browser2(), 1);
    import_it_pushable = __toESM(require_it_pushable(), 1);
    import_it_drain2 = __toESM(require_it_drain(), 1);
    log6 = (0, import_debug6.default)("datastore:core:tiered");
    TieredDatastore = class extends BaseDatastore {
      constructor(stores) {
        super();
        this.stores = stores.slice();
      }
      async open() {
        try {
          await Promise.all(this.stores.map((store) => store.open()));
        } catch (err) {
          throw dbOpenFailedError();
        }
      }
      async put(key, value) {
        try {
          await Promise.all(this.stores.map((store) => store.put(key, value)));
        } catch (err) {
          throw dbWriteFailedError();
        }
      }
      async get(key, options) {
        for (const store of this.stores) {
          try {
            const res = await store.get(key, options);
            if (res)
              return res;
          } catch (err) {
            log6(err);
          }
        }
        throw notFoundError();
      }
      async has(key, options) {
        for (const s of this.stores) {
          if (await s.has(key, options)) {
            return true;
          }
        }
        return false;
      }
      async delete(key, options) {
        try {
          await Promise.all(this.stores.map((store) => store.delete(key, options)));
        } catch (err) {
          throw dbDeleteFailedError();
        }
      }
      async *putMany(source, options = {}) {
        let error;
        const pushables = this.stores.map((store) => {
          const source2 = (0, import_it_pushable.default)();
          (0, import_it_drain2.default)(store.putMany(source2, options)).catch((err) => {
            error = err;
          });
          return source2;
        });
        try {
          for await (const pair of source) {
            if (error) {
              throw error;
            }
            pushables.forEach((p) => p.push(pair));
            yield pair;
          }
        } finally {
          pushables.forEach((p) => p.end());
        }
      }
      async *deleteMany(source, options = {}) {
        let error;
        const pushables = this.stores.map((store) => {
          const source2 = (0, import_it_pushable.default)();
          (0, import_it_drain2.default)(store.deleteMany(source2, options)).catch((err) => {
            error = err;
          });
          return source2;
        });
        try {
          for await (const key of source) {
            if (error) {
              throw error;
            }
            pushables.forEach((p) => p.push(key));
            yield key;
          }
        } finally {
          pushables.forEach((p) => p.end());
        }
      }
      async close() {
        await Promise.all(this.stores.map((store) => store.close()));
      }
      batch() {
        const batches = this.stores.map((store) => store.batch());
        return {
          put: (key, value) => {
            batches.forEach((b) => b.put(key, value));
          },
          delete: (key) => {
            batches.forEach((b) => b.delete(key));
          },
          commit: async (options) => {
            for (const batch3 of batches) {
              await batch3.commit(options);
            }
          }
        };
      }
      query(q, options) {
        return this.stores[this.stores.length - 1].query(q, options);
      }
      queryKeys(q, options) {
        return this.stores[this.stores.length - 1].queryKeys(q, options);
      }
    };
  }
});

// node_modules/dlv/dist/dlv.umd.js
var require_dlv_umd = __commonJS({
  "node_modules/dlv/dist/dlv.umd.js"(exports2, module2) {
    init_globals();
    !function(t, n) {
      typeof exports2 == "object" && typeof module2 != "undefined" ? module2.exports = function(t2, n2, e, i, o) {
        for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
          t2 = t2 ? t2[n2[i]] : o;
        return t2 === o ? e : t2;
      } : typeof define == "function" && define.amd ? define(function() {
        return function(t2, n2, e, i, o) {
          for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
            t2 = t2 ? t2[n2[i]] : o;
          return t2 === o ? e : t2;
        };
      }) : t.dlv = function(t2, n2, e, i, o) {
        for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
          t2 = t2 ? t2[n2[i]] : o;
        return t2 === o ? e : t2;
      };
    }(exports2);
  }
});

// node_modules/interface-datastore/esm/src/index.js
var init_src2 = __esm({
  "node_modules/interface-datastore/esm/src/index.js"() {
    init_globals();
    init_key();
  }
});

// node_modules/datastore-core/esm/src/shard-readme.js
var shard_readme_default;
var init_shard_readme = __esm({
  "node_modules/datastore-core/esm/src/shard-readme.js"() {
    init_globals();
    shard_readme_default = `This is a repository of IPLD objects. Each IPLD object is in a single file,
named <base32 encoding of cid>.data. Where <base32 encoding of cid> is the
"base32" encoding of the CID (as specified in
https://github.com/multiformats/multibase) without the 'B' prefix.
All the object files are placed in a tree of directories, based on a
function of the CID. This is a form of sharding similar to
the objects directory in git repositories. Previously, we used
prefixes, we now use the next-to-last two charters.
    func NextToLast(base32cid string) {
      nextToLastLen := 2
      offset := len(base32cid) - nextToLastLen - 1
      return str[offset : offset+nextToLastLen]
    }
For example, an object with a base58 CIDv1 of
    zb2rhYSxw4ZjuzgCnWSt19Q94ERaeFhu9uSqRgjSdx9bsgM6f
has a base32 CIDv1 of
    BAFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA
and will be placed at
    SC/AFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA.data
with 'SC' being the last-to-next two characters and the 'B' at the
beginning of the CIDv1 string is the multibase prefix that is not
stored in the filename.
`;
  }
});

// node_modules/datastore-core/esm/src/shard.js
var shard_exports = {};
__export(shard_exports, {
  NextToLast: () => NextToLast,
  PREFIX: () => PREFIX,
  Prefix: () => Prefix,
  README_FN: () => README_FN,
  SHARDING_FN: () => SHARDING_FN,
  ShardBase: () => ShardBase,
  Suffix: () => Suffix,
  parseShardFun: () => parseShardFun,
  readShardFun: () => readShardFun,
  readme: () => shard_readme_default
});
function parseShardFun(str) {
  str = str.trim();
  if (str.length === 0) {
    throw new Error("empty shard string");
  }
  if (!str.startsWith(PREFIX)) {
    throw new Error(`invalid or no path prefix: ${str}`);
  }
  const parts = str.slice(PREFIX.length).split("/");
  const version4 = parts[0];
  if (version4 !== "v1") {
    throw new Error(`expect 'v1' version, got '${version4}'`);
  }
  const name10 = parts[1];
  if (!parts[2]) {
    throw new Error("missing param");
  }
  const param = parseInt(parts[2], 10);
  switch (name10) {
    case "prefix":
      return new Prefix(param);
    case "suffix":
      return new Suffix(param);
    case "next-to-last":
      return new NextToLast(param);
    default:
      throw new Error(`unkown sharding function: ${name10}`);
  }
}
var PREFIX, SHARDING_FN, README_FN, ShardBase, Prefix, Suffix, NextToLast, readShardFun;
var init_shard = __esm({
  "node_modules/datastore-core/esm/src/shard.js"() {
    init_globals();
    init_key();
    init_shard_readme();
    init_shard_readme();
    PREFIX = "/repo/flatfs/shard/";
    SHARDING_FN = "SHARDING";
    README_FN = "_README";
    ShardBase = class {
      constructor(param) {
        this.param = param;
        this.name = "base";
        this._padding = "";
      }
      fun(s) {
        return "implement me";
      }
      toString() {
        return `${PREFIX}v1/${this.name}/${this.param}`;
      }
    };
    Prefix = class extends ShardBase {
      constructor(prefixLen) {
        super(prefixLen);
        this._padding = "".padStart(prefixLen, "_");
        this.name = "prefix";
      }
      fun(noslash) {
        return (noslash + this._padding).slice(0, this.param);
      }
    };
    Suffix = class extends ShardBase {
      constructor(suffixLen) {
        super(suffixLen);
        this._padding = "".padStart(suffixLen, "_");
        this.name = "suffix";
      }
      fun(noslash) {
        const s = this._padding + noslash;
        return s.slice(s.length - this.param);
      }
    };
    NextToLast = class extends ShardBase {
      constructor(suffixLen) {
        super(suffixLen);
        this._padding = "".padStart(suffixLen + 1, "_");
        this.name = "next-to-last";
      }
      fun(noslash) {
        const s = this._padding + noslash;
        const offset = s.length - this.param - 1;
        return s.slice(offset, offset + this.param);
      }
    };
    readShardFun = async (path, store) => {
      const key = new Key(path).child(new Key(SHARDING_FN));
      const get6 = typeof store.getRaw === "function" ? store.getRaw.bind(store) : store.get.bind(store);
      const res = await get6(key);
      return parseShardFun(new TextDecoder().decode(res || "").trim());
    };
  }
});

// node_modules/datastore-core/esm/src/memory.js
var memory_exports = {};
__export(memory_exports, {
  MemoryDatastore: () => MemoryDatastore
});
var MemoryDatastore;
var init_memory = __esm({
  "node_modules/datastore-core/esm/src/memory.js"() {
    init_globals();
    init_base3();
    init_key();
    init_errors();
    MemoryDatastore = class extends BaseDatastore {
      constructor() {
        super();
        this.data = {};
      }
      open() {
        return Promise.resolve();
      }
      close() {
        return Promise.resolve();
      }
      async put(key, val) {
        this.data[key.toString()] = val;
      }
      async get(key) {
        const exists = await this.has(key);
        if (!exists)
          throw notFoundError();
        return this.data[key.toString()];
      }
      async has(key) {
        return this.data[key.toString()] !== void 0;
      }
      async delete(key) {
        delete this.data[key.toString()];
      }
      async *_all() {
        yield* Object.entries(this.data).map(([key, value]) => ({
          key: new Key(key),
          value
        }));
      }
      async *_allKeys() {
        yield* Object.entries(this.data).map(([key]) => new Key(key));
      }
    };
  }
});

// node_modules/it-map/index.js
var require_it_map = __commonJS({
  "node_modules/it-map/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var map12 = async function* (source, func) {
      for await (const val of source) {
        yield func(val);
      }
    };
    module2.exports = map12;
  }
});

// node_modules/it-pipe/index.js
var require_it_pipe = __commonJS({
  "node_modules/it-pipe/index.js"(exports2, module2) {
    init_globals();
    var rawPipe = (...fns) => {
      let res;
      while (fns.length) {
        res = fns.shift()(res);
      }
      return res;
    };
    var isIterable2 = (obj) => obj && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
    var isDuplex = (obj) => obj && typeof obj.sink === "function" && isIterable2(obj.source);
    var duplexPipelineFn = (duplex) => (source) => {
      duplex.sink(source);
      return duplex.source;
    };
    var pipe8 = (...fns) => {
      if (isDuplex(fns[0])) {
        const duplex = fns[0];
        fns[0] = () => duplex.source;
      } else if (isIterable2(fns[0])) {
        const source = fns[0];
        fns[0] = () => source;
      }
      if (fns.length > 1) {
        if (isDuplex(fns[fns.length - 1])) {
          fns[fns.length - 1] = fns[fns.length - 1].sink;
        }
      }
      if (fns.length > 2) {
        for (let i = 1; i < fns.length - 1; i++) {
          if (isDuplex(fns[i])) {
            fns[i] = duplexPipelineFn(fns[i]);
          }
        }
      }
      return rawPipe(...fns);
    };
    module2.exports = pipe8;
    module2.exports.pipe = pipe8;
    module2.exports.rawPipe = rawPipe;
    module2.exports.isIterable = isIterable2;
    module2.exports.isDuplex = isDuplex;
  }
});

// node_modules/datastore-core/esm/src/keytransform.js
var import_it_map, import_it_pipe, KeyTransformDatastore;
var init_keytransform = __esm({
  "node_modules/datastore-core/esm/src/keytransform.js"() {
    init_globals();
    init_base3();
    import_it_map = __toESM(require_it_map(), 1);
    import_it_pipe = __toESM(require_it_pipe(), 1);
    KeyTransformDatastore = class extends BaseDatastore {
      constructor(child, transform) {
        super();
        this.child = child;
        this.transform = transform;
      }
      open() {
        return this.child.open();
      }
      put(key, val, options) {
        return this.child.put(this.transform.convert(key), val, options);
      }
      get(key, options) {
        return this.child.get(this.transform.convert(key), options);
      }
      has(key, options) {
        return this.child.has(this.transform.convert(key), options);
      }
      delete(key, options) {
        return this.child.delete(this.transform.convert(key), options);
      }
      async *putMany(source, options = {}) {
        const transform = this.transform;
        const child = this.child;
        yield* (0, import_it_pipe.pipe)(source, async function* (source2) {
          yield* (0, import_it_map.default)(source2, ({ key, value }) => ({
            key: transform.convert(key),
            value
          }));
        }, async function* (source2) {
          yield* child.putMany(source2, options);
        }, async function* (source2) {
          yield* (0, import_it_map.default)(source2, ({ key, value }) => ({
            key: transform.invert(key),
            value
          }));
        });
      }
      async *getMany(source, options = {}) {
        const transform = this.transform;
        const child = this.child;
        yield* (0, import_it_pipe.pipe)(source, async function* (source2) {
          yield* (0, import_it_map.default)(source2, (key) => transform.convert(key));
        }, async function* (source2) {
          yield* child.getMany(source2, options);
        });
      }
      async *deleteMany(source, options = {}) {
        const transform = this.transform;
        const child = this.child;
        yield* (0, import_it_pipe.pipe)(source, async function* (source2) {
          yield* (0, import_it_map.default)(source2, (key) => transform.convert(key));
        }, async function* (source2) {
          yield* child.deleteMany(source2, options);
        }, async function* (source2) {
          yield* (0, import_it_map.default)(source2, (key) => transform.invert(key));
        });
      }
      batch() {
        const b = this.child.batch();
        return {
          put: (key, value) => {
            b.put(this.transform.convert(key), value);
          },
          delete: (key) => {
            b.delete(this.transform.convert(key));
          },
          commit: (options) => {
            return b.commit(options);
          }
        };
      }
      query(q, options) {
        const query = { ...q };
        query.filters = (query.filters || []).map((filter10) => {
          return ({ key, value }) => filter10({
            key: this.transform.convert(key),
            value
          });
        });
        const { prefix } = q;
        if (prefix != null && prefix !== "/") {
          delete query.prefix;
          query.filters.push(({ key }) => {
            return this.transform.invert(key).toString().startsWith(prefix);
          });
        }
        if (query.orders) {
          query.orders = query.orders.map((order) => {
            return (a, b) => order({
              key: this.transform.invert(a.key),
              value: a.value
            }, {
              key: this.transform.invert(b.key),
              value: b.value
            });
          });
        }
        return (0, import_it_map.default)(this.child.query(query, options), ({ key, value }) => {
          return {
            key: this.transform.invert(key),
            value
          };
        });
      }
      queryKeys(q, options) {
        const query = { ...q };
        query.filters = (query.filters || []).map((filter10) => {
          return (key) => filter10(this.transform.convert(key));
        });
        const { prefix } = q;
        if (prefix != null && prefix !== "/") {
          delete query.prefix;
          query.filters.push((key) => {
            return this.transform.invert(key).toString().startsWith(prefix);
          });
        }
        if (query.orders) {
          query.orders = query.orders.map((order) => {
            return (a, b) => order(this.transform.invert(a), this.transform.invert(b));
          });
        }
        return (0, import_it_map.default)(this.child.queryKeys(query, options), (key) => {
          return this.transform.invert(key);
        });
      }
      close() {
        return this.child.close();
      }
    };
  }
});

// node_modules/datastore-core/esm/src/sharding.js
var shardKey, shardReadmeKey, ShardingDatastore;
var init_sharding = __esm({
  "node_modules/datastore-core/esm/src/sharding.js"() {
    init_globals();
    init_src2();
    init_shard();
    init_base3();
    init_keytransform();
    init_errors();
    shardKey = new Key(SHARDING_FN);
    shardReadmeKey = new Key(README_FN);
    ShardingDatastore = class extends BaseDatastore {
      constructor(store, shard2) {
        super();
        this.child = new KeyTransformDatastore(store, {
          convert: this._convertKey.bind(this),
          invert: this._invertKey.bind(this)
        });
        this.shard = shard2;
      }
      async open() {
        await this.child.open();
        this.shard = await ShardingDatastore.create(this.child, this.shard);
      }
      _convertKey(key) {
        const s = key.toString();
        if (s === shardKey.toString() || s === shardReadmeKey.toString()) {
          return key;
        }
        const parent2 = new Key(this.shard.fun(s));
        return parent2.child(key);
      }
      _invertKey(key) {
        const s = key.toString();
        if (s === shardKey.toString() || s === shardReadmeKey.toString()) {
          return key;
        }
        return Key.withNamespaces(key.list().slice(1));
      }
      static async createOrOpen(store, shard2) {
        try {
          await ShardingDatastore.create(store, shard2);
        } catch (err) {
          if (err && err.message !== "datastore exists")
            throw err;
        }
        return ShardingDatastore.open(store);
      }
      static async open(store) {
        const shard2 = await readShardFun("/", store);
        return new ShardingDatastore(store, shard2);
      }
      static async create(store, shard2) {
        const hasShard = await store.has(shardKey);
        if (!hasShard && !shard2) {
          throw dbOpenFailedError(Error("Shard is required when datastore doesn't have a shard key already."));
        }
        if (!hasShard) {
          const put = typeof store.putRaw === "function" ? store.putRaw.bind(store) : store.put.bind(store);
          await Promise.all([
            put(shardKey, new TextEncoder().encode(shard2.toString() + "\n")),
            put(shardReadmeKey, new TextEncoder().encode(shard_readme_default))
          ]);
          return shard2;
        }
        const diskShard = await readShardFun("/", store);
        const a = (diskShard || "").toString();
        const b = shard2.toString();
        if (a !== b) {
          throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);
        }
        return diskShard;
      }
      put(key, val, options) {
        return this.child.put(key, val, options);
      }
      get(key, options) {
        return this.child.get(key, options);
      }
      has(key, options) {
        return this.child.has(key, options);
      }
      delete(key, options) {
        return this.child.delete(key, options);
      }
      async *putMany(source, options = {}) {
        yield* this.child.putMany(source, options);
      }
      async *getMany(source, options = {}) {
        yield* this.child.getMany(source, options);
      }
      async *deleteMany(source, options = {}) {
        yield* this.child.deleteMany(source, options);
      }
      batch() {
        return this.child.batch();
      }
      query(q, options) {
        const tq = {
          ...q,
          filters: [
            ({ key }) => key.toString() !== shardKey.toString(),
            ({ key }) => key.toString() !== shardReadmeKey.toString()
          ].concat(q.filters || [])
        };
        return this.child.query(tq, options);
      }
      queryKeys(q, options) {
        const tq = {
          ...q,
          filters: [
            (key) => key.toString() !== shardKey.toString(),
            (key) => key.toString() !== shardReadmeKey.toString()
          ].concat(q.filters || [])
        };
        return this.child.queryKeys(tq, options);
      }
      close() {
        return this.child.close();
      }
    };
  }
});

// node_modules/it-merge/index.js
var require_it_merge = __commonJS({
  "node_modules/it-merge/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var pushable5 = require_it_pushable();
    var merge5 = async function* (...sources) {
      const output = pushable5();
      setTimeout(async () => {
        try {
          await Promise.all(sources.map(async (source) => {
            for await (const item of source) {
              output.push(item);
            }
          }));
          output.end();
        } catch (err) {
          output.end(err);
        }
      }, 0);
      yield* output;
    };
    module2.exports = merge5;
  }
});

// node_modules/datastore-core/esm/src/mount.js
var import_it_filter2, import_it_take2, import_it_merge, MountDatastore;
var init_mount = __esm({
  "node_modules/datastore-core/esm/src/mount.js"() {
    init_globals();
    import_it_filter2 = __toESM(require_it_filter(), 1);
    import_it_take2 = __toESM(require_it_take(), 1);
    import_it_merge = __toESM(require_it_merge(), 1);
    init_base3();
    init_errors();
    init_utils();
    MountDatastore = class extends BaseDatastore {
      constructor(mounts) {
        super();
        this.mounts = mounts.slice();
      }
      async open() {
        await Promise.all(this.mounts.map((m) => m.datastore.open()));
      }
      _lookup(key) {
        for (const mount of this.mounts) {
          if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {
            return {
              datastore: mount.datastore,
              mountpoint: mount.prefix
            };
          }
        }
      }
      put(key, value, options) {
        const match = this._lookup(key);
        if (match == null) {
          throw dbWriteFailedError(new Error("No datastore mounted for this key"));
        }
        return match.datastore.put(key, value, options);
      }
      get(key, options) {
        const match = this._lookup(key);
        if (match == null) {
          throw notFoundError(new Error("No datastore mounted for this key"));
        }
        return match.datastore.get(key, options);
      }
      has(key, options) {
        const match = this._lookup(key);
        if (match == null) {
          return Promise.resolve(false);
        }
        return match.datastore.has(key, options);
      }
      delete(key, options) {
        const match = this._lookup(key);
        if (match == null) {
          throw dbDeleteFailedError(new Error("No datastore mounted for this key"));
        }
        return match.datastore.delete(key, options);
      }
      async close() {
        await Promise.all(this.mounts.map((m) => {
          return m.datastore.close();
        }));
      }
      batch() {
        const batchMounts = {};
        const lookup = (key) => {
          const match = this._lookup(key);
          if (match == null) {
            throw new Error("No datastore mounted for this key");
          }
          const m = match.mountpoint.toString();
          if (batchMounts[m] == null) {
            batchMounts[m] = match.datastore.batch();
          }
          return { batch: batchMounts[m] };
        };
        return {
          put: (key, value) => {
            const match = lookup(key);
            match.batch.put(key, value);
          },
          delete: (key) => {
            const match = lookup(key);
            match.batch.delete(key);
          },
          commit: async (options) => {
            await Promise.all(Object.keys(batchMounts).map((p) => batchMounts[p].commit(options)));
          }
        };
      }
      query(q, options) {
        const qs = this.mounts.map((m) => {
          return m.datastore.query({
            prefix: q.prefix,
            filters: q.filters
          }, options);
        });
        let it = (0, import_it_merge.default)(...qs);
        if (q.filters)
          q.filters.forEach((f) => {
            it = (0, import_it_filter2.default)(it, f);
          });
        if (q.orders)
          q.orders.forEach((o) => {
            it = sortAll(it, o);
          });
        if (q.offset != null) {
          let i = 0;
          it = (0, import_it_filter2.default)(it, () => i++ >= q.offset);
        }
        if (q.limit != null)
          it = (0, import_it_take2.default)(it, q.limit);
        return it;
      }
      queryKeys(q, options) {
        const qs = this.mounts.map((m) => {
          return m.datastore.queryKeys({
            prefix: q.prefix,
            filters: q.filters
          }, options);
        });
        let it = (0, import_it_merge.default)(...qs);
        if (q.filters)
          q.filters.forEach((f) => {
            it = (0, import_it_filter2.default)(it, f);
          });
        if (q.orders)
          q.orders.forEach((o) => {
            it = sortAll(it, o);
          });
        if (q.offset != null) {
          let i = 0;
          it = (0, import_it_filter2.default)(it, () => i++ >= q.offset);
        }
        if (q.limit != null)
          it = (0, import_it_take2.default)(it, q.limit);
        return it;
      }
    };
  }
});

// node_modules/datastore-core/esm/src/namespace.js
var NamespaceDatastore;
var init_namespace = __esm({
  "node_modules/datastore-core/esm/src/namespace.js"() {
    init_globals();
    init_src2();
    init_keytransform();
    NamespaceDatastore = class extends KeyTransformDatastore {
      constructor(child, prefix) {
        super(child, {
          convert(key) {
            return prefix.child(key);
          },
          invert(key) {
            if (prefix.toString() === "/") {
              return key;
            }
            if (!prefix.isAncestorOf(key)) {
              throw new Error(`Expected prefix: (${prefix.toString()}) in key: ${key.toString()}`);
            }
            return new Key(key.toString().slice(prefix.toString().length), false);
          }
        });
      }
    };
  }
});

// node_modules/datastore-core/esm/src/index.js
var src_exports4 = {};
__export(src_exports4, {
  BaseDatastore: () => BaseDatastore,
  Errors: () => Errors,
  KeyTransformDatastore: () => KeyTransformDatastore,
  MemoryDatastore: () => MemoryDatastore,
  MountDatastore: () => MountDatastore,
  NamespaceDatastore: () => NamespaceDatastore,
  ShardingDatastore: () => ShardingDatastore,
  TieredDatastore: () => TieredDatastore,
  shard: () => shard
});
var Errors, shard;
var init_src3 = __esm({
  "node_modules/datastore-core/esm/src/index.js"() {
    init_globals();
    init_errors();
    init_shard();
    init_base3();
    init_memory();
    init_keytransform();
    init_sharding();
    init_mount();
    init_tiered();
    init_namespace();
    Errors = errors_exports;
    shard = shard_exports;
  }
});

// node_modules/libp2p-record/src/record/record.js
var require_record = __commonJS({
  "node_modules/libp2p-record/src/record/record.js"(exports2, module2) {
    "use strict";
    init_globals();
    var $protobuf12 = require_minimal2();
    var $Reader11 = $protobuf12.Reader;
    var $Writer11 = $protobuf12.Writer;
    var $util11 = $protobuf12.util;
    var $root11 = $protobuf12.roots["libp2p-record"] || ($protobuf12.roots["libp2p-record"] = {});
    $root11.Record = function() {
      function Record2(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Record2.prototype.key = $util11.newBuffer([]);
      Record2.prototype.value = $util11.newBuffer([]);
      Record2.prototype.timeReceived = "";
      Record2.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.key != null && Object.hasOwnProperty.call(m, "key"))
          w.uint32(10).bytes(m.key);
        if (m.value != null && Object.hasOwnProperty.call(m, "value"))
          w.uint32(18).bytes(m.value);
        if (m.timeReceived != null && Object.hasOwnProperty.call(m, "timeReceived"))
          w.uint32(42).string(m.timeReceived);
        return w;
      };
      Record2.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.Record();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.key = r.bytes();
              break;
            case 2:
              m.value = r.bytes();
              break;
            case 5:
              m.timeReceived = r.string();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Record2.fromObject = function fromObject(d) {
        if (d instanceof $root11.Record)
          return d;
        var m = new $root11.Record();
        if (d.key != null) {
          if (typeof d.key === "string")
            $util11.base64.decode(d.key, m.key = $util11.newBuffer($util11.base64.length(d.key)), 0);
          else if (d.key.length)
            m.key = d.key;
        }
        if (d.value != null) {
          if (typeof d.value === "string")
            $util11.base64.decode(d.value, m.value = $util11.newBuffer($util11.base64.length(d.value)), 0);
          else if (d.value.length)
            m.value = d.value;
        }
        if (d.timeReceived != null) {
          m.timeReceived = String(d.timeReceived);
        }
        return m;
      };
      Record2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.key = "";
          else {
            d.key = [];
            if (o.bytes !== Array)
              d.key = $util11.newBuffer(d.key);
          }
          if (o.bytes === String)
            d.value = "";
          else {
            d.value = [];
            if (o.bytes !== Array)
              d.value = $util11.newBuffer(d.value);
          }
          d.timeReceived = "";
        }
        if (m.key != null && m.hasOwnProperty("key")) {
          d.key = o.bytes === String ? $util11.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
        }
        if (m.value != null && m.hasOwnProperty("value")) {
          d.value = o.bytes === String ? $util11.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
        }
        if (m.timeReceived != null && m.hasOwnProperty("timeReceived")) {
          d.timeReceived = m.timeReceived;
        }
        return d;
      };
      Record2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      return Record2;
    }();
    module2.exports = $root11;
  }
});

// node_modules/libp2p-record/src/utils.js
var require_utils2 = __commonJS({
  "node_modules/libp2p-record/src/utils.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports.toRFC3339 = (time) => {
      const year = time.getUTCFullYear();
      const month = String(time.getUTCMonth() + 1).padStart(2, "0");
      const day = String(time.getUTCDate()).padStart(2, "0");
      const hour2 = String(time.getUTCHours()).padStart(2, "0");
      const minute2 = String(time.getUTCMinutes()).padStart(2, "0");
      const seconds = String(time.getUTCSeconds()).padStart(2, "0");
      const milliseconds = time.getUTCMilliseconds();
      const nanoseconds = milliseconds * 1e3 * 1e3;
      return `${year}-${month}-${day}T${hour2}:${minute2}:${seconds}.${nanoseconds}Z`;
    };
    module2.exports.parseRFC3339 = (time) => {
      const rfc3339Matcher = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z");
      const m = String(time).trim().match(rfc3339Matcher);
      if (!m) {
        throw new Error("Invalid format");
      }
      const year = parseInt(m[1], 10);
      const month = parseInt(m[2], 10) - 1;
      const date = parseInt(m[3], 10);
      const hour2 = parseInt(m[4], 10);
      const minute2 = parseInt(m[5], 10);
      const second = parseInt(m[6], 10);
      const millisecond = parseInt(m[7].slice(0, -6), 10);
      return new Date(Date.UTC(year, month, date, hour2, minute2, second, millisecond));
    };
  }
});

// node_modules/libp2p-record/src/record/index.js
var require_record2 = __commonJS({
  "node_modules/libp2p-record/src/record/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var {
      Record: PBRecord
    } = require_record();
    var utils = require_utils2();
    var Record2 = class {
      constructor(key, value, timeReceived) {
        if (!(key instanceof Uint8Array)) {
          throw new Error("key must be a Uint8Array");
        }
        if (!(value instanceof Uint8Array)) {
          throw new Error("value must be a Uint8Array");
        }
        this.key = key;
        this.value = value;
        this.timeReceived = timeReceived;
      }
      serialize() {
        return PBRecord.encode(this.prepareSerialize()).finish();
      }
      prepareSerialize() {
        return {
          key: this.key,
          value: this.value,
          timeReceived: this.timeReceived && utils.toRFC3339(this.timeReceived)
        };
      }
      static deserialize(raw) {
        const message = PBRecord.decode(raw);
        return Record2.fromDeserialized(PBRecord.toObject(message, {
          defaults: false,
          arrays: true,
          longs: Number,
          objects: false
        }));
      }
      static fromDeserialized(obj) {
        let recvtime;
        if (obj.timeReceived) {
          recvtime = utils.parseRFC3339(obj.timeReceived);
        }
        const rec = new Record2(obj.key, obj.value, recvtime);
        return rec;
      }
    };
    module2.exports = Record2;
  }
});

// node_modules/libp2p-record/src/validators/public-key.js
var require_public_key = __commonJS({
  "node_modules/libp2p-record/src/validators/public-key.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    var errcode17 = require_err_code();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var validatePublicKeyRecord = async (key, publicKey) => {
      if (!(key instanceof Uint8Array)) {
        throw errcode17(new Error('"key" must be a Uint8Array'), "ERR_INVALID_RECORD_KEY_NOT_BUFFER");
      }
      if (key.byteLength < 5) {
        throw errcode17(new Error("invalid public key record"), "ERR_INVALID_RECORD_KEY_TOO_SHORT");
      }
      const prefix = uint8ArrayToString(key.subarray(0, 4));
      if (prefix !== "/pk/") {
        throw errcode17(new Error("key was not prefixed with /pk/"), "ERR_INVALID_RECORD_KEY_BAD_PREFIX");
      }
      const keyhash = key.slice(4);
      const publicKeyHash = await sha2563.digest(publicKey);
      if (!uint8ArrayEquals(keyhash, publicKeyHash.bytes)) {
        throw errcode17(new Error("public key does not match passed in key"), "ERR_INVALID_RECORD_HASH_MISMATCH");
      }
    };
    module2.exports = {
      func: validatePublicKeyRecord,
      sign: false
    };
  }
});

// node_modules/libp2p-record/src/validators/index.js
var require_validators = __commonJS({
  "node_modules/libp2p-record/src/validators/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      pk: require_public_key()
    };
  }
});

// node_modules/libp2p-record/src/validator.js
var require_validator = __commonJS({
  "node_modules/libp2p-record/src/validator.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errcode17 = require_err_code();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var verifyRecord = (validators, record) => {
      const key = record.key;
      const keyString = uint8ArrayToString(key);
      const parts = keyString.split("/");
      if (parts.length < 3) {
        return;
      }
      const validator3 = validators[parts[1].toString()];
      if (!validator3) {
        const errMsg = "Invalid record keytype";
        throw errcode17(new Error(errMsg), "ERR_INVALID_RECORD_KEY_TYPE");
      }
      return validator3.func(key, record.value);
    };
    module2.exports = {
      verifyRecord,
      validators: require_validators()
    };
  }
});

// node_modules/libp2p-record/src/selectors/public-key.js
var require_public_key2 = __commonJS({
  "node_modules/libp2p-record/src/selectors/public-key.js"(exports2, module2) {
    "use strict";
    init_globals();
    var publicKeySelector = (k, records) => {
      return 0;
    };
    module2.exports = publicKeySelector;
  }
});

// node_modules/libp2p-record/src/selectors/index.js
var require_selectors = __commonJS({
  "node_modules/libp2p-record/src/selectors/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      pk: require_public_key2()
    };
  }
});

// node_modules/libp2p-record/src/selection.js
var require_selection = __commonJS({
  "node_modules/libp2p-record/src/selection.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errcode17 = require_err_code();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var bestRecord = (selectors, k, records) => {
      if (records.length === 0) {
        const errMsg = "No records given";
        throw errcode17(new Error(errMsg), "ERR_NO_RECORDS_RECEIVED");
      }
      const kStr = uint8ArrayToString(k);
      const parts = kStr.split("/");
      if (parts.length < 3) {
        const errMsg = "Record key does not have a selector function";
        throw errcode17(new Error(errMsg), "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY");
      }
      const selector2 = selectors[parts[1].toString()];
      if (!selector2) {
        const errMsg = `Unrecognized key prefix: ${parts[1]}`;
        throw errcode17(new Error(errMsg), "ERR_UNRECOGNIZED_KEY_PREFIX");
      }
      if (records.length === 1) {
        return 0;
      }
      return selector2(k, records);
    };
    module2.exports = {
      bestRecord,
      selectors: require_selectors()
    };
  }
});

// node_modules/libp2p-record/src/index.js
var require_src7 = __commonJS({
  "node_modules/libp2p-record/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      Record: require_record2(),
      validator: require_validator(),
      selection: require_selection()
    };
  }
});

// node_modules/is-domain-name/index.js
var require_is_domain_name = __commonJS({
  "node_modules/is-domain-name/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var domainNameRegex = /^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;
    module2.exports = function isDomainName(domainName, rootDot) {
      if (rootDot == null)
        rootDot = false;
      if (domainName.length < 2)
        return false;
      if (domainName.length > 255)
        return false;
      var lastChar = domainName[domainName.length - 1];
      if (rootDot) {
        if (lastChar !== ".")
          return false;
      } else {
        if (lastChar === ".")
          return false;
      }
      return domainNameRegex.test(domainName);
    };
  }
});

// node_modules/p-defer/index.js
var require_p_defer = __commonJS({
  "node_modules/p-defer/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var pDefer = () => {
      const deferred = {};
      deferred.promise = new Promise((resolve11, reject) => {
        deferred.resolve = resolve11;
        deferred.reject = reject;
      });
      return deferred;
    };
    module2.exports = pDefer;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    "use strict";
    init_globals();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter4() {
      EventEmitter4.init.call(this);
    }
    module2.exports = EventEmitter4;
    module2.exports.once = once;
    EventEmitter4.EventEmitter = EventEmitter4;
    EventEmitter4.prototype._events = void 0;
    EventEmitter4.prototype._eventsCount = 0;
    EventEmitter4.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter4, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter4.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter4.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter4.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter4.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter4.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit("newListener", type, listener.listener ? listener.listener : listener);
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter4.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter4.prototype.on = EventEmitter4.prototype.addListener;
    EventEmitter4.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter4.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter4.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter4.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter4.prototype.off = EventEmitter4.prototype.removeListener;
    EventEmitter4.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events2);
        var key;
        for (i = 0; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap3) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap3 ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap3 ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter4.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter4.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter4.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter4.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter4.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name10) {
      return new Promise(function(resolve11, reject) {
        function errorListener(err) {
          emitter.removeListener(name10, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve11([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name10, resolver, { once: true });
        if (name10 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name10, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name10, listener);
        } else {
          emitter.on(name10, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name10, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name10, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/it-parallel/index.js
var require_it_parallel = __commonJS({
  "node_modules/it-parallel/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var defer = require_p_defer();
    var EventEmitter4 = require_events().EventEmitter;
    async function* parallel2(source, options = {}) {
      let concurrency = options.concurrency || Infinity;
      if (concurrency < 1) {
        concurrency = Infinity;
      }
      const ordered = options.ordered == null ? false : options.ordered;
      const emitter = new EventEmitter4();
      const ops = [];
      let slotAvailable = defer();
      let resultAvailable = defer();
      let sourceFinished = false;
      let sourceErr;
      let opErred = false;
      emitter.on("task-complete", () => {
        resultAvailable.resolve();
      });
      Promise.resolve().then(async () => {
        try {
          for await (const task of source) {
            if (ops.length === concurrency) {
              slotAvailable = defer();
              await slotAvailable.promise;
            }
            if (opErred) {
              break;
            }
            const op = {
              done: false
            };
            ops.push(op);
            task().then((result) => {
              op.done = true;
              op.ok = true;
              op.value = result;
              emitter.emit("task-complete");
            }, (err) => {
              op.done = true;
              op.err = err;
              emitter.emit("task-complete");
            });
          }
          sourceFinished = true;
          emitter.emit("task-complete");
        } catch (err) {
          sourceErr = err;
          emitter.emit("task-complete");
        }
      });
      function valuesAvailable() {
        if (ordered) {
          return Boolean(ops[0] && ops[0].done);
        }
        return Boolean(ops.find((op) => op.done));
      }
      function* yieldOrderedValues() {
        while (ops.length && ops[0].done) {
          const op = ops[0];
          ops.shift();
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
      function* yieldUnOrderedValues() {
        while (valuesAvailable()) {
          for (let i = 0; i < ops.length; i++) {
            if (ops[i].done) {
              const op = ops[i];
              ops.splice(i, 1);
              i--;
              if (op.ok) {
                yield op.value;
              } else {
                opErred = true;
                slotAvailable.resolve();
                throw op.err;
              }
              slotAvailable.resolve();
            }
          }
        }
      }
      while (true) {
        if (!valuesAvailable()) {
          resultAvailable = defer();
          await resultAvailable.promise;
        }
        if (sourceErr) {
          throw sourceErr;
        }
        if (ordered) {
          yield* yieldOrderedValues();
        } else {
          yield* yieldUnOrderedValues();
        }
        if (sourceFinished && ops.length === 0) {
          break;
        }
      }
    }
    module2.exports = parallel2;
  }
});

// node_modules/browser-readablestream-to-it/index.js
var require_browser_readablestream_to_it = __commonJS({
  "node_modules/browser-readablestream-to-it/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    async function* browserReadableStreamToIt(stream, options = {}) {
      const reader = stream.getReader();
      try {
        while (true) {
          const result = await reader.read();
          if (result.done) {
            return;
          }
          yield result.value;
        }
      } finally {
        if (options.preventCancel !== true) {
          reader.cancel();
        }
        reader.releaseLock();
      }
    }
    module2.exports = browserReadableStreamToIt;
  }
});

// node_modules/blob-to-it/index.js
var require_blob_to_it = __commonJS({
  "node_modules/blob-to-it/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var browserReadableStreamToIt = require_browser_readablestream_to_it();
    function blobToIt2(blob) {
      if (typeof blob.stream === "function") {
        return browserReadableStreamToIt(blob.stream());
      }
      return browserReadableStreamToIt(new Response(blob).body);
    }
    module2.exports = blobToIt2;
  }
});

// node_modules/it-peekable/index.js
var require_it_peekable = __commonJS({
  "node_modules/it-peekable/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    function peekableIterator(iterable) {
      const [iterator, symbol] = iterable[Symbol.asyncIterator] ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
      const queue = [];
      return {
        peek: () => {
          return iterator.next();
        },
        push: (value) => {
          queue.push(value);
        },
        next: () => {
          if (queue.length) {
            return {
              done: false,
              value: queue.shift()
            };
          }
          return iterator.next();
        },
        [symbol]() {
          return this;
        }
      };
    }
    module2.exports = peekableIterator;
  }
});

// node_modules/it-batch/index.js
var require_it_batch = __commonJS({
  "node_modules/it-batch/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    async function* batch3(source, size = 1) {
      let things = [];
      if (size < 1) {
        size = 1;
      }
      for await (const thing of source) {
        things.push(thing);
        while (things.length >= size) {
          yield things.slice(0, size);
          things = things.slice(size);
        }
      }
      while (things.length) {
        yield things.slice(0, size);
        things = things.slice(size);
      }
    }
    module2.exports = batch3;
  }
});

// node_modules/it-parallel-batch/index.js
var require_it_parallel_batch = __commonJS({
  "node_modules/it-parallel-batch/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var batch3 = require_it_batch();
    async function* parallelBatch4(source, size = 1) {
      for await (const tasks of batch3(source, size)) {
        const things = tasks.map((p) => {
          return p().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
        });
        for (let i = 0; i < things.length; i++) {
          const result = await things[i];
          if (result.ok) {
            yield result.value;
          } else {
            throw result.err;
          }
        }
      }
    }
    module2.exports = parallelBatch4;
  }
});

// node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports2, module2) {
    init_globals();
    (function(root, undefined2) {
      "use strict";
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes2) {
        if (!Array.isArray(bytes2) && !ArrayBuffer.isView(bytes2)) {
          return false;
        }
        for (var i = 0; i < bytes2.length; i++) {
          if (!Number.isInteger(bytes2[i]) || bytes2[i] < 0 || bytes2[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m, n) {
        return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
      }
      function _x86Rotl(m, n) {
        return m << n | m >>> 32 - n;
      }
      function _x86Fmix(h) {
        h ^= h >>> 16;
        h = _x86Multiply(h, 2246822507);
        h ^= h >>> 13;
        h = _x86Multiply(h, 3266489909);
        h ^= h >>> 16;
        return h;
      }
      function _x64Add(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] + n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Multiply(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Rotl(m, n) {
        n %= 64;
        if (n === 32) {
          return [m[1], m[0]];
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
        } else {
          n -= 32;
          return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
        }
      }
      function _x64LeftShift(m, n) {
        n %= 64;
        if (n === 0) {
          return m;
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
        } else {
          return [m[1] << n - 32, 0];
        }
      }
      function _x64Xor(m, n) {
        return [m[0] ^ n[0], m[1] ^ n[1]];
      }
      function _x64Fmix(h) {
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [4283543511, 3981806797]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [3301882366, 444984403]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        return h;
      }
      library.x86.hash32 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 4;
        var blocks = bytes2.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i = 0; i < blocks; i = i + 4) {
          k1 = bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes2[i + 2] << 16;
          case 2:
            k1 ^= bytes2[i + 1] << 8;
          case 1:
            k1 ^= bytes2[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24;
          k2 = bytes2[i + 4] | bytes2[i + 5] << 8 | bytes2[i + 6] << 16 | bytes2[i + 7] << 24;
          k3 = bytes2[i + 8] | bytes2[i + 9] << 8 | bytes2[i + 10] << 16 | bytes2[i + 11] << 24;
          k4 = bytes2[i + 12] | bytes2[i + 13] << 8 | bytes2[i + 14] << 16 | bytes2[i + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes2[i + 14] << 16;
          case 14:
            k4 ^= bytes2[i + 13] << 8;
          case 13:
            k4 ^= bytes2[i + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes2[i + 11] << 24;
          case 11:
            k3 ^= bytes2[i + 10] << 16;
          case 10:
            k3 ^= bytes2[i + 9] << 8;
          case 9:
            k3 ^= bytes2[i + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes2[i + 7] << 24;
          case 7:
            k2 ^= bytes2[i + 6] << 16;
          case 6:
            k2 ^= bytes2[i + 5] << 8;
          case 5:
            k2 ^= bytes2[i + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes2[i + 3] << 24;
          case 3:
            k1 ^= bytes2[i + 2] << 16;
          case 2:
            k1 ^= bytes2[i + 1] << 8;
          case 1:
            k1 ^= bytes2[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h2 ^= bytes2.length;
        h3 ^= bytes2.length;
        h4 ^= bytes2.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = [0, seed];
        var h2 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = [bytes2[i + 4] | bytes2[i + 5] << 8 | bytes2[i + 6] << 16 | bytes2[i + 7] << 24, bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24];
          k2 = [bytes2[i + 12] | bytes2[i + 13] << 8 | bytes2[i + 14] << 16 | bytes2[i + 15] << 24, bytes2[i + 8] | bytes2[i + 9] << 8 | bytes2[i + 10] << 16 | bytes2[i + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes2[i + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes2[i]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes2.length]);
        h2 = _x64Xor(h2, [0, bytes2.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports2 !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports2 = module2.exports = library;
        }
        exports2.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
          root.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root.murmurHash3 = library;
      }
    })(exports2);
  }
});

// node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited = __commonJS({
  "node_modules/murmurhash3js-revisited/index.js"(exports2, module2) {
    init_globals();
    module2.exports = require_murmurHash3js();
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    init_globals();
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code13 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code13.length; i < len; ++i) {
      lookup[i] = code13[i];
      revLookup[code13.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    init_globals();
    exports2.read = function(buffer3, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer3[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer3[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer3[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer3, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer3[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer3[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer3[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    "use strict";
    init_globals();
    var base643 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length5) {
      if (length5 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length5 + '" is invalid for option "size"');
      }
      const buf3 = new Uint8Array(length5);
      Object.setPrototypeOf(buf3, Buffer2.prototype);
      return buf3;
    }
    function Buffer2(arg, encodingOrOffset, length5) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from5(arg, encodingOrOffset, length5);
    }
    Buffer2.poolSize = 8192;
    function from5(value, encodingOrOffset, length5) {
      if (typeof value === "string") {
        return fromString7(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length5);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length5);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length5);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length5);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer2.from = function(value, encodingOrOffset, length5) {
      return from5(value, encodingOrOffset, length5);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc3(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc3(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString7(string3, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length5 = byteLength(string3, encoding) | 0;
      let buf3 = createBuffer(length5);
      const actual = buf3.write(string3, encoding);
      if (actual !== length5) {
        buf3 = buf3.slice(0, actual);
      }
      return buf3;
    }
    function fromArrayLike(array) {
      const length5 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf3 = createBuffer(length5);
      for (let i = 0; i < length5; i += 1) {
        buf3[i] = array[i] & 255;
      }
      return buf3;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length5) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length5 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf3;
      if (byteOffset === void 0 && length5 === void 0) {
        buf3 = new Uint8Array(array);
      } else if (length5 === void 0) {
        buf3 = new Uint8Array(array, byteOffset);
      } else {
        buf3 = new Uint8Array(array, byteOffset, length5);
      }
      Object.setPrototypeOf(buf3, Buffer2.prototype);
      return buf3;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf3 = createBuffer(len);
        if (buf3.length === 0) {
          return buf3;
        }
        obj.copy(buf3, 0, 0, len);
        return buf3;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length5) {
      if (length5 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length5 | 0;
    }
    function SlowBuffer(length5) {
      if (+length5 != length5) {
        length5 = 0;
      }
      return Buffer2.alloc(+length5);
    }
    Buffer2.isBuffer = function isBuffer5(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare4(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat5(list, length5) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length5 === void 0) {
        length5 = 0;
        for (i = 0; i < list.length; ++i) {
          length5 += list[i].length;
        }
      }
      const buffer3 = Buffer2.allocUnsafe(length5);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf3 = list[i];
        if (isInstance(buf3, Uint8Array)) {
          if (pos + buf3.length > buffer3.length) {
            if (!Buffer2.isBuffer(buf3))
              buf3 = Buffer2.from(buf3);
            buf3.copy(buffer3, pos);
          } else {
            Uint8Array.prototype.set.call(buffer3, buf3, pos);
          }
        } else if (!Buffer2.isBuffer(buf3)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf3.copy(buffer3, pos);
        }
        pos += buf3.length;
      }
      return buffer3;
    };
    function byteLength(string3, encoding) {
      if (Buffer2.isBuffer(string3)) {
        return string3.length;
      }
      if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer)) {
        return string3.byteLength;
      }
      if (typeof string3 !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3);
      }
      const len = string3.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes3(string3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string3).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes3(string3).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice3(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString6() {
      const length5 = this.length;
      if (length5 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice3(this, 0, length5);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals6(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer3, val, byteOffset, encoding, dir) {
      if (buffer3.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer3.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer3.length + byteOffset;
      if (byteOffset >= buffer3.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer3.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer3, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer3, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read3(buf3, i2) {
        if (indexSize === 1) {
          return buf3[i2];
        } else {
          return buf3.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read3(arr, i) === read3(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read3(arr, i + j) !== read3(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf3, string3, offset, length5) {
      offset = Number(offset) || 0;
      const remaining = buf3.length - offset;
      if (!length5) {
        length5 = remaining;
      } else {
        length5 = Number(length5);
        if (length5 > remaining) {
          length5 = remaining;
        }
      }
      const strLen = string3.length;
      if (length5 > strLen / 2) {
        length5 = strLen / 2;
      }
      let i;
      for (i = 0; i < length5; ++i) {
        const parsed = parseInt(string3.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf3[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf3, string3, offset, length5) {
      return blitBuffer(utf8ToBytes3(string3, buf3.length - offset), buf3, offset, length5);
    }
    function asciiWrite(buf3, string3, offset, length5) {
      return blitBuffer(asciiToBytes(string3), buf3, offset, length5);
    }
    function base64Write(buf3, string3, offset, length5) {
      return blitBuffer(base64ToBytes(string3), buf3, offset, length5);
    }
    function ucs2Write(buf3, string3, offset, length5) {
      return blitBuffer(utf16leToBytes(string3, buf3.length - offset), buf3, offset, length5);
    }
    Buffer2.prototype.write = function write2(string3, offset, length5, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length5 = this.length;
        offset = 0;
      } else if (length5 === void 0 && typeof offset === "string") {
        encoding = offset;
        length5 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length5)) {
          length5 = length5 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length5;
          length5 = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length5 === void 0 || length5 > remaining)
        length5 = remaining;
      if (string3.length > 0 && (length5 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset, length5);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset, length5);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string3, offset, length5);
          case "base64":
            return base64Write(this, string3, offset, length5);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset, length5);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf3, start, end) {
      if (start === 0 && end === buf3.length) {
        return base643.fromByteArray(buf3);
      } else {
        return base643.fromByteArray(buf3.slice(start, end));
      }
    }
    function utf8Slice3(buf3, start, end) {
      end = Math.min(buf3.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf3[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf3[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf3[i + 1];
              thirdByte = buf3[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf3[i + 1];
              thirdByte = buf3[i + 2];
              fourthByte = buf3[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray3(res);
    }
    var MAX_ARGUMENTS_LENGTH3 = 4096;
    function decodeCodePointsArray3(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH3) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH3));
      }
      return res;
    }
    function asciiSlice(buf3, start, end) {
      let ret = "";
      end = Math.min(buf3.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf3[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf3, start, end) {
      let ret = "";
      end = Math.min(buf3.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf3[i]);
      }
      return ret;
    }
    function hexSlice(buf3, start, end) {
      const len = buf3.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf3[i]];
      }
      return out;
    }
    function utf16leSlice(buf3, start, end) {
      const bytes2 = buf3.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes2.length - 1; i += 2) {
        res += String.fromCharCode(bytes2[i] + bytes2[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice3(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length5) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length5)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first4 = this[offset];
      const last15 = this[offset + 7];
      if (first4 === void 0 || last15 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first4 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last15 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first4 = this[offset];
      const last15 = this[offset + 7];
      if (first4 === void 0 || last15 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first4 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last15;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first4 = this[offset];
      const last15 = this[offset + 7];
      if (first4 === void 0 || last15 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last15 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first4 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first4 = this[offset];
      const last15 = this[offset + 7];
      if (first4 === void 0 || last15 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first4 << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last15);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf3, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf3))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf3.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf3, value, offset, min, max) {
      checkIntBI(value, min, max, buf3, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf3, value, offset, min, max) {
      checkIntBI(value, min, max, buf3, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf3[offset + 7] = lo;
      lo = lo >> 8;
      buf3[offset + 6] = lo;
      lo = lo >> 8;
      buf3[offset + 5] = lo;
      lo = lo >> 8;
      buf3[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf3[offset + 3] = hi;
      hi = hi >> 8;
      buf3[offset + 2] = hi;
      hi = hi >> 8;
      buf3[offset + 1] = hi;
      hi = hi >> 8;
      buf3[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf3, value, offset, ext, max, min) {
      if (offset + ext > buf3.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf3, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf3, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf3, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf3, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf3, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf3, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code13 = val.charCodeAt(0);
          if (encoding === "utf8" && code13 < 128 || encoding === "latin1") {
            val = code13;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes2.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes2[i % len];
        }
      }
      return this;
    };
    var errors2 = {};
    function E(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E("ERR_BUFFER_OUT_OF_BOUNDS", function(name10) {
      if (name10) {
        return `${name10} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E("ERR_INVALID_ARG_TYPE", function(name10, actual) {
      return `The "${name10}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf3, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf3[offset] === void 0 || buf3[offset + byteLength2] === void 0) {
        boundsError(offset, buf3.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf3, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf3, offset, byteLength2);
    }
    function validateNumber(value, name10) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name10, "number", value);
      }
    }
    function boundsError(value, length5, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length5 < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length5}`, value);
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes3(string3, units) {
      units = units || Infinity;
      let codePoint;
      const length5 = string3.length;
      let leadSurrogate = null;
      const bytes2 = [];
      for (let i = 0; i < length5; ++i) {
        codePoint = string3.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            } else if (i + 1 === length5) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes2.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes2;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base643.toByteArray(base64clean(str));
    }
    function blitBuffer(src3, dst, offset, length5) {
      let i;
      for (i = 0; i < length5; ++i) {
        if (i + offset >= dst.length || i >= src3.length)
          break;
        dst[i + offset] = src3[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var symbol = Symbol.for("BufferList");
    function BufferList3(buf3) {
      if (!(this instanceof BufferList3)) {
        return new BufferList3(buf3);
      }
      BufferList3._init.call(this, buf3);
    }
    BufferList3._init = function _init(buf3) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf3) {
        this.append(buf3);
      }
    };
    BufferList3.prototype._new = function _new(buf3) {
      return new BufferList3(buf3);
    };
    BufferList3.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList3.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList3.prototype.get = function get6(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList3.prototype.slice = function slice3(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList3.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes2 = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes2 <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes2) : this._bufs[off[0]].slice(start, start + bytes2);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes2 > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes2);
          bufoff += l;
          break;
        }
        bytes2 -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList3.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList3.prototype.toString = function toString6(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList3.prototype.consume = function consume(bytes2) {
      bytes2 = Math.trunc(bytes2);
      if (Number.isNaN(bytes2) || bytes2 <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes2 >= this._bufs[0].length) {
          bytes2 -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes2);
          this.length -= bytes2;
          break;
        }
      }
      return this;
    };
    BufferList3.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList3.prototype.append = function append(buf3) {
      if (buf3 == null) {
        return this;
      }
      if (buf3.buffer) {
        this._appendBuffer(Buffer2.from(buf3.buffer, buf3.byteOffset, buf3.byteLength));
      } else if (Array.isArray(buf3)) {
        for (let i = 0; i < buf3.length; i++) {
          this.append(buf3[i]);
        }
      } else if (this._isBufferList(buf3)) {
        for (let i = 0; i < buf3._bufs.length; i++) {
          this.append(buf3._bufs[i]);
        }
      } else {
        if (typeof buf3 === "number") {
          buf3 = buf3.toString();
        }
        this._appendBuffer(Buffer2.from(buf3));
      }
      return this;
    };
    BufferList3.prototype._appendBuffer = function appendBuffer(buf3) {
      this._bufs.push(buf3);
      this.length += buf3.length;
    };
    BufferList3.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList3.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList3.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList3.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList3.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList3 || BufferList3.isBufferList(b);
    };
    BufferList3.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList3;
  }
});

// node_modules/rabin-wasm/src/rabin.js
var require_rabin = __commonJS({
  "node_modules/rabin-wasm/src/rabin.js"(exports2, module2) {
    init_globals();
    var Rabin = class {
      constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {
        this.bits = bits;
        this.min = min;
        this.max = max;
        this.asModule = asModule;
        this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial);
        this.polynomial = polynomial;
      }
      fingerprint(buf3) {
        const {
          __retain,
          __release,
          __allocArray,
          __getInt32Array,
          Int32Array_ID,
          Uint8Array_ID
        } = this.asModule;
        const lengths = new Int32Array(Math.ceil(buf3.length / this.min));
        const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
        const pointer = __retain(__allocArray(Uint8Array_ID, buf3));
        const out = this.rabin.fingerprint(pointer, lengthsPtr);
        const processed = __getInt32Array(out);
        __release(pointer);
        __release(lengthsPtr);
        const end = processed.indexOf(0);
        return end >= 0 ? processed.subarray(0, end) : processed;
      }
    };
    module2.exports = Rabin;
  }
});

// node_modules/@assemblyscript/loader/index.js
var require_loader = __commonJS({
  "node_modules/@assemblyscript/loader/index.js"(exports2) {
    "use strict";
    init_globals();
    var ID_OFFSET = -8;
    var SIZE_OFFSET = -4;
    var ARRAYBUFFER_ID = 0;
    var STRING_ID = 1;
    var ARRAYBUFFERVIEW = 1 << 0;
    var ARRAY = 1 << 1;
    var SET = 1 << 2;
    var MAP = 1 << 3;
    var VAL_ALIGN_OFFSET = 5;
    var VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
    var VAL_SIGNED = 1 << 10;
    var VAL_FLOAT = 1 << 11;
    var VAL_NULLABLE = 1 << 12;
    var VAL_MANAGED = 1 << 13;
    var KEY_ALIGN_OFFSET = 14;
    var KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
    var KEY_SIGNED = 1 << 19;
    var KEY_FLOAT = 1 << 20;
    var KEY_NULLABLE = 1 << 21;
    var KEY_MANAGED = 1 << 22;
    var ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
    var ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
    var ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
    var ARRAYBUFFERVIEW_SIZE = 12;
    var ARRAY_LENGTH_OFFSET = 12;
    var ARRAY_SIZE = 16;
    var BIGINT = typeof BigUint64Array !== "undefined";
    var THIS = Symbol();
    var CHUNKSIZE = 1024;
    function getStringImpl(buffer3, ptr) {
      const U32 = new Uint32Array(buffer3);
      const U16 = new Uint16Array(buffer3);
      var length5 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
      var offset = ptr >>> 1;
      if (length5 <= CHUNKSIZE)
        return String.fromCharCode.apply(String, U16.subarray(offset, offset + length5));
      const parts = [];
      do {
        const last15 = U16[offset + CHUNKSIZE - 1];
        const size = last15 >= 55296 && last15 < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
        parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));
        length5 -= size;
      } while (length5 > CHUNKSIZE);
      return parts.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length5));
    }
    function preInstantiate(imports) {
      const baseModule = {};
      function getString(memory, ptr) {
        if (!memory)
          return "<yet unknown>";
        return getStringImpl(memory.buffer, ptr);
      }
      const env = imports.env = imports.env || {};
      env.abort = env.abort || function abort(mesg, file, line, colm) {
        const memory = baseModule.memory || env.memory;
        throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
      };
      env.trace = env.trace || function trace(mesg, n) {
        const memory = baseModule.memory || env.memory;
        console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
      };
      imports.Math = imports.Math || Math;
      imports.Date = imports.Date || Date;
      return baseModule;
    }
    function postInstantiate(baseModule, instance) {
      const rawExports = instance.exports;
      const memory = rawExports.memory;
      const table = rawExports.table;
      const alloc3 = rawExports["__alloc"];
      const retain = rawExports["__retain"];
      const rttiBase = rawExports["__rtti_base"] || ~0;
      function getInfo(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2];
      }
      function getBase(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];
      }
      function getValueAlign(info) {
        return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
      }
      function getKeyAlign(info) {
        return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31);
      }
      function __allocString(str) {
        const length5 = str.length;
        const ptr = alloc3(length5 << 1, STRING_ID);
        const U16 = new Uint16Array(memory.buffer);
        for (var i = 0, p = ptr >>> 1; i < length5; ++i)
          U16[p + i] = str.charCodeAt(i);
        return ptr;
      }
      baseModule.__allocString = __allocString;
      function __getString(ptr) {
        const buffer3 = memory.buffer;
        const id = new Uint32Array(buffer3)[ptr + ID_OFFSET >>> 2];
        if (id !== STRING_ID)
          throw Error("not a string: " + ptr);
        return getStringImpl(buffer3, ptr);
      }
      baseModule.__getString = __getString;
      function getView(alignLog2, signed, float) {
        const buffer3 = memory.buffer;
        if (float) {
          switch (alignLog2) {
            case 2:
              return new Float32Array(buffer3);
            case 3:
              return new Float64Array(buffer3);
          }
        } else {
          switch (alignLog2) {
            case 0:
              return new (signed ? Int8Array : Uint8Array)(buffer3);
            case 1:
              return new (signed ? Int16Array : Uint16Array)(buffer3);
            case 2:
              return new (signed ? Int32Array : Uint32Array)(buffer3);
            case 3:
              return new (signed ? BigInt64Array : BigUint64Array)(buffer3);
          }
        }
        throw Error("unsupported align: " + alignLog2);
      }
      function __allocArray(id, values2) {
        const info = getInfo(id);
        if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
          throw Error("not an array: " + id + " @ " + info);
        const align = getValueAlign(info);
        const length5 = values2.length;
        const buf3 = alloc3(length5 << align, ARRAYBUFFER_ID);
        const arr = alloc3(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
        const U32 = new Uint32Array(memory.buffer);
        U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf3);
        U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf3;
        U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length5 << align;
        if (info & ARRAY)
          U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length5;
        const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
        if (info & VAL_MANAGED) {
          for (let i = 0; i < length5; ++i)
            view[(buf3 >>> align) + i] = retain(values2[i]);
        } else {
          view.set(values2, buf3 >>> align);
        }
        return arr;
      }
      baseModule.__allocArray = __allocArray;
      function __getArrayView(arr) {
        const U32 = new Uint32Array(memory.buffer);
        const id = U32[arr + ID_OFFSET >>> 2];
        const info = getInfo(id);
        if (!(info & ARRAYBUFFERVIEW))
          throw Error("not an array: " + id);
        const align = getValueAlign(info);
        var buf3 = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        const length5 = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf3 + SIZE_OFFSET >>> 2] >>> align;
        return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf3 >>>= align, buf3 + length5);
      }
      baseModule.__getArrayView = __getArrayView;
      function __getArray(arr) {
        const input = __getArrayView(arr);
        const len = input.length;
        const out = new Array(len);
        for (let i = 0; i < len; i++)
          out[i] = input[i];
        return out;
      }
      baseModule.__getArray = __getArray;
      function __getArrayBuffer(ptr) {
        const buffer3 = memory.buffer;
        const length5 = new Uint32Array(buffer3)[ptr + SIZE_OFFSET >>> 2];
        return buffer3.slice(ptr, ptr + length5);
      }
      baseModule.__getArrayBuffer = __getArrayBuffer;
      function getTypedArray(Type3, alignLog2, ptr) {
        return new Type3(getTypedArrayView(Type3, alignLog2, ptr));
      }
      function getTypedArrayView(Type3, alignLog2, ptr) {
        const buffer3 = memory.buffer;
        const U32 = new Uint32Array(buffer3);
        const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        return new Type3(buffer3, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
      }
      baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
      baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
      baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
      baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
      baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
      baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
      baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
      baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
      baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
      baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
      baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
      baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
      baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
      baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
      if (BIGINT) {
        baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
        baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
        baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
        baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
      }
      baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
      baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
      baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
      baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
      function __instanceof(ptr, baseId) {
        const U32 = new Uint32Array(memory.buffer);
        var id = U32[ptr + ID_OFFSET >>> 2];
        if (id <= U32[rttiBase >>> 2]) {
          do
            if (id == baseId)
              return true;
          while (id = getBase(id));
        }
        return false;
      }
      baseModule.__instanceof = __instanceof;
      baseModule.memory = baseModule.memory || memory;
      baseModule.table = baseModule.table || table;
      return demangle(rawExports, baseModule);
    }
    function isResponse(o) {
      return typeof Response !== "undefined" && o instanceof Response;
    }
    async function instantiate(source, imports) {
      if (isResponse(source = await source))
        return instantiateStreaming(source, imports);
      return postInstantiate(preInstantiate(imports || (imports = {})), await WebAssembly.instantiate(source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source), imports));
    }
    exports2.instantiate = instantiate;
    function instantiateSync(source, imports) {
      return postInstantiate(preInstantiate(imports || (imports = {})), new WebAssembly.Instance(source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source), imports));
    }
    exports2.instantiateSync = instantiateSync;
    async function instantiateStreaming(source, imports) {
      if (!WebAssembly.instantiateStreaming) {
        return instantiate(isResponse(source = await source) ? source.arrayBuffer() : source, imports);
      }
      return postInstantiate(preInstantiate(imports || (imports = {})), (await WebAssembly.instantiateStreaming(source, imports)).instance);
    }
    exports2.instantiateStreaming = instantiateStreaming;
    function demangle(exports3, baseModule) {
      var module3 = baseModule ? Object.create(baseModule) : {};
      var setArgumentsLength = exports3["__argumentsLength"] ? function(length5) {
        exports3["__argumentsLength"].value = length5;
      } : exports3["__setArgumentsLength"] || exports3["__setargc"] || function() {
      };
      for (let internalName in exports3) {
        if (!Object.prototype.hasOwnProperty.call(exports3, internalName))
          continue;
        const elem = exports3[internalName];
        let parts = internalName.split(".");
        let curr = module3;
        while (parts.length > 1) {
          let part = parts.shift();
          if (!Object.prototype.hasOwnProperty.call(curr, part))
            curr[part] = {};
          curr = curr[part];
        }
        let name10 = parts[0];
        let hash2 = name10.indexOf("#");
        if (hash2 >= 0) {
          let className = name10.substring(0, hash2);
          let classElem = curr[className];
          if (typeof classElem === "undefined" || !classElem.prototype) {
            let ctor = function(...args) {
              return ctor.wrap(ctor.prototype.constructor(0, ...args));
            };
            ctor.prototype = {
              valueOf: function valueOf() {
                return this[THIS];
              }
            };
            ctor.wrap = function(thisValue) {
              return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
            };
            if (classElem)
              Object.getOwnPropertyNames(classElem).forEach((name11) => Object.defineProperty(ctor, name11, Object.getOwnPropertyDescriptor(classElem, name11)));
            curr[className] = ctor;
          }
          name10 = name10.substring(hash2 + 1);
          curr = curr[className].prototype;
          if (/^(get|set):/.test(name10)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name10 = name10.substring(4))) {
              let getter = exports3[internalName.replace("set:", "get:")];
              let setter = exports3[internalName.replace("get:", "set:")];
              Object.defineProperty(curr, name10, {
                get: function() {
                  return getter(this[THIS]);
                },
                set: function(value) {
                  setter(this[THIS], value);
                },
                enumerable: true
              });
            }
          } else {
            if (name10 === "constructor") {
              (curr[name10] = (...args) => {
                setArgumentsLength(args.length);
                return elem(...args);
              }).original = elem;
            } else {
              (curr[name10] = function(...args) {
                setArgumentsLength(args.length);
                return elem(this[THIS], ...args);
              }).original = elem;
            }
          }
        } else {
          if (/^(get|set):/.test(name10)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name10 = name10.substring(4))) {
              Object.defineProperty(curr, name10, {
                get: exports3[internalName.replace("set:", "get:")],
                set: exports3[internalName.replace("get:", "set:")],
                enumerable: true
              });
            }
          } else if (typeof elem === "function" && elem !== setArgumentsLength) {
            (curr[name10] = (...args) => {
              setArgumentsLength(args.length);
              return elem(...args);
            }).original = elem;
          } else {
            curr[name10] = elem;
          }
        }
      }
      return module3;
    }
    exports2.demangle = demangle;
  }
});

// node_modules/rabin-wasm/dist/rabin-wasm.js
var require_rabin_wasm = __commonJS({
  "node_modules/rabin-wasm/dist/rabin-wasm.js"(exports2, module2) {
    init_globals();
    var { instantiate } = require_loader();
    loadWebAssembly.supported = typeof WebAssembly !== "undefined";
    function loadWebAssembly(imp = {}) {
      if (!loadWebAssembly.supported)
        return null;
      var wasm = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
      return instantiate(new Response(new Blob([wasm], { type: "application/wasm" })), imp);
    }
    module2.exports = loadWebAssembly;
  }
});

// node_modules/rabin-wasm/src/index.js
var require_src8 = __commonJS({
  "node_modules/rabin-wasm/src/index.js"(exports2, module2) {
    init_globals();
    var Rabin = require_rabin();
    var getRabin = require_rabin_wasm();
    var create9 = async (avg, min, max, windowSize, polynomial) => {
      const compiled = await getRabin();
      return new Rabin(compiled, avg, min, max, windowSize, polynomial);
    };
    module2.exports = {
      Rabin,
      create: create9
    };
  }
});

// node_modules/sparse-array/index.js
var require_sparse_array = __commonJS({
  "node_modules/sparse-array/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var BITS_PER_BYTE = 7;
    module2.exports = class SparseArray {
      constructor() {
        this._bitArrays = [];
        this._data = [];
        this._length = 0;
        this._changedLength = false;
        this._changedData = false;
      }
      set(index, value) {
        let pos = this._internalPositionFor(index, false);
        if (value === void 0) {
          if (pos !== -1) {
            this._unsetInternalPos(pos);
            this._unsetBit(index);
            this._changedLength = true;
            this._changedData = true;
          }
        } else {
          let needsSort = false;
          if (pos === -1) {
            pos = this._data.length;
            this._setBit(index);
            this._changedData = true;
          } else {
            needsSort = true;
          }
          this._setInternalPos(pos, index, value, needsSort);
          this._changedLength = true;
        }
      }
      unset(index) {
        this.set(index, void 0);
      }
      get(index) {
        this._sortData();
        const pos = this._internalPositionFor(index, true);
        if (pos === -1) {
          return void 0;
        }
        return this._data[pos][1];
      }
      push(value) {
        this.set(this.length, value);
        return this.length;
      }
      get length() {
        this._sortData();
        if (this._changedLength) {
          const last15 = this._data[this._data.length - 1];
          this._length = last15 ? last15[0] + 1 : 0;
          this._changedLength = false;
        }
        return this._length;
      }
      forEach(iterator) {
        let i = 0;
        while (i < this.length) {
          iterator(this.get(i), i, this);
          i++;
        }
      }
      map(iterator) {
        let i = 0;
        let mapped = new Array(this.length);
        while (i < this.length) {
          mapped[i] = iterator(this.get(i), i, this);
          i++;
        }
        return mapped;
      }
      reduce(reducer, initialValue) {
        let i = 0;
        let acc = initialValue;
        while (i < this.length) {
          const value = this.get(i);
          acc = reducer(acc, value, i);
          i++;
        }
        return acc;
      }
      find(finder) {
        let i = 0, found, last15;
        while (i < this.length && !found) {
          last15 = this.get(i);
          found = finder(last15);
          i++;
        }
        return found ? last15 : void 0;
      }
      _internalPositionFor(index, noCreate) {
        const bytePos = this._bytePosFor(index, noCreate);
        if (bytePos >= this._bitArrays.length) {
          return -1;
        }
        const byte = this._bitArrays[bytePos];
        const bitPos = index - bytePos * BITS_PER_BYTE;
        const exists = (byte & 1 << bitPos) > 0;
        if (!exists) {
          return -1;
        }
        const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
        const mask = ~(4294967295 << bitPos + 1);
        const bytePopCount = popCount(byte & mask);
        const arrayPos = previousPopCount + bytePopCount - 1;
        return arrayPos;
      }
      _bytePosFor(index, noCreate) {
        const bytePos = Math.floor(index / BITS_PER_BYTE);
        const targetLength = bytePos + 1;
        while (!noCreate && this._bitArrays.length < targetLength) {
          this._bitArrays.push(0);
        }
        return bytePos;
      }
      _setBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
      }
      _unsetBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
      }
      _setInternalPos(pos, index, value, needsSort) {
        const data = this._data;
        const elem = [index, value];
        if (needsSort) {
          this._sortData();
          data[pos] = elem;
        } else {
          if (data.length) {
            if (data[data.length - 1][0] >= index) {
              data.push(elem);
            } else if (data[0][0] <= index) {
              data.unshift(elem);
            } else {
              const randomIndex = Math.round(data.length / 2);
              this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
            }
          } else {
            this._data.push(elem);
          }
          this._changedData = true;
          this._changedLength = true;
        }
      }
      _unsetInternalPos(pos) {
        this._data.splice(pos, 1);
      }
      _sortData() {
        if (this._changedData) {
          this._data.sort(sortInternal);
        }
        this._changedData = false;
      }
      bitField() {
        const bytes2 = [];
        let pendingBitsForResultingByte = 8;
        let pendingBitsForNewByte = 0;
        let resultingByte = 0;
        let newByte;
        const pending = this._bitArrays.slice();
        while (pending.length || pendingBitsForNewByte) {
          if (pendingBitsForNewByte === 0) {
            newByte = pending.shift();
            pendingBitsForNewByte = 7;
          }
          const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
          const mask = ~(255 << usingBits);
          const masked = newByte & mask;
          resultingByte |= masked << 8 - pendingBitsForResultingByte;
          newByte = newByte >>> usingBits;
          pendingBitsForNewByte -= usingBits;
          pendingBitsForResultingByte -= usingBits;
          if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
            bytes2.push(resultingByte);
            resultingByte = 0;
            pendingBitsForResultingByte = 8;
          }
        }
        for (var i = bytes2.length - 1; i > 0; i--) {
          const value = bytes2[i];
          if (value === 0) {
            bytes2.pop();
          } else {
            break;
          }
        }
        return bytes2;
      }
      compactArray() {
        this._sortData();
        return this._data.map(valueOnly);
      }
    };
    function popCountReduce(count, byte) {
      return count + popCount(byte);
    }
    function popCount(_v) {
      let v = _v;
      v = v - (v >> 1 & 1431655765);
      v = (v & 858993459) + (v >> 2 & 858993459);
      return (v + (v >> 4) & 252645135) * 16843009 >> 24;
    }
    function sortInternal(a, b) {
      return a[0] - b[0];
    }
    function valueOnly(elem) {
      return elem[1];
    }
  }
});

// node_modules/hamt-sharding/src/bucket.js
var require_bucket = __commonJS({
  "node_modules/hamt-sharding/src/bucket.js"(exports2, module2) {
    "use strict";
    init_globals();
    var SparseArray = require_sparse_array();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var Bucket6 = class {
      constructor(options, parent2, posAtParent = 0) {
        this._options = options;
        this._popCount = 0;
        this._parent = parent2;
        this._posAtParent = posAtParent;
        this._children = new SparseArray();
        this.key = null;
      }
      async put(key, value) {
        const place = await this._findNewBucketAndPos(key);
        await place.bucket._putAt(place, key, value);
      }
      async get(key) {
        const child = await this._findChild(key);
        if (child) {
          return child.value;
        }
      }
      async del(key) {
        const place = await this._findPlace(key);
        const child = place.bucket._at(place.pos);
        if (child && child.key === key) {
          place.bucket._delAt(place.pos);
        }
      }
      leafCount() {
        const children = this._children.compactArray();
        return children.reduce((acc, child) => {
          if (child instanceof Bucket6) {
            return acc + child.leafCount();
          }
          return acc + 1;
        }, 0);
      }
      childrenCount() {
        return this._children.length;
      }
      onlyChild() {
        return this._children.get(0);
      }
      *eachLeafSeries() {
        const children = this._children.compactArray();
        for (const child of children) {
          if (child instanceof Bucket6) {
            yield* child.eachLeafSeries();
          } else {
            yield child;
          }
        }
        return [];
      }
      serialize(map12, reduce2) {
        const acc = [];
        return reduce2(this._children.reduce((acc2, child, index) => {
          if (child) {
            if (child instanceof Bucket6) {
              acc2.push(child.serialize(map12, reduce2));
            } else {
              acc2.push(map12(child, index));
            }
          }
          return acc2;
        }, acc));
      }
      asyncTransform(asyncMap, asyncReduce) {
        return asyncTransformBucket(this, asyncMap, asyncReduce);
      }
      toJSON() {
        return this.serialize(mapNode, reduceNodes);
      }
      prettyPrint() {
        return JSON.stringify(this.toJSON(), null, "  ");
      }
      tableSize() {
        return Math.pow(2, this._options.bits);
      }
      async _findChild(key) {
        const result = await this._findPlace(key);
        const child = result.bucket._at(result.pos);
        if (child instanceof Bucket6) {
          return void 0;
        }
        if (child && child.key === key) {
          return child;
        }
      }
      async _findPlace(key) {
        const hashValue = this._options.hash(typeof key === "string" ? uint8ArrayFromString(key) : key);
        const index = await hashValue.take(this._options.bits);
        const child = this._children.get(index);
        if (child instanceof Bucket6) {
          return child._findPlace(hashValue);
        }
        return {
          bucket: this,
          pos: index,
          hash: hashValue,
          existingChild: child
        };
      }
      async _findNewBucketAndPos(key) {
        const place = await this._findPlace(key);
        if (place.existingChild && place.existingChild.key !== key) {
          const bucket = new Bucket6(this._options, place.bucket, place.pos);
          place.bucket._putObjectAt(place.pos, bucket);
          const newPlace = await bucket._findPlace(place.existingChild.hash);
          newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
          return bucket._findNewBucketAndPos(place.hash);
        }
        return place;
      }
      _putAt(place, key, value) {
        this._putObjectAt(place.pos, {
          key,
          value,
          hash: place.hash
        });
      }
      _putObjectAt(pos, object) {
        if (!this._children.get(pos)) {
          this._popCount++;
        }
        this._children.set(pos, object);
      }
      _delAt(pos) {
        if (pos === -1) {
          throw new Error("Invalid position");
        }
        if (this._children.get(pos)) {
          this._popCount--;
        }
        this._children.unset(pos);
        this._level();
      }
      _level() {
        if (this._parent && this._popCount <= 1) {
          if (this._popCount === 1) {
            const onlyChild = this._children.find(exists);
            if (onlyChild && !(onlyChild instanceof Bucket6)) {
              const hash2 = onlyChild.hash;
              hash2.untake(this._options.bits);
              const place = {
                pos: this._posAtParent,
                hash: hash2,
                bucket: this._parent
              };
              this._parent._putAt(place, onlyChild.key, onlyChild.value);
            }
          } else {
            this._parent._delAt(this._posAtParent);
          }
        }
      }
      _at(index) {
        return this._children.get(index);
      }
    };
    function exists(o) {
      return Boolean(o);
    }
    function mapNode(node, index) {
      return node.key;
    }
    function reduceNodes(nodes) {
      return nodes;
    }
    async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
      const output = [];
      for (const child of bucket._children.compactArray()) {
        if (child instanceof Bucket6) {
          await asyncTransformBucket(child, asyncMap, asyncReduce);
        } else {
          const mappedChildren = await asyncMap(child);
          output.push({
            bitField: bucket._children.bitField(),
            children: mappedChildren
          });
        }
      }
      return asyncReduce(output);
    }
    module2.exports = Bucket6;
  }
});

// node_modules/hamt-sharding/src/consumable-buffer.js
var require_consumable_buffer = __commonJS({
  "node_modules/hamt-sharding/src/consumable-buffer.js"(exports2, module2) {
    "use strict";
    init_globals();
    var START_MASKS = [
      255,
      254,
      252,
      248,
      240,
      224,
      192,
      128
    ];
    var STOP_MASKS = [
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255
    ];
    module2.exports = class ConsumableBuffer {
      constructor(value) {
        this._value = value;
        this._currentBytePos = value.length - 1;
        this._currentBitPos = 7;
      }
      availableBits() {
        return this._currentBitPos + 1 + this._currentBytePos * 8;
      }
      totalBits() {
        return this._value.length * 8;
      }
      take(bits) {
        let pendingBits = bits;
        let result = 0;
        while (pendingBits && this._haveBits()) {
          const byte = this._value[this._currentBytePos];
          const availableBits = this._currentBitPos + 1;
          const taking = Math.min(availableBits, pendingBits);
          const value = byteBitsToInt(byte, availableBits - taking, taking);
          result = (result << taking) + value;
          pendingBits -= taking;
          this._currentBitPos -= taking;
          if (this._currentBitPos < 0) {
            this._currentBitPos = 7;
            this._currentBytePos--;
          }
        }
        return result;
      }
      untake(bits) {
        this._currentBitPos += bits;
        while (this._currentBitPos > 7) {
          this._currentBitPos -= 8;
          this._currentBytePos += 1;
        }
      }
      _haveBits() {
        return this._currentBytePos >= 0;
      }
    };
    function byteBitsToInt(byte, start, length5) {
      const mask = maskFor(start, length5);
      return (byte & mask) >>> start;
    }
    function maskFor(start, length5) {
      return START_MASKS[start] & STOP_MASKS[Math.min(length5 + start - 1, 7)];
    }
  }
});

// node_modules/hamt-sharding/src/consumable-hash.js
var require_consumable_hash = __commonJS({
  "node_modules/hamt-sharding/src/consumable-hash.js"(exports2, module2) {
    "use strict";
    init_globals();
    var ConsumableBuffer = require_consumable_buffer();
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    function wrapHash(hashFn3) {
      function hashing(value) {
        if (value instanceof InfiniteHash) {
          return value;
        } else {
          return new InfiniteHash(value, hashFn3);
        }
      }
      return hashing;
    }
    var InfiniteHash = class {
      constructor(value, hashFn3) {
        if (!(value instanceof Uint8Array)) {
          throw new Error("can only hash Uint8Arrays");
        }
        this._value = value;
        this._hashFn = hashFn3;
        this._depth = -1;
        this._availableBits = 0;
        this._currentBufferIndex = 0;
        this._buffers = [];
      }
      async take(bits) {
        let pendingBits = bits;
        while (this._availableBits < pendingBits) {
          await this._produceMoreBits();
        }
        let result = 0;
        while (pendingBits > 0) {
          const hash2 = this._buffers[this._currentBufferIndex];
          const available = Math.min(hash2.availableBits(), pendingBits);
          const took = hash2.take(available);
          result = (result << available) + took;
          pendingBits -= available;
          this._availableBits -= available;
          if (hash2.availableBits() === 0) {
            this._currentBufferIndex++;
          }
        }
        return result;
      }
      untake(bits) {
        let pendingBits = bits;
        while (pendingBits > 0) {
          const hash2 = this._buffers[this._currentBufferIndex];
          const availableForUntake = Math.min(hash2.totalBits() - hash2.availableBits(), pendingBits);
          hash2.untake(availableForUntake);
          pendingBits -= availableForUntake;
          this._availableBits += availableForUntake;
          if (this._currentBufferIndex > 0 && hash2.totalBits() === hash2.availableBits()) {
            this._depth--;
            this._currentBufferIndex--;
          }
        }
      }
      async _produceMoreBits() {
        this._depth++;
        const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;
        const hashValue = await this._hashFn(value);
        const buffer3 = new ConsumableBuffer(hashValue);
        this._buffers.push(buffer3);
        this._availableBits += buffer3.availableBits();
      }
    };
    module2.exports = wrapHash;
    module2.exports.InfiniteHash = InfiniteHash;
  }
});

// node_modules/hamt-sharding/src/index.js
var require_src9 = __commonJS({
  "node_modules/hamt-sharding/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Bucket6 = require_bucket();
    var wrapHash = require_consumable_hash();
    function createHAMT6(options) {
      if (!options || !options.hashFn) {
        throw new Error("please define an options.hashFn");
      }
      const bucketOptions = {
        bits: options.bits || 8,
        hash: wrapHash(options.hashFn)
      };
      return new Bucket6(bucketOptions);
    }
    module2.exports = {
      createHAMT: createHAMT6,
      Bucket: Bucket6
    };
  }
});

// node_modules/it-tar/extract-headers.js
var require_extract_headers = __commonJS({
  "node_modules/it-tar/extract-headers.js"(exports2) {
    init_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var BufferList3 = require_BufferList();
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR_MAGIC = Buffer2.from("ustar\0", "binary");
    var GNU_MAGIC = Buffer2.from("ustar ", "binary");
    var GNU_VER = Buffer2.from(" \0", "binary");
    var MAGIC_OFFSET = 257;
    var VERSION_OFFSET = 263;
    var clamp = function(index, len, defaultValue) {
      if (typeof index !== "number")
        return defaultValue;
      index = ~~index;
      if (index >= len)
        return len;
      if (index >= 0)
        return index;
      index += len;
      if (index >= 0)
        return index;
      return 0;
    };
    var toType = function(flag) {
      switch (flag) {
        case 0:
          return "file";
        case 1:
          return "link";
        case 2:
          return "symlink";
        case 3:
          return "character-device";
        case 4:
          return "block-device";
        case 5:
          return "directory";
        case 6:
          return "fifo";
        case 7:
          return "contiguous-file";
        case 72:
          return "pax-header";
        case 55:
          return "pax-global-header";
        case 27:
          return "gnu-long-link-path";
        case 28:
        case 30:
          return "gnu-long-path";
      }
      return null;
    };
    var indexOf = function(block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block.get(offset) === num)
          return offset;
      }
      return end;
    };
    var cksum = function(block) {
      let sum = 8 * 32;
      for (let i = 0; i < 148; i++)
        sum += block.get(i);
      for (let j = 156; j < 512; j++)
        sum += block.get(j);
      return sum;
    };
    function parse256(buf3) {
      let positive;
      if (buf3.get(0) === 128)
        positive = true;
      else if (buf3.get(0) === 255)
        positive = false;
      else
        return null;
      let zero = false;
      const tuple = [];
      for (let i = buf3.length - 1; i > 0; i--) {
        const byte = buf3.get(i);
        if (positive)
          tuple.push(byte);
        else if (zero && byte === 0)
          tuple.push(0);
        else if (zero) {
          zero = false;
          tuple.push(256 - byte);
        } else
          tuple.push(255 - byte);
      }
      let sum = 0;
      const l = tuple.length;
      for (let i = 0; i < l; i++) {
        sum += tuple[i] * Math.pow(256, i);
      }
      return positive ? sum : -1 * sum;
    }
    var decodeOct = function(val, offset, length5) {
      val = val.shallowSlice(offset, offset + length5);
      offset = 0;
      if (val.get(offset) & 128) {
        return parse256(val);
      } else {
        while (offset < val.length && val.get(offset) === 32)
          offset++;
        const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while (offset < end && val.get(offset) === 0)
          offset++;
        if (end === offset)
          return 0;
        return parseInt(val.shallowSlice(offset, end).toString(), 8);
      }
    };
    var decodeStr = function(val, offset, length5, encoding) {
      return val.shallowSlice(offset, indexOf(val, 0, offset, offset + length5)).toString(encoding);
    };
    exports2.decodeLongPath = function(buf3, encoding) {
      buf3 = BufferList3.isBufferList(buf3) ? buf3 : new BufferList3(buf3);
      return decodeStr(buf3, 0, buf3.length, encoding);
    };
    exports2.decodePax = function(buf3) {
      buf3 = BufferList3.isBufferList(buf3) ? buf3 : new BufferList3(buf3);
      const result = {};
      while (buf3.length) {
        let i = 0;
        while (i < buf3.length && buf3.get(i) !== 32)
          i++;
        const len = parseInt(buf3.shallowSlice(0, i).toString(), 10);
        if (!len)
          return result;
        const b = buf3.shallowSlice(i + 1, len - 1).toString();
        const keyIndex = b.indexOf("=");
        if (keyIndex === -1)
          return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf3 = buf3.shallowSlice(len);
      }
      return result;
    };
    exports2.decode = function(buf3, filenameEncoding) {
      buf3 = BufferList3.isBufferList(buf3) ? buf3 : new BufferList3(buf3);
      let typeflag = buf3.get(156) === 0 ? 0 : buf3.get(156) - ZERO_OFFSET;
      let name10 = decodeStr(buf3, 0, 100, filenameEncoding);
      const mode = decodeOct(buf3, 100, 8);
      const uid = decodeOct(buf3, 108, 8);
      const gid = decodeOct(buf3, 116, 8);
      const size = decodeOct(buf3, 124, 12);
      const mtime = decodeOct(buf3, 136, 12);
      const type = toType(typeflag);
      const linkname = buf3.get(157) === 0 ? null : decodeStr(buf3, 157, 100, filenameEncoding);
      const uname = decodeStr(buf3, 265, 32);
      const gname = decodeStr(buf3, 297, 32);
      const devmajor = decodeOct(buf3, 329, 8);
      const devminor = decodeOct(buf3, 337, 8);
      const c = cksum(buf3);
      if (c === 8 * 32)
        return null;
      if (c !== decodeOct(buf3, 148, 8))
        throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
      if (USTAR_MAGIC.compare(buf3.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0) {
        if (buf3.get(345))
          name10 = decodeStr(buf3, 345, 155, filenameEncoding) + "/" + name10;
      } else if (GNU_MAGIC.compare(buf3.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0 && GNU_VER.compare(buf3.slice(VERSION_OFFSET, VERSION_OFFSET + 2)) === 0) {
      } else {
        throw new Error("Invalid tar header: unknown format.");
      }
      if (typeflag === 0 && name10 && name10[name10.length - 1] === "/")
        typeflag = 5;
      return {
        name: name10,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1e3 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor
      };
    };
  }
});

// node_modules/it-reader/index.js
var require_it_reader = __commonJS({
  "node_modules/it-reader/index.js"(exports2, module2) {
    init_globals();
    var BufferList3 = require_BufferList();
    module2.exports = (source) => {
      const reader = async function* () {
        let bytes2 = yield;
        let bl = new BufferList3();
        for await (const chunk of source) {
          if (!bytes2) {
            bytes2 = yield bl.append(chunk);
            bl = new BufferList3();
            continue;
          }
          bl.append(chunk);
          while (bl.length >= bytes2) {
            const data = bl.shallowSlice(0, bytes2);
            bl.consume(bytes2);
            bytes2 = yield data;
            if (!bytes2) {
              if (bl.length) {
                bytes2 = yield bl;
                bl = new BufferList3();
              }
              break;
            }
          }
        }
        if (bytes2) {
          throw Object.assign(new Error(`stream ended before ${bytes2} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
        }
      }();
      reader.next();
      return reader;
    };
  }
});

// node_modules/it-tar/lte-reader.js
var require_lte_reader = __commonJS({
  "node_modules/it-tar/lte-reader.js"(exports2, module2) {
    init_globals();
    var BufferList3 = require_BufferList();
    var Reader = require_it_reader();
    module2.exports = function LteReader(source) {
      const reader = Reader(source);
      let overflow;
      const lteReader = {
        [Symbol.asyncIterator]: () => lteReader,
        async next(bytes2) {
          if (overflow) {
            let value;
            if (bytes2 == null || overflow.length === bytes2) {
              value = overflow;
              overflow = null;
            } else if (overflow.length > bytes2) {
              value = overflow.shallowSlice(0, bytes2);
              overflow = overflow.shallowSlice(bytes2);
            } else if (overflow.length < bytes2) {
              const { value: nextValue, done } = await reader.next(bytes2 - overflow.length);
              if (done) {
                throw Object.assign(new Error(`stream ended before ${bytes2 - overflow.length} bytes became available`), { code: "ERR_UNDER_READ" });
              }
              value = new BufferList3([overflow, nextValue]);
              overflow = null;
            }
            return { value };
          }
          return reader.next(bytes2);
        },
        async nextLte(bytes2) {
          let { done, value } = await lteReader.next();
          if (done)
            return { done };
          if (value.length <= bytes2)
            return { value };
          value = BufferList3.isBufferList(value) ? value : new BufferList3(value);
          if (overflow) {
            overflow.append(value.shallowSlice(bytes2));
          } else {
            overflow = value.shallowSlice(bytes2);
          }
          return { value: value.shallowSlice(0, bytes2) };
        },
        return() {
          return reader.return();
        }
      };
      return lteReader;
    };
  }
});

// node_modules/it-tar/extract.js
var require_extract = __commonJS({
  "node_modules/it-tar/extract.js"(exports2, module2) {
    init_globals();
    var defer = require_p_defer();
    var Headers = require_extract_headers();
    var LteReader = require_lte_reader();
    function getPadding(size) {
      size &= 511;
      return size && 512 - size;
    }
    async function discardPadding(reader, size) {
      const overflow = getPadding(size);
      if (overflow)
        await reader.next(overflow);
    }
    module2.exports = (options) => {
      options = options || {};
      options.highWaterMark = options.highWaterMark || 1024 * 16;
      return (source) => async function* () {
        const reader = LteReader(source);
        let gnuLongPath, gnuLongLinkPath, paxGlobal, pax;
        try {
          while (true) {
            let headerBytes;
            try {
              const { done, value } = await reader.next(512);
              if (done)
                return;
              headerBytes = value;
            } catch (err) {
              if (err.code === "ERR_UNDER_READ")
                return;
              throw err;
            }
            const header = Headers.decode(headerBytes, options.filenameEncoding);
            if (!header)
              continue;
            if (header.type === "gnu-long-path") {
              const { done, value: gnuLongPathBytes } = await reader.next(header.size);
              if (done)
                return;
              gnuLongPath = Headers.decodeLongPath(gnuLongPathBytes, options.filenameEncoding);
              await discardPadding(reader, header.size);
              continue;
            }
            if (header.type === "gnu-long-link-path") {
              const { done, value: gnuLongLinkPathBytes } = await reader.next(header.size);
              if (done)
                return;
              gnuLongLinkPath = Headers.decodeLongPath(gnuLongLinkPathBytes, options.filenameEncoding);
              await discardPadding(reader, header.size);
              continue;
            }
            if (header.type === "pax-global-header") {
              const { done, value: paxGlobalBytes } = await reader.next(header.size);
              if (done)
                return;
              paxGlobal = Headers.decodePax(paxGlobalBytes, options.filenameEncoding);
              await discardPadding(reader, header.size);
              continue;
            }
            if (header.type === "pax-header") {
              const { done, value: paxBytes } = await reader.next(header.size);
              if (done)
                return;
              pax = Headers.decodePax(paxBytes, options.filenameEncoding);
              if (paxGlobal)
                pax = { ...paxGlobal, ...pax };
              await discardPadding(reader, header.size);
              continue;
            }
            if (gnuLongPath) {
              header.name = gnuLongPath;
              gnuLongPath = null;
            }
            if (gnuLongLinkPath) {
              header.linkname = gnuLongLinkPath;
              gnuLongLinkPath = null;
            }
            if (pax) {
              if (pax.path)
                header.name = pax.path;
              if (pax.linkpath)
                header.linkname = pax.linkpath;
              if (pax.size)
                header.size = parseInt(pax.size, 10);
              header.pax = pax;
              pax = null;
            }
            if (!header.size || header.type === "directory") {
              yield { header, body: async function* () {
              }() };
              continue;
            }
            let bytesRemaining = header.size;
            const bodyConsumed = defer();
            const firstChunk = await reader.nextLte(Math.min(bytesRemaining, options.highWaterMark));
            bytesRemaining -= firstChunk.value.length;
            if (!bytesRemaining)
              bodyConsumed.resolve();
            const body = async function* () {
              try {
                yield firstChunk.value;
                while (bytesRemaining) {
                  const { done, value } = await reader.nextLte(bytesRemaining);
                  if (done) {
                    bytesRemaining = 0;
                    return;
                  }
                  bytesRemaining -= value.length;
                  yield value;
                }
              } finally {
                bodyConsumed.resolve();
              }
            }();
            yield { header, body };
            await bodyConsumed.promise;
            if (bytesRemaining) {
              for await (const _ of body) {
              }
            }
            await discardPadding(reader, header.size);
          }
        } finally {
          await reader.return();
        }
      }();
    };
  }
});

// node_modules/iso-constants/index.browser.js
var require_index_browser2 = __commonJS({
  "node_modules/iso-constants/index.browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      "RTLD_LAZY": 1,
      "RTLD_NOW": 2,
      "RTLD_GLOBAL": 256,
      "RTLD_LOCAL": 0,
      "RTLD_DEEPBIND": 8,
      "E2BIG": 7,
      "EACCES": 13,
      "EADDRINUSE": 98,
      "EADDRNOTAVAIL": 99,
      "EAFNOSUPPORT": 97,
      "EAGAIN": 11,
      "EALREADY": 114,
      "EBADF": 9,
      "EBADMSG": 74,
      "EBUSY": 16,
      "ECANCELED": 125,
      "ECHILD": 10,
      "ECONNABORTED": 103,
      "ECONNREFUSED": 111,
      "ECONNRESET": 104,
      "EDEADLK": 35,
      "EDESTADDRREQ": 89,
      "EDOM": 33,
      "EDQUOT": 122,
      "EEXIST": 17,
      "EFAULT": 14,
      "EFBIG": 27,
      "EHOSTUNREACH": 113,
      "EIDRM": 43,
      "EILSEQ": 84,
      "EINPROGRESS": 115,
      "EINTR": 4,
      "EINVAL": 22,
      "EIO": 5,
      "EISCONN": 106,
      "EISDIR": 21,
      "ELOOP": 40,
      "EMFILE": 24,
      "EMLINK": 31,
      "EMSGSIZE": 90,
      "EMULTIHOP": 72,
      "ENAMETOOLONG": 36,
      "ENETDOWN": 100,
      "ENETRESET": 102,
      "ENETUNREACH": 101,
      "ENFILE": 23,
      "ENOBUFS": 105,
      "ENODATA": 61,
      "ENODEV": 19,
      "ENOENT": 2,
      "ENOEXEC": 8,
      "ENOLCK": 37,
      "ENOLINK": 67,
      "ENOMEM": 12,
      "ENOMSG": 42,
      "ENOPROTOOPT": 92,
      "ENOSPC": 28,
      "ENOSR": 63,
      "ENOSTR": 60,
      "ENOSYS": 38,
      "ENOTCONN": 107,
      "ENOTDIR": 20,
      "ENOTEMPTY": 39,
      "ENOTSOCK": 88,
      "ENOTSUP": 95,
      "ENOTTY": 25,
      "ENXIO": 6,
      "EOPNOTSUPP": 95,
      "EOVERFLOW": 75,
      "EPERM": 1,
      "EPIPE": 32,
      "EPROTO": 71,
      "EPROTONOSUPPORT": 93,
      "EPROTOTYPE": 91,
      "ERANGE": 34,
      "EROFS": 30,
      "ESPIPE": 29,
      "ESRCH": 3,
      "ESTALE": 116,
      "ETIME": 62,
      "ETIMEDOUT": 110,
      "ETXTBSY": 26,
      "EWOULDBLOCK": 11,
      "EXDEV": 18,
      "PRIORITY_LOW": 19,
      "PRIORITY_BELOW_NORMAL": 10,
      "PRIORITY_NORMAL": 0,
      "PRIORITY_ABOVE_NORMAL": -7,
      "PRIORITY_HIGH": -14,
      "PRIORITY_HIGHEST": -20,
      "SIGHUP": 1,
      "SIGINT": 2,
      "SIGQUIT": 3,
      "SIGILL": 4,
      "SIGTRAP": 5,
      "SIGABRT": 6,
      "SIGIOT": 6,
      "SIGBUS": 7,
      "SIGFPE": 8,
      "SIGKILL": 9,
      "SIGUSR1": 10,
      "SIGSEGV": 11,
      "SIGUSR2": 12,
      "SIGPIPE": 13,
      "SIGALRM": 14,
      "SIGTERM": 15,
      "SIGCHLD": 17,
      "SIGSTKFLT": 16,
      "SIGCONT": 18,
      "SIGSTOP": 19,
      "SIGTSTP": 20,
      "SIGTTIN": 21,
      "SIGTTOU": 22,
      "SIGURG": 23,
      "SIGXCPU": 24,
      "SIGXFSZ": 25,
      "SIGVTALRM": 26,
      "SIGPROF": 27,
      "SIGWINCH": 28,
      "SIGIO": 29,
      "SIGPOLL": 29,
      "SIGPWR": 30,
      "SIGSYS": 31,
      "UV_FS_SYMLINK_DIR": 1,
      "UV_FS_SYMLINK_JUNCTION": 2,
      "O_RDONLY": 0,
      "O_WRONLY": 1,
      "O_RDWR": 2,
      "UV_DIRENT_UNKNOWN": 0,
      "UV_DIRENT_FILE": 1,
      "UV_DIRENT_DIR": 2,
      "UV_DIRENT_LINK": 3,
      "UV_DIRENT_FIFO": 4,
      "UV_DIRENT_SOCKET": 5,
      "UV_DIRENT_CHAR": 6,
      "UV_DIRENT_BLOCK": 7,
      "S_IFMT": 61440,
      "S_IFREG": 32768,
      "S_IFDIR": 16384,
      "S_IFCHR": 8192,
      "S_IFBLK": 24576,
      "S_IFIFO": 4096,
      "S_IFLNK": 40960,
      "S_IFSOCK": 49152,
      "O_CREAT": 64,
      "O_EXCL": 128,
      "UV_FS_O_FILEMAP": 0,
      "O_NOCTTY": 256,
      "O_TRUNC": 512,
      "O_APPEND": 1024,
      "O_DIRECTORY": 65536,
      "O_NOATIME": 262144,
      "O_NOFOLLOW": 131072,
      "O_SYNC": 1052672,
      "O_DSYNC": 4096,
      "O_DIRECT": 16384,
      "O_NONBLOCK": 2048,
      "S_IRWXU": 448,
      "S_IRUSR": 256,
      "S_IWUSR": 128,
      "S_IXUSR": 64,
      "S_IRWXG": 56,
      "S_IRGRP": 32,
      "S_IWGRP": 16,
      "S_IXGRP": 8,
      "S_IRWXO": 7,
      "S_IROTH": 4,
      "S_IWOTH": 2,
      "S_IXOTH": 1,
      "F_OK": 0,
      "R_OK": 4,
      "W_OK": 2,
      "X_OK": 1,
      "UV_FS_COPYFILE_EXCL": 1,
      "COPYFILE_EXCL": 1,
      "UV_FS_COPYFILE_FICLONE": 2,
      "COPYFILE_FICLONE": 2,
      "UV_FS_COPYFILE_FICLONE_FORCE": 4,
      "COPYFILE_FICLONE_FORCE": 4,
      "OPENSSL_VERSION_NUMBER": 269488367,
      "SSL_OP_ALL": 2147485780,
      "SSL_OP_ALLOW_NO_DHE_KEX": 1024,
      "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
      "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
      "SSL_OP_CISCO_ANYCONNECT": 32768,
      "SSL_OP_COOKIE_EXCHANGE": 8192,
      "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
      "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
      "SSL_OP_EPHEMERAL_RSA": 0,
      "SSL_OP_LEGACY_SERVER_CONNECT": 4,
      "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 0,
      "SSL_OP_MICROSOFT_SESS_ID_BUG": 0,
      "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
      "SSL_OP_NETSCAPE_CA_DN_BUG": 0,
      "SSL_OP_NETSCAPE_CHALLENGE_BUG": 0,
      "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 0,
      "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 0,
      "SSL_OP_NO_COMPRESSION": 131072,
      "SSL_OP_NO_ENCRYPT_THEN_MAC": 524288,
      "SSL_OP_NO_QUERY_MTU": 4096,
      "SSL_OP_NO_RENEGOTIATION": 1073741824,
      "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
      "SSL_OP_NO_SSLv2": 0,
      "SSL_OP_NO_SSLv3": 33554432,
      "SSL_OP_NO_TICKET": 16384,
      "SSL_OP_NO_TLSv1": 67108864,
      "SSL_OP_NO_TLSv1_1": 268435456,
      "SSL_OP_NO_TLSv1_2": 134217728,
      "SSL_OP_NO_TLSv1_3": 536870912,
      "SSL_OP_PKCS1_CHECK_1": 0,
      "SSL_OP_PKCS1_CHECK_2": 0,
      "SSL_OP_PRIORITIZE_CHACHA": 2097152,
      "SSL_OP_SINGLE_DH_USE": 0,
      "SSL_OP_SINGLE_ECDH_USE": 0,
      "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 0,
      "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
      "SSL_OP_TLS_BLOCK_PADDING_BUG": 0,
      "SSL_OP_TLS_D5_BUG": 0,
      "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
      "ENGINE_METHOD_RSA": 1,
      "ENGINE_METHOD_DSA": 2,
      "ENGINE_METHOD_DH": 4,
      "ENGINE_METHOD_RAND": 8,
      "ENGINE_METHOD_EC": 2048,
      "ENGINE_METHOD_CIPHERS": 64,
      "ENGINE_METHOD_DIGESTS": 128,
      "ENGINE_METHOD_PKEY_METHS": 512,
      "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
      "ENGINE_METHOD_ALL": 65535,
      "ENGINE_METHOD_NONE": 0,
      "DH_CHECK_P_NOT_SAFE_PRIME": 2,
      "DH_CHECK_P_NOT_PRIME": 1,
      "DH_UNABLE_TO_CHECK_GENERATOR": 4,
      "DH_NOT_SUITABLE_GENERATOR": 8,
      "ALPN_ENABLED": 1,
      "RSA_PKCS1_PADDING": 1,
      "RSA_SSLV23_PADDING": 2,
      "RSA_NO_PADDING": 3,
      "RSA_PKCS1_OAEP_PADDING": 4,
      "RSA_X931_PADDING": 5,
      "RSA_PKCS1_PSS_PADDING": 6,
      "RSA_PSS_SALTLEN_DIGEST": -1,
      "RSA_PSS_SALTLEN_MAX_SIGN": -2,
      "RSA_PSS_SALTLEN_AUTO": -2,
      "defaultCoreCipherList": "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
      "TLS1_VERSION": 769,
      "TLS1_1_VERSION": 770,
      "TLS1_2_VERSION": 771,
      "TLS1_3_VERSION": 772,
      "POINT_CONVERSION_COMPRESSED": 2,
      "POINT_CONVERSION_UNCOMPRESSED": 4,
      "POINT_CONVERSION_HYBRID": 6,
      "defaultCipherList": "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA"
    };
  }
});

// node_modules/it-concat/index.js
var require_it_concat = __commonJS({
  "node_modules/it-concat/index.js"(exports2, module2) {
    init_globals();
    var BufferList3 = require_BufferList();
    var TypeDefault = {
      string: () => "",
      buffer: () => BufferList3()
    };
    module2.exports = async (source, options) => {
      options = options || {};
      if (options.type && !TypeDefault[options.type]) {
        throw new Error(`invalid type "${options.type}"`);
      }
      let res, type;
      for await (const chunk of source) {
        if (!res) {
          type = options.type || (typeof chunk === "string" ? "string" : "buffer");
          res = TypeDefault[type]();
        }
        if (type === "string") {
          res += chunk;
        } else {
          res.append(chunk);
        }
      }
      return res || TypeDefault[options.type || "buffer"]();
    };
  }
});

// node_modules/it-tar/pack-headers.js
var require_pack_headers = __commonJS({
  "node_modules/it-tar/pack-headers.js"(exports2) {
    init_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var alloc3 = Buffer2.alloc;
    var ZEROS = "0000000000000000000";
    var SEVENS = "7777777777777777777";
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR_MAGIC = Buffer2.from("ustar\0", "binary");
    var USTAR_VER = Buffer2.from("00", "binary");
    var MASK = parseInt("7777", 8);
    var MAGIC_OFFSET = 257;
    var VERSION_OFFSET = 263;
    var toTypeflag = function(flag) {
      switch (flag) {
        case "file":
          return 0;
        case "link":
          return 1;
        case "symlink":
          return 2;
        case "character-device":
          return 3;
        case "block-device":
          return 4;
        case "directory":
          return 5;
        case "fifo":
          return 6;
        case "contiguous-file":
          return 7;
        case "pax-header":
          return 72;
      }
      return 0;
    };
    var cksum = function(block) {
      let sum = 8 * 32;
      for (let i = 0; i < 148; i++)
        sum += block[i];
      for (let j = 156; j < 512; j++)
        sum += block[j];
      return sum;
    };
    var encodeOct = function(val, n) {
      val = val.toString(8);
      if (val.length > n)
        return SEVENS.slice(0, n) + " ";
      else
        return ZEROS.slice(0, n - val.length) + val + " ";
    };
    var addLength = function(str) {
      const len = Buffer2.byteLength(str);
      let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
      if (len + digits >= Math.pow(10, digits))
        digits++;
      return len + digits + str;
    };
    exports2.encodePax = function(opts) {
      let result = "";
      if (opts.name)
        result += addLength(" path=" + opts.name + "\n");
      if (opts.linkname)
        result += addLength(" linkpath=" + opts.linkname + "\n");
      const pax = opts.pax;
      if (pax) {
        for (const key in pax) {
          result += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
      return Buffer2.from(result);
    };
    exports2.encode = function(opts) {
      const buf3 = alloc3(512);
      let name10 = opts.name;
      let prefix = "";
      if (opts.typeflag === 5 && name10[name10.length - 1] !== "/")
        name10 += "/";
      if (Buffer2.byteLength(name10) !== name10.length)
        return null;
      while (Buffer2.byteLength(name10) > 100) {
        const i = name10.indexOf("/");
        if (i === -1)
          return null;
        prefix += prefix ? "/" + name10.slice(0, i) : name10.slice(0, i);
        name10 = name10.slice(i + 1);
      }
      if (Buffer2.byteLength(name10) > 100 || Buffer2.byteLength(prefix) > 155)
        return null;
      if (opts.linkname && Buffer2.byteLength(opts.linkname) > 100)
        return null;
      buf3.write(name10);
      buf3.write(encodeOct(opts.mode & MASK, 6), 100);
      buf3.write(encodeOct(opts.uid, 6), 108);
      buf3.write(encodeOct(opts.gid, 6), 116);
      buf3.write(encodeOct(opts.size, 11), 124);
      buf3.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
      buf3[156] = ZERO_OFFSET + toTypeflag(opts.type);
      if (opts.linkname)
        buf3.write(opts.linkname, 157);
      USTAR_MAGIC.copy(buf3, MAGIC_OFFSET);
      USTAR_VER.copy(buf3, VERSION_OFFSET);
      if (opts.uname)
        buf3.write(opts.uname, 265);
      if (opts.gname)
        buf3.write(opts.gname, 297);
      buf3.write(encodeOct(opts.devmajor || 0, 6), 329);
      buf3.write(encodeOct(opts.devminor || 0, 6), 337);
      if (prefix)
        buf3.write(prefix, 345);
      buf3.write(encodeOct(cksum(buf3), 6), 148);
      return buf3;
    };
  }
});

// node_modules/it-tar/pack.js
var require_pack = __commonJS({
  "node_modules/it-tar/pack.js"(exports2, module2) {
    init_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var BufferList3 = require_BufferList();
    var { S_IFMT, S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO, S_IFLNK } = require_index_browser2();
    var concat5 = require_it_concat();
    var Headers = require_pack_headers();
    var DMODE = parseInt("755", 8);
    var FMODE = parseInt("644", 8);
    var END_OF_TAR = Buffer2.alloc(1024);
    function modeToType(mode) {
      switch (mode & S_IFMT) {
        case S_IFBLK:
          return "block-device";
        case S_IFCHR:
          return "character-device";
        case S_IFDIR:
          return "directory";
        case S_IFIFO:
          return "fifo";
        case S_IFLNK:
          return "symlink";
      }
      return "file";
    }
    function getPadding(size) {
      size &= 511;
      if (size)
        return new BufferList3(END_OF_TAR.slice(0, 512 - size));
    }
    function encode19(header) {
      if (!header.pax) {
        const encoded = Headers.encode(header);
        if (encoded)
          return encoded;
      }
      return encodePax(header);
    }
    function encodePax(header) {
      const paxHeader = Headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      });
      const newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      return new BufferList3([
        Headers.encode(newHeader),
        paxHeader,
        getPadding(paxHeader.length),
        Headers.encode({ ...newHeader, size: header.size, type: header.type })
      ]);
    }
    module2.exports = () => async function* (source) {
      for await (let { header, body } of source) {
        if (!header.size || header.type === "symlink")
          header.size = 0;
        if (!header.type)
          header.type = modeToType(header.mode);
        if (!header.mode)
          header.mode = header.type === "directory" ? DMODE : FMODE;
        if (!header.uid)
          header.uid = 0;
        if (!header.gid)
          header.gid = 0;
        if (!header.mtime)
          header.mtime = new Date();
        if (typeof body === "string")
          body = Buffer2.from(body);
        if (Buffer2.isBuffer(body) || BufferList3.isBufferList(body)) {
          header.size = body.length;
          yield new BufferList3([encode19(header), body, getPadding(header.size)]);
          continue;
        }
        if (header.type === "symlink" && !header.linkname) {
          header.linkname = (await concat5(body)).toString();
          yield encode19(header);
          continue;
        }
        yield encode19(header);
        if (header.type !== "file" && header.type !== "contiguous-file") {
          continue;
        }
        let written = 0;
        for await (const chunk of body) {
          written += chunk.length;
          yield BufferList3.isBufferList(chunk) ? chunk : new BufferList3(chunk);
        }
        if (written !== header.size) {
          throw new Error("size mismatch");
        }
        const overflow = getPadding(header.size);
        if (overflow)
          yield overflow;
      }
      yield new BufferList3(END_OF_TAR);
    };
  }
});

// node_modules/it-tar/index.js
var require_it_tar = __commonJS({
  "node_modules/it-tar/index.js"(exports2) {
    init_globals();
    exports2.extract = require_extract();
    exports2.pack = require_pack();
  }
});

// node_modules/pako/lib/utils/common.js
var require_common2 = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports2) {
    "use strict";
    init_globals();
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports2.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports2.shrinkBuf = function(buf3, size) {
      if (buf3.length === size) {
        return buf3;
      }
      if (buf3.subarray) {
        return buf3.subarray(0, size);
      }
      buf3.length = size;
      return buf3;
    };
    var fnTyped = {
      arraySet: function(dest, src3, src_offs, len, dest_offs) {
        if (src3.subarray && dest.subarray) {
          dest.set(src3.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src3[src_offs + i];
        }
      },
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src3, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src3[src_offs + i];
        }
      },
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports2.setTyped = function(on) {
      if (on) {
        exports2.Buf8 = Uint8Array;
        exports2.Buf16 = Uint16Array;
        exports2.Buf32 = Int32Array;
        exports2.assign(exports2, fnTyped);
      } else {
        exports2.Buf8 = Array;
        exports2.Buf16 = Array;
        exports2.Buf32 = Array;
        exports2.assign(exports2, fnUntyped);
      }
    };
    exports2.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports2) {
    "use strict";
    init_globals();
    var utils = require_common2();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf3) {
      var len = buf3.length;
      while (--len >= 0) {
        buf3[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length5) {
      if (s.bi_valid > Buf_size - length5) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length5 - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length5;
      }
    }
    function send_code(s, c, tree2) {
      send_bits(s, tree2[c * 2], tree2[c * 2 + 1]);
    }
    function bi_reverse(code13, len) {
      var res = 0;
      do {
        res |= code13 & 1;
        code13 >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree2 = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base4 = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree2[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree2[tree2[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree2[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base4) {
          xbits = extra[n - base4];
        }
        f = tree2[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree2[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree2[m * 2 + 1]) * tree2[m * 2];
            tree2[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree2, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code13 = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code13 = code13 + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree2[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree2[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length5;
      var code13;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length5 = 0;
      for (code13 = 0; code13 < LENGTH_CODES - 1; code13++) {
        base_length[code13] = length5;
        for (n = 0; n < 1 << extra_lbits[code13]; n++) {
          _length_code[length5++] = code13;
        }
      }
      _length_code[length5 - 1] = code13;
      dist = 0;
      for (code13 = 0; code13 < 16; code13++) {
        base_dist[code13] = dist;
        for (n = 0; n < 1 << extra_dbits[code13]; n++) {
          _dist_code[dist++] = code13;
        }
      }
      dist >>= 7;
      for (; code13 < D_CODES; code13++) {
        base_dist[code13] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code13] - 7; n++) {
          _dist_code[256 + dist++] = code13;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf3, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf3, len, s.pending);
      s.pending += len;
    }
    function smaller(tree2, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree2[_n2] < tree2[_m2] || tree2[_n2] === tree2[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree2, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree2, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree2, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code13;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code13 = _length_code[lc];
            send_code(s, code13 + LITERALS + 1, ltree);
            extra = extra_lbits[code13];
            if (extra !== 0) {
              lc -= base_length[code13];
              send_bits(s, lc, extra);
            }
            dist--;
            code13 = d_code(dist);
            send_code(s, code13, dtree);
            extra = extra_dbits[code13];
            if (extra !== 0) {
              dist -= base_dist[code13];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree2 = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree2[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree2[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree2[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree2, n);
      }
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree2, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree2[node * 2] = tree2[n * 2] + tree2[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree2[n * 2 + 1] = tree2[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree2, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s, desc);
      gen_codes(tree2, max_code, s.bl_count);
    }
    function scan_tree(s, tree2, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree2[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree2[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree2[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree2, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree2[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree2[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf3, stored_len, last15) {
      send_bits(s, (STORED_BLOCK << 1) + (last15 ? 1 : 0), 3);
      copy_block(s, buf3, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf3, stored_len, last15) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf3 !== -1) {
        _tr_stored_block(s, buf3, stored_len, last15);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last15 ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last15 ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last15) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports2._tr_init = _tr_init;
    exports2._tr_stored_block = _tr_stored_block;
    exports2._tr_flush_block = _tr_flush_block;
    exports2._tr_tally = _tr_tally;
    exports2._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    "use strict";
    init_globals();
    function adler32(adler, buf3, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf3[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    "use strict";
    init_globals();
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf3, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf3[i]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version"
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports2) {
    "use strict";
    init_globals();
    var utils = require_common2();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf3) {
      var len = buf3.length;
      while (--len >= 0) {
        buf3[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last15) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last15);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf3, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf3, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf3, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf3, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush3) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush3 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush3 === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush3) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush3 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush3 === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush3) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush3 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush3 === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush3) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush3 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush3 === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush3) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush3 === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush3 === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      new Config(0, 0, 0, 0, deflate_stored),
      new Config(4, 4, 8, 4, deflate_fast),
      new Config(4, 5, 16, 8, deflate_fast),
      new Config(4, 6, 32, 32, deflate_fast),
      new Config(4, 4, 16, 16, deflate_slow),
      new Config(8, 16, 32, 32, deflate_slow),
      new Config(8, 16, 128, 128, deflate_slow),
      new Config(8, 32, 128, 256, deflate_slow),
      new Config(32, 128, 258, 1024, deflate_slow),
      new Config(32, 258, 258, 4096, deflate_slow)
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap2 = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap2 = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap2 = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap2;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush3) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush3 > Z_BLOCK || flush3 < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush3 !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush3;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush3) <= rank(old_flush) && flush3 !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush3 !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush3) : s.strategy === Z_RLE ? deflate_rle(s, flush3) : configuration_table[s.level].func(s, flush3);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush3 === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush3 !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush3 === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush3 !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap2;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap2 = s.wrap;
      if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap2 === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap2 === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap2;
      return Z_OK;
    }
    exports2.deflateInit = deflateInit;
    exports2.deflateInit2 = deflateInit2;
    exports2.deflateReset = deflateReset;
    exports2.deflateResetKeep = deflateResetKeep;
    exports2.deflateSetHeader = deflateSetHeader;
    exports2.deflate = deflate;
    exports2.deflateEnd = deflateEnd;
    exports2.deflateSetDictionary = deflateSetDictionary;
    exports2.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports2) {
    "use strict";
    init_globals();
    var utils = require_common2();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports2.string2buf = function(str) {
      var buf3, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf3 = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf3[i++] = c;
        } else if (c < 2048) {
          buf3[i++] = 192 | c >>> 6;
          buf3[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf3[i++] = 224 | c >>> 12;
          buf3[i++] = 128 | c >>> 6 & 63;
          buf3[i++] = 128 | c & 63;
        } else {
          buf3[i++] = 240 | c >>> 18;
          buf3[i++] = 128 | c >>> 12 & 63;
          buf3[i++] = 128 | c >>> 6 & 63;
          buf3[i++] = 128 | c & 63;
        }
      }
      return buf3;
    };
    function buf2binstring(buf3, len) {
      if (len < 65534) {
        if (buf3.subarray && STR_APPLY_UIA_OK || !buf3.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf3, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf3[i]);
      }
      return result;
    }
    exports2.buf2binstring = function(buf3) {
      return buf2binstring(buf3, buf3.length);
    };
    exports2.binstring2buf = function(str) {
      var buf3 = new utils.Buf8(str.length);
      for (var i = 0, len = buf3.length; i < len; i++) {
        buf3[i] = str.charCodeAt(i);
      }
      return buf3;
    };
    exports2.buf2string = function(buf3, max) {
      var i, out, c, c_len;
      var len = max || buf3.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf3[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf3[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports2.utf8border = function(buf3, max) {
      var pos;
      max = max || buf3.length;
      if (max > buf3.length) {
        max = buf3.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf3[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf3[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    "use strict";
    init_globals();
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports2) {
    "use strict";
    init_globals();
    var zlib_deflate = require_deflate();
    var utils = require_common2();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString6 = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString6.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize2 = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString6.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize2);
          strm.next_out = 0;
          strm.avail_out = chunkSize2;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports2.Deflate = Deflate;
    exports2.deflate = deflate;
    exports2.deflateRaw = deflateRaw;
    exports2.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    "use strict";
    init_globals();
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last15;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from5;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last15 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from5 = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from5 += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from5++];
                            } while (--op);
                            from5 = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from5 += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from5++];
                            } while (--op);
                            from5 = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from5++];
                              } while (--op);
                              from5 = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from5 += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from5++];
                            } while (--op);
                            from5 = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from5++];
                          output[_out++] = from_source[from5++];
                          output[_out++] = from_source[from5++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from5++];
                          if (len > 1) {
                            output[_out++] = from_source[from5++];
                          }
                        }
                      } else {
                        from5 = _out - dist;
                        do {
                          output[_out++] = output[from5++];
                          output[_out++] = output[from5++];
                          output[_out++] = output[from5++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from5++];
                          if (len > 1) {
                            output[_out++] = output[from5++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last15 && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last15 ? 5 + (last15 - _in) : 5 - (_in - last15);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    "use strict";
    init_globals();
    var utils = require_common2();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base4 = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base4 = extra = work;
        end = 19;
      } else if (type === LENS) {
        base4 = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base4 = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base4[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports2) {
    "use strict";
    init_globals();
    var utils = require_common2();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE3 = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap2;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap2 = 0;
        windowBits = -windowBits;
      } else {
        wrap2 = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap2;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src3, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src3, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src3, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src3, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush3) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from5;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(state.head.extra, input, next, copy, len);
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush3 === Z_BLOCK || flush3 === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush3 === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush3 === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush3 === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from5 = state.wsize - copy;
                } else {
                  from5 = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from5 = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from5++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE3;
            case DONE3:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush3 !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush3 === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports2.inflateReset = inflateReset;
    exports2.inflateReset2 = inflateReset2;
    exports2.inflateResetKeep = inflateResetKeep;
    exports2.inflateInit = inflateInit;
    exports2.inflateInit2 = inflateInit2;
    exports2.inflate = inflate;
    exports2.inflateEnd = inflateEnd;
    exports2.inflateGetHeader = inflateGetHeader;
    exports2.inflateSetDictionary = inflateSetDictionary;
    exports2.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_BUF_ERROR: -5,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports2, module2) {
    "use strict";
    init_globals();
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports2) {
    "use strict";
    init_globals();
    var zlib_inflate = require_inflate();
    var utils = require_common2();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString6 = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString6.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize2 = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString6.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize2);
          strm.next_out = 0;
          strm.avail_out = chunkSize2;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize2 - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports2.Inflate = Inflate;
    exports2.inflate = inflate;
    exports2.inflateRaw = inflateRaw;
    exports2.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var assign = require_common2().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module2.exports = pako;
  }
});

// node_modules/it-to-buffer/index.js
var require_it_to_buffer = __commonJS({
  "node_modules/it-to-buffer/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    async function toBuffer2(stream) {
      let buffer3 = new Uint8Array(0);
      for await (const buf3 of stream) {
        buffer3 = uint8ArrayConcat([buffer3, buf3], buffer3.length + buf3.length);
      }
      return buffer3;
    }
    module2.exports = toBuffer2;
  }
});

// node_modules/just-safe-set/index.js
var require_just_safe_set = __commonJS({
  "node_modules/just-safe-set/index.js"(exports2, module2) {
    init_globals();
    module2.exports = set2;
    function set2(obj, propsArg, value) {
      var props, lastProp;
      if (Array.isArray(propsArg)) {
        props = propsArg.slice(0);
      }
      if (typeof propsArg == "string") {
        props = propsArg.split(".");
      }
      if (typeof propsArg == "symbol") {
        props = [propsArg];
      }
      if (!Array.isArray(props)) {
        throw new Error("props arg must be an array, a string or a symbol");
      }
      lastProp = props.pop();
      if (!lastProp) {
        return false;
      }
      prototypeCheck(lastProp);
      var thisProp;
      while (thisProp = props.shift()) {
        prototypeCheck(thisProp);
        if (typeof obj[thisProp] == "undefined") {
          obj[thisProp] = {};
        }
        obj = obj[thisProp];
        if (!obj || typeof obj != "object") {
          return false;
        }
      }
      obj[lastProp] = value;
      return true;
    }
    function prototypeCheck(prop) {
      if (prop === "__proto__" || prop === "constructor" || prop === "prototype") {
        throw new Error("setting of prototype values not supported");
      }
    }
  }
});

// node_modules/it-first/index.js
var require_it_first = __commonJS({
  "node_modules/it-first/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var first4 = async (source) => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    };
    module2.exports = first4;
  }
});

// node_modules/multiaddr-to-uri/index.js
var require_multiaddr_to_uri = __commonJS({
  "node_modules/multiaddr-to-uri/index.js"(exports2, module2) {
    init_globals();
    var { Multiaddr: Multiaddr22 } = require_src();
    var reduceValue = (_, v) => v;
    var tcpUri = (str, port, parts, opts) => {
      if (opts && opts.assumeHttp === false)
        return `tcp://${str}:${port}`;
      let protocol = "tcp";
      let explicitPort = `:${port}`;
      const last15 = parts[parts.length - 1];
      if (last15.protocol === "tcp") {
        protocol = port === "443" ? "https" : "http";
        explicitPort = port === "443" || port === "80" ? "" : explicitPort;
      }
      return `${protocol}://${str}${explicitPort}`;
    };
    var Reducers = {
      ip4: reduceValue,
      ip6: (str, content, i, parts) => parts.length === 1 && parts[0].protocol === "ip6" ? content : `[${content}]`,
      tcp: (str, content, i, parts, opts) => parts.some((p) => ["http", "https", "ws", "wss"].includes(p.protocol)) ? `${str}:${content}` : tcpUri(str, content, parts, opts),
      udp: (str, content) => `udp://${str}:${content}`,
      dnsaddr: reduceValue,
      dns4: reduceValue,
      dns6: reduceValue,
      ipfs: (str, content) => `${str}/ipfs/${content}`,
      p2p: (str, content) => `${str}/p2p/${content}`,
      http: (str) => `http://${str}`,
      https: (str) => `https://${str}`,
      ws: (str) => `ws://${str}`,
      wss: (str) => `wss://${str}`,
      "p2p-websocket-star": (str) => `${str}/p2p-websocket-star`,
      "p2p-webrtc-star": (str) => `${str}/p2p-webrtc-star`,
      "p2p-webrtc-direct": (str) => `${str}/p2p-webrtc-direct`
    };
    module2.exports = (multiaddr, opts) => {
      const ma = new Multiaddr22(multiaddr);
      const parts = multiaddr.toString().split("/").slice(1);
      return ma.tuples().map((tuple) => ({
        protocol: parts.shift(),
        content: tuple[1] ? parts.shift() : null
      })).reduce((str, part, i, parts2) => {
        const reduce2 = Reducers[part.protocol];
        if (!reduce2)
          throw new Error(`Unsupported protocol ${part.protocol}`);
        return reduce2(str, part.content, i, parts2, opts);
      }, "");
    };
  }
});

// node_modules/array-shuffle/index.js
var require_array_shuffle = __commonJS({
  "node_modules/array-shuffle/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = (array) => {
      if (!Array.isArray(array)) {
        throw new TypeError(`Expected an array, got ${typeof array}`);
      }
      array = [...array];
      for (let index = array.length - 1; index > 0; index--) {
        const newIndex = Math.floor(Math.random() * (index + 1));
        [array[index], array[newIndex]] = [array[newIndex], array[index]];
      }
      return array;
    };
  }
});

// node_modules/mortice/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/mortice/lib/constants.js"(exports2, module2) {
    init_globals();
    module2.exports = {
      WORKER_REQUEST_READ_LOCK: "lock:worker:request-read",
      WORKER_RELEASE_READ_LOCK: "lock:worker:release-read",
      MASTER_GRANT_READ_LOCK: "lock:master:grant-read",
      WORKER_REQUEST_WRITE_LOCK: "lock:worker:request-write",
      WORKER_RELEASE_WRITE_LOCK: "lock:worker:release-write",
      MASTER_GRANT_WRITE_LOCK: "lock:master:grant-write"
    };
  }
});

// (disabled):cluster
var require_cluster = __commonJS({
  "(disabled):cluster"() {
    init_globals();
  }
});

// node_modules/mortice/lib/node.js
var require_node = __commonJS({
  "node_modules/mortice/lib/node.js"(exports2, module2) {
    init_globals();
    var EventEmitter4 = require_events().EventEmitter;
    var { nanoid: nanoid2 } = (init_index_browser(), __toCommonJS(index_browser_exports));
    var {
      WORKER_REQUEST_READ_LOCK,
      WORKER_RELEASE_READ_LOCK,
      MASTER_GRANT_READ_LOCK,
      WORKER_REQUEST_WRITE_LOCK,
      WORKER_RELEASE_WRITE_LOCK,
      MASTER_GRANT_WRITE_LOCK
    } = require_constants2();
    var cluster;
    var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
      return (worker, requestEvent) => {
        if (requestEvent && requestEvent.type === requestType) {
          emitter.emit(masterEvent, requestEvent.name, () => {
            worker.send({
              type: grantType,
              name: requestEvent.name,
              identifier: requestEvent.identifier
            });
            return new Promise((resolve11) => {
              const releaseEventListener = (releaseEvent) => {
                if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                  worker.removeListener("message", releaseEventListener);
                  resolve11();
                }
              };
              worker.on("message", releaseEventListener);
            });
          });
        }
      };
    };
    var makeWorkerLockRequest = (name10, requestType, grantType, releaseType) => {
      return () => {
        const id = nanoid2();
        process.send({
          type: requestType,
          identifier: id,
          name: name10
        });
        return new Promise((resolve11) => {
          const listener = (event) => {
            if (event && event.type === grantType && event.identifier === id) {
              process.removeListener("message", listener);
              resolve11(() => {
                process.send({
                  type: releaseType,
                  identifier: id,
                  name: name10
                });
              });
            }
          };
          process.on("message", listener);
        });
      };
    };
    module2.exports = (options) => {
      try {
        cluster = require_cluster();
        if (!Object.keys(cluster).length) {
          return;
        }
      } catch (_) {
        return;
      }
      if (cluster.isMaster || options.singleProcess) {
        const emitter = new EventEmitter4();
        cluster.on("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
        cluster.on("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
        return emitter;
      }
      return {
        isWorker: true,
        readLock: (name10) => makeWorkerLockRequest(name10, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
        writeLock: (name10) => makeWorkerLockRequest(name10, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
      };
    };
  }
});

// node_modules/observable-webworkers/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/observable-webworkers/lib/index.js"(exports2, module2) {
    init_globals();
    var events2 = {};
    var observable = (worker) => {
      worker.addEventListener("message", (event) => {
        observable.dispatchEvent("message", worker, event);
      });
      if (worker.port) {
        worker.port.addEventListener("message", (event) => {
          observable.dispatchEvent("message", worker, event);
        });
      }
    };
    observable.addEventListener = (type, fn) => {
      if (!events2[type]) {
        events2[type] = [];
      }
      events2[type].push(fn);
    };
    observable.removeEventListener = (type, fn) => {
      if (!events2[type]) {
        return;
      }
      events2[type] = events2[type].filter((listener) => listener === fn);
    };
    observable.dispatchEvent = function() {
      const args = Array.prototype.slice.call(arguments);
      const type = args.shift();
      if (!events2[type]) {
        return;
      }
      events2[type].forEach((fn) => fn.apply(null, args));
    };
    module2.exports = observable;
  }
});

// node_modules/mortice/lib/browser.js
var require_browser4 = __commonJS({
  "node_modules/mortice/lib/browser.js"(exports2, module2) {
    init_globals();
    var EventEmitter4 = require_events().EventEmitter;
    var { nanoid: nanoid2 } = (init_index_browser(), __toCommonJS(index_browser_exports));
    var {
      WORKER_REQUEST_READ_LOCK,
      WORKER_RELEASE_READ_LOCK,
      MASTER_GRANT_READ_LOCK,
      WORKER_REQUEST_WRITE_LOCK,
      WORKER_RELEASE_WRITE_LOCK,
      MASTER_GRANT_WRITE_LOCK
    } = require_constants2();
    var observer = require_lib5();
    var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
      return (worker, event) => {
        if (!event || !event.data || event.data.type !== requestType) {
          return;
        }
        const requestEvent = {
          type: event.data.type,
          name: event.data.name,
          identifier: event.data.identifier
        };
        emitter.emit(masterEvent, requestEvent.name, () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          return new Promise((resolve11) => {
            const releaseEventListener = (event2) => {
              if (!event2 || !event2.data) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve11();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        });
      };
    };
    var makeWorkerLockRequest = (name10, requestType, grantType, releaseType) => {
      return () => {
        const id = nanoid2();
        globalThis.postMessage({
          type: requestType,
          identifier: id,
          name: name10
        });
        return new Promise((resolve11) => {
          const listener = (event) => {
            if (!event || !event.data) {
              return;
            }
            const responseEvent = {
              type: event.data.type,
              identifier: event.data.identifier
            };
            if (responseEvent && responseEvent.type === grantType && responseEvent.identifier === id) {
              globalThis.removeEventListener("message", listener);
              resolve11(() => {
                globalThis.postMessage({
                  type: releaseType,
                  identifier: id,
                  name: name10
                });
              });
            }
          };
          globalThis.addEventListener("message", listener);
        });
      };
    };
    var defaultOptions16 = {
      singleProcess: false
    };
    module2.exports = (options) => {
      options = Object.assign({}, defaultOptions16, options);
      const isMaster = !!globalThis.document || options.singleProcess;
      if (isMaster) {
        const emitter = new EventEmitter4();
        observer.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
        observer.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
        return emitter;
      }
      return {
        isWorker: true,
        readLock: (name10) => makeWorkerLockRequest(name10, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
        writeLock: (name10) => makeWorkerLockRequest(name10, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
      };
    };
  }
});

// node_modules/promise-timeout/index.js
var require_promise_timeout = __commonJS({
  "node_modules/promise-timeout/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var TimeoutError2;
    var timeout = module2.exports.timeout = function(promise, timeoutMillis) {
      var error = new TimeoutError2(), timeout2;
      return Promise.race([
        promise,
        new Promise(function(resolve11, reject) {
          timeout2 = setTimeout(function() {
            reject(error);
          }, timeoutMillis);
        })
      ]).then(function(v) {
        clearTimeout(timeout2);
        return v;
      }, function(err) {
        clearTimeout(timeout2);
        throw err;
      });
    };
    TimeoutError2 = module2.exports.TimeoutError = function() {
      Error.call(this);
      this.stack = Error().stack;
      this.message = "Timeout";
    };
    TimeoutError2.prototype = Object.create(Error.prototype);
    TimeoutError2.prototype.name = "TimeoutError";
  }
});

// node_modules/mortice/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/mortice/lib/index.js"(exports2, module2) {
    init_globals();
    var node = require_node();
    var browser = require_browser4();
    var { default: Queue4 } = require_dist();
    var { timeout } = require_promise_timeout();
    var observe = require_lib5();
    var mutexes = {};
    var implementation;
    function createReleaseable(queue, options) {
      let res;
      const p = new Promise((resolve11) => {
        res = resolve11;
      });
      queue.add(() => timeout((() => {
        return new Promise((resolve11) => {
          res(() => {
            resolve11();
          });
        });
      })(), options.timeout));
      return p;
    }
    var createMutex = (name10, options) => {
      if (implementation.isWorker) {
        return {
          readLock: implementation.readLock(name10, options),
          writeLock: implementation.writeLock(name10, options)
        };
      }
      const masterQueue = new Queue4({ concurrency: 1 });
      let readQueue = null;
      return {
        readLock: () => {
          if (readQueue) {
            return createReleaseable(readQueue, options);
          }
          readQueue = new Queue4({
            concurrency: options.concurrency,
            autoStart: false
          });
          const localReadQueue = readQueue;
          const readPromise = createReleaseable(readQueue, options);
          masterQueue.add(() => {
            localReadQueue.start();
            return localReadQueue.onIdle().then(() => {
              if (readQueue === localReadQueue) {
                readQueue = null;
              }
            });
          });
          return readPromise;
        },
        writeLock: () => {
          readQueue = null;
          return createReleaseable(masterQueue, options);
        }
      };
    };
    var defaultOptions16 = {
      concurrency: Infinity,
      timeout: 846e5,
      global,
      singleProcess: false
    };
    module2.exports = (name10, options) => {
      if (!options) {
        options = {};
      }
      if (typeof name10 === "object") {
        options = name10;
        name10 = "lock";
      }
      if (!name10) {
        name10 = "lock";
      }
      options = Object.assign({}, defaultOptions16, options);
      if (!implementation) {
        implementation = node(options) || browser(options);
        if (!implementation.isWorker) {
          implementation.on("requestReadLock", (name11, fn) => {
            if (!mutexes[name11]) {
              return;
            }
            mutexes[name11].readLock().then((release) => fn().finally(() => release()));
          });
          implementation.on("requestWriteLock", async (name11, fn) => {
            if (!mutexes[name11]) {
              return;
            }
            mutexes[name11].writeLock().then((release) => fn().finally(() => release()));
          });
        }
      }
      if (!mutexes[name10]) {
        mutexes[name10] = createMutex(name10, options);
      }
      return mutexes[name10];
    };
    module2.exports.Worker = function(script, Impl) {
      Impl = Impl || global.Worker;
      let worker;
      try {
        worker = new Impl(script);
      } catch (error) {
        if (error.message.includes("not a constructor")) {
          worker = Impl(script);
        }
      }
      if (!worker) {
        throw new Error("Could not create Worker from", Impl);
      }
      observe(worker);
      return worker;
    };
  }
});

// node_modules/just-safe-get/index.js
var require_just_safe_get = __commonJS({
  "node_modules/just-safe-get/index.js"(exports2, module2) {
    init_globals();
    module2.exports = get6;
    function get6(obj, propsArg, defaultValue) {
      if (!obj) {
        return defaultValue;
      }
      var props, prop;
      if (Array.isArray(propsArg)) {
        props = propsArg.slice(0);
      }
      if (typeof propsArg == "string") {
        props = propsArg.split(".");
      }
      if (typeof propsArg == "symbol") {
        props = [propsArg];
      }
      if (!Array.isArray(props)) {
        throw new Error("props arg must be an array, a string or a symbol");
      }
      while (props.length) {
        prop = props.shift();
        if (!obj) {
          return defaultValue;
        }
        obj = obj[prop];
        if (obj === void 0) {
          return defaultValue;
        }
      }
      return obj;
    }
  }
});

// node_modules/it-length/index.js
var require_it_length = __commonJS({
  "node_modules/it-length/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var length5 = async (iterator) => {
      let count = 0;
      for await (const _ of iterator) {
        count++;
      }
      return count;
    };
    module2.exports = length5;
  }
});

// node_modules/fnv1a/index.js
var require_fnv1a = __commonJS({
  "node_modules/fnv1a/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    hash2.BASE = 2166136261;
    function hash2(s, h = hash2.BASE) {
      const l = s.length;
      for (let i = 0; i < l; i++) {
        h ^= s.charCodeAt(i);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
      }
      return h >>> 0;
    }
    exports2.default = hash2;
    module2.exports = hash2;
  }
});

// node_modules/uint8arrays/esm/src/compare.js
var compare_exports = {};
__export(compare_exports, {
  compare: () => compare2
});
function compare2(a, b) {
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] < b[i]) {
      return -1;
    }
    if (a[i] > b[i]) {
      return 1;
    }
  }
  if (a.byteLength > b.byteLength) {
    return 1;
  }
  if (a.byteLength < b.byteLength) {
    return -1;
  }
  return 0;
}
var init_compare = __esm({
  "node_modules/uint8arrays/esm/src/compare.js"() {
    init_globals();
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = bytes2;
    module2.exports.format = format;
    module2.exports.parse = parse2;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map12 = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value, options) {
      if (typeof value === "string") {
        return parse2(value);
      }
      if (typeof value === "number") {
        return format(value, options);
      }
      return null;
    }
    function format(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map12[unit.toLowerCase()]) {
        if (mag >= map12.pb) {
          unit = "PB";
        } else if (mag >= map12.tb) {
          unit = "TB";
        } else if (mag >= map12.gb) {
          unit = "GB";
        } else if (mag >= map12.mb) {
          unit = "MB";
        } else if (mag >= map12.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map12[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i) {
          return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse2(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map12[unit] * floatValue);
    }
  }
});

// node_modules/sort-keys/index.js
var require_sort_keys = __commonJS({
  "node_modules/sort-keys/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var isPlainObject = require_is_plain_obj();
    module2.exports = (object, options = {}) => {
      if (!isPlainObject(object) && !Array.isArray(object)) {
        throw new TypeError("Expected a plain object or array");
      }
      const { deep } = options;
      const seenInput = [];
      const seenOutput = [];
      const deepSortArray = (array) => {
        const seenIndex = seenInput.indexOf(array);
        if (seenIndex !== -1) {
          return seenOutput[seenIndex];
        }
        const result = [];
        seenInput.push(array);
        seenOutput.push(result);
        result.push(...array.map((item) => {
          if (Array.isArray(item)) {
            return deepSortArray(item);
          }
          if (isPlainObject(item)) {
            return sortKeys2(item);
          }
          return item;
        }));
        return result;
      };
      const sortKeys2 = (object2) => {
        const seenIndex = seenInput.indexOf(object2);
        if (seenIndex !== -1) {
          return seenOutput[seenIndex];
        }
        const result = {};
        const keys2 = Object.keys(object2).sort(options.compare);
        seenInput.push(object2);
        seenOutput.push(result);
        for (const key of keys2) {
          const value = object2[key];
          let newValue;
          if (deep && Array.isArray(value)) {
            newValue = deepSortArray(value);
          } else {
            newValue = deep && isPlainObject(value) ? sortKeys2(value) : value;
          }
          Object.defineProperty(result, key, {
            ...Object.getOwnPropertyDescriptor(object2, key),
            value: newValue
          });
        }
        return result;
      };
      if (Array.isArray(object)) {
        return deep ? deepSortArray(object) : object.slice();
      }
      return sortKeys2(object);
    };
  }
});

// node_modules/it-sort/index.js
var require_it_sort = __commonJS({
  "node_modules/it-sort/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var all6 = require_it_all();
    var sort2 = async function* (source, sorter) {
      const arr = await all6(source);
      yield* arr.sort(sorter);
    };
    module2.exports = sort2;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    init_globals();
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    init_globals();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice3 = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice3.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice3.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice3.call(arguments)));
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src10 = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray2 = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray2,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name10) {
      var value;
      if (name10 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name10 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name10 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name10 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name10 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name10] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src10();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string3) {
      var first4 = $strSlice(string3, 0, 1);
      var last15 = $strSlice(string3, -1);
      if (first4 === "%" && last15 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last15 === "%" && first4 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string3, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name10, allowMissing) {
      var intrinsicName = name10;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name10 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name10 + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name10, allowMissing) {
      if (typeof name10 !== "string" || name10.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name10);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first4 = $strSlice(part, 0, 1);
        var last15 = $strSlice(part, -1);
        if ((first4 === '"' || first4 === "'" || first4 === "`" || (last15 === '"' || last15 === "'" || last15 === "`")) && first4 !== last15) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name10 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    init_globals();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name10, allowMissing) {
      var intrinsic = GetIntrinsic(name10, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name10, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module2.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var documentDotAll = typeof document === "object" && typeof document.all === "undefined" && document.all !== void 0 ? document.all : {};
    module2.exports = reflectApply ? function isCallable(value) {
      if (value === documentDotAll) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (typeof value === "function" && !value.prototype) {
        return true;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value);
    } : function isCallable(value) {
      if (value === documentDotAll) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (typeof value === "function" && !value.prototype) {
        return true;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      return strClass === fnClass || strClass === genClass;
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string3, iterator, receiver) {
      for (var i = 0, len = string3.length; i < len; i++) {
        if (receiver == null) {
          iterator(string3.charAt(i), i, string3);
        } else {
          iterator.call(receiver, string3.charAt(i), i, string3);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module2.exports = forEach;
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g = typeof globalThis === "undefined" ? global : globalThis;
    module2.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
var require_getOwnPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js"(exports2, module2) {
    "use strict";
    init_globals();
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var gOPD = require_getOwnPropertyDescriptor();
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e) {
          }
        }
      });
      return anyTrue;
    };
    module2.exports = function isTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var gOPD = require_getOwnPropertyDescriptor();
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        if (typeof g[typedArray] === "function") {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var foundName = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name10 = getter.call(value);
            if (name10 === typedArray) {
              foundName = name10;
            }
          } catch (e) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray = require_is_typed_array();
    module2.exports = function whichTypedArray(value) {
      if (!isTypedArray(value)) {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        return $slice($toString(value), 8, -1);
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/util/support/types.js"(exports2) {
    "use strict";
    init_globals();
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction;
    exports2.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports2.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports2.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports2, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports2, module2) {
    init_globals();
    module2.exports = function isBuffer5(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    init_globals();
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util/util.js
var require_util3 = __commonJS({
  "node_modules/util/util.js"(exports2) {
    init_globals();
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys2 = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys2.length; i++) {
        descriptors[keys2[i]] = Object.getOwnPropertyDescriptor(obj, keys2[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports2.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports2.debuglog = function(set2) {
      set2 = set2.toUpperCase();
      if (!debugs[set2]) {
        if (debugEnvRegex.test(set2)) {
          var pid = process.pid;
          debugs[set2] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set2, pid, msg);
          };
        } else {
          debugs[set2] = function() {
          };
        }
      }
      return debugs[set2];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports2.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash2 = {};
      array.forEach(function(val, idx) {
        hash2[val] = true;
      });
      return hash2;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports2.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys2 = Object.keys(value);
      var visibleKeys = arrayToHash(keys2);
      if (ctx.showHidden) {
        keys2 = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys2.length === 0) {
        if (isFunction(value)) {
          var name10 = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name10 + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base4 = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base4 = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base4 = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base4 = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base4 = " " + formatError(value);
      }
      if (keys2.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base4 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
      } else {
        output = keys2.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base4, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push("");
        }
      }
      keys2.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name10, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name10 = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").substr(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name10)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name10 = JSON.stringify("" + key);
        if (name10.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name10 = name10.substr(1, name10.length - 2);
          name10 = ctx.stylize(name10, "name");
        } else {
          name10 = name10.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name10 = ctx.stylize(name10, "string");
        }
      }
      return name10 + ": " + str;
    }
    function reduceToSingleString(output, base4, braces) {
      var numLinesEst = 0;
      var length5 = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length5 > 60) {
        return braces[0] + (base4 === "" ? "" : base4 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base4 + " " + output.join(", ") + " " + braces[1];
    }
    exports2.types = require_types();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    exports2.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    exports2.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports2.isError = isError;
    exports2.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = require_inherits_browser();
    exports2._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys2 = Object.keys(add);
      var i = keys2.length;
      while (i--) {
        origin[keys2[i]] = add[keys2[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve11, reject) {
          promiseResolve = resolve11;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(function(ret) {
          process.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
          process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }
    exports2.callbackify = callbackify;
  }
});

// node_modules/level-supports/index.js
var require_level_supports = __commonJS({
  "node_modules/level-supports/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = function supports(...manifests) {
      const manifest = manifests.reduce((acc, m) => Object.assign(acc, m), {});
      return Object.assign(manifest, {
        bufferKeys: manifest.bufferKeys || false,
        snapshots: manifest.snapshots || false,
        permanence: manifest.permanence || false,
        seek: manifest.seek || false,
        clear: manifest.clear || false,
        getMany: manifest.getMany || false,
        keyIterator: manifest.keyIterator || false,
        valueIterator: manifest.valueIterator || false,
        iteratorNextv: manifest.iteratorNextv || false,
        iteratorAll: manifest.iteratorAll || false,
        status: manifest.status || false,
        idempotentOpen: manifest.idempotentOpen || false,
        passiveOpen: manifest.passiveOpen || false,
        serialize: manifest.serialize || false,
        createIfMissing: manifest.createIfMissing || false,
        errorIfExists: manifest.errorIfExists || false,
        deferredOpen: manifest.deferredOpen || false,
        openCallback: manifest.openCallback || false,
        promises: manifest.promises || false,
        streams: manifest.streams || false,
        encodings: maybeObject(manifest.encodings),
        events: maybeObject(manifest.events),
        additionalMethods: Object.assign({}, manifest.additionalMethods)
      });
    };
    function maybeObject(value) {
      return !value ? false : Object.assign({}, value);
    }
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports2, module2) {
    init_globals();
    module2.exports = function isBuffer5(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// node_modules/catering/next-tick-browser.js
var require_next_tick_browser = __commonJS({
  "node_modules/catering/next-tick-browser.js"(exports2, module2) {
    init_globals();
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
  }
});

// node_modules/catering/index.js
var require_catering = __commonJS({
  "node_modules/catering/index.js"(exports2) {
    "use strict";
    init_globals();
    var nextTick = require_next_tick_browser();
    exports2.fromCallback = function(callback, symbol) {
      if (callback === void 0) {
        var promise = new Promise(function(resolve11, reject) {
          callback = function(err, res) {
            if (err)
              reject(err);
            else
              resolve11(res);
          };
        });
        callback[symbol !== void 0 ? symbol : "promise"] = promise;
      } else if (typeof callback !== "function") {
        throw new TypeError("Callback must be a function");
      }
      return callback;
    };
    exports2.fromPromise = function(promise, callback) {
      if (callback === void 0)
        return promise;
      promise.then(function(res) {
        nextTick(() => callback(null, res));
      }).catch(function(err) {
        nextTick(() => callback(err));
      });
    };
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports2, module2) {
    init_globals();
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/abstract-leveldown/next-tick-browser.js
var require_next_tick_browser2 = __commonJS({
  "node_modules/abstract-leveldown/next-tick-browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    var queueMicrotask2 = require_queue_microtask();
    module2.exports = function(fn, ...args) {
      if (args.length === 0) {
        queueMicrotask2(fn);
      } else {
        queueMicrotask2(() => fn(...args));
      }
    };
  }
});

// node_modules/abstract-leveldown/abstract-iterator.js
var require_abstract_iterator = __commonJS({
  "node_modules/abstract-leveldown/abstract-iterator.js"(exports2, module2) {
    "use strict";
    init_globals();
    function AbstractIterator(db) {
      if (typeof db !== "object" || db === null) {
        throw new TypeError("First argument must be an abstract-leveldown compliant store");
      }
      this.db = db;
      this._ended = false;
      this._nexting = false;
    }
    AbstractIterator.prototype.next = function(callback) {
      let ret = this;
      if (callback === void 0) {
        ret = new Promise(function(resolve11, reject) {
          callback = function(err, key, value) {
            if (err)
              reject(err);
            else if (key === void 0 && value === void 0)
              resolve11();
            else
              resolve11([key, value]);
          };
        });
      } else if (typeof callback !== "function") {
        throw new Error("next() requires a callback argument");
      }
      if (this._ended) {
        this._nextTick(callback, new Error("cannot call next() after end()"));
        return ret;
      }
      if (this._nexting) {
        this._nextTick(callback, new Error("cannot call next() before previous next() has completed"));
        return ret;
      }
      this._nexting = true;
      this._next((err, ...rest) => {
        this._nexting = false;
        callback(err, ...rest);
      });
      return ret;
    };
    AbstractIterator.prototype._next = function(callback) {
      this._nextTick(callback);
    };
    AbstractIterator.prototype.seek = function(target) {
      if (this._ended) {
        throw new Error("cannot call seek() after end()");
      }
      if (this._nexting) {
        throw new Error("cannot call seek() before next() has completed");
      }
      target = this.db._serializeKey(target);
      this._seek(target);
    };
    AbstractIterator.prototype._seek = function(target) {
    };
    AbstractIterator.prototype.end = function(callback) {
      let promise;
      if (callback === void 0) {
        promise = new Promise(function(resolve11, reject) {
          callback = function(err) {
            if (err)
              reject(err);
            else
              resolve11();
          };
        });
      } else if (typeof callback !== "function") {
        throw new Error("end() requires a callback argument");
      }
      if (this._ended) {
        this._nextTick(callback, new Error("end() already called on iterator"));
        return promise;
      }
      this._ended = true;
      this._end(callback);
      return promise;
    };
    AbstractIterator.prototype._end = function(callback) {
      this._nextTick(callback);
    };
    AbstractIterator.prototype[Symbol.asyncIterator] = async function* () {
      try {
        let kv;
        while ((kv = await this.next()) !== void 0) {
          yield kv;
        }
      } finally {
        if (!this._ended)
          await this.end();
      }
    };
    AbstractIterator.prototype._nextTick = require_next_tick_browser2();
    module2.exports = AbstractIterator;
  }
});

// node_modules/abstract-leveldown/abstract-chained-batch.js
var require_abstract_chained_batch = __commonJS({
  "node_modules/abstract-leveldown/abstract-chained-batch.js"(exports2, module2) {
    "use strict";
    init_globals();
    var emptyOptions = Object.freeze({});
    function AbstractChainedBatch(db) {
      if (typeof db !== "object" || db === null) {
        throw new TypeError("First argument must be an abstract-leveldown compliant store");
      }
      this.db = db;
      this._operations = [];
      this._written = false;
    }
    AbstractChainedBatch.prototype._checkWritten = function() {
      if (this._written) {
        throw new Error("write() already called on this batch");
      }
    };
    AbstractChainedBatch.prototype.put = function(key, value, options) {
      this._checkWritten();
      const err = this.db._checkKey(key) || this.db._checkValue(value);
      if (err)
        throw err;
      key = this.db._serializeKey(key);
      value = this.db._serializeValue(value);
      this._put(key, value, options != null ? options : emptyOptions);
      return this;
    };
    AbstractChainedBatch.prototype._put = function(key, value, options) {
      this._operations.push({ ...options, type: "put", key, value });
    };
    AbstractChainedBatch.prototype.del = function(key, options) {
      this._checkWritten();
      const err = this.db._checkKey(key);
      if (err)
        throw err;
      key = this.db._serializeKey(key);
      this._del(key, options != null ? options : emptyOptions);
      return this;
    };
    AbstractChainedBatch.prototype._del = function(key, options) {
      this._operations.push({ ...options, type: "del", key });
    };
    AbstractChainedBatch.prototype.clear = function() {
      this._checkWritten();
      this._clear();
      return this;
    };
    AbstractChainedBatch.prototype._clear = function() {
      this._operations = [];
    };
    AbstractChainedBatch.prototype.write = function(options, callback) {
      this._checkWritten();
      if (typeof options === "function") {
        callback = options;
      }
      if (typeof callback !== "function") {
        throw new Error("write() requires a callback argument");
      }
      if (typeof options !== "object" || options === null) {
        options = {};
      }
      this._written = true;
      this._write(options, callback);
    };
    AbstractChainedBatch.prototype._write = function(options, callback) {
      this.db._batch(this._operations, options, callback);
    };
    AbstractChainedBatch.prototype._nextTick = require_next_tick_browser2();
    module2.exports = AbstractChainedBatch;
  }
});

// node_modules/abstract-leveldown/lib/common.js
var require_common3 = __commonJS({
  "node_modules/abstract-leveldown/lib/common.js"(exports2) {
    "use strict";
    init_globals();
    exports2.getCallback = function(options, callback) {
      return typeof options === "function" ? options : callback;
    };
    exports2.getOptions = function(options) {
      return typeof options === "object" && options !== null ? options : {};
    };
  }
});

// node_modules/abstract-leveldown/abstract-leveldown.js
var require_abstract_leveldown = __commonJS({
  "node_modules/abstract-leveldown/abstract-leveldown.js"(exports2, module2) {
    "use strict";
    init_globals();
    var supports = require_level_supports();
    var isBuffer5 = require_is_buffer();
    var catering = require_catering();
    var AbstractIterator = require_abstract_iterator();
    var AbstractChainedBatch = require_abstract_chained_batch();
    var getCallback = require_common3().getCallback;
    var getOptions = require_common3().getOptions;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var rangeOptions = ["lt", "lte", "gt", "gte"];
    function AbstractLevelDOWN(manifest) {
      this.status = "new";
      this.supports = supports(manifest, {
        status: true
      });
    }
    AbstractLevelDOWN.prototype.open = function(options, callback) {
      const oldStatus = this.status;
      if (typeof options === "function")
        callback = options;
      if (typeof callback !== "function") {
        throw new Error("open() requires a callback argument");
      }
      if (typeof options !== "object" || options === null)
        options = {};
      options.createIfMissing = options.createIfMissing !== false;
      options.errorIfExists = !!options.errorIfExists;
      this.status = "opening";
      this._open(options, (err) => {
        if (err) {
          this.status = oldStatus;
          return callback(err);
        }
        this.status = "open";
        callback();
      });
    };
    AbstractLevelDOWN.prototype._open = function(options, callback) {
      this._nextTick(callback);
    };
    AbstractLevelDOWN.prototype.close = function(callback) {
      const oldStatus = this.status;
      if (typeof callback !== "function") {
        throw new Error("close() requires a callback argument");
      }
      this.status = "closing";
      this._close((err) => {
        if (err) {
          this.status = oldStatus;
          return callback(err);
        }
        this.status = "closed";
        callback();
      });
    };
    AbstractLevelDOWN.prototype._close = function(callback) {
      this._nextTick(callback);
    };
    AbstractLevelDOWN.prototype.get = function(key, options, callback) {
      if (typeof options === "function")
        callback = options;
      if (typeof callback !== "function") {
        throw new Error("get() requires a callback argument");
      }
      const err = this._checkKey(key);
      if (err)
        return this._nextTick(callback, err);
      key = this._serializeKey(key);
      if (typeof options !== "object" || options === null)
        options = {};
      options.asBuffer = options.asBuffer !== false;
      this._get(key, options, callback);
    };
    AbstractLevelDOWN.prototype._get = function(key, options, callback) {
      this._nextTick(function() {
        callback(new Error("NotFound"));
      });
    };
    AbstractLevelDOWN.prototype.getMany = function(keys2, options, callback) {
      callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      options = getOptions(options);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      if (!Array.isArray(keys2)) {
        this._nextTick(callback, new Error("getMany() requires an array argument"));
        return callback.promise;
      }
      if (keys2.length === 0) {
        this._nextTick(callback, null, []);
        return callback.promise;
      }
      if (typeof options.asBuffer !== "boolean") {
        options = { ...options, asBuffer: true };
      }
      const serialized = new Array(keys2.length);
      for (let i = 0; i < keys2.length; i++) {
        const key = keys2[i];
        const err = this._checkKey(key);
        if (err) {
          this._nextTick(callback, err);
          return callback.promise;
        }
        serialized[i] = this._serializeKey(key);
      }
      this._getMany(serialized, options, callback);
      return callback.promise;
    };
    AbstractLevelDOWN.prototype._getMany = function(keys2, options, callback) {
      this._nextTick(callback, null, new Array(keys2.length).fill(void 0));
    };
    AbstractLevelDOWN.prototype.put = function(key, value, options, callback) {
      if (typeof options === "function")
        callback = options;
      if (typeof callback !== "function") {
        throw new Error("put() requires a callback argument");
      }
      const err = this._checkKey(key) || this._checkValue(value);
      if (err)
        return this._nextTick(callback, err);
      key = this._serializeKey(key);
      value = this._serializeValue(value);
      if (typeof options !== "object" || options === null)
        options = {};
      this._put(key, value, options, callback);
    };
    AbstractLevelDOWN.prototype._put = function(key, value, options, callback) {
      this._nextTick(callback);
    };
    AbstractLevelDOWN.prototype.del = function(key, options, callback) {
      if (typeof options === "function")
        callback = options;
      if (typeof callback !== "function") {
        throw new Error("del() requires a callback argument");
      }
      const err = this._checkKey(key);
      if (err)
        return this._nextTick(callback, err);
      key = this._serializeKey(key);
      if (typeof options !== "object" || options === null)
        options = {};
      this._del(key, options, callback);
    };
    AbstractLevelDOWN.prototype._del = function(key, options, callback) {
      this._nextTick(callback);
    };
    AbstractLevelDOWN.prototype.batch = function(array, options, callback) {
      if (!arguments.length)
        return this._chainedBatch();
      if (typeof options === "function")
        callback = options;
      if (typeof array === "function")
        callback = array;
      if (typeof callback !== "function") {
        throw new Error("batch(array) requires a callback argument");
      }
      if (!Array.isArray(array)) {
        return this._nextTick(callback, new Error("batch(array) requires an array argument"));
      }
      if (array.length === 0) {
        return this._nextTick(callback);
      }
      if (typeof options !== "object" || options === null)
        options = {};
      const serialized = new Array(array.length);
      for (let i = 0; i < array.length; i++) {
        if (typeof array[i] !== "object" || array[i] === null) {
          return this._nextTick(callback, new Error("batch(array) element must be an object and not `null`"));
        }
        const e = Object.assign({}, array[i]);
        if (e.type !== "put" && e.type !== "del") {
          return this._nextTick(callback, new Error("`type` must be 'put' or 'del'"));
        }
        const err = this._checkKey(e.key);
        if (err)
          return this._nextTick(callback, err);
        e.key = this._serializeKey(e.key);
        if (e.type === "put") {
          const valueErr = this._checkValue(e.value);
          if (valueErr)
            return this._nextTick(callback, valueErr);
          e.value = this._serializeValue(e.value);
        }
        serialized[i] = e;
      }
      this._batch(serialized, options, callback);
    };
    AbstractLevelDOWN.prototype._batch = function(array, options, callback) {
      this._nextTick(callback);
    };
    AbstractLevelDOWN.prototype.clear = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
      } else if (typeof callback !== "function") {
        throw new Error("clear() requires a callback argument");
      }
      options = cleanRangeOptions(this, options);
      options.reverse = !!options.reverse;
      options.limit = "limit" in options ? options.limit : -1;
      this._clear(options, callback);
    };
    AbstractLevelDOWN.prototype._clear = function(options, callback) {
      options.keys = true;
      options.values = false;
      options.keyAsBuffer = true;
      options.valueAsBuffer = true;
      const iterator = this._iterator(options);
      const emptyOptions = {};
      const next = (err) => {
        if (err) {
          return iterator.end(function() {
            callback(err);
          });
        }
        iterator.next((err2, key) => {
          if (err2)
            return next(err2);
          if (key === void 0)
            return iterator.end(callback);
          this._del(key, emptyOptions, next);
        });
      };
      next();
    };
    AbstractLevelDOWN.prototype._setupIteratorOptions = function(options) {
      options = cleanRangeOptions(this, options);
      options.reverse = !!options.reverse;
      options.keys = options.keys !== false;
      options.values = options.values !== false;
      options.limit = "limit" in options ? options.limit : -1;
      options.keyAsBuffer = options.keyAsBuffer !== false;
      options.valueAsBuffer = options.valueAsBuffer !== false;
      return options;
    };
    function cleanRangeOptions(db, options) {
      const result = {};
      for (const k in options) {
        if (!hasOwnProperty.call(options, k))
          continue;
        if (k === "start" || k === "end") {
          throw new Error('Legacy range options ("start" and "end") have been removed');
        }
        let opt = options[k];
        if (isRangeOption(k)) {
          opt = db._serializeKey(opt);
        }
        result[k] = opt;
      }
      return result;
    }
    function isRangeOption(k) {
      return rangeOptions.indexOf(k) !== -1;
    }
    AbstractLevelDOWN.prototype.iterator = function(options) {
      if (typeof options !== "object" || options === null)
        options = {};
      options = this._setupIteratorOptions(options);
      return this._iterator(options);
    };
    AbstractLevelDOWN.prototype._iterator = function(options) {
      return new AbstractIterator(this);
    };
    AbstractLevelDOWN.prototype._chainedBatch = function() {
      return new AbstractChainedBatch(this);
    };
    AbstractLevelDOWN.prototype._serializeKey = function(key) {
      return key;
    };
    AbstractLevelDOWN.prototype._serializeValue = function(value) {
      return value;
    };
    AbstractLevelDOWN.prototype._checkKey = function(key) {
      if (key === null || key === void 0) {
        return new Error("key cannot be `null` or `undefined`");
      } else if (isBuffer5(key) && key.length === 0) {
        return new Error("key cannot be an empty Buffer");
      } else if (key === "") {
        return new Error("key cannot be an empty String");
      } else if (Array.isArray(key) && key.length === 0) {
        return new Error("key cannot be an empty Array");
      }
    };
    AbstractLevelDOWN.prototype._checkValue = function(value) {
      if (value === null || value === void 0) {
        return new Error("value cannot be `null` or `undefined`");
      }
    };
    AbstractLevelDOWN.prototype.isOperational = function() {
      return this.status === "open" || this._isOperational();
    };
    AbstractLevelDOWN.prototype._isOperational = function() {
      return false;
    };
    AbstractLevelDOWN.prototype._nextTick = require_next_tick_browser2();
    module2.exports = AbstractLevelDOWN;
    function maybeError(db, callback) {
      if (!db.isOperational()) {
        db._nextTick(callback, new Error("Database is not open"));
        return true;
      }
      return false;
    }
  }
});

// node_modules/abstract-leveldown/index.js
var require_abstract_leveldown2 = __commonJS({
  "node_modules/abstract-leveldown/index.js"(exports2) {
    "use strict";
    init_globals();
    exports2.AbstractLevelDOWN = require_abstract_leveldown();
    exports2.AbstractIterator = require_abstract_iterator();
    exports2.AbstractChainedBatch = require_abstract_chained_batch();
  }
});

// node_modules/deferred-leveldown/util.js
var require_util4 = __commonJS({
  "node_modules/deferred-leveldown/util.js"(exports2) {
    "use strict";
    init_globals();
    exports2.getCallback = function(args, symbol, map12) {
      let callback = args[args.length - 1];
      if (typeof callback !== "function") {
        const promise = new Promise((resolve11, reject) => {
          args.push(callback = function(err, ...results) {
            if (err)
              reject(err);
            else
              resolve11(map12 ? map12(...results) : results[0]);
          });
        });
        callback[symbol] = promise;
      }
      return callback;
    };
  }
});

// node_modules/deferred-leveldown/deferred-iterator.js
var require_deferred_iterator = __commonJS({
  "node_modules/deferred-leveldown/deferred-iterator.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { AbstractIterator } = require_abstract_leveldown2();
    var inherits = require_inherits_browser();
    var getCallback = require_util4().getCallback;
    var kOptions = Symbol("options");
    var kIterator = Symbol("iterator");
    var kOperations = Symbol("operations");
    var kPromise = Symbol("promise");
    function DeferredIterator(db, options) {
      AbstractIterator.call(this, db);
      this[kOptions] = options;
      this[kIterator] = null;
      this[kOperations] = [];
    }
    inherits(DeferredIterator, AbstractIterator);
    DeferredIterator.prototype.setDb = function(db) {
      this[kIterator] = db.iterator(this[kOptions]);
      for (const op of this[kOperations].splice(0, this[kOperations].length)) {
        this[kIterator][op.method](...op.args);
      }
    };
    DeferredIterator.prototype.next = function(...args) {
      if (this.db.status === "open") {
        return this[kIterator].next(...args);
      }
      const callback = getCallback(args, kPromise, function map12(key, value) {
        if (key === void 0 && value === void 0) {
          return void 0;
        } else {
          return [key, value];
        }
      });
      if (this.db.status === "opening") {
        this[kOperations].push({ method: "next", args });
      } else {
        this._nextTick(callback, new Error("Database is not open"));
      }
      return callback[kPromise] || this;
    };
    DeferredIterator.prototype.seek = function(...args) {
      if (this.db.status === "open") {
        this[kIterator].seek(...args);
      } else if (this.db.status === "opening") {
        this[kOperations].push({ method: "seek", args });
      } else {
        throw new Error("Database is not open");
      }
    };
    DeferredIterator.prototype.end = function(...args) {
      if (this.db.status === "open") {
        return this[kIterator].end(...args);
      }
      const callback = getCallback(args, kPromise);
      if (this.db.status === "opening") {
        this[kOperations].push({ method: "end", args });
      } else {
        this._nextTick(callback, new Error("Database is not open"));
      }
      return callback[kPromise] || this;
    };
    for (const method of ["next", "seek", "end"]) {
      DeferredIterator.prototype["_" + method] = function() {
        throw new Error("Did not expect private method to be called: " + method);
      };
    }
    module2.exports = DeferredIterator;
  }
});

// node_modules/deferred-leveldown/deferred-chained-batch.js
var require_deferred_chained_batch = __commonJS({
  "node_modules/deferred-leveldown/deferred-chained-batch.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { AbstractChainedBatch } = require_abstract_leveldown2();
    var kOperations = Symbol("operations");
    module2.exports = class DeferredChainedBatch extends AbstractChainedBatch {
      constructor(db) {
        super(db);
        this[kOperations] = [];
      }
      _put(key, value, options) {
        this[kOperations].push({ ...options, type: "put", key, value });
      }
      _del(key, options) {
        this[kOperations].push({ ...options, type: "del", key });
      }
      _clear() {
        this[kOperations] = [];
      }
      _write(options, callback) {
        this.db.batch(this[kOperations], options, callback);
      }
    };
  }
});

// node_modules/deferred-leveldown/deferred-leveldown.js
var require_deferred_leveldown = __commonJS({
  "node_modules/deferred-leveldown/deferred-leveldown.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { AbstractLevelDOWN } = require_abstract_leveldown2();
    var inherits = require_inherits_browser();
    var DeferredIterator = require_deferred_iterator();
    var DeferredChainedBatch = require_deferred_chained_batch();
    var getCallback = require_util4().getCallback;
    var deferrables = ["put", "get", "getMany", "del", "batch", "clear"];
    var optionalDeferrables = ["approximateSize", "compactRange"];
    var kInnerDb = Symbol("innerDb");
    var kOperations = Symbol("operations");
    var kPromise = Symbol("promise");
    function DeferredLevelDOWN(db) {
      AbstractLevelDOWN.call(this, db.supports || {});
      for (const m of optionalDeferrables) {
        if (typeof db[m] === "function" && !this.supports.additionalMethods[m]) {
          this.supports.additionalMethods[m] = true;
        }
      }
      this[kInnerDb] = db;
      this[kOperations] = [];
      implement(this);
    }
    inherits(DeferredLevelDOWN, AbstractLevelDOWN);
    DeferredLevelDOWN.prototype.type = "deferred-leveldown";
    Object.defineProperty(DeferredLevelDOWN.prototype, "_db", {
      enumerable: true,
      get() {
        return this[kInnerDb];
      }
    });
    DeferredLevelDOWN.prototype._open = function(options, callback) {
      const onopen = (err) => {
        if (err || this[kInnerDb].status !== "open") {
          return callback(err || new Error("Database is not open"));
        }
        const operations = this[kOperations];
        this[kOperations] = [];
        for (const op of operations) {
          if (op.iterator) {
            op.iterator.setDb(this[kInnerDb]);
          } else {
            this[kInnerDb][op.method](...op.args);
          }
        }
        if (this[kOperations].length > 0) {
          throw new Error("Did not expect further operations");
        }
        callback();
      };
      if (this[kInnerDb].status === "new" || this[kInnerDb].status === "closed") {
        this[kInnerDb].open(options, onopen);
      } else {
        this._nextTick(onopen);
      }
    };
    DeferredLevelDOWN.prototype._close = function(callback) {
      this[kInnerDb].close(callback);
    };
    DeferredLevelDOWN.prototype._isOperational = function() {
      return this.status === "opening";
    };
    function implement(self2) {
      const additionalMethods = Object.keys(self2.supports.additionalMethods);
      for (const method of deferrables.concat(additionalMethods)) {
        self2[method] = function(...args) {
          if (method === "batch" && args.length === 0) {
            return new DeferredChainedBatch(this);
          } else if (this.status === "open") {
            return this[kInnerDb][method](...args);
          }
          const callback = getCallback(args, kPromise);
          if (this.status === "opening") {
            this[kOperations].push({ method, args });
          } else {
            this._nextTick(callback, new Error("Database is not open"));
          }
          return callback[kPromise];
        };
      }
      self2.iterator = function(options) {
        if (this.status === "open") {
          return this[kInnerDb].iterator(options);
        } else if (this.status === "opening") {
          const iterator = new DeferredIterator(this, options);
          this[kOperations].push({ iterator });
          return iterator;
        } else {
          throw new Error("Database is not open");
        }
      };
      for (const method of deferrables.concat(["iterator"])) {
        self2["_" + method] = function() {
          throw new Error("Did not expect private method to be called: " + method);
        };
      }
    }
    module2.exports = DeferredLevelDOWN;
    module2.exports.DeferredIterator = DeferredIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    init_globals();
    module2.exports = require_events().EventEmitter;
  }
});

// (disabled):node_modules/util/util.js
var require_util5 = __commonJS({
  "(disabled):node_modules/util/util.js"() {
    init_globals();
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    init_globals();
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util5();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src3, target, offset) {
      Buffer2.prototype.copy.call(src3, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList3() {
        _classCallCheck(this, BufferList3);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList3, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat5(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first4() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf3 = p.data;
            var nb = n > buf3.length ? buf3.length : n;
            buf3.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf3.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf3.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread({}, options, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList3;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    init_globals();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code13, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code13;
      codes[code13] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name10, value) {
      return 'The value "' + value + '" is invalid for option "' + name10 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name10, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name10, " argument")) {
        msg = "The ".concat(name10, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name10, ".") ? "property" : "argument";
        msg = 'The "'.concat(name10, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name10) {
      return "The " + name10 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name10) {
      return "Cannot call " + name10 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    init_globals();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name10 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name10, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser5 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    init_globals();
    module2.exports = deprecate3;
    function deprecate3(fn, msg) {
      if (config2("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config2("throwDeprecation")) {
            throw new Error(msg);
          } else if (config2("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config2(name10) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name10];
      if (val == null)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser5()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      enumerable: false,
      get: function get6() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get6() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last15 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last15) {
          last15.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer3 = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer3[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer3.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer3, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      enumerable: false,
      get: function get6() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      enumerable: false,
      get: function get6() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set2(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    init_globals();
    var objectKeys = Object.keys || function(obj) {
      var keys3 = [];
      for (var key in obj) {
        keys3.push(key);
      }
      return keys3;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys2 = objectKeys(Writable.prototype);
      for (v = 0; v < keys2.length; v++) {
        method = keys2[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys2;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get6() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      enumerable: false,
      get: function get6() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      enumerable: false,
      get: function get6() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      enumerable: false,
      get: function get6() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set2(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    init_globals();
    var buffer3 = require_buffer();
    var Buffer2 = buffer3.Buffer;
    function copyProps(src3, dst) {
      for (var key in src3) {
        dst[key] = src3[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer3;
    } else {
      copyProps(buffer3, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length5) {
      return Buffer2(arg, encodingOrOffset, length5);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length5) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length5);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf3 = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf3.fill(fill, encoding);
        } else {
          buf3.fill(fill);
        }
      } else {
        buf3.fill(0);
      }
      return buf3;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer3.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    init_globals();
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf3) {
      if (buf3.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf3);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf3.length)
        return r ? r + this.text(buf3, i) : this.text(buf3, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf3) {
      if (this.lastNeed <= buf3.length) {
        buf3.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf3.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf3.length);
      this.lastNeed -= buf3.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf3, i) {
      var j = buf3.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf3[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf3[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf3[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf3, p) {
      if ((buf3[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf3.length > 1) {
        if ((buf3[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf3.length > 2) {
          if ((buf3[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf3) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf3, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf3.length) {
        buf3.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf3.copy(this.lastChar, p, 0, buf3.length);
      this.lastNeed -= buf3.length;
    }
    function utf8Text(buf3, i) {
      var total = utf8CheckIncomplete(this, buf3, i);
      if (!this.lastNeed)
        return buf3.toString("utf8", i);
      this.lastTotal = total;
      var end = buf3.length - (total - this.lastNeed);
      buf3.copy(this.lastChar, 0, end);
      return buf3.toString("utf8", i, end);
    }
    function utf8End(buf3) {
      var r = buf3 && buf3.length ? this.write(buf3) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf3, i) {
      if ((buf3.length - i) % 2 === 0) {
        var r = buf3.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf3[buf3.length - 2];
            this.lastChar[1] = buf3[buf3.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf3[buf3.length - 1];
      return buf3.toString("utf16le", i, buf3.length - 1);
    }
    function utf16End(buf3) {
      var r = buf3 && buf3.length ? this.write(buf3) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf3, i) {
      var n = (buf3.length - i) % 3;
      if (n === 0)
        return buf3.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf3[buf3.length - 1];
      } else {
        this.lastChar[0] = buf3[buf3.length - 2];
        this.lastChar[1] = buf3[buf3.length - 1];
      }
      return buf3.toString("base64", i, buf3.length - n);
    }
    function base64End(buf3) {
      var r = buf3 && buf3.length ? this.write(buf3) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf3) {
      return buf3.toString(this.encoding);
    }
    function simpleEnd(buf3) {
      return buf3 && buf3.length ? this.write(buf3) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    init_globals();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    init_globals();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve11 = iter[kLastResolve];
      if (resolve11 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve11(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve11, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve11(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve11, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve11, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve11(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve11, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve11(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve11, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve11(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve11;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve11 = iterator[kLastResolve];
        if (resolve11 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve11(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports2, module2) {
    init_globals();
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util5();
    var debug50;
    if (debugUtil && debugUtil.debuglog) {
      debug50 = debugUtil.debuglog("stream");
    } else {
      debug50 = function debug51() {
      };
    }
    var BufferList3 = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from5;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList3();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      enumerable: false,
      get: function get6() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set2(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug50("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug50("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug50("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug50("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug50("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug50("reading or ended", doRead);
      } else if (doRead) {
        debug50("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug50("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug50("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug50("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug50("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug50("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src3 = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug50("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src3.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug50("onunpipe");
        if (readable === src3) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug50("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src3);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug50("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src3.removeListener("end", onend);
        src3.removeListener("end", unpipe);
        src3.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src3.on("data", ondata);
      function ondata(chunk) {
        debug50("ondata");
        var ret = dest.write(chunk);
        debug50("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug50("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src3.pause();
        }
      }
      function onerror(er) {
        debug50("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug50("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug50("unpipe");
        src3.unpipe(dest);
      }
      dest.emit("pipe", src3);
      if (!state.flowing) {
        debug50("pipe resume");
        src3.resume();
      }
      return dest;
    };
    function pipeOnDrain(src3) {
      return function pipeOnDrainFunctionResult() {
        var state = src3._readableState;
        debug50("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src3, "data")) {
          state.flowing = true;
          flow(src3);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug50("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug50("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug50("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug50("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug50("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug50("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug50("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug50("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug50("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug50("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get6() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      enumerable: false,
      get: function get6() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      enumerable: false,
      get: function get6() {
        return this._readableState.flowing;
      },
      set: function set2(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      enumerable: false,
      get: function get6() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug50("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug50("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from5 === void 0) {
          from5 = require_from_browser();
        }
        return from5(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    init_globals();
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe8(from5, to) {
      return from5.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe8);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    init_globals();
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    exports2.finished = require_end_of_stream();
    exports2.pipeline = require_pipeline();
  }
});

// node_modules/level-iterator-stream/index.js
var require_level_iterator_stream = __commonJS({
  "node_modules/level-iterator-stream/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var inherits = require_inherits_browser();
    var { Readable } = require_readable_browser();
    module2.exports = ReadStream;
    inherits(ReadStream, Readable);
    function ReadStream(iterator, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(iterator, options);
      options = options || {};
      Readable.call(this, Object.assign({}, options, {
        objectMode: true
      }));
      this._iterator = iterator;
      this._options = options;
      this.on("end", this.destroy.bind(this, null, null));
    }
    ReadStream.prototype._read = function() {
      if (this.destroyed)
        return;
      this._iterator.next((err, key, value) => {
        if (this.destroyed)
          return;
        if (err)
          return this.destroy(err);
        if (key === void 0 && value === void 0) {
          this.push(null);
        } else if (this._options.keys !== false && this._options.values === false) {
          this.push(key);
        } else if (this._options.keys === false && this._options.values !== false) {
          this.push(value);
        } else {
          this.push({ key, value });
        }
      });
    };
    ReadStream.prototype._destroy = function(err, callback) {
      this._iterator.end(function(err2) {
        callback(err || err2);
      });
    };
  }
});

// node_modules/level-errors/errors.js
var require_errors = __commonJS({
  "node_modules/level-errors/errors.js"(exports2, module2) {
    "use strict";
    init_globals();
    function createError(type, Proto) {
      const Err = function(message, cause) {
        if (typeof message === "object" && message !== null) {
          cause = cause || message;
          message = message.message || message.name;
        }
        message = message || "";
        cause = cause || void 0;
        if (typeof cause === "object" && cause.type === type && cause.message === message) {
          return cause;
        }
        Object.defineProperty(this, "type", { value: type, enumerable: false, writable: true, configurable: true });
        Object.defineProperty(this, "name", { value: type, enumerable: false, writable: true, configurable: true });
        Object.defineProperty(this, "cause", { value: cause, enumerable: false, writable: true, configurable: true });
        Object.defineProperty(this, "message", { value: message, enumerable: false, writable: true, configurable: true });
        Error.call(this);
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, Err);
        }
      };
      Err.prototype = new Proto();
      return Err;
    }
    var LevelUPError = createError("LevelUPError", Error);
    module2.exports = {
      LevelUPError,
      InitializationError: createError("InitializationError", LevelUPError),
      OpenError: createError("OpenError", LevelUPError),
      ReadError: createError("ReadError", LevelUPError),
      WriteError: createError("WriteError", LevelUPError),
      NotFoundError: createError("NotFoundError", LevelUPError),
      EncodingError: createError("EncodingError", LevelUPError)
    };
    module2.exports.NotFoundError.prototype.notFound = true;
    module2.exports.NotFoundError.prototype.status = 404;
  }
});

// node_modules/levelup/lib/common.js
var require_common4 = __commonJS({
  "node_modules/levelup/lib/common.js"(exports2) {
    "use strict";
    init_globals();
    exports2.getCallback = function(options, callback) {
      return typeof options === "function" ? options : callback;
    };
    exports2.getOptions = function(options) {
      return typeof options === "object" && options !== null ? options : {};
    };
  }
});

// node_modules/levelup/lib/batch.js
var require_batch = __commonJS({
  "node_modules/levelup/lib/batch.js"(exports2, module2) {
    "use strict";
    init_globals();
    var WriteError = require_errors().WriteError;
    var catering = require_catering();
    var getCallback = require_common4().getCallback;
    var getOptions = require_common4().getOptions;
    function Batch(levelup) {
      this.db = levelup;
      this.batch = levelup.db.batch();
      this.ops = [];
      this.length = 0;
    }
    Batch.prototype.put = function(key, value, options) {
      try {
        this.batch.put(key, value, options);
      } catch (e) {
        throw new WriteError(e);
      }
      this.ops.push({ ...options, type: "put", key, value });
      this.length++;
      return this;
    };
    Batch.prototype.del = function(key, options) {
      try {
        this.batch.del(key, options);
      } catch (err) {
        throw new WriteError(err);
      }
      this.ops.push({ ...options, type: "del", key });
      this.length++;
      return this;
    };
    Batch.prototype.clear = function() {
      try {
        this.batch.clear();
      } catch (err) {
        throw new WriteError(err);
      }
      this.ops = [];
      this.length = 0;
      return this;
    };
    Batch.prototype.write = function(options, callback) {
      const levelup = this.db;
      const ops = this.ops;
      callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      options = getOptions(options);
      try {
        this.batch.write(options, function(err) {
          if (err) {
            return callback(new WriteError(err));
          }
          levelup.emit("batch", ops);
          callback();
        });
      } catch (err) {
        throw new WriteError(err);
      }
      return callback.promise;
    };
    module2.exports = Batch;
  }
});

// node_modules/levelup/lib/next-tick-browser.js
var require_next_tick_browser3 = __commonJS({
  "node_modules/levelup/lib/next-tick-browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    var queueMicrotask2 = require_queue_microtask();
    module2.exports = function(fn, ...args) {
      if (args.length === 0) {
        queueMicrotask2(fn);
      } else {
        queueMicrotask2(() => fn(...args));
      }
    };
  }
});

// node_modules/levelup/lib/levelup.js
var require_levelup = __commonJS({
  "node_modules/levelup/lib/levelup.js"(exports2, module2) {
    "use strict";
    init_globals();
    var EventEmitter4 = require_events().EventEmitter;
    var inherits = require_util3().inherits;
    var DeferredLevelDOWN = require_deferred_leveldown();
    var IteratorStream = require_level_iterator_stream();
    var Batch = require_batch();
    var errors2 = require_errors();
    var supports = require_level_supports();
    var catering = require_catering();
    var getCallback = require_common4().getCallback;
    var getOptions = require_common4().getOptions;
    var nextTick = require_next_tick_browser3();
    var WriteError = errors2.WriteError;
    var ReadError = errors2.ReadError;
    var NotFoundError2 = errors2.NotFoundError;
    var OpenError = errors2.OpenError;
    var InitializationError = errors2.InitializationError;
    function LevelUP(db, options, callback) {
      if (!(this instanceof LevelUP)) {
        return new LevelUP(db, options, callback);
      }
      let error;
      EventEmitter4.call(this);
      this.setMaxListeners(Infinity);
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if (!db || typeof db !== "object") {
        error = new InitializationError("First argument must be an abstract-leveldown compliant store");
        if (typeof callback === "function") {
          return nextTick(callback, error);
        }
        throw error;
      }
      if (typeof db.status !== "string") {
        throw new Error(".status required, old abstract-leveldown");
      }
      this.options = getOptions(options);
      this._db = db;
      this.db = null;
      this.open(callback || ((err) => {
        if (err)
          this.emit("error", err);
      }));
      this.supports = supports(this.db.supports, {
        status: true,
        deferredOpen: true,
        openCallback: true,
        promises: true,
        streams: true
      });
      for (const method of Object.keys(this.supports.additionalMethods)) {
        if (this[method] != null)
          continue;
        this[method] = function(...args) {
          return this.db[method](...args);
        };
      }
    }
    LevelUP.prototype.emit = EventEmitter4.prototype.emit;
    LevelUP.prototype.once = EventEmitter4.prototype.once;
    inherits(LevelUP, EventEmitter4);
    Object.defineProperty(LevelUP.prototype, "status", {
      enumerable: true,
      get() {
        return this.db.status;
      }
    });
    LevelUP.prototype.isOperational = function() {
      return this.db.status === "open" || this.db.status === "opening";
    };
    LevelUP.prototype.open = function(opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = null;
      }
      callback = catering.fromCallback(callback);
      if (!opts) {
        opts = this.options;
      }
      if (this.db && this.isOpen()) {
        nextTick(callback, null, this);
        return callback.promise;
      }
      if (this.db && this._isOpening()) {
        this.once("open", () => {
          callback(null, this);
        });
        return callback.promise;
      }
      this.db = new DeferredLevelDOWN(this._db);
      this.emit("opening");
      this.db.open(opts, (err) => {
        if (err) {
          return callback(new OpenError(err));
        }
        this.db = this._db;
        callback(null, this);
        this.emit("open");
        this.emit("ready");
      });
      return callback.promise;
    };
    LevelUP.prototype.close = function(callback) {
      callback = catering.fromCallback(callback);
      if (this.isOpen()) {
        this.db.close((err, ...rest) => {
          this.emit("closed");
          callback(err, ...rest);
        });
        this.emit("closing");
      } else if (this.isClosed()) {
        nextTick(callback);
      } else if (this.db.status === "closing") {
        this.once("closed", callback);
      } else if (this._isOpening()) {
        this.once("open", () => {
          this.close(callback);
        });
      }
      return callback.promise;
    };
    LevelUP.prototype.isOpen = function() {
      return this.db.status === "open";
    };
    LevelUP.prototype._isOpening = function() {
      return this.db.status === "opening";
    };
    LevelUP.prototype.isClosed = function() {
      return /^clos|new/.test(this.db.status);
    };
    LevelUP.prototype.get = function(key, options, callback) {
      callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      options = getOptions(options);
      this.db.get(key, options, function(err, value) {
        if (err) {
          if (/notfound/i.test(err) || err.notFound) {
            err = new NotFoundError2("Key not found in database [" + key + "]", err);
          } else {
            err = new ReadError(err);
          }
          return callback(err);
        }
        callback(null, value);
      });
      return callback.promise;
    };
    LevelUP.prototype.getMany = function(keys2, options, callback) {
      return this.db.getMany(keys2, options, callback);
    };
    LevelUP.prototype.put = function(key, value, options, callback) {
      callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      options = getOptions(options);
      this.db.put(key, value, options, (err) => {
        if (err) {
          return callback(new WriteError(err));
        }
        this.emit("put", key, value);
        callback();
      });
      return callback.promise;
    };
    LevelUP.prototype.del = function(key, options, callback) {
      callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      options = getOptions(options);
      this.db.del(key, options, (err) => {
        if (err) {
          return callback(new WriteError(err));
        }
        this.emit("del", key);
        callback();
      });
      return callback.promise;
    };
    LevelUP.prototype.batch = function(arr, options, callback) {
      if (!arguments.length) {
        return new Batch(this);
      }
      if (typeof arr === "function")
        callback = arr;
      else
        callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      options = getOptions(options);
      this.db.batch(arr, options, (err) => {
        if (err) {
          return callback(new WriteError(err));
        }
        this.emit("batch", arr);
        callback();
      });
      return callback.promise;
    };
    LevelUP.prototype.iterator = function(options) {
      return this.db.iterator(options);
    };
    LevelUP.prototype.clear = function(options, callback) {
      callback = getCallback(options, callback);
      options = getOptions(options);
      callback = catering.fromCallback(callback);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      this.db.clear(options, (err) => {
        if (err) {
          return callback(new WriteError(err));
        }
        this.emit("clear", options);
        callback();
      });
      return callback.promise;
    };
    LevelUP.prototype.readStream = LevelUP.prototype.createReadStream = function(options) {
      options = Object.assign({ keys: true, values: true }, options);
      if (typeof options.limit !== "number") {
        options.limit = -1;
      }
      return new IteratorStream(this.db.iterator(options), options);
    };
    LevelUP.prototype.keyStream = LevelUP.prototype.createKeyStream = function(options) {
      return this.createReadStream(Object.assign({}, options, { keys: true, values: false }));
    };
    LevelUP.prototype.valueStream = LevelUP.prototype.createValueStream = function(options) {
      return this.createReadStream(Object.assign({}, options, { keys: false, values: true }));
    };
    LevelUP.prototype.toString = function() {
      return "LevelUP";
    };
    LevelUP.prototype.type = "levelup";
    LevelUP.prototype._nextTick = nextTick;
    function maybeError(db, callback) {
      if (!db.isOperational()) {
        nextTick(callback, new ReadError("Database is not open"));
        return true;
      }
      return false;
    }
    LevelUP.errors = errors2;
    module2.exports = LevelUP;
  }
});

// node_modules/level-codec/lib/encodings.js
var require_encodings = __commonJS({
  "node_modules/level-codec/lib/encodings.js"(exports2) {
    "use strict";
    init_globals();
    var { Buffer: Buffer2 } = require_buffer();
    exports2.utf8 = exports2["utf-8"] = {
      encode: function(data) {
        return isBinary3(data) ? data : String(data);
      },
      decode: identity5,
      buffer: false,
      type: "utf8"
    };
    exports2.json = {
      encode: JSON.stringify,
      decode: JSON.parse,
      buffer: false,
      type: "json"
    };
    exports2.binary = {
      encode: function(data) {
        return isBinary3(data) ? data : Buffer2.from(data);
      },
      decode: identity5,
      buffer: true,
      type: "binary"
    };
    exports2.none = {
      encode: identity5,
      decode: identity5,
      buffer: false,
      type: "id"
    };
    exports2.id = exports2.none;
    var bufferEncodings = [
      "hex",
      "ascii",
      "base64",
      "ucs2",
      "ucs-2",
      "utf16le",
      "utf-16le"
    ];
    for (const type of bufferEncodings) {
      exports2[type] = {
        encode: function(data) {
          return isBinary3(data) ? data : Buffer2.from(data, type);
        },
        decode: function(buffer3) {
          return buffer3.toString(type);
        },
        buffer: true,
        type
      };
    }
    function identity5(value) {
      return value;
    }
    function isBinary3(data) {
      return data === void 0 || data === null || Buffer2.isBuffer(data);
    }
  }
});

// node_modules/level-codec/index.js
var require_level_codec = __commonJS({
  "node_modules/level-codec/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var encodings = require_encodings();
    var rangeOptions = /* @__PURE__ */ new Set(["lt", "gt", "lte", "gte"]);
    module2.exports = Codec3;
    function Codec3(opts) {
      if (!(this instanceof Codec3)) {
        return new Codec3(opts);
      }
      this.opts = opts || {};
      this.encodings = encodings;
    }
    Codec3.prototype._encoding = function(encoding) {
      if (typeof encoding === "string")
        encoding = encodings[encoding];
      if (!encoding)
        encoding = encodings.id;
      return encoding;
    };
    Codec3.prototype._keyEncoding = function(opts, batchOpts) {
      return this._encoding(batchOpts && batchOpts.keyEncoding || opts && opts.keyEncoding || this.opts.keyEncoding);
    };
    Codec3.prototype._valueEncoding = function(opts, batchOpts) {
      return this._encoding(batchOpts && (batchOpts.valueEncoding || batchOpts.encoding) || opts && (opts.valueEncoding || opts.encoding) || (this.opts.valueEncoding || this.opts.encoding));
    };
    Codec3.prototype.encodeKey = function(key, opts, batchOpts) {
      return this._keyEncoding(opts, batchOpts).encode(key);
    };
    Codec3.prototype.encodeValue = function(value, opts, batchOpts) {
      return this._valueEncoding(opts, batchOpts).encode(value);
    };
    Codec3.prototype.decodeKey = function(key, opts) {
      return this._keyEncoding(opts).decode(key);
    };
    Codec3.prototype.decodeValue = function(value, opts) {
      return this._valueEncoding(opts).decode(value);
    };
    Codec3.prototype.encodeBatch = function(ops, opts) {
      return ops.map((_op) => {
        const op = {
          type: _op.type,
          key: this.encodeKey(_op.key, opts, _op)
        };
        if (this.keyAsBuffer(opts, _op))
          op.keyEncoding = "binary";
        if (_op.prefix)
          op.prefix = _op.prefix;
        if ("value" in _op) {
          op.value = this.encodeValue(_op.value, opts, _op);
          if (this.valueAsBuffer(opts, _op))
            op.valueEncoding = "binary";
        }
        return op;
      });
    };
    Codec3.prototype.encodeLtgt = function(ltgt) {
      const ret = {};
      for (const key of Object.keys(ltgt)) {
        if (key === "start" || key === "end") {
          throw new Error('Legacy range options ("start" and "end") have been removed');
        }
        ret[key] = rangeOptions.has(key) ? this.encodeKey(ltgt[key], ltgt) : ltgt[key];
      }
      return ret;
    };
    Codec3.prototype.createStreamDecoder = function(opts) {
      if (opts.keys && opts.values) {
        return (key, value) => {
          return {
            key: this.decodeKey(key, opts),
            value: this.decodeValue(value, opts)
          };
        };
      } else if (opts.keys) {
        return (key) => {
          return this.decodeKey(key, opts);
        };
      } else if (opts.values) {
        return (_, value) => {
          return this.decodeValue(value, opts);
        };
      } else {
        return function() {
        };
      }
    };
    Codec3.prototype.keyAsBuffer = function(opts) {
      return this._keyEncoding(opts).buffer;
    };
    Codec3.prototype.valueAsBuffer = function(opts) {
      return this._valueEncoding(opts).buffer;
    };
  }
});

// node_modules/encoding-down/index.js
var require_encoding_down = __commonJS({
  "node_modules/encoding-down/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var AbstractLevelDOWN = require_abstract_leveldown2().AbstractLevelDOWN;
    var AbstractChainedBatch = require_abstract_leveldown2().AbstractChainedBatch;
    var AbstractIterator = require_abstract_leveldown2().AbstractIterator;
    var inherits = require_inherits_browser();
    var Codec3 = require_level_codec();
    var EncodingError = require_errors().EncodingError;
    var rangeMethods = ["approximateSize", "compactRange"];
    module2.exports = DB;
    function DB(db, opts) {
      if (!(this instanceof DB))
        return new DB(db, opts);
      const manifest = db.supports || {};
      const additionalMethods = manifest.additionalMethods || {};
      AbstractLevelDOWN.call(this, manifest);
      this.supports.encodings = true;
      this.supports.additionalMethods = {};
      rangeMethods.forEach(function(m) {
        const fallback = typeof db[m] === "function";
        if (additionalMethods[m] || fallback) {
          this.supports.additionalMethods[m] = true;
          this[m] = function(start, end, opts2, cb) {
            start = this.codec.encodeKey(start, opts2);
            end = this.codec.encodeKey(end, opts2);
            return this.db[m](start, end, opts2, cb);
          };
        }
      }, this);
      opts = opts || {};
      if (typeof opts.keyEncoding === "undefined")
        opts.keyEncoding = "utf8";
      if (typeof opts.valueEncoding === "undefined")
        opts.valueEncoding = "utf8";
      this.db = db;
      this.codec = new Codec3(opts);
    }
    inherits(DB, AbstractLevelDOWN);
    DB.prototype.type = "encoding-down";
    DB.prototype._serializeKey = DB.prototype._serializeValue = function(datum) {
      return datum;
    };
    DB.prototype._open = function(opts, cb) {
      this.db.open(opts, cb);
    };
    DB.prototype._close = function(cb) {
      this.db.close(cb);
    };
    DB.prototype._put = function(key, value, opts, cb) {
      key = this.codec.encodeKey(key, opts);
      value = this.codec.encodeValue(value, opts);
      this.db.put(key, value, opts, cb);
    };
    DB.prototype._get = function(key, opts, cb) {
      key = this.codec.encodeKey(key, opts);
      opts.asBuffer = this.codec.valueAsBuffer(opts);
      this.db.get(key, opts, (err, value) => {
        if (err)
          return cb(err);
        try {
          value = this.codec.decodeValue(value, opts);
        } catch (err2) {
          return cb(new EncodingError(err2));
        }
        cb(null, value);
      });
    };
    DB.prototype._getMany = function(keys2, opts, cb) {
      keys2 = keys2.map((key) => this.codec.encodeKey(key, opts));
      opts.asBuffer = this.codec.valueAsBuffer(opts);
      this.db.getMany(keys2, opts, (err, values2) => {
        if (err)
          return cb(err);
        const decoded = new Array(values2.length);
        for (let i = 0; i < values2.length; i++) {
          if (values2[i] === void 0) {
            decoded[i] = void 0;
            continue;
          }
          try {
            decoded[i] = this.codec.decodeValue(values2[i], opts);
          } catch (err2) {
            return cb(new EncodingError(err2));
          }
        }
        cb(null, decoded);
      });
    };
    DB.prototype._del = function(key, opts, cb) {
      key = this.codec.encodeKey(key, opts);
      this.db.del(key, opts, cb);
    };
    DB.prototype._chainedBatch = function() {
      return new Batch(this);
    };
    DB.prototype._batch = function(ops, opts, cb) {
      ops = this.codec.encodeBatch(ops, opts);
      this.db.batch(ops, opts, cb);
    };
    DB.prototype._iterator = function(opts) {
      opts.keyAsBuffer = this.codec.keyAsBuffer(opts);
      opts.valueAsBuffer = this.codec.valueAsBuffer(opts);
      return new Iterator(this, opts);
    };
    DB.prototype._clear = function(opts, callback) {
      opts = this.codec.encodeLtgt(opts);
      this.db.clear(opts, callback);
    };
    function Iterator(db, opts) {
      AbstractIterator.call(this, db);
      this.codec = db.codec;
      this.keys = opts.keys;
      this.values = opts.values;
      this.opts = this.codec.encodeLtgt(opts);
      this.it = db.db.iterator(this.opts);
    }
    inherits(Iterator, AbstractIterator);
    Iterator.prototype._next = function(cb) {
      this.it.next((err, key, value) => {
        if (err)
          return cb(err);
        try {
          if (this.keys && typeof key !== "undefined") {
            key = this.codec.decodeKey(key, this.opts);
          } else {
            key = void 0;
          }
          if (this.values && typeof value !== "undefined") {
            value = this.codec.decodeValue(value, this.opts);
          } else {
            value = void 0;
          }
        } catch (err2) {
          return cb(new EncodingError(err2));
        }
        cb(null, key, value);
      });
    };
    Iterator.prototype._seek = function(key) {
      key = this.codec.encodeKey(key, this.opts);
      this.it.seek(key);
    };
    Iterator.prototype._end = function(cb) {
      this.it.end(cb);
    };
    function Batch(db, codec) {
      AbstractChainedBatch.call(this, db);
      this.codec = db.codec;
      this.batch = db.db.batch();
    }
    inherits(Batch, AbstractChainedBatch);
    Batch.prototype._put = function(key, value, options) {
      key = this.codec.encodeKey(key, options);
      value = this.codec.encodeValue(value, options);
      this.batch.put(key, value);
    };
    Batch.prototype._del = function(key, options) {
      key = this.codec.encodeKey(key, options);
      this.batch.del(key);
    };
    Batch.prototype._clear = function() {
      this.batch.clear();
    };
    Batch.prototype._write = function(opts, cb) {
      this.batch.write(opts, cb);
    };
  }
});

// node_modules/level-packager/level-packager.js
var require_level_packager = __commonJS({
  "node_modules/level-packager/level-packager.js"(exports2, module2) {
    "use strict";
    init_globals();
    var levelup = require_levelup();
    var encode19 = require_encoding_down();
    function packager(leveldown) {
      function Level2(location2, options, callback) {
        if (typeof location2 === "function") {
          callback = location2;
        } else if (typeof options === "function") {
          callback = options;
        }
        if (!isObject(options)) {
          options = isObject(location2) ? location2 : {};
        }
        return levelup(encode19(leveldown(location2, options), options), options, callback);
      }
      function isObject(o) {
        return typeof o === "object" && o !== null;
      }
      for (const m of ["destroy", "repair"]) {
        if (typeof leveldown[m] === "function") {
          Level2[m] = function(...args) {
            leveldown[m](...args);
          };
        }
      }
      Level2.errors = levelup.errors;
      return Level2;
    }
    module2.exports = packager;
  }
});

// node_modules/run-parallel-limit/index.js
var require_run_parallel_limit = __commonJS({
  "node_modules/run-parallel-limit/index.js"(exports2, module2) {
    init_globals();
    module2.exports = runParallelLimit;
    var queueMicrotask2 = require_queue_microtask();
    function runParallelLimit(tasks, limit, cb) {
      if (typeof limit !== "number")
        throw new Error("second argument must be a Number");
      let results, len, pending, keys2, isErrored;
      let isSync = true;
      let next;
      if (Array.isArray(tasks)) {
        results = [];
        pending = len = tasks.length;
      } else {
        keys2 = Object.keys(tasks);
        results = {};
        pending = len = keys2.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (err)
          isErrored = true;
        if (--pending === 0 || err) {
          done(err);
        } else if (!isErrored && next < len) {
          let key;
          if (keys2) {
            key = keys2[next];
            next += 1;
            tasks[key](function(err2, result2) {
              each(key, err2, result2);
            });
          } else {
            key = next;
            next += 1;
            tasks[key](function(err2, result2) {
              each(key, err2, result2);
            });
          }
        }
      }
      next = limit;
      if (!pending) {
        done(null);
      } else if (keys2) {
        keys2.some(function(key, i) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
          if (i === limit - 1)
            return true;
          return false;
        });
      } else {
        tasks.some(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
          if (i === limit - 1)
            return true;
          return false;
        });
      }
      isSync = false;
    }
  }
});

// node_modules/ltgt/index.js
var require_ltgt = __commonJS({
  "node_modules/ltgt/index.js"(exports2) {
    init_globals();
    exports2.compare = function(a, b) {
      if (Buffer.isBuffer(a)) {
        var l = Math.min(a.length, b.length);
        for (var i = 0; i < l; i++) {
          var cmp = a[i] - b[i];
          if (cmp)
            return cmp;
        }
        return a.length - b.length;
      }
      return a < b ? -1 : a > b ? 1 : 0;
    };
    function isDef(val) {
      return val !== void 0 && val !== "";
    }
    function has(range, name10) {
      return Object.hasOwnProperty.call(range, name10);
    }
    function hasKey(range, name10) {
      return Object.hasOwnProperty.call(range, name10) && name10;
    }
    var lowerBoundKey = exports2.lowerBoundKey = function(range) {
      return hasKey(range, "gt") || hasKey(range, "gte") || hasKey(range, "min") || (range.reverse ? hasKey(range, "end") : hasKey(range, "start")) || void 0;
    };
    var lowerBound = exports2.lowerBound = function(range, def) {
      var k = lowerBoundKey(range);
      return k ? range[k] : def;
    };
    var lowerBoundInclusive = exports2.lowerBoundInclusive = function(range) {
      return has(range, "gt") ? false : true;
    };
    var upperBoundInclusive = exports2.upperBoundInclusive = function(range) {
      return has(range, "lt") ? false : true;
    };
    var lowerBoundExclusive = exports2.lowerBoundExclusive = function(range) {
      return !lowerBoundInclusive(range);
    };
    var upperBoundExclusive = exports2.upperBoundExclusive = function(range) {
      return !upperBoundInclusive(range);
    };
    var upperBoundKey = exports2.upperBoundKey = function(range) {
      return hasKey(range, "lt") || hasKey(range, "lte") || hasKey(range, "max") || (range.reverse ? hasKey(range, "start") : hasKey(range, "end")) || void 0;
    };
    var upperBound = exports2.upperBound = function(range, def) {
      var k = upperBoundKey(range);
      return k ? range[k] : def;
    };
    exports2.start = function(range, def) {
      return range.reverse ? upperBound(range, def) : lowerBound(range, def);
    };
    exports2.end = function(range, def) {
      return range.reverse ? lowerBound(range, def) : upperBound(range, def);
    };
    exports2.startInclusive = function(range) {
      return range.reverse ? upperBoundInclusive(range) : lowerBoundInclusive(range);
    };
    exports2.endInclusive = function(range) {
      return range.reverse ? lowerBoundInclusive(range) : upperBoundInclusive(range);
    };
    function id(e) {
      return e;
    }
    exports2.toLtgt = function(range, _range, map12, lower, upper) {
      _range = _range || {};
      map12 = map12 || id;
      var defaults = arguments.length > 3;
      var lb = exports2.lowerBoundKey(range);
      var ub = exports2.upperBoundKey(range);
      if (lb) {
        if (lb === "gt")
          _range.gt = map12(range.gt, false);
        else
          _range.gte = map12(range[lb], false);
      } else if (defaults)
        _range.gte = map12(lower, false);
      if (ub) {
        if (ub === "lt")
          _range.lt = map12(range.lt, true);
        else
          _range.lte = map12(range[ub], true);
      } else if (defaults)
        _range.lte = map12(upper, true);
      if (range.reverse != null)
        _range.reverse = !!range.reverse;
      if (has(_range, "max"))
        delete _range.max;
      if (has(_range, "min"))
        delete _range.min;
      if (has(_range, "start"))
        delete _range.start;
      if (has(_range, "end"))
        delete _range.end;
      return _range;
    };
    exports2.contains = function(range, key, compare4) {
      compare4 = compare4 || exports2.compare;
      var lb = lowerBound(range);
      if (isDef(lb)) {
        var cmp = compare4(key, lb);
        if (cmp < 0 || cmp === 0 && lowerBoundExclusive(range))
          return false;
      }
      var ub = upperBound(range);
      if (isDef(ub)) {
        var cmp = compare4(key, ub);
        if (cmp > 0 || cmp === 0 && upperBoundExclusive(range))
          return false;
      }
      return true;
    };
    exports2.filter = function(range, compare4) {
      return function(key) {
        return exports2.contains(range, key, compare4);
      };
    };
  }
});

// node_modules/level-js/util/key-range.js
var require_key_range = __commonJS({
  "node_modules/level-js/util/key-range.js"(exports2, module2) {
    "use strict";
    init_globals();
    var ltgt = require_ltgt();
    var NONE = Symbol("none");
    module2.exports = function createKeyRange(options) {
      const lower = ltgt.lowerBound(options, NONE);
      const upper = ltgt.upperBound(options, NONE);
      const lowerOpen = ltgt.lowerBoundExclusive(options, NONE);
      const upperOpen = ltgt.upperBoundExclusive(options, NONE);
      if (lower !== NONE && upper !== NONE) {
        return IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen);
      } else if (lower !== NONE) {
        return IDBKeyRange.lowerBound(lower, lowerOpen);
      } else if (upper !== NONE) {
        return IDBKeyRange.upperBound(upper, upperOpen);
      } else {
        return null;
      }
    };
  }
});

// node_modules/level-js/util/deserialize.js
var require_deserialize = __commonJS({
  "node_modules/level-js/util/deserialize.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Buffer2 = require_buffer().Buffer;
    var ta2str = function() {
      if (global.TextDecoder) {
        const decoder = new TextDecoder("utf-8");
        return decoder.decode.bind(decoder);
      } else {
        return function ta2str2(ta) {
          return ta2buf(ta).toString();
        };
      }
    }();
    var ab2str = function() {
      if (global.TextDecoder) {
        const decoder = new TextDecoder("utf-8");
        return decoder.decode.bind(decoder);
      } else {
        return function ab2str2(ab) {
          return Buffer2.from(ab).toString();
        };
      }
    }();
    function ta2buf(ta) {
      const buf3 = Buffer2.from(ta.buffer);
      if (ta.byteLength === ta.buffer.byteLength) {
        return buf3;
      } else {
        return buf3.slice(ta.byteOffset, ta.byteOffset + ta.byteLength);
      }
    }
    module2.exports = function(data, asBuffer) {
      if (data instanceof Uint8Array) {
        return asBuffer ? ta2buf(data) : ta2str(data);
      } else if (data instanceof ArrayBuffer) {
        return asBuffer ? Buffer2.from(data) : ab2str(data);
      } else {
        return asBuffer ? Buffer2.from(String(data)) : String(data);
      }
    };
  }
});

// node_modules/level-js/iterator.js
var require_iterator = __commonJS({
  "node_modules/level-js/iterator.js"(exports2, module2) {
    "use strict";
    init_globals();
    var inherits = require_inherits_browser();
    var AbstractIterator = require_abstract_leveldown2().AbstractIterator;
    var createKeyRange = require_key_range();
    var deserialize = require_deserialize();
    var noop2 = function() {
    };
    module2.exports = Iterator;
    function Iterator(db, location2, options) {
      AbstractIterator.call(this, db);
      this._limit = options.limit;
      this._count = 0;
      this._callback = null;
      this._cache = [];
      this._completed = false;
      this._aborted = false;
      this._error = null;
      this._transaction = null;
      this._keys = options.keys;
      this._values = options.values;
      this._keyAsBuffer = options.keyAsBuffer;
      this._valueAsBuffer = options.valueAsBuffer;
      if (this._limit === 0) {
        this._completed = true;
        return;
      }
      let keyRange;
      try {
        keyRange = createKeyRange(options);
      } catch (e) {
        this._completed = true;
        return;
      }
      this.createIterator(location2, keyRange, options.reverse);
    }
    inherits(Iterator, AbstractIterator);
    Iterator.prototype.createIterator = function(location2, keyRange, reverse) {
      const transaction = this.db.db.transaction([location2], "readonly");
      const store = transaction.objectStore(location2);
      const req = store.openCursor(keyRange, reverse ? "prev" : "next");
      req.onsuccess = (ev) => {
        const cursor = ev.target.result;
        if (cursor)
          this.onItem(cursor);
      };
      this._transaction = transaction;
      transaction.onabort = () => {
        this.onAbort(this._transaction.error || new Error("aborted by user"));
      };
      transaction.oncomplete = () => {
        this.onComplete();
      };
    };
    Iterator.prototype.onItem = function(cursor) {
      this._cache.push(cursor.key, cursor.value);
      if (this._limit <= 0 || ++this._count < this._limit) {
        cursor.continue();
      }
      this.maybeNext();
    };
    Iterator.prototype.onAbort = function(err) {
      this._aborted = true;
      this._error = err;
      this.maybeNext();
    };
    Iterator.prototype.onComplete = function() {
      this._completed = true;
      this.maybeNext();
    };
    Iterator.prototype.maybeNext = function() {
      if (this._callback) {
        this._next(this._callback);
        this._callback = null;
      }
    };
    Iterator.prototype._next = function(callback) {
      if (this._aborted) {
        const err = this._error;
        this._error = null;
        this._nextTick(callback, err);
      } else if (this._cache.length > 0) {
        let key = this._cache.shift();
        let value = this._cache.shift();
        if (this._keys && key !== void 0) {
          key = this._deserializeKey(key, this._keyAsBuffer);
        } else {
          key = void 0;
        }
        if (this._values && value !== void 0) {
          value = this._deserializeValue(value, this._valueAsBuffer);
        } else {
          value = void 0;
        }
        this._nextTick(callback, null, key, value);
      } else if (this._completed) {
        this._nextTick(callback);
      } else {
        this._callback = callback;
      }
    };
    Iterator.prototype._deserializeKey = deserialize;
    Iterator.prototype._deserializeValue = deserialize;
    Iterator.prototype._end = function(callback) {
      if (this._aborted || this._completed) {
        return this._nextTick(callback, this._error);
      }
      this.onItem = noop2;
      this.onAbort = callback;
      this.onComplete = callback;
    };
  }
});

// node_modules/level-js/util/serialize.js
var require_serialize = __commonJS({
  "node_modules/level-js/util/serialize.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Buffer2 = require_buffer().Buffer;
    var str2bin = function() {
      if (global.TextEncoder) {
        const encoder = new TextEncoder("utf-8");
        return encoder.encode.bind(encoder);
      } else {
        return Buffer2.from;
      }
    }();
    module2.exports = function(data, asBuffer) {
      if (asBuffer) {
        return Buffer2.isBuffer(data) ? data : str2bin(String(data));
      } else {
        return String(data);
      }
    };
  }
});

// node_modules/level-js/util/support.js
var require_support = __commonJS({
  "node_modules/level-js/util/support.js"(exports2) {
    "use strict";
    init_globals();
    var Buffer2 = require_buffer().Buffer;
    exports2.test = function(key) {
      return function test(impl) {
        try {
          impl.cmp(key, 0);
          return true;
        } catch (err) {
          return false;
        }
      };
    };
    exports2.bufferKeys = exports2.test(Buffer2.alloc(0));
  }
});

// node_modules/level-js/util/clear.js
var require_clear = __commonJS({
  "node_modules/level-js/util/clear.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = function clear(db, location2, keyRange, options, callback) {
      if (options.limit === 0)
        return db._nextTick(callback);
      const transaction = db.db.transaction([location2], "readwrite");
      const store = transaction.objectStore(location2);
      let count = 0;
      transaction.oncomplete = function() {
        callback();
      };
      transaction.onabort = function() {
        callback(transaction.error || new Error("aborted by user"));
      };
      const method = store.openKeyCursor ? "openKeyCursor" : "openCursor";
      const direction = options.reverse ? "prev" : "next";
      store[method](keyRange, direction).onsuccess = function(ev) {
        const cursor = ev.target.result;
        if (cursor) {
          store.delete(cursor.key).onsuccess = function() {
            if (options.limit <= 0 || ++count < options.limit) {
              cursor.continue();
            }
          };
        }
      };
    };
  }
});

// node_modules/level-js/index.js
var require_level_js = __commonJS({
  "node_modules/level-js/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = Level2;
    var AbstractLevelDOWN = require_abstract_leveldown2().AbstractLevelDOWN;
    var inherits = require_inherits_browser();
    var parallel2 = require_run_parallel_limit();
    var Iterator = require_iterator();
    var serialize = require_serialize();
    var deserialize = require_deserialize();
    var support = require_support();
    var clear = require_clear();
    var createKeyRange = require_key_range();
    var DEFAULT_PREFIX = "level-js-";
    function Level2(location2, opts) {
      if (!(this instanceof Level2))
        return new Level2(location2, opts);
      AbstractLevelDOWN.call(this, {
        bufferKeys: support.bufferKeys(indexedDB),
        snapshots: true,
        permanence: true,
        clear: true,
        getMany: true
      });
      opts = opts || {};
      if (typeof location2 !== "string") {
        throw new Error("constructor requires a location string argument");
      }
      this.location = location2;
      this.prefix = opts.prefix == null ? DEFAULT_PREFIX : opts.prefix;
      this.version = parseInt(opts.version || 1, 10);
    }
    inherits(Level2, AbstractLevelDOWN);
    Level2.prototype.type = "level-js";
    Level2.prototype._open = function(options, callback) {
      const req = indexedDB.open(this.prefix + this.location, this.version);
      req.onerror = function() {
        callback(req.error || new Error("unknown error"));
      };
      req.onsuccess = () => {
        this.db = req.result;
        callback();
      };
      req.onupgradeneeded = (ev) => {
        const db = ev.target.result;
        if (!db.objectStoreNames.contains(this.location)) {
          db.createObjectStore(this.location);
        }
      };
    };
    Level2.prototype.store = function(mode) {
      const transaction = this.db.transaction([this.location], mode);
      return transaction.objectStore(this.location);
    };
    Level2.prototype.await = function(request, callback) {
      const transaction = request.transaction;
      transaction.onabort = function() {
        callback(transaction.error || new Error("aborted by user"));
      };
      transaction.oncomplete = function() {
        callback(null, request.result);
      };
    };
    Level2.prototype._get = function(key, options, callback) {
      const store = this.store("readonly");
      let req;
      try {
        req = store.get(key);
      } catch (err) {
        return this._nextTick(callback, err);
      }
      this.await(req, function(err, value) {
        if (err)
          return callback(err);
        if (value === void 0) {
          return callback(new Error("NotFound"));
        }
        callback(null, deserialize(value, options.asBuffer));
      });
    };
    Level2.prototype._getMany = function(keys2, options, callback) {
      const asBuffer = options.asBuffer;
      const store = this.store("readonly");
      const tasks = keys2.map((key) => (next) => {
        let request;
        try {
          request = store.get(key);
        } catch (err) {
          return next(err);
        }
        request.onsuccess = () => {
          const value = request.result;
          next(null, value === void 0 ? value : deserialize(value, asBuffer));
        };
        request.onerror = (ev) => {
          ev.stopPropagation();
          next(request.error);
        };
      });
      parallel2(tasks, 16, callback);
    };
    Level2.prototype._del = function(key, options, callback) {
      const store = this.store("readwrite");
      let req;
      try {
        req = store.delete(key);
      } catch (err) {
        return this._nextTick(callback, err);
      }
      this.await(req, callback);
    };
    Level2.prototype._put = function(key, value, options, callback) {
      const store = this.store("readwrite");
      let req;
      try {
        req = store.put(value, key);
      } catch (err) {
        return this._nextTick(callback, err);
      }
      this.await(req, callback);
    };
    Level2.prototype._serializeKey = function(key) {
      return serialize(key, this.supports.bufferKeys);
    };
    Level2.prototype._serializeValue = function(value) {
      return serialize(value, true);
    };
    Level2.prototype._iterator = function(options) {
      return new Iterator(this, this.location, options);
    };
    Level2.prototype._batch = function(operations, options, callback) {
      if (operations.length === 0)
        return this._nextTick(callback);
      const store = this.store("readwrite");
      const transaction = store.transaction;
      let index = 0;
      let error;
      transaction.onabort = function() {
        callback(error || transaction.error || new Error("aborted by user"));
      };
      transaction.oncomplete = function() {
        callback();
      };
      function loop() {
        const op = operations[index++];
        const key = op.key;
        let req;
        try {
          req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
        } catch (err) {
          error = err;
          transaction.abort();
          return;
        }
        if (index < operations.length) {
          req.onsuccess = loop;
        }
      }
      loop();
    };
    Level2.prototype._clear = function(options, callback) {
      let keyRange;
      let req;
      try {
        keyRange = createKeyRange(options);
      } catch (e) {
        return this._nextTick(callback);
      }
      if (options.limit >= 0) {
        return clear(this, this.location, keyRange, options, callback);
      }
      try {
        const store = this.store("readwrite");
        req = keyRange ? store.delete(keyRange) : store.clear();
      } catch (err) {
        return this._nextTick(callback, err);
      }
      this.await(req, callback);
    };
    Level2.prototype._close = function(callback) {
      this.db.close();
      this._nextTick(callback);
    };
    Level2.prototype.upgrade = function(callback) {
      if (this.status !== "open") {
        return this._nextTick(callback, new Error("cannot upgrade() before open()"));
      }
      const it = this.iterator();
      const batchOptions = {};
      const self2 = this;
      it._deserializeKey = it._deserializeValue = identity5;
      next();
      function next(err) {
        if (err)
          return finish(err);
        it.next(each);
      }
      function each(err, key, value) {
        if (err || key === void 0) {
          return finish(err);
        }
        const newKey = self2._serializeKey(deserialize(key, true));
        const newValue = self2._serializeValue(deserialize(value, true));
        self2._batch([
          { type: "del", key },
          { type: "put", key: newKey, value: newValue }
        ], batchOptions, next);
      }
      function finish(err) {
        it.end(function(err2) {
          callback(err || err2);
        });
      }
      function identity5(data) {
        return data;
      }
    };
    Level2.destroy = function(location2, prefix, callback) {
      if (typeof prefix === "function") {
        callback = prefix;
        prefix = DEFAULT_PREFIX;
      }
      const request = indexedDB.deleteDatabase(prefix + location2);
      request.onsuccess = function() {
        callback();
      };
      request.onerror = function(err) {
        callback(err);
      };
    };
  }
});

// node_modules/level/browser.js
var require_browser6 = __commonJS({
  "node_modules/level/browser.js"(exports2, module2) {
    init_globals();
    module2.exports = require_level_packager()(require_level_js());
  }
});

// node_modules/libp2p-interfaces/src/topology/index.js
var require_topology = __commonJS({
  "node_modules/libp2p-interfaces/src/topology/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var noop2 = () => {
    };
    var topologySymbol = Symbol.for("@libp2p/js-interfaces/topology");
    var Topology = class {
      constructor({
        min = 0,
        max = Infinity,
        handlers = {}
      }) {
        this.min = min;
        this.max = max;
        this._onConnect = handlers.onConnect || noop2;
        this._onDisconnect = handlers.onDisconnect || noop2;
        this.peers = /* @__PURE__ */ new Set();
      }
      get [Symbol.toStringTag]() {
        return "Topology";
      }
      get [topologySymbol]() {
        return true;
      }
      static isTopology(other) {
        return Boolean(other && other[topologySymbol]);
      }
      async setRegistrar(registrar) {
        this._registrar = registrar;
      }
      disconnect(peerId) {
        this._onDisconnect(peerId);
      }
    };
    module2.exports = Topology;
  }
});

// node_modules/libp2p-interfaces/src/topology/multicodec-topology.js
var require_multicodec_topology = __commonJS({
  "node_modules/libp2p-interfaces/src/topology/multicodec-topology.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Topology = require_topology();
    var multicodecTopologySymbol = Symbol.for("@libp2p/js-interfaces/topology/multicodec-topology");
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:topology:multicodec-topology"), {
      error: debug50("libp2p:topology:multicodec-topology:error")
    });
    var MulticodecTopology2 = class extends Topology {
      constructor({
        min,
        max,
        multicodecs,
        handlers
      }) {
        super({ min, max, handlers });
        if (!multicodecs) {
          throw new Error("one or more multicodec should be provided");
        }
        if (!handlers) {
          throw new Error("the handlers should be provided");
        }
        if (typeof handlers.onConnect !== "function") {
          throw new Error("the 'onConnect' handler must be provided");
        }
        if (typeof handlers.onDisconnect !== "function") {
          throw new Error("the 'onDisconnect' handler must be provided");
        }
        this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs];
        this._registrar = void 0;
        this._onProtocolChange = this._onProtocolChange.bind(this);
        this._onPeerConnect = this._onPeerConnect.bind(this);
      }
      get [Symbol.toStringTag]() {
        return "Topology";
      }
      get [multicodecTopologySymbol]() {
        return true;
      }
      static isMulticodecTopology(other) {
        return Boolean(other && other[multicodecTopologySymbol]);
      }
      async setRegistrar(registrar) {
        this._registrar = registrar;
        this._registrar.peerStore.on("change:protocols", this._onProtocolChange);
        this._registrar.connectionManager.on("peer:connect", this._onPeerConnect);
        await this._updatePeers(this._registrar.peerStore.getPeers());
      }
      async _updatePeers(peerDataIterable) {
        for await (const { id, protocols } of peerDataIterable) {
          if (this.multicodecs.filter((multicodec) => protocols.includes(multicodec)).length) {
            this.peers.add(id.toB58String());
            const connection = this._registrar.getConnection(id);
            connection && this._onConnect(id, connection);
          } else {
            this.peers.delete(id.toB58String());
          }
        }
      }
      async _onProtocolChange({ peerId, protocols }) {
        try {
          const hadPeer = this.peers.has(peerId.toB58String());
          const hasProtocol = protocols.filter((protocol) => this.multicodecs.includes(protocol));
          if (hadPeer && hasProtocol.length === 0) {
            this._onDisconnect(peerId);
          }
          for (const protocol of protocols) {
            if (this.multicodecs.includes(protocol)) {
              const peerData = await this._registrar.peerStore.get(peerId);
              await this._updatePeers([peerData]);
              return;
            }
          }
        } catch (err) {
          log48.error(err);
        }
      }
      async _onPeerConnect(connection) {
        try {
          const peerId = connection.remotePeer;
          const protocols = await this._registrar.peerStore.protoBook.get(peerId);
          if (!protocols) {
            return;
          }
          if (this.multicodecs.find((multicodec) => protocols.includes(multicodec))) {
            this.peers.add(peerId.toB58String());
            this._onConnect(peerId, connection);
          }
        } catch (err) {
          log48.error(err);
        }
      }
    };
    module2.exports = MulticodecTopology2;
  }
});

// node_modules/libp2p-interfaces/src/pubsub/errors.js
var require_errors2 = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/errors.js"(exports2) {
    "use strict";
    init_globals();
    exports2.codes = {
      ERR_INVALID_SIGNATURE_POLICY: "ERR_INVALID_SIGNATURE_POLICY",
      ERR_UNHANDLED_SIGNATURE_POLICY: "ERR_UNHANDLED_SIGNATURE_POLICY",
      ERR_MISSING_SIGNATURE: "ERR_MISSING_SIGNATURE",
      ERR_MISSING_SEQNO: "ERR_MISSING_SEQNO",
      ERR_INVALID_SIGNATURE: "ERR_INVALID_SIGNATURE",
      ERR_UNEXPECTED_FROM: "ERR_UNEXPECTED_FROM",
      ERR_UNEXPECTED_SIGNATURE: "ERR_UNEXPECTED_SIGNATURE",
      ERR_UNEXPECTED_KEY: "ERR_UNEXPECTED_KEY",
      ERR_UNEXPECTED_SEQNO: "ERR_UNEXPECTED_SEQNO"
    };
  }
});

// node_modules/libp2p-interfaces/src/pubsub/message/rpc.js
var require_rpc2 = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/message/rpc.js"(exports2, module2) {
    "use strict";
    init_globals();
    var $protobuf12 = require_minimal2();
    var $Reader11 = $protobuf12.Reader;
    var $Writer11 = $protobuf12.Writer;
    var $util11 = $protobuf12.util;
    var $root11 = $protobuf12.roots["libp2p-pubsub-rpc"] || ($protobuf12.roots["libp2p-pubsub-rpc"] = {});
    $root11.RPC = function() {
      function RPC(p) {
        this.subscriptions = [];
        this.msgs = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      RPC.prototype.subscriptions = $util11.emptyArray;
      RPC.prototype.msgs = $util11.emptyArray;
      RPC.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.subscriptions != null && m.subscriptions.length) {
          for (var i = 0; i < m.subscriptions.length; ++i)
            $root11.RPC.SubOpts.encode(m.subscriptions[i], w.uint32(10).fork()).ldelim();
        }
        if (m.msgs != null && m.msgs.length) {
          for (var i = 0; i < m.msgs.length; ++i)
            $root11.RPC.Message.encode(m.msgs[i], w.uint32(18).fork()).ldelim();
        }
        return w;
      };
      RPC.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              if (!(m.subscriptions && m.subscriptions.length))
                m.subscriptions = [];
              m.subscriptions.push($root11.RPC.SubOpts.decode(r, r.uint32()));
              break;
            case 2:
              if (!(m.msgs && m.msgs.length))
                m.msgs = [];
              m.msgs.push($root11.RPC.Message.decode(r, r.uint32()));
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      RPC.fromObject = function fromObject(d) {
        if (d instanceof $root11.RPC)
          return d;
        var m = new $root11.RPC();
        if (d.subscriptions) {
          if (!Array.isArray(d.subscriptions))
            throw TypeError(".RPC.subscriptions: array expected");
          m.subscriptions = [];
          for (var i = 0; i < d.subscriptions.length; ++i) {
            if (typeof d.subscriptions[i] !== "object")
              throw TypeError(".RPC.subscriptions: object expected");
            m.subscriptions[i] = $root11.RPC.SubOpts.fromObject(d.subscriptions[i]);
          }
        }
        if (d.msgs) {
          if (!Array.isArray(d.msgs))
            throw TypeError(".RPC.msgs: array expected");
          m.msgs = [];
          for (var i = 0; i < d.msgs.length; ++i) {
            if (typeof d.msgs[i] !== "object")
              throw TypeError(".RPC.msgs: object expected");
            m.msgs[i] = $root11.RPC.Message.fromObject(d.msgs[i]);
          }
        }
        return m;
      };
      RPC.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.subscriptions = [];
          d.msgs = [];
        }
        if (m.subscriptions && m.subscriptions.length) {
          d.subscriptions = [];
          for (var j = 0; j < m.subscriptions.length; ++j) {
            d.subscriptions[j] = $root11.RPC.SubOpts.toObject(m.subscriptions[j], o);
          }
        }
        if (m.msgs && m.msgs.length) {
          d.msgs = [];
          for (var j = 0; j < m.msgs.length; ++j) {
            d.msgs[j] = $root11.RPC.Message.toObject(m.msgs[j], o);
          }
        }
        return d;
      };
      RPC.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      RPC.SubOpts = function() {
        function SubOpts(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        SubOpts.prototype.subscribe = null;
        SubOpts.prototype.topicID = null;
        var $oneOfFields;
        Object.defineProperty(SubOpts.prototype, "_subscribe", {
          get: $util11.oneOfGetter($oneOfFields = ["subscribe"]),
          set: $util11.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(SubOpts.prototype, "_topicID", {
          get: $util11.oneOfGetter($oneOfFields = ["topicID"]),
          set: $util11.oneOfSetter($oneOfFields)
        });
        SubOpts.encode = function encode19(m, w) {
          if (!w)
            w = $Writer11.create();
          if (m.subscribe != null && Object.hasOwnProperty.call(m, "subscribe"))
            w.uint32(8).bool(m.subscribe);
          if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
            w.uint32(18).string(m.topicID);
          return w;
        };
        SubOpts.decode = function decode22(r, l) {
          if (!(r instanceof $Reader11))
            r = $Reader11.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC.SubOpts();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.subscribe = r.bool();
                break;
              case 2:
                m.topicID = r.string();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        SubOpts.fromObject = function fromObject(d) {
          if (d instanceof $root11.RPC.SubOpts)
            return d;
          var m = new $root11.RPC.SubOpts();
          if (d.subscribe != null) {
            m.subscribe = Boolean(d.subscribe);
          }
          if (d.topicID != null) {
            m.topicID = String(d.topicID);
          }
          return m;
        };
        SubOpts.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (m.subscribe != null && m.hasOwnProperty("subscribe")) {
            d.subscribe = m.subscribe;
            if (o.oneofs)
              d._subscribe = "subscribe";
          }
          if (m.topicID != null && m.hasOwnProperty("topicID")) {
            d.topicID = m.topicID;
            if (o.oneofs)
              d._topicID = "topicID";
          }
          return d;
        };
        SubOpts.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
        };
        return SubOpts;
      }();
      RPC.Message = function() {
        function Message2(p) {
          this.topicIDs = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Message2.prototype.from = null;
        Message2.prototype.data = null;
        Message2.prototype.seqno = null;
        Message2.prototype.topicIDs = $util11.emptyArray;
        Message2.prototype.signature = null;
        Message2.prototype.key = null;
        var $oneOfFields;
        Object.defineProperty(Message2.prototype, "_from", {
          get: $util11.oneOfGetter($oneOfFields = ["from"]),
          set: $util11.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(Message2.prototype, "_data", {
          get: $util11.oneOfGetter($oneOfFields = ["data"]),
          set: $util11.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(Message2.prototype, "_seqno", {
          get: $util11.oneOfGetter($oneOfFields = ["seqno"]),
          set: $util11.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(Message2.prototype, "_signature", {
          get: $util11.oneOfGetter($oneOfFields = ["signature"]),
          set: $util11.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(Message2.prototype, "_key", {
          get: $util11.oneOfGetter($oneOfFields = ["key"]),
          set: $util11.oneOfSetter($oneOfFields)
        });
        Message2.encode = function encode19(m, w) {
          if (!w)
            w = $Writer11.create();
          if (m.from != null && Object.hasOwnProperty.call(m, "from"))
            w.uint32(10).bytes(m.from);
          if (m.data != null && Object.hasOwnProperty.call(m, "data"))
            w.uint32(18).bytes(m.data);
          if (m.seqno != null && Object.hasOwnProperty.call(m, "seqno"))
            w.uint32(26).bytes(m.seqno);
          if (m.topicIDs != null && m.topicIDs.length) {
            for (var i = 0; i < m.topicIDs.length; ++i)
              w.uint32(34).string(m.topicIDs[i]);
          }
          if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
            w.uint32(42).bytes(m.signature);
          if (m.key != null && Object.hasOwnProperty.call(m, "key"))
            w.uint32(50).bytes(m.key);
          return w;
        };
        Message2.decode = function decode22(r, l) {
          if (!(r instanceof $Reader11))
            r = $Reader11.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC.Message();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.from = r.bytes();
                break;
              case 2:
                m.data = r.bytes();
                break;
              case 3:
                m.seqno = r.bytes();
                break;
              case 4:
                if (!(m.topicIDs && m.topicIDs.length))
                  m.topicIDs = [];
                m.topicIDs.push(r.string());
                break;
              case 5:
                m.signature = r.bytes();
                break;
              case 6:
                m.key = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        Message2.fromObject = function fromObject(d) {
          if (d instanceof $root11.RPC.Message)
            return d;
          var m = new $root11.RPC.Message();
          if (d.from != null) {
            if (typeof d.from === "string")
              $util11.base64.decode(d.from, m.from = $util11.newBuffer($util11.base64.length(d.from)), 0);
            else if (d.from.length)
              m.from = d.from;
          }
          if (d.data != null) {
            if (typeof d.data === "string")
              $util11.base64.decode(d.data, m.data = $util11.newBuffer($util11.base64.length(d.data)), 0);
            else if (d.data.length)
              m.data = d.data;
          }
          if (d.seqno != null) {
            if (typeof d.seqno === "string")
              $util11.base64.decode(d.seqno, m.seqno = $util11.newBuffer($util11.base64.length(d.seqno)), 0);
            else if (d.seqno.length)
              m.seqno = d.seqno;
          }
          if (d.topicIDs) {
            if (!Array.isArray(d.topicIDs))
              throw TypeError(".RPC.Message.topicIDs: array expected");
            m.topicIDs = [];
            for (var i = 0; i < d.topicIDs.length; ++i) {
              m.topicIDs[i] = String(d.topicIDs[i]);
            }
          }
          if (d.signature != null) {
            if (typeof d.signature === "string")
              $util11.base64.decode(d.signature, m.signature = $util11.newBuffer($util11.base64.length(d.signature)), 0);
            else if (d.signature.length)
              m.signature = d.signature;
          }
          if (d.key != null) {
            if (typeof d.key === "string")
              $util11.base64.decode(d.key, m.key = $util11.newBuffer($util11.base64.length(d.key)), 0);
            else if (d.key.length)
              m.key = d.key;
          }
          return m;
        };
        Message2.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.topicIDs = [];
          }
          if (m.from != null && m.hasOwnProperty("from")) {
            d.from = o.bytes === String ? $util11.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;
            if (o.oneofs)
              d._from = "from";
          }
          if (m.data != null && m.hasOwnProperty("data")) {
            d.data = o.bytes === String ? $util11.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
            if (o.oneofs)
              d._data = "data";
          }
          if (m.seqno != null && m.hasOwnProperty("seqno")) {
            d.seqno = o.bytes === String ? $util11.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;
            if (o.oneofs)
              d._seqno = "seqno";
          }
          if (m.topicIDs && m.topicIDs.length) {
            d.topicIDs = [];
            for (var j = 0; j < m.topicIDs.length; ++j) {
              d.topicIDs[j] = m.topicIDs[j];
            }
          }
          if (m.signature != null && m.hasOwnProperty("signature")) {
            d.signature = o.bytes === String ? $util11.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
            if (o.oneofs)
              d._signature = "signature";
          }
          if (m.key != null && m.hasOwnProperty("key")) {
            d.key = o.bytes === String ? $util11.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
            if (o.oneofs)
              d._key = "key";
          }
          return d;
        };
        Message2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
        };
        return Message2;
      }();
      return RPC;
    }();
    module2.exports = $root11;
  }
});

// node_modules/it-length-prefixed/src/varint-encode.js
var require_varint_encode = __commonJS({
  "node_modules/it-length-prefixed/src/varint-encode.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Varint = require_varint();
    var { Buffer: Buffer2 } = require_buffer();
    var varintEncode = (value, target, offset) => {
      const ret = Varint.encode(value, target, offset);
      varintEncode.bytes = Varint.encode.bytes;
      return target || Buffer2.from(ret);
    };
    module2.exports = varintEncode;
  }
});

// node_modules/it-length-prefixed/src/encode.js
var require_encode2 = __commonJS({
  "node_modules/it-length-prefixed/src/encode.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var BufferList3 = require_BufferList();
    var varintEncode = require_varint_encode();
    var MIN_POOL_SIZE = 8;
    var DEFAULT_POOL_SIZE = 10 * 1024;
    function encode19(options) {
      options = options || {};
      const poolSize = Math.max(options.poolSize || DEFAULT_POOL_SIZE, options.minPoolSize || MIN_POOL_SIZE);
      const encodeLength = options.lengthEncoder || varintEncode;
      const encoder = async function* (source) {
        let pool = Buffer2.alloc(poolSize);
        let poolOffset = 0;
        for await (const chunk of source) {
          encodeLength(chunk.length, pool, poolOffset);
          const encodedLength = pool.slice(poolOffset, poolOffset + encodeLength.bytes);
          poolOffset += encodeLength.bytes;
          if (pool.length - poolOffset < MIN_POOL_SIZE) {
            pool = Buffer2.alloc(poolSize);
            poolOffset = 0;
          }
          yield new BufferList3().append(encodedLength).append(chunk);
        }
      };
      return encoder;
    }
    encode19.single = (chunk, options) => {
      options = options || {};
      const encodeLength = options.lengthEncoder || varintEncode;
      return new BufferList3([encodeLength(chunk.length), chunk.slice()]);
    };
    module2.exports = encode19;
    module2.exports.MIN_POOL_SIZE = MIN_POOL_SIZE;
    module2.exports.DEFAULT_POOL_SIZE = DEFAULT_POOL_SIZE;
  }
});

// node_modules/it-length-prefixed/src/varint-decode.js
var require_varint_decode = __commonJS({
  "node_modules/it-length-prefixed/src/varint-decode.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Varint = require_varint();
    var { Buffer: Buffer2 } = require_buffer();
    var toBufferProxy = (bl) => new Proxy({}, {
      get: (_, prop) => {
        return prop[0] === "l" ? bl[prop] : bl.get(parseInt(prop));
      }
    });
    var varintDecode = (data) => {
      const len = Varint.decode(Buffer2.isBuffer(data) ? data : toBufferProxy(data));
      varintDecode.bytes = Varint.decode.bytes;
      return len;
    };
    module2.exports = varintDecode;
  }
});

// node_modules/it-length-prefixed/src/decode.js
var require_decode2 = __commonJS({
  "node_modules/it-length-prefixed/src/decode.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var BufferList3 = require_BufferList();
    var varintDecode = require_varint_decode();
    var MAX_LENGTH_LENGTH = 8;
    var MAX_DATA_LENGTH = 1024 * 1024 * 4;
    var Empty = Buffer2.alloc(0);
    var ReadModes = { LENGTH: "readLength", DATA: "readData" };
    var ReadHandlers = {
      [ReadModes.LENGTH]: (chunk, buffer3, state, options) => {
        buffer3 = buffer3.append(chunk);
        let dataLength;
        try {
          dataLength = options.lengthDecoder(buffer3);
        } catch (err) {
          if (buffer3.length > options.maxLengthLength) {
            throw Object.assign(err, { message: "message length too long", code: "ERR_MSG_LENGTH_TOO_LONG" });
          }
          if (err instanceof RangeError) {
            return { mode: ReadModes.LENGTH, buffer: buffer3, chunk: void 0, state: void 0, data: void 0 };
          }
          throw err;
        }
        if (dataLength > options.maxDataLength) {
          throw Object.assign(new Error("message data too long"), { code: "ERR_MSG_DATA_TOO_LONG" });
        }
        chunk = buffer3.shallowSlice(options.lengthDecoder.bytes);
        buffer3 = new BufferList3();
        if (options.onLength)
          options.onLength(dataLength);
        if (dataLength <= 0) {
          if (options.onData)
            options.onData(Empty);
          return { mode: ReadModes.LENGTH, chunk, buffer: buffer3, data: Empty };
        }
        return { mode: ReadModes.DATA, chunk, buffer: buffer3, state: { dataLength }, data: void 0 };
      },
      [ReadModes.DATA]: (chunk, buffer3, state, options) => {
        buffer3 = buffer3.append(chunk);
        if (!state) {
          throw new Error("state is required");
        }
        if (buffer3.length < state.dataLength) {
          return { mode: ReadModes.DATA, buffer: buffer3, state, chunk: void 0, data: void 0 };
        }
        const { dataLength } = state;
        const data = buffer3.shallowSlice(0, dataLength);
        const nextChunk = buffer3.length > dataLength ? buffer3.shallowSlice(dataLength) : void 0;
        buffer3 = new BufferList3();
        if (options.onData)
          options.onData(data);
        return { mode: ReadModes.LENGTH, chunk: nextChunk, buffer: buffer3, state: void 0, data };
      }
    };
    function decode22(options) {
      options = options || {};
      const opts = {
        lengthDecoder: options.lengthDecoder || varintDecode,
        maxLengthLength: options.maxLengthLength || MAX_LENGTH_LENGTH,
        maxDataLength: options.maxDataLength || MAX_DATA_LENGTH,
        onLength: options.onLength,
        onData: options.onData
      };
      const decoder = async function* (source) {
        let buffer3 = new BufferList3();
        let mode = ReadModes.LENGTH;
        let state;
        for await (const chunk of source) {
          let nextChunk = chunk;
          while (nextChunk) {
            const result = ReadHandlers[mode](nextChunk, buffer3, state, opts);
            mode = result.mode;
            nextChunk = result.chunk;
            buffer3 = result.buffer;
            state = result.state;
            if (result.data) {
              yield result.data;
            }
          }
        }
        if (buffer3.length) {
          throw Object.assign(new Error("unexpected end of input"), { code: "ERR_UNEXPECTED_EOF" });
        }
      };
      return decoder;
    }
    decode22.fromReader = (reader, options) => {
      let byteLength = 1;
      const varByteSource = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next: async () => {
          try {
            return await reader.next(byteLength);
          } catch (err) {
            if (err.code === "ERR_UNDER_READ") {
              return { done: true, value: null };
            }
            throw err;
          } finally {
            byteLength = 1;
          }
        }
      };
      const onLength = (l) => {
        byteLength = l;
      };
      return decode22({
        ...options || {},
        onLength
      })(varByteSource);
    };
    module2.exports = decode22;
    module2.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;
    module2.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;
  }
});

// node_modules/it-length-prefixed/src/int32BE-encode.js
var require_int32BE_encode = __commonJS({
  "node_modules/it-length-prefixed/src/int32BE-encode.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var int32BEEncode = (value, target, offset) => {
      target = target || Buffer2.allocUnsafe(4);
      target.writeInt32BE(value, offset);
      return target;
    };
    int32BEEncode.bytes = 4;
    module2.exports = int32BEEncode;
  }
});

// node_modules/it-length-prefixed/src/int32BE-decode.js
var require_int32BE_decode = __commonJS({
  "node_modules/it-length-prefixed/src/int32BE-decode.js"(exports2, module2) {
    "use strict";
    init_globals();
    var int32BEDecode = (data) => {
      if (data.length < 4)
        throw RangeError("Could not decode int32BE");
      return data.readInt32BE(0);
    };
    int32BEDecode.bytes = 4;
    module2.exports = int32BEDecode;
  }
});

// node_modules/it-length-prefixed/src/index.js
var require_src11 = __commonJS({
  "node_modules/it-length-prefixed/src/index.js"(exports2) {
    "use strict";
    init_globals();
    exports2.encode = require_encode2();
    exports2.decode = require_decode2();
    exports2.varintEncode = require_varint_encode();
    exports2.varintDecode = require_varint_decode();
    exports2.int32BEEncode = require_int32BE_encode();
    exports2.int32BEDecode = require_int32BE_decode();
  }
});

// node_modules/get-iterator/index.js
var require_get_iterator = __commonJS({
  "node_modules/get-iterator/index.js"(exports2, module2) {
    init_globals();
    module2.exports = function getIterator(obj) {
      if (obj) {
        if (typeof obj[Symbol.iterator] === "function") {
          return obj[Symbol.iterator]();
        }
        if (typeof obj[Symbol.asyncIterator] === "function") {
          return obj[Symbol.asyncIterator]();
        }
        if (typeof obj.next === "function") {
          return obj;
        }
      }
      throw new Error("argument is not an iterator or iterable");
    };
  }
});

// node_modules/abortable-iterator/AbortError.js
var require_AbortError = __commonJS({
  "node_modules/abortable-iterator/AbortError.js"(exports2, module2) {
    init_globals();
    module2.exports = class AbortError extends Error {
      constructor(message, code13) {
        super(message || "The operation was aborted");
        this.type = "aborted";
        this.code = code13 || "ABORT_ERR";
      }
    };
  }
});

// node_modules/abortable-iterator/index.js
var require_abortable_iterator = __commonJS({
  "node_modules/abortable-iterator/index.js"(exports2, module2) {
    init_globals();
    var getIterator = require_get_iterator();
    var AbortError = require_AbortError();
    var toAbortableSource = (source, signal, options) => toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{ signal, options }]);
    var toMultiAbortableSource = (source, signals) => {
      source = getIterator(source);
      signals = signals.map(({ signal, options }) => ({ signal, options: options || {} }));
      async function* abortable() {
        let nextAbortHandler;
        const abortHandler = () => {
          if (nextAbortHandler)
            nextAbortHandler();
        };
        for (const { signal } of signals) {
          signal.addEventListener("abort", abortHandler);
        }
        while (true) {
          let result;
          try {
            for (const { signal, options } of signals) {
              if (signal.aborted) {
                const { abortMessage, abortCode } = options;
                throw new AbortError(abortMessage, abortCode);
              }
            }
            const abort = new Promise((resolve11, reject) => {
              nextAbortHandler = () => {
                const { options } = signals.find(({ signal }) => signal.aborted);
                const { abortMessage, abortCode } = options;
                reject(new AbortError(abortMessage, abortCode));
              };
            });
            result = await Promise.race([abort, source.next()]);
            nextAbortHandler = null;
          } catch (err) {
            for (const { signal } of signals) {
              signal.removeEventListener("abort", abortHandler);
            }
            const aborter = signals.find(({ signal }) => signal.aborted);
            const isKnownAborter = err.type === "aborted" && aborter;
            if (isKnownAborter && aborter.options.onAbort) {
              await aborter.options.onAbort(source);
            }
            if (typeof source.return === "function") {
              try {
                const p = source.return();
                if (p instanceof Promise) {
                  p.catch((err2) => {
                    if (aborter.options.onReturnError != null) {
                      aborter.options.onReturnError(err2);
                    }
                  });
                }
              } catch (err2) {
                if (aborter.options.onReturnError != null) {
                  aborter.options.onReturnError(err2);
                }
              }
            }
            if (isKnownAborter && aborter.options.returnOnAbort) {
              return;
            }
            throw err;
          }
          if (result.done)
            break;
          yield result.value;
        }
        for (const { signal } of signals) {
          signal.removeEventListener("abort", abortHandler);
        }
      }
      return abortable();
    };
    var toAbortableSink = (sink, signal, options) => toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{ signal, options }]);
    var toMultiAbortableSink = (sink, signals) => (source) => sink(toMultiAbortableSource(source, signals));
    var toAbortableDuplex = (duplex, signal, options) => toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{ signal, options }]);
    var toMultiAbortableDuplex = (duplex, signals) => ({
      sink: toMultiAbortableSink(duplex.sink, signals),
      source: toMultiAbortableSource(duplex.source, signals)
    });
    module2.exports = toAbortableSource;
    module2.exports.AbortError = AbortError;
    module2.exports.source = toAbortableSource;
    module2.exports.sink = toAbortableSink;
    module2.exports.transform = toAbortableSink;
    module2.exports.duplex = toAbortableDuplex;
  }
});

// node_modules/libp2p-interfaces/src/pubsub/peer-streams.js
var require_peer_streams = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/peer-streams.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p-pubsub:peer-streams"), {
      error: debug50("libp2p-pubsub:peer-streams:err")
    });
    var { EventEmitter: EventEmitter4 } = require_events();
    var lp2 = require_src11();
    var pushable5 = require_it_pushable();
    var { pipe: pipe8 } = require_it_pipe();
    var { source: abortable } = require_abortable_iterator();
    var PeerStreams = class extends EventEmitter4 {
      constructor({ id, protocol }) {
        super();
        this.id = id;
        this.protocol = protocol;
        this._rawOutboundStream = null;
        this._rawInboundStream = null;
        this._inboundAbortController = new AbortController();
        this.outboundStream = null;
        this.inboundStream = null;
      }
      get isReadable() {
        return Boolean(this.inboundStream);
      }
      get isWritable() {
        return Boolean(this.outboundStream);
      }
      write(data) {
        if (!this.outboundStream) {
          const id = this.id.toB58String();
          throw new Error("No writable connection to " + id);
        }
        this.outboundStream.push(data);
      }
      attachInboundStream(stream) {
        this._rawInboundStream = stream;
        this.inboundStream = abortable(pipe8(this._rawInboundStream, lp2.decode()), this._inboundAbortController.signal, { returnOnAbort: true });
        this.emit("stream:inbound");
        return this.inboundStream;
      }
      async attachOutboundStream(stream) {
        const _prevStream = this.outboundStream;
        if (this.outboundStream) {
          await this.outboundStream.end();
        }
        this._rawOutboundStream = stream;
        this.outboundStream = pushable5({
          onEnd: (shouldEmit) => {
            this._rawOutboundStream && this._rawOutboundStream.reset && this._rawOutboundStream.reset();
            this._rawOutboundStream = null;
            this.outboundStream = null;
            if (shouldEmit) {
              this.emit("close");
            }
          }
        });
        pipe8(this.outboundStream, lp2.encode(), this._rawOutboundStream).catch((err) => {
          log48.error(err);
        });
        if (!_prevStream) {
          this.emit("stream:outbound");
        }
      }
      close() {
        if (this.outboundStream) {
          this.outboundStream.end();
        }
        if (this.inboundStream) {
          this._inboundAbortController.abort();
        }
        this._rawOutboundStream = null;
        this.outboundStream = null;
        this._rawInboundStream = null;
        this.inboundStream = null;
        this.emit("close");
      }
    };
    module2.exports = PeerStreams;
  }
});

// node_modules/libp2p-interfaces/src/pubsub/signature-policy.js
var require_signature_policy = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/signature-policy.js"(exports2) {
    "use strict";
    init_globals();
    var SignaturePolicy = {
      StrictSign: "StrictSign",
      StrictNoSign: "StrictNoSign"
    };
    exports2.SignaturePolicy = SignaturePolicy;
  }
});

// node_modules/libp2p-interfaces/src/pubsub/utils.js
var require_utils3 = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/utils.js"(exports2, module2) {
    "use strict";
    init_globals();
    var randomBytes = require_random_bytes();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var PeerId14 = require_src5();
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    var randomSeqno = () => {
      return randomBytes(8);
    };
    var msgId = (from5, seqno) => {
      let fromBytes2;
      if (from5 instanceof Uint8Array) {
        fromBytes2 = PeerId14.createFromBytes(from5).id;
      } else {
        fromBytes2 = PeerId14.parse(from5).id;
      }
      const msgId2 = new Uint8Array(fromBytes2.length + seqno.length);
      msgId2.set(fromBytes2, 0);
      msgId2.set(seqno, fromBytes2.length);
      return msgId2;
    };
    var noSignMsgId = (data) => sha2563.encode(data);
    var anyMatch = (a, b) => {
      let bHas;
      if (Array.isArray(b)) {
        bHas = (val) => b.indexOf(val) > -1;
      } else {
        bHas = (val) => b.has(val);
      }
      for (const val of a) {
        if (bHas(val)) {
          return true;
        }
      }
      return false;
    };
    var ensureArray = (maybeArray) => {
      if (!Array.isArray(maybeArray)) {
        return [maybeArray];
      }
      return maybeArray;
    };
    var normalizeInRpcMessage = (message, peerId) => {
      const m = Object.assign({}, message);
      if (message.from instanceof Uint8Array) {
        m.from = uint8ArrayToString(message.from, "base58btc");
      }
      if (peerId) {
        m.receivedFrom = peerId;
      }
      return m;
    };
    var normalizeOutRpcMessage = (message) => {
      const m = Object.assign({}, message);
      if (typeof message.from === "string") {
        m.from = uint8ArrayFromString(message.from, "base58btc");
      }
      if (typeof message.data === "string") {
        m.data = uint8ArrayFromString(message.data);
      }
      return m;
    };
    module2.exports = {
      randomSeqno,
      msgId,
      noSignMsgId,
      anyMatch,
      ensureArray,
      normalizeInRpcMessage,
      normalizeOutRpcMessage
    };
  }
});

// node_modules/libp2p-interfaces/src/pubsub/message/sign.js
var require_sign = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/message/sign.js"(exports2, module2) {
    "use strict";
    init_globals();
    var PeerId14 = require_src5();
    var { RPC } = require_rpc2();
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var SignPrefix = uint8ArrayFromString("libp2p-pubsub:");
    var { normalizeOutRpcMessage } = require_utils3();
    async function signMessage(peerId, message) {
      const bytes2 = uint8ArrayConcat([
        SignPrefix,
        RPC.Message.encode(normalizeOutRpcMessage(message)).finish()
      ]);
      const signature = await peerId.privKey.sign(bytes2);
      return {
        ...message,
        signature,
        key: peerId.pubKey.bytes
      };
    }
    async function verifySignature(message) {
      if (!message.signature) {
        throw new Error("Message must contain a signature to be verified");
      }
      if (!message.from) {
        throw new Error("Message must contain a from property to be verified");
      }
      const bytes2 = uint8ArrayConcat([
        SignPrefix,
        RPC.Message.encode({
          ...message,
          from: PeerId14.createFromB58String(message.from).toBytes(),
          signature: void 0,
          key: void 0
        }).finish()
      ]);
      const pubKey = await messagePublicKey(message);
      return pubKey.verify(bytes2, message.signature);
    }
    async function messagePublicKey(message) {
      if (!message.from) {
        throw new Error("Could not get the public key from the originator id");
      }
      const from5 = PeerId14.createFromB58String(message.from);
      if (message.key) {
        const keyPeerId = await PeerId14.createFromPubKey(message.key);
        if (keyPeerId.equals(from5))
          return keyPeerId.pubKey;
        throw new Error("Public Key does not match the originator");
      } else if (from5.pubKey) {
        return from5.pubKey;
      } else {
        throw new Error("Could not get the public key from the originator id");
      }
    }
    module2.exports = {
      messagePublicKey,
      signMessage,
      SignPrefix,
      verifySignature
    };
  }
});

// node_modules/libp2p-interfaces/src/pubsub/index.js
var require_pubsub = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var { EventEmitter: EventEmitter4 } = require_events();
    var errcode17 = require_err_code();
    var { pipe: pipe8 } = require_it_pipe();
    var { default: Queue4 } = require_dist();
    var MulticodecTopology2 = require_multicodec_topology();
    var { codes } = require_errors2();
    var { RPC } = require_rpc2();
    var PeerStreams = require_peer_streams();
    var { SignaturePolicy } = require_signature_policy();
    var utils = require_utils3();
    var {
      signMessage,
      verifySignature
    } = require_sign();
    var PubsubBaseProtocol = class extends EventEmitter4 {
      constructor({
        debugName,
        multicodecs,
        libp2p,
        globalSignaturePolicy = SignaturePolicy.StrictSign,
        canRelayMessage = false,
        emitSelf = false,
        messageProcessingConcurrency = 10
      }) {
        if (typeof debugName !== "string") {
          throw new Error("a debugname `string` is required");
        }
        if (!multicodecs) {
          throw new Error("multicodecs are required");
        }
        if (!libp2p) {
          throw new Error("libp2p is required");
        }
        super();
        this.log = Object.assign(debug50(debugName), {
          err: debug50(`${debugName}:error`)
        });
        this.multicodecs = utils.ensureArray(multicodecs);
        this._libp2p = libp2p;
        this.registrar = libp2p.registrar;
        this.peerId = libp2p.peerId;
        this.started = false;
        this.topics = /* @__PURE__ */ new Map();
        this.subscriptions = /* @__PURE__ */ new Set();
        this.peers = /* @__PURE__ */ new Map();
        if (!SignaturePolicy[globalSignaturePolicy]) {
          throw errcode17(new Error("Invalid global signature policy"), codes.ERR_INVALID_SIGNATURE_POLICY);
        }
        this.globalSignaturePolicy = globalSignaturePolicy;
        this.canRelayMessage = canRelayMessage;
        this.emitSelf = emitSelf;
        this.topicValidators = /* @__PURE__ */ new Map();
        this.queue = new Queue4({ concurrency: messageProcessingConcurrency });
        this._registrarId = void 0;
        this._onIncomingStream = this._onIncomingStream.bind(this);
        this._onPeerConnected = this._onPeerConnected.bind(this);
        this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
      }
      async start() {
        if (this.started) {
          return;
        }
        this.log("starting");
        this.registrar.handle(this.multicodecs, this._onIncomingStream);
        const topology = new MulticodecTopology2({
          multicodecs: this.multicodecs,
          handlers: {
            onConnect: this._onPeerConnected,
            onDisconnect: this._onPeerDisconnected
          }
        });
        this._registrarId = await this.registrar.register(topology);
        this.log("started");
        this.started = true;
      }
      async stop() {
        if (!this.started) {
          return;
        }
        this.registrar.unregister(this._registrarId);
        this.log("stopping");
        this.peers.forEach((peerStreams) => peerStreams.close());
        this.peers = /* @__PURE__ */ new Map();
        this.subscriptions = /* @__PURE__ */ new Set();
        this.started = false;
        this.log("stopped");
      }
      _onIncomingStream({ protocol, stream, connection }) {
        const peerId = connection.remotePeer;
        const idB58Str = peerId.toB58String();
        const peer = this._addPeer(peerId, protocol);
        const inboundStream = peer.attachInboundStream(stream);
        this._processMessages(idB58Str, inboundStream, peer);
      }
      async _onPeerConnected(peerId, conn) {
        const idB58Str = peerId.toB58String();
        this.log("connected", idB58Str);
        try {
          const { stream, protocol } = await conn.newStream(this.multicodecs);
          const peer = this._addPeer(peerId, protocol);
          await peer.attachOutboundStream(stream);
        } catch (err) {
          this.log.err(err);
        }
        this._sendSubscriptions(idB58Str, Array.from(this.subscriptions), true);
      }
      _onPeerDisconnected(peerId, err) {
        const idB58Str = peerId.toB58String();
        this.log("connection ended", idB58Str, err ? err.message : "");
        this._removePeer(peerId);
      }
      _addPeer(peerId, protocol) {
        const id = peerId.toB58String();
        const existing = this.peers.get(id);
        if (existing) {
          return existing;
        }
        this.log("new peer", id);
        const peerStreams = new PeerStreams({
          id: peerId,
          protocol
        });
        this.peers.set(id, peerStreams);
        peerStreams.once("close", () => this._removePeer(peerId));
        return peerStreams;
      }
      _removePeer(peerId) {
        if (!peerId)
          return;
        const id = peerId.toB58String();
        const peerStreams = this.peers.get(id);
        if (!peerStreams)
          return;
        peerStreams.removeAllListeners();
        peerStreams.close();
        this.log("delete peer", id);
        this.peers.delete(id);
        for (const peers of this.topics.values()) {
          peers.delete(id);
        }
        return peerStreams;
      }
      async _processMessages(idB58Str, stream, peerStreams) {
        try {
          await pipe8(stream, async (source) => {
            for await (const data of source) {
              const rpcBytes = data instanceof Uint8Array ? data : data.slice();
              const rpcMsg = this._decodeRpc(rpcBytes);
              (async () => {
                try {
                  await this._processRpc(idB58Str, peerStreams, rpcMsg);
                } catch (err) {
                  this.log.err(err);
                }
              })();
            }
          });
        } catch (err) {
          this._onPeerDisconnected(peerStreams.id, err);
        }
      }
      async _processRpc(idB58Str, peerStreams, rpc) {
        this.log("rpc from", idB58Str);
        const subs = rpc.subscriptions;
        const msgs = rpc.msgs;
        if (subs.length) {
          subs.forEach((subOpt) => {
            this._processRpcSubOpt(idB58Str, subOpt);
          });
          this.emit("pubsub:subscription-change", peerStreams.id, subs);
        }
        if (!this._acceptFrom(idB58Str)) {
          this.log("received message from unacceptable peer %s", idB58Str);
          return false;
        }
        if (msgs.length) {
          this.queue.addAll(msgs.map((message) => async () => {
            if (!(this.canRelayMessage || message.topicIDs && message.topicIDs.some((topic) => this.subscriptions.has(topic)))) {
              this.log("received message we didn't subscribe to. Dropping.");
              return;
            }
            try {
              const msg = utils.normalizeInRpcMessage(message, idB58Str);
              await this._processRpcMessage(msg);
            } catch (err) {
              this.log.err(err);
            }
          }));
        }
        return true;
      }
      _processRpcSubOpt(id, subOpt) {
        const t = subOpt.topicID;
        if (!t) {
          return;
        }
        let topicSet = this.topics.get(t);
        if (!topicSet) {
          topicSet = /* @__PURE__ */ new Set();
          this.topics.set(t, topicSet);
        }
        if (subOpt.subscribe) {
          topicSet.add(id);
        } else {
          topicSet.delete(id);
        }
      }
      async _processRpcMessage(msg) {
        if (this.peerId.toB58String() === msg.from && !this.emitSelf) {
          return;
        }
        try {
          await this.validate(msg);
        } catch (err) {
          this.log("Message is invalid, dropping it. %O", err);
          return;
        }
        this._emitMessage(msg);
        return this._publish(utils.normalizeOutRpcMessage(msg));
      }
      _emitMessage(message) {
        message.topicIDs.forEach((topic) => {
          if (this.subscriptions.has(topic)) {
            this.emit(topic, message);
          }
        });
      }
      getMsgId(msg) {
        const signaturePolicy = this.globalSignaturePolicy;
        switch (signaturePolicy) {
          case SignaturePolicy.StrictSign:
            return utils.msgId(msg.from, msg.seqno);
          case SignaturePolicy.StrictNoSign:
            return utils.noSignMsgId(msg.data);
          default:
            throw errcode17(new Error("Cannot get message id: unhandled signature policy: " + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);
        }
      }
      _acceptFrom(id) {
        return true;
      }
      _decodeRpc(bytes2) {
        return RPC.decode(bytes2);
      }
      _encodeRpc(rpc) {
        return RPC.encode(rpc).finish();
      }
      _sendRpc(id, rpc) {
        const peerStreams = this.peers.get(id);
        if (!peerStreams || !peerStreams.isWritable) {
          const msg = `Cannot send RPC to ${id} as there is no open stream to it available`;
          this.log.err(msg);
          return;
        }
        peerStreams.write(this._encodeRpc(rpc));
      }
      _sendSubscriptions(id, topics, subscribe) {
        return this._sendRpc(id, {
          subscriptions: topics.map((t) => ({ topicID: t, subscribe }))
        });
      }
      async validate(message) {
        const signaturePolicy = this.globalSignaturePolicy;
        switch (signaturePolicy) {
          case SignaturePolicy.StrictNoSign:
            if (message.from) {
              throw errcode17(new Error("StrictNoSigning: from should not be present"), codes.ERR_UNEXPECTED_FROM);
            }
            if (message.signature) {
              throw errcode17(new Error("StrictNoSigning: signature should not be present"), codes.ERR_UNEXPECTED_SIGNATURE);
            }
            if (message.key) {
              throw errcode17(new Error("StrictNoSigning: key should not be present"), codes.ERR_UNEXPECTED_KEY);
            }
            if (message.seqno) {
              throw errcode17(new Error("StrictNoSigning: seqno should not be present"), codes.ERR_UNEXPECTED_SEQNO);
            }
            break;
          case SignaturePolicy.StrictSign:
            if (!message.signature) {
              throw errcode17(new Error("StrictSigning: Signing required and no signature was present"), codes.ERR_MISSING_SIGNATURE);
            }
            if (!message.seqno) {
              throw errcode17(new Error("StrictSigning: Signing required and no seqno was present"), codes.ERR_MISSING_SEQNO);
            }
            if (!await verifySignature(message)) {
              throw errcode17(new Error("StrictSigning: Invalid message signature"), codes.ERR_INVALID_SIGNATURE);
            }
            break;
          default:
            throw errcode17(new Error("Cannot validate message: unhandled signature policy: " + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);
        }
        for (const topic of message.topicIDs) {
          const validatorFn = this.topicValidators.get(topic);
          if (validatorFn) {
            await validatorFn(topic, message);
          }
        }
      }
      _buildMessage(message) {
        const signaturePolicy = this.globalSignaturePolicy;
        switch (signaturePolicy) {
          case SignaturePolicy.StrictSign:
            message.from = this.peerId.toB58String();
            message.seqno = utils.randomSeqno();
            return signMessage(this.peerId, message);
          case SignaturePolicy.StrictNoSign:
            return Promise.resolve(message);
          default:
            throw errcode17(new Error("Cannot build message: unhandled signature policy: " + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);
        }
      }
      getSubscribers(topic) {
        if (!this.started) {
          throw errcode17(new Error("not started yet"), "ERR_NOT_STARTED_YET");
        }
        if (!topic || typeof topic !== "string") {
          throw errcode17(new Error("a string topic must be provided"), "ERR_NOT_VALID_TOPIC");
        }
        const peersInTopic = this.topics.get(topic);
        if (!peersInTopic) {
          return [];
        }
        return Array.from(peersInTopic);
      }
      async publish(topic, message) {
        if (!this.started) {
          throw new Error("Pubsub has not started");
        }
        this.log("publish", topic, message);
        const from5 = this.peerId.toB58String();
        const msgObject = {
          receivedFrom: from5,
          data: message,
          topicIDs: [topic]
        };
        const outMsg = await this._buildMessage(msgObject);
        const msg = utils.normalizeInRpcMessage(outMsg);
        this.emitSelf && this._emitMessage(msg);
        await this._publish(msg);
      }
      _publish(message) {
        throw errcode17(new Error("publish must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED");
      }
      subscribe(topic) {
        if (!this.started) {
          throw new Error("Pubsub has not started");
        }
        if (!this.subscriptions.has(topic)) {
          this.subscriptions.add(topic);
          this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], true));
        }
      }
      unsubscribe(topic) {
        if (!this.started) {
          throw new Error("Pubsub is not started");
        }
        if (this.subscriptions.has(topic) && this.listenerCount(topic) === 0) {
          this.subscriptions.delete(topic);
          this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], false));
        }
      }
      getTopics() {
        if (!this.started) {
          throw new Error("Pubsub is not started");
        }
        return Array.from(this.subscriptions);
      }
    };
    PubsubBaseProtocol.utils = utils;
    PubsubBaseProtocol.SignaturePolicy = SignaturePolicy;
    module2.exports = PubsubBaseProtocol;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/create-gossip-rpc.js
var require_create_gossip_rpc = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/create-gossip-rpc.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createGossipRpc = void 0;
    function createGossipRpc(msgs = [], control = {}) {
      return {
        subscriptions: [],
        msgs,
        control: Object.assign({ ihave: [], iwant: [], graft: [], prune: [] }, control)
      };
    }
    exports2.createGossipRpc = createGossipRpc;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/shuffle.js
var require_shuffle = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/shuffle.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shuffle = void 0;
    function shuffle2(arr) {
      if (arr.length <= 1) {
        return arr;
      }
      const randInt = () => {
        return Math.floor(Math.random() * Math.floor(arr.length));
      };
      for (let i = 0; i < arr.length; i++) {
        const j = randInt();
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      return arr;
    }
    exports2.shuffle = shuffle2;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/constants.js
var require_constants3 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/constants.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ACCEPT_FROM_WHITELIST_DURATION_MS = exports2.ACCEPT_FROM_WHITELIST_MAX_MESSAGES = exports2.ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = exports2.ERR_TOPIC_VALIDATOR_IGNORE = exports2.ERR_TOPIC_VALIDATOR_REJECT = exports2.TimeCacheDuration = exports2.GossipsubSeenTTL = exports2.GossipsubIWantFollowupTime = exports2.GossipsubMaxIHaveMessages = exports2.GossipsubMaxIHaveLength = exports2.GossipsubGraftFloodThreshold = exports2.GossipsubOpportunisticGraftPeers = exports2.GossipsubOpportunisticGraftTicks = exports2.GossipsubDirectConnectInitialDelay = exports2.GossipsubDirectConnectTicks = exports2.GossipsubConnectionTimeout = exports2.GossipsubMaxPendingConnections = exports2.GossipsubConnectors = exports2.GossipsubPruneBackoffTicks = exports2.GossipsubPruneBackoff = exports2.GossipsubPrunePeers = exports2.GossipsubFanoutTTL = exports2.GossipsubHeartbeatInterval = exports2.GossipsubHeartbeatInitialDelay = exports2.GossipsubGossipRetransmission = exports2.GossipsubGossipFactor = exports2.GossipsubDlazy = exports2.GossipsubHistoryGossip = exports2.GossipsubHistoryLength = exports2.GossipsubDout = exports2.GossipsubDscore = exports2.GossipsubDhi = exports2.GossipsubDlo = exports2.GossipsubD = exports2.GossipsubIDv11 = exports2.GossipsubIDv10 = exports2.FloodsubID = exports2.minute = exports2.second = void 0;
    exports2.second = 1e3;
    exports2.minute = 60 * exports2.second;
    exports2.FloodsubID = "/floodsub/1.0.0";
    exports2.GossipsubIDv10 = "/meshsub/1.0.0";
    exports2.GossipsubIDv11 = "/meshsub/1.1.0";
    exports2.GossipsubD = 6;
    exports2.GossipsubDlo = 4;
    exports2.GossipsubDhi = 12;
    exports2.GossipsubDscore = 4;
    exports2.GossipsubDout = 2;
    exports2.GossipsubHistoryLength = 5;
    exports2.GossipsubHistoryGossip = 3;
    exports2.GossipsubDlazy = 6;
    exports2.GossipsubGossipFactor = 0.25;
    exports2.GossipsubGossipRetransmission = 3;
    exports2.GossipsubHeartbeatInitialDelay = 100;
    exports2.GossipsubHeartbeatInterval = exports2.second;
    exports2.GossipsubFanoutTTL = exports2.minute;
    exports2.GossipsubPrunePeers = 16;
    exports2.GossipsubPruneBackoff = exports2.minute;
    exports2.GossipsubPruneBackoffTicks = 15;
    exports2.GossipsubConnectors = 8;
    exports2.GossipsubMaxPendingConnections = 128;
    exports2.GossipsubConnectionTimeout = 30 * exports2.second;
    exports2.GossipsubDirectConnectTicks = 300;
    exports2.GossipsubDirectConnectInitialDelay = exports2.second;
    exports2.GossipsubOpportunisticGraftTicks = 60;
    exports2.GossipsubOpportunisticGraftPeers = 2;
    exports2.GossipsubGraftFloodThreshold = 10 * exports2.second;
    exports2.GossipsubMaxIHaveLength = 5e3;
    exports2.GossipsubMaxIHaveMessages = 10;
    exports2.GossipsubIWantFollowupTime = 3 * exports2.second;
    exports2.GossipsubSeenTTL = 30 * exports2.second;
    exports2.TimeCacheDuration = 120 * 1e3;
    exports2.ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
    exports2.ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
    exports2.ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0;
    exports2.ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128;
    exports2.ACCEPT_FROM_WHITELIST_DURATION_MS = 1e3;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/has-gossip-protocol.js
var require_has_gossip_protocol = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/has-gossip-protocol.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasGossipProtocol = void 0;
    var constants_1 = require_constants3();
    function hasGossipProtocol(protocol) {
      return protocol === constants_1.GossipsubIDv10 || protocol === constants_1.GossipsubIDv11;
    }
    exports2.hasGossipProtocol = hasGossipProtocol;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/messageIdToString.js
var require_messageIdToString = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/messageIdToString.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.messageIdFromString = exports2.messageIdToString = void 0;
    var from_string_1 = (init_from_string(), __toCommonJS(from_string_exports));
    var to_string_1 = (init_to_string(), __toCommonJS(to_string_exports));
    function messageIdToString(msgId) {
      return to_string_1.toString(msgId, "base64");
    }
    exports2.messageIdToString = messageIdToString;
    function messageIdFromString(msgId) {
      return from_string_1.fromString(msgId, "base64");
    }
    exports2.messageIdFromString = messageIdFromString;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/index.js
var require_utils4 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/index.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_create_gossip_rpc(), exports2);
    __exportStar(require_shuffle(), exports2);
    __exportStar(require_has_gossip_protocol(), exports2);
    __exportStar(require_messageIdToString(), exports2);
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/message-cache.js
var require_message_cache = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/message-cache.js"(exports2) {
    "use strict";
    init_globals();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve11) {
          resolve11(value);
        });
      }
      return new (P || (P = Promise))(function(resolve11, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve11(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessageCache = void 0;
    var utils_1 = require_utils4();
    var MessageCache = class {
      constructor(gossip, history) {
        this.msgs = /* @__PURE__ */ new Map();
        this.peertx = /* @__PURE__ */ new Map();
        this.history = [];
        for (let i = 0; i < history; i++) {
          this.history[i] = [];
        }
        this.gossip = gossip;
      }
      put(msg, msgIdStr) {
        return __awaiter(this, void 0, void 0, function* () {
          this.msgs.set(msgIdStr, msg);
          const msgId = utils_1.messageIdFromString(msgIdStr);
          this.history[0].push({ msgId, topics: msg.topicIDs });
        });
      }
      get(msgId) {
        return this.msgs.get(utils_1.messageIdToString(msgId));
      }
      getForPeer(msgIdStr, p) {
        const msg = this.msgs.get(msgIdStr);
        if (!msg) {
          return [void 0, 0];
        }
        let peertx = this.peertx.get(msgIdStr);
        if (!peertx) {
          peertx = /* @__PURE__ */ new Map();
          this.peertx.set(msgIdStr, peertx);
        }
        const count = (peertx.get(p) || 0) + 1;
        peertx.set(p, count);
        return [msg, count];
      }
      getGossipIDs(topic) {
        const msgIds = [];
        for (let i = 0; i < this.gossip; i++) {
          this.history[i].forEach((entry) => {
            for (const t of entry.topics) {
              if (t === topic) {
                msgIds.push(entry.msgId);
                break;
              }
            }
          });
        }
        return msgIds;
      }
      shift() {
        const last15 = this.history[this.history.length - 1];
        last15.forEach((entry) => {
          const msgIdStr = utils_1.messageIdToString(entry.msgId);
          this.msgs.delete(msgIdStr);
          this.peertx.delete(msgIdStr);
        });
        this.history.pop();
        this.history.unshift([]);
      }
    };
    exports2.MessageCache = MessageCache;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/message/rpc.js
var require_rpc3 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/message/rpc.js"(exports2, module2) {
    init_globals();
    (function(global2, factory) {
      if (typeof define === "function" && define.amd)
        define(["protobufjs/minimal"], factory);
      else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2.exports)
        module2.exports = factory(require_minimal2());
    })(exports2, function($protobuf12) {
      "use strict";
      var $Reader11 = $protobuf12.Reader, $Writer11 = $protobuf12.Writer, $util11 = $protobuf12.util;
      var $root11 = $protobuf12.roots["default"] || ($protobuf12.roots["default"] = {});
      $root11.RPC = function() {
        function RPC(p) {
          this.subscriptions = [];
          this.msgs = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        RPC.prototype.subscriptions = $util11.emptyArray;
        RPC.prototype.msgs = $util11.emptyArray;
        RPC.prototype.control = null;
        var $oneOfFields;
        Object.defineProperty(RPC.prototype, "_control", {
          get: $util11.oneOfGetter($oneOfFields = ["control"]),
          set: $util11.oneOfSetter($oneOfFields)
        });
        RPC.encode = function encode19(m, w) {
          if (!w)
            w = $Writer11.create();
          if (m.subscriptions != null && m.subscriptions.length) {
            for (var i = 0; i < m.subscriptions.length; ++i)
              $root11.RPC.SubOpts.encode(m.subscriptions[i], w.uint32(10).fork()).ldelim();
          }
          if (m.msgs != null && m.msgs.length) {
            for (var i = 0; i < m.msgs.length; ++i)
              $root11.RPC.Message.encode(m.msgs[i], w.uint32(18).fork()).ldelim();
          }
          if (m.control != null && Object.hasOwnProperty.call(m, "control"))
            $root11.RPC.ControlMessage.encode(m.control, w.uint32(26).fork()).ldelim();
          return w;
        };
        RPC.decode = function decode22(r, l) {
          if (!(r instanceof $Reader11))
            r = $Reader11.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.subscriptions && m.subscriptions.length))
                  m.subscriptions = [];
                m.subscriptions.push($root11.RPC.SubOpts.decode(r, r.uint32()));
                break;
              case 2:
                if (!(m.msgs && m.msgs.length))
                  m.msgs = [];
                m.msgs.push($root11.RPC.Message.decode(r, r.uint32()));
                break;
              case 3:
                m.control = $root11.RPC.ControlMessage.decode(r, r.uint32());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        RPC.fromObject = function fromObject(d) {
          if (d instanceof $root11.RPC)
            return d;
          var m = new $root11.RPC();
          if (d.subscriptions) {
            if (!Array.isArray(d.subscriptions))
              throw TypeError(".RPC.subscriptions: array expected");
            m.subscriptions = [];
            for (var i = 0; i < d.subscriptions.length; ++i) {
              if (typeof d.subscriptions[i] !== "object")
                throw TypeError(".RPC.subscriptions: object expected");
              m.subscriptions[i] = $root11.RPC.SubOpts.fromObject(d.subscriptions[i]);
            }
          }
          if (d.msgs) {
            if (!Array.isArray(d.msgs))
              throw TypeError(".RPC.msgs: array expected");
            m.msgs = [];
            for (var i = 0; i < d.msgs.length; ++i) {
              if (typeof d.msgs[i] !== "object")
                throw TypeError(".RPC.msgs: object expected");
              m.msgs[i] = $root11.RPC.Message.fromObject(d.msgs[i]);
            }
          }
          if (d.control != null) {
            if (typeof d.control !== "object")
              throw TypeError(".RPC.control: object expected");
            m.control = $root11.RPC.ControlMessage.fromObject(d.control);
          }
          return m;
        };
        RPC.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.subscriptions = [];
            d.msgs = [];
          }
          if (m.subscriptions && m.subscriptions.length) {
            d.subscriptions = [];
            for (var j = 0; j < m.subscriptions.length; ++j) {
              d.subscriptions[j] = $root11.RPC.SubOpts.toObject(m.subscriptions[j], o);
            }
          }
          if (m.msgs && m.msgs.length) {
            d.msgs = [];
            for (var j = 0; j < m.msgs.length; ++j) {
              d.msgs[j] = $root11.RPC.Message.toObject(m.msgs[j], o);
            }
          }
          if (m.control != null && m.hasOwnProperty("control")) {
            d.control = $root11.RPC.ControlMessage.toObject(m.control, o);
            if (o.oneofs)
              d._control = "control";
          }
          return d;
        };
        RPC.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
        };
        RPC.SubOpts = function() {
          function SubOpts(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          SubOpts.prototype.subscribe = null;
          SubOpts.prototype.topicID = null;
          var $oneOfFields2;
          Object.defineProperty(SubOpts.prototype, "_subscribe", {
            get: $util11.oneOfGetter($oneOfFields2 = ["subscribe"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(SubOpts.prototype, "_topicID", {
            get: $util11.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          SubOpts.encode = function encode19(m, w) {
            if (!w)
              w = $Writer11.create();
            if (m.subscribe != null && Object.hasOwnProperty.call(m, "subscribe"))
              w.uint32(8).bool(m.subscribe);
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(18).string(m.topicID);
            return w;
          };
          SubOpts.decode = function decode22(r, l) {
            if (!(r instanceof $Reader11))
              r = $Reader11.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC.SubOpts();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.subscribe = r.bool();
                  break;
                case 2:
                  m.topicID = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          SubOpts.fromObject = function fromObject(d) {
            if (d instanceof $root11.RPC.SubOpts)
              return d;
            var m = new $root11.RPC.SubOpts();
            if (d.subscribe != null) {
              m.subscribe = Boolean(d.subscribe);
            }
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            return m;
          };
          SubOpts.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.subscribe != null && m.hasOwnProperty("subscribe")) {
              d.subscribe = m.subscribe;
              if (o.oneofs)
                d._subscribe = "subscribe";
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            return d;
          };
          SubOpts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
          };
          return SubOpts;
        }();
        RPC.Message = function() {
          function Message2(p) {
            this.topicIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          Message2.prototype.from = null;
          Message2.prototype.data = null;
          Message2.prototype.seqno = null;
          Message2.prototype.topicIDs = $util11.emptyArray;
          Message2.prototype.signature = null;
          Message2.prototype.key = null;
          var $oneOfFields2;
          Object.defineProperty(Message2.prototype, "_from", {
            get: $util11.oneOfGetter($oneOfFields2 = ["from"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message2.prototype, "_data", {
            get: $util11.oneOfGetter($oneOfFields2 = ["data"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message2.prototype, "_seqno", {
            get: $util11.oneOfGetter($oneOfFields2 = ["seqno"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message2.prototype, "_signature", {
            get: $util11.oneOfGetter($oneOfFields2 = ["signature"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message2.prototype, "_key", {
            get: $util11.oneOfGetter($oneOfFields2 = ["key"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          Message2.encode = function encode19(m, w) {
            if (!w)
              w = $Writer11.create();
            if (m.from != null && Object.hasOwnProperty.call(m, "from"))
              w.uint32(10).bytes(m.from);
            if (m.data != null && Object.hasOwnProperty.call(m, "data"))
              w.uint32(18).bytes(m.data);
            if (m.seqno != null && Object.hasOwnProperty.call(m, "seqno"))
              w.uint32(26).bytes(m.seqno);
            if (m.topicIDs != null && m.topicIDs.length) {
              for (var i = 0; i < m.topicIDs.length; ++i)
                w.uint32(34).string(m.topicIDs[i]);
            }
            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
              w.uint32(42).bytes(m.signature);
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
              w.uint32(50).bytes(m.key);
            return w;
          };
          Message2.decode = function decode22(r, l) {
            if (!(r instanceof $Reader11))
              r = $Reader11.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC.Message();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.from = r.bytes();
                  break;
                case 2:
                  m.data = r.bytes();
                  break;
                case 3:
                  m.seqno = r.bytes();
                  break;
                case 4:
                  if (!(m.topicIDs && m.topicIDs.length))
                    m.topicIDs = [];
                  m.topicIDs.push(r.string());
                  break;
                case 5:
                  m.signature = r.bytes();
                  break;
                case 6:
                  m.key = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          Message2.fromObject = function fromObject(d) {
            if (d instanceof $root11.RPC.Message)
              return d;
            var m = new $root11.RPC.Message();
            if (d.from != null) {
              if (typeof d.from === "string")
                $util11.base64.decode(d.from, m.from = $util11.newBuffer($util11.base64.length(d.from)), 0);
              else if (d.from.length)
                m.from = d.from;
            }
            if (d.data != null) {
              if (typeof d.data === "string")
                $util11.base64.decode(d.data, m.data = $util11.newBuffer($util11.base64.length(d.data)), 0);
              else if (d.data.length)
                m.data = d.data;
            }
            if (d.seqno != null) {
              if (typeof d.seqno === "string")
                $util11.base64.decode(d.seqno, m.seqno = $util11.newBuffer($util11.base64.length(d.seqno)), 0);
              else if (d.seqno.length)
                m.seqno = d.seqno;
            }
            if (d.topicIDs) {
              if (!Array.isArray(d.topicIDs))
                throw TypeError(".RPC.Message.topicIDs: array expected");
              m.topicIDs = [];
              for (var i = 0; i < d.topicIDs.length; ++i) {
                m.topicIDs[i] = String(d.topicIDs[i]);
              }
            }
            if (d.signature != null) {
              if (typeof d.signature === "string")
                $util11.base64.decode(d.signature, m.signature = $util11.newBuffer($util11.base64.length(d.signature)), 0);
              else if (d.signature.length)
                m.signature = d.signature;
            }
            if (d.key != null) {
              if (typeof d.key === "string")
                $util11.base64.decode(d.key, m.key = $util11.newBuffer($util11.base64.length(d.key)), 0);
              else if (d.key.length)
                m.key = d.key;
            }
            return m;
          };
          Message2.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.topicIDs = [];
            }
            if (m.from != null && m.hasOwnProperty("from")) {
              d.from = o.bytes === String ? $util11.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;
              if (o.oneofs)
                d._from = "from";
            }
            if (m.data != null && m.hasOwnProperty("data")) {
              d.data = o.bytes === String ? $util11.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
              if (o.oneofs)
                d._data = "data";
            }
            if (m.seqno != null && m.hasOwnProperty("seqno")) {
              d.seqno = o.bytes === String ? $util11.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;
              if (o.oneofs)
                d._seqno = "seqno";
            }
            if (m.topicIDs && m.topicIDs.length) {
              d.topicIDs = [];
              for (var j = 0; j < m.topicIDs.length; ++j) {
                d.topicIDs[j] = m.topicIDs[j];
              }
            }
            if (m.signature != null && m.hasOwnProperty("signature")) {
              d.signature = o.bytes === String ? $util11.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
              if (o.oneofs)
                d._signature = "signature";
            }
            if (m.key != null && m.hasOwnProperty("key")) {
              d.key = o.bytes === String ? $util11.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
              if (o.oneofs)
                d._key = "key";
            }
            return d;
          };
          Message2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
          };
          return Message2;
        }();
        RPC.ControlMessage = function() {
          function ControlMessage(p) {
            this.ihave = [];
            this.iwant = [];
            this.graft = [];
            this.prune = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlMessage.prototype.ihave = $util11.emptyArray;
          ControlMessage.prototype.iwant = $util11.emptyArray;
          ControlMessage.prototype.graft = $util11.emptyArray;
          ControlMessage.prototype.prune = $util11.emptyArray;
          ControlMessage.encode = function encode19(m, w) {
            if (!w)
              w = $Writer11.create();
            if (m.ihave != null && m.ihave.length) {
              for (var i = 0; i < m.ihave.length; ++i)
                $root11.RPC.ControlIHave.encode(m.ihave[i], w.uint32(10).fork()).ldelim();
            }
            if (m.iwant != null && m.iwant.length) {
              for (var i = 0; i < m.iwant.length; ++i)
                $root11.RPC.ControlIWant.encode(m.iwant[i], w.uint32(18).fork()).ldelim();
            }
            if (m.graft != null && m.graft.length) {
              for (var i = 0; i < m.graft.length; ++i)
                $root11.RPC.ControlGraft.encode(m.graft[i], w.uint32(26).fork()).ldelim();
            }
            if (m.prune != null && m.prune.length) {
              for (var i = 0; i < m.prune.length; ++i)
                $root11.RPC.ControlPrune.encode(m.prune[i], w.uint32(34).fork()).ldelim();
            }
            return w;
          };
          ControlMessage.decode = function decode22(r, l) {
            if (!(r instanceof $Reader11))
              r = $Reader11.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC.ControlMessage();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.ihave && m.ihave.length))
                    m.ihave = [];
                  m.ihave.push($root11.RPC.ControlIHave.decode(r, r.uint32()));
                  break;
                case 2:
                  if (!(m.iwant && m.iwant.length))
                    m.iwant = [];
                  m.iwant.push($root11.RPC.ControlIWant.decode(r, r.uint32()));
                  break;
                case 3:
                  if (!(m.graft && m.graft.length))
                    m.graft = [];
                  m.graft.push($root11.RPC.ControlGraft.decode(r, r.uint32()));
                  break;
                case 4:
                  if (!(m.prune && m.prune.length))
                    m.prune = [];
                  m.prune.push($root11.RPC.ControlPrune.decode(r, r.uint32()));
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlMessage.fromObject = function fromObject(d) {
            if (d instanceof $root11.RPC.ControlMessage)
              return d;
            var m = new $root11.RPC.ControlMessage();
            if (d.ihave) {
              if (!Array.isArray(d.ihave))
                throw TypeError(".RPC.ControlMessage.ihave: array expected");
              m.ihave = [];
              for (var i = 0; i < d.ihave.length; ++i) {
                if (typeof d.ihave[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.ihave: object expected");
                m.ihave[i] = $root11.RPC.ControlIHave.fromObject(d.ihave[i]);
              }
            }
            if (d.iwant) {
              if (!Array.isArray(d.iwant))
                throw TypeError(".RPC.ControlMessage.iwant: array expected");
              m.iwant = [];
              for (var i = 0; i < d.iwant.length; ++i) {
                if (typeof d.iwant[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.iwant: object expected");
                m.iwant[i] = $root11.RPC.ControlIWant.fromObject(d.iwant[i]);
              }
            }
            if (d.graft) {
              if (!Array.isArray(d.graft))
                throw TypeError(".RPC.ControlMessage.graft: array expected");
              m.graft = [];
              for (var i = 0; i < d.graft.length; ++i) {
                if (typeof d.graft[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.graft: object expected");
                m.graft[i] = $root11.RPC.ControlGraft.fromObject(d.graft[i]);
              }
            }
            if (d.prune) {
              if (!Array.isArray(d.prune))
                throw TypeError(".RPC.ControlMessage.prune: array expected");
              m.prune = [];
              for (var i = 0; i < d.prune.length; ++i) {
                if (typeof d.prune[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.prune: object expected");
                m.prune[i] = $root11.RPC.ControlPrune.fromObject(d.prune[i]);
              }
            }
            return m;
          };
          ControlMessage.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.ihave = [];
              d.iwant = [];
              d.graft = [];
              d.prune = [];
            }
            if (m.ihave && m.ihave.length) {
              d.ihave = [];
              for (var j = 0; j < m.ihave.length; ++j) {
                d.ihave[j] = $root11.RPC.ControlIHave.toObject(m.ihave[j], o);
              }
            }
            if (m.iwant && m.iwant.length) {
              d.iwant = [];
              for (var j = 0; j < m.iwant.length; ++j) {
                d.iwant[j] = $root11.RPC.ControlIWant.toObject(m.iwant[j], o);
              }
            }
            if (m.graft && m.graft.length) {
              d.graft = [];
              for (var j = 0; j < m.graft.length; ++j) {
                d.graft[j] = $root11.RPC.ControlGraft.toObject(m.graft[j], o);
              }
            }
            if (m.prune && m.prune.length) {
              d.prune = [];
              for (var j = 0; j < m.prune.length; ++j) {
                d.prune[j] = $root11.RPC.ControlPrune.toObject(m.prune[j], o);
              }
            }
            return d;
          };
          ControlMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
          };
          return ControlMessage;
        }();
        RPC.ControlIHave = function() {
          function ControlIHave(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlIHave.prototype.topicID = null;
          ControlIHave.prototype.messageIDs = $util11.emptyArray;
          var $oneOfFields2;
          Object.defineProperty(ControlIHave.prototype, "_topicID", {
            get: $util11.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          ControlIHave.encode = function encode19(m, w) {
            if (!w)
              w = $Writer11.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i = 0; i < m.messageIDs.length; ++i)
                w.uint32(18).bytes(m.messageIDs[i]);
            }
            return w;
          };
          ControlIHave.decode = function decode22(r, l) {
            if (!(r instanceof $Reader11))
              r = $Reader11.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC.ControlIHave();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIHave.fromObject = function fromObject(d) {
            if (d instanceof $root11.RPC.ControlIHave)
              return d;
            var m = new $root11.RPC.ControlIHave();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIHave.messageIDs: array expected");
              m.messageIDs = [];
              for (var i = 0; i < d.messageIDs.length; ++i) {
                if (typeof d.messageIDs[i] === "string")
                  $util11.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util11.newBuffer($util11.base64.length(d.messageIDs[i])), 0);
                else if (d.messageIDs[i].length)
                  m.messageIDs[i] = d.messageIDs[i];
              }
            }
            return m;
          };
          ControlIHave.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util11.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIHave.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
          };
          return ControlIHave;
        }();
        RPC.ControlIWant = function() {
          function ControlIWant(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlIWant.prototype.messageIDs = $util11.emptyArray;
          ControlIWant.encode = function encode19(m, w) {
            if (!w)
              w = $Writer11.create();
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i = 0; i < m.messageIDs.length; ++i)
                w.uint32(10).bytes(m.messageIDs[i]);
            }
            return w;
          };
          ControlIWant.decode = function decode22(r, l) {
            if (!(r instanceof $Reader11))
              r = $Reader11.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC.ControlIWant();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIWant.fromObject = function fromObject(d) {
            if (d instanceof $root11.RPC.ControlIWant)
              return d;
            var m = new $root11.RPC.ControlIWant();
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIWant.messageIDs: array expected");
              m.messageIDs = [];
              for (var i = 0; i < d.messageIDs.length; ++i) {
                if (typeof d.messageIDs[i] === "string")
                  $util11.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util11.newBuffer($util11.base64.length(d.messageIDs[i])), 0);
                else if (d.messageIDs[i].length)
                  m.messageIDs[i] = d.messageIDs[i];
              }
            }
            return m;
          };
          ControlIWant.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util11.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIWant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
          };
          return ControlIWant;
        }();
        RPC.ControlGraft = function() {
          function ControlGraft(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlGraft.prototype.topicID = null;
          var $oneOfFields2;
          Object.defineProperty(ControlGraft.prototype, "_topicID", {
            get: $util11.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          ControlGraft.encode = function encode19(m, w) {
            if (!w)
              w = $Writer11.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            return w;
          };
          ControlGraft.decode = function decode22(r, l) {
            if (!(r instanceof $Reader11))
              r = $Reader11.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC.ControlGraft();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlGraft.fromObject = function fromObject(d) {
            if (d instanceof $root11.RPC.ControlGraft)
              return d;
            var m = new $root11.RPC.ControlGraft();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            return m;
          };
          ControlGraft.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            return d;
          };
          ControlGraft.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
          };
          return ControlGraft;
        }();
        RPC.ControlPrune = function() {
          function ControlPrune(p) {
            this.peers = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlPrune.prototype.topicID = null;
          ControlPrune.prototype.peers = $util11.emptyArray;
          ControlPrune.prototype.backoff = null;
          var $oneOfFields2;
          Object.defineProperty(ControlPrune.prototype, "_topicID", {
            get: $util11.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(ControlPrune.prototype, "_backoff", {
            get: $util11.oneOfGetter($oneOfFields2 = ["backoff"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          ControlPrune.encode = function encode19(m, w) {
            if (!w)
              w = $Writer11.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.peers != null && m.peers.length) {
              for (var i = 0; i < m.peers.length; ++i)
                $root11.RPC.PeerInfo.encode(m.peers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.backoff != null && Object.hasOwnProperty.call(m, "backoff"))
              w.uint32(24).uint64(m.backoff);
            return w;
          };
          ControlPrune.decode = function decode22(r, l) {
            if (!(r instanceof $Reader11))
              r = $Reader11.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC.ControlPrune();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.peers && m.peers.length))
                    m.peers = [];
                  m.peers.push($root11.RPC.PeerInfo.decode(r, r.uint32()));
                  break;
                case 3:
                  m.backoff = r.uint64();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlPrune.fromObject = function fromObject(d) {
            if (d instanceof $root11.RPC.ControlPrune)
              return d;
            var m = new $root11.RPC.ControlPrune();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.peers) {
              if (!Array.isArray(d.peers))
                throw TypeError(".RPC.ControlPrune.peers: array expected");
              m.peers = [];
              for (var i = 0; i < d.peers.length; ++i) {
                if (typeof d.peers[i] !== "object")
                  throw TypeError(".RPC.ControlPrune.peers: object expected");
                m.peers[i] = $root11.RPC.PeerInfo.fromObject(d.peers[i]);
              }
            }
            if (d.backoff != null) {
              if ($util11.Long)
                (m.backoff = $util11.Long.fromValue(d.backoff)).unsigned = true;
              else if (typeof d.backoff === "string")
                m.backoff = parseInt(d.backoff, 10);
              else if (typeof d.backoff === "number")
                m.backoff = d.backoff;
              else if (typeof d.backoff === "object")
                m.backoff = new $util11.LongBits(d.backoff.low >>> 0, d.backoff.high >>> 0).toNumber(true);
            }
            return m;
          };
          ControlPrune.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.peers = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.peers && m.peers.length) {
              d.peers = [];
              for (var j = 0; j < m.peers.length; ++j) {
                d.peers[j] = $root11.RPC.PeerInfo.toObject(m.peers[j], o);
              }
            }
            if (m.backoff != null && m.hasOwnProperty("backoff")) {
              if (typeof m.backoff === "number")
                d.backoff = o.longs === String ? String(m.backoff) : m.backoff;
              else
                d.backoff = o.longs === String ? $util11.Long.prototype.toString.call(m.backoff) : o.longs === Number ? new $util11.LongBits(m.backoff.low >>> 0, m.backoff.high >>> 0).toNumber(true) : m.backoff;
              if (o.oneofs)
                d._backoff = "backoff";
            }
            return d;
          };
          ControlPrune.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
          };
          return ControlPrune;
        }();
        RPC.PeerInfo = function() {
          function PeerInfo(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          PeerInfo.prototype.peerID = null;
          PeerInfo.prototype.signedPeerRecord = null;
          var $oneOfFields2;
          Object.defineProperty(PeerInfo.prototype, "_peerID", {
            get: $util11.oneOfGetter($oneOfFields2 = ["peerID"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(PeerInfo.prototype, "_signedPeerRecord", {
            get: $util11.oneOfGetter($oneOfFields2 = ["signedPeerRecord"]),
            set: $util11.oneOfSetter($oneOfFields2)
          });
          PeerInfo.encode = function encode19(m, w) {
            if (!w)
              w = $Writer11.create();
            if (m.peerID != null && Object.hasOwnProperty.call(m, "peerID"))
              w.uint32(10).bytes(m.peerID);
            if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord"))
              w.uint32(18).bytes(m.signedPeerRecord);
            return w;
          };
          PeerInfo.decode = function decode22(r, l) {
            if (!(r instanceof $Reader11))
              r = $Reader11.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root11.RPC.PeerInfo();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.peerID = r.bytes();
                  break;
                case 2:
                  m.signedPeerRecord = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          PeerInfo.fromObject = function fromObject(d) {
            if (d instanceof $root11.RPC.PeerInfo)
              return d;
            var m = new $root11.RPC.PeerInfo();
            if (d.peerID != null) {
              if (typeof d.peerID === "string")
                $util11.base64.decode(d.peerID, m.peerID = $util11.newBuffer($util11.base64.length(d.peerID)), 0);
              else if (d.peerID.length)
                m.peerID = d.peerID;
            }
            if (d.signedPeerRecord != null) {
              if (typeof d.signedPeerRecord === "string")
                $util11.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util11.newBuffer($util11.base64.length(d.signedPeerRecord)), 0);
              else if (d.signedPeerRecord.length)
                m.signedPeerRecord = d.signedPeerRecord;
            }
            return m;
          };
          PeerInfo.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.peerID != null && m.hasOwnProperty("peerID")) {
              d.peerID = o.bytes === String ? $util11.base64.encode(m.peerID, 0, m.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerID) : m.peerID;
              if (o.oneofs)
                d._peerID = "peerID";
            }
            if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
              d.signedPeerRecord = o.bytes === String ? $util11.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
              if (o.oneofs)
                d._signedPeerRecord = "signedPeerRecord";
            }
            return d;
          };
          PeerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
          };
          return PeerInfo;
        }();
        return RPC;
      }();
      return $root11;
    });
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/get-gossip-peers.js
var require_get_gossip_peers = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/get-gossip-peers.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGossipPeers = void 0;
    var utils_1 = require_utils4();
    function getGossipPeers(router, topic, count, filter10 = () => true) {
      const peersInTopic = router.topics.get(topic);
      if (!peersInTopic) {
        return /* @__PURE__ */ new Set();
      }
      let peers = [];
      peersInTopic.forEach((id) => {
        const peerStreams = router.peers.get(id);
        if (!peerStreams) {
          return;
        }
        if (utils_1.hasGossipProtocol(peerStreams.protocol) && filter10(id)) {
          peers.push(id);
        }
      });
      peers = utils_1.shuffle(peers);
      if (count > 0 && peers.length > count) {
        peers = peers.slice(0, count);
      }
      return new Set(peers);
    }
    exports2.getGossipPeers = getGossipPeers;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/heartbeat.js
var require_heartbeat = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/heartbeat.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Heartbeat = void 0;
    var constants = __importStar(require_constants3());
    var get_gossip_peers_1 = require_get_gossip_peers();
    var utils_1 = require_utils4();
    var Heartbeat = class {
      constructor(gossipsub) {
        this.gossipsub = gossipsub;
      }
      start() {
        if (this._heartbeatTimer) {
          return;
        }
        const heartbeat = this._heartbeat.bind(this);
        const timeout = setTimeout(() => {
          heartbeat();
          this._heartbeatTimer.runPeriodically(heartbeat, this.gossipsub._options.heartbeatInterval);
        }, constants.GossipsubHeartbeatInitialDelay);
        this._heartbeatTimer = {
          _intervalId: void 0,
          runPeriodically: (fn, period) => {
            this._heartbeatTimer._intervalId = setInterval(fn, period);
          },
          cancel: () => {
            clearTimeout(timeout);
            clearInterval(this._heartbeatTimer._intervalId);
          }
        };
      }
      stop() {
        if (!this._heartbeatTimer) {
          return;
        }
        this._heartbeatTimer.cancel();
        this._heartbeatTimer = null;
      }
      _heartbeat() {
        const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.gossipsub._options;
        this.gossipsub.heartbeatTicks++;
        const scores = /* @__PURE__ */ new Map();
        const getScore = (id) => {
          let s = scores.get(id);
          if (s === void 0) {
            s = this.gossipsub.score.score(id);
            scores.set(id, s);
          }
          return s;
        };
        const tograft = /* @__PURE__ */ new Map();
        const toprune = /* @__PURE__ */ new Map();
        const noPX = /* @__PURE__ */ new Map();
        this.gossipsub._clearBackoff();
        this.gossipsub.peerhave.clear();
        this.gossipsub.iasked.clear();
        this.gossipsub._applyIwantPenalties();
        this.gossipsub._directConnect();
        this.gossipsub.mesh.forEach((peers, topic) => {
          const prunePeer = (id) => {
            this.gossipsub.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
            this.gossipsub.score.prune(id, topic);
            this.gossipsub._addBackoff(id, topic);
            peers.delete(id);
            const topics = toprune.get(id);
            if (!topics) {
              toprune.set(id, [topic]);
            } else {
              topics.push(topic);
            }
          };
          const graftPeer = (id) => {
            this.gossipsub.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
            this.gossipsub.score.graft(id, topic);
            peers.add(id);
            const topics = tograft.get(id);
            if (!topics) {
              tograft.set(id, [topic]);
            } else {
              topics.push(topic);
            }
          };
          peers.forEach((id) => {
            const score = getScore(id);
            if (score < 0) {
              this.gossipsub.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
              prunePeer(id);
              noPX.set(id, true);
            }
          });
          if (peers.size < Dlo) {
            const backoff = this.gossipsub.backoff.get(topic);
            const ineed = D - peers.size;
            const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {
              return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;
            });
            peersSet.forEach(graftPeer);
          }
          if (peers.size > Dhi) {
            let peersArray = Array.from(peers);
            peersArray.sort((a, b) => getScore(b) - getScore(a));
            peersArray = peersArray.slice(0, Dscore).concat(utils_1.shuffle(peersArray.slice(Dscore)));
            let outbound = 0;
            peersArray.slice(0, D).forEach((p) => {
              if (this.gossipsub.outbound.get(p)) {
                outbound++;
              }
            });
            if (outbound < Dout) {
              const rotate = (i) => {
                const p = peersArray[i];
                for (let j = i; j > 0; j--) {
                  peersArray[j] = peersArray[j - 1];
                }
                peersArray[0] = p;
              };
              if (outbound > 0) {
                let ihave = outbound;
                for (let i = 1; i < D && ihave > 0; i++) {
                  if (this.gossipsub.outbound.get(peersArray[i])) {
                    rotate(i);
                    ihave--;
                  }
                }
              }
              let ineed = D - outbound;
              for (let i = D; i < peersArray.length && ineed > 0; i++) {
                if (this.gossipsub.outbound.get(peersArray[i])) {
                  rotate(i);
                  ineed--;
                }
              }
            }
            peersArray.slice(D).forEach(prunePeer);
          }
          if (peers.size >= Dlo) {
            let outbound = 0;
            peers.forEach((p) => {
              if (this.gossipsub.outbound.get(p)) {
                outbound++;
              }
            });
            if (outbound < Dout) {
              const ineed = Dout - outbound;
              const backoff = this.gossipsub.backoff.get(topic);
              get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {
                return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;
              }).forEach(graftPeer);
            }
          }
          if (this.gossipsub.heartbeatTicks % constants.GossipsubOpportunisticGraftTicks === 0 && peers.size > 1) {
            const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
            const medianIndex = Math.floor(peers.size / 2);
            const medianScore = getScore(peersList[medianIndex]);
            if (medianScore < this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {
              const backoff = this.gossipsub.backoff.get(topic);
              const peersToGraft = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, constants.GossipsubOpportunisticGraftPeers, (id) => {
                return peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) > medianScore;
              });
              peersToGraft.forEach((id) => {
                this.gossipsub.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
                graftPeer(id);
              });
            }
          }
          this.gossipsub._emitGossip(topic, peers);
        });
        const now = this.gossipsub._now();
        this.gossipsub.lastpub.forEach((lastpb, topic) => {
          if (lastpb + fanoutTTL < now) {
            this.gossipsub.fanout.delete(topic);
            this.gossipsub.lastpub.delete(topic);
          }
        });
        this.gossipsub.fanout.forEach((fanoutPeers, topic) => {
          const topicPeers = this.gossipsub.topics.get(topic);
          fanoutPeers.forEach((id) => {
            if (!topicPeers.has(id) || getScore(id) < this.gossipsub._options.scoreThresholds.publishThreshold) {
              fanoutPeers.delete(id);
            }
          });
          if (fanoutPeers.size < D) {
            const ineed = D - fanoutPeers.size;
            const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {
              return !fanoutPeers.has(id) && !this.gossipsub.direct.has(id) && getScore(id) >= this.gossipsub._options.scoreThresholds.publishThreshold;
            });
            peersSet.forEach((id) => {
              fanoutPeers.add(id);
            });
          }
          this.gossipsub._emitGossip(topic, fanoutPeers);
        });
        this.gossipsub._sendGraftPrune(tograft, toprune, noPX);
        this.gossipsub._flush();
        this.gossipsub.messageCache.shift();
        this.gossipsub.emit("gossipsub:heartbeat");
      }
    };
    exports2.Heartbeat = Heartbeat;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/constants.js
var require_constants4 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/constants.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ERR_INVALID_PEER_SCORE_THRESHOLDS = exports2.ERR_INVALID_PEER_SCORE_PARAMS = void 0;
    exports2.ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS";
    exports2.ERR_INVALID_PEER_SCORE_THRESHOLDS = "ERR_INVALID_PEER_SCORE_THRESHOLDS";
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/peer-score-params.js
var require_peer_score_params = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/peer-score-params.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTopicScoreParams = exports2.validatePeerScoreParams = exports2.createTopicScoreParams = exports2.createPeerScoreParams = exports2.defaultTopicScoreParams = exports2.defaultPeerScoreParams = void 0;
    var constants_1 = require_constants4();
    var errcode17 = require_err_code();
    exports2.defaultPeerScoreParams = {
      topics: {},
      topicScoreCap: 10,
      appSpecificScore: () => 0,
      appSpecificWeight: 10,
      IPColocationFactorWeight: -5,
      IPColocationFactorThreshold: 10,
      IPColocationFactorWhitelist: /* @__PURE__ */ new Set(),
      behaviourPenaltyWeight: -10,
      behaviourPenaltyDecay: 0.2,
      decayInterval: 1e3,
      decayToZero: 0.1,
      retainScore: 3600 * 1e3
    };
    exports2.defaultTopicScoreParams = {
      topicWeight: 0.5,
      timeInMeshWeight: 1,
      timeInMeshQuantum: 1,
      timeInMeshCap: 3600,
      firstMessageDeliveriesWeight: 1,
      firstMessageDeliveriesDecay: 0.5,
      firstMessageDeliveriesCap: 2e3,
      meshMessageDeliveriesWeight: -1,
      meshMessageDeliveriesDecay: 0.5,
      meshMessageDeliveriesCap: 100,
      meshMessageDeliveriesThreshold: 20,
      meshMessageDeliveriesWindow: 10,
      meshMessageDeliveriesActivation: 5e3,
      meshFailurePenaltyWeight: -1,
      meshFailurePenaltyDecay: 0.5,
      invalidMessageDeliveriesWeight: -1,
      invalidMessageDeliveriesDecay: 0.3
    };
    function createPeerScoreParams(p = {}) {
      return Object.assign(Object.assign(Object.assign({}, exports2.defaultPeerScoreParams), p), { topics: p.topics ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {
        topics[topic] = createTopicScoreParams(topicScoreParams);
        return topics;
      }, {}) : {} });
    }
    exports2.createPeerScoreParams = createPeerScoreParams;
    function createTopicScoreParams(p = {}) {
      return Object.assign(Object.assign({}, exports2.defaultTopicScoreParams), p);
    }
    exports2.createTopicScoreParams = createTopicScoreParams;
    function validatePeerScoreParams(p) {
      for (const [topic, params] of Object.entries(p.topics)) {
        try {
          validateTopicScoreParams(params);
        } catch (e) {
          throw errcode17(new Error(`invalid score parameters for topic ${topic}: ${e.message}`), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
        }
      }
      if (p.topicScoreCap < 0) {
        throw errcode17(new Error("invalid topic score cap; must be positive (or 0 for no cap)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.appSpecificScore === null || p.appSpecificScore === void 0) {
        throw errcode17(new Error("missing application specific score function"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.IPColocationFactorWeight > 0) {
        throw errcode17(new Error("invalid IPColocationFactorWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {
        throw errcode17(new Error("invalid IPColocationFactorThreshold; must be at least 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.behaviourPenaltyWeight > 0) {
        throw errcode17(new Error("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {
        throw errcode17(new Error("invalid BehaviourPenaltyDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.decayInterval < 1e3) {
        throw errcode17(new Error("invalid DecayInterval; must be at least 1s"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.decayToZero <= 0 || p.decayToZero >= 1) {
        throw errcode17(new Error("invalid DecayToZero; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
    }
    exports2.validatePeerScoreParams = validatePeerScoreParams;
    function validateTopicScoreParams(p) {
      if (p.topicWeight < 0) {
        throw errcode17(new Error("invalid topic weight; must be >= 0"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.timeInMeshQuantum === 0) {
        throw errcode17(new Error("invalid TimeInMeshQuantum; must be non zero"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.timeInMeshWeight < 0) {
        throw errcode17(new Error("invalid TimeInMeshWeight; must be positive (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {
        throw errcode17(new Error("invalid TimeInMeshQuantum; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {
        throw errcode17(new Error("invalid TimeInMeshCap; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.firstMessageDeliveriesWeight < 0) {
        throw errcode17(new Error("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.firstMessageDeliveriesWeight !== 0 && (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {
        throw errcode17(new Error("invalid FirstMessageDeliveriesDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {
        throw errcode17(new Error("invalid FirstMessageDeliveriesCap; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWeight > 0) {
        throw errcode17(new Error("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {
        throw errcode17(new Error("invalid MeshMessageDeliveriesDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {
        throw errcode17(new Error("invalid MeshMessageDeliveriesCap; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {
        throw errcode17(new Error("invalid MeshMessageDeliveriesThreshold; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWindow < 0) {
        throw errcode17(new Error("invalid MeshMessageDeliveriesWindow; must be non-negative"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1e3) {
        throw errcode17(new Error("invalid MeshMessageDeliveriesActivation; must be at least 1s"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshFailurePenaltyWeight > 0) {
        throw errcode17(new Error("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {
        throw errcode17(new Error("invalid MeshFailurePenaltyDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.invalidMessageDeliveriesWeight > 0) {
        throw errcode17(new Error("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {
        throw errcode17(new Error("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
    }
    exports2.validateTopicScoreParams = validateTopicScoreParams;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/peer-score-thresholds.js
var require_peer_score_thresholds = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/peer-score-thresholds.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validatePeerScoreThresholds = exports2.createPeerScoreThresholds = exports2.defaultPeerScoreThresholds = void 0;
    var constants_1 = require_constants4();
    var errcode17 = require_err_code();
    exports2.defaultPeerScoreThresholds = {
      gossipThreshold: -10,
      publishThreshold: -50,
      graylistThreshold: -80,
      acceptPXThreshold: 10,
      opportunisticGraftThreshold: 20
    };
    function createPeerScoreThresholds(p = {}) {
      return Object.assign(Object.assign({}, exports2.defaultPeerScoreThresholds), p);
    }
    exports2.createPeerScoreThresholds = createPeerScoreThresholds;
    function validatePeerScoreThresholds(p) {
      if (p.gossipThreshold > 0) {
        throw errcode17(new Error("invalid gossip threshold; it must be <= 0"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
      }
      if (p.publishThreshold > 0 || p.publishThreshold > p.gossipThreshold) {
        throw errcode17(new Error("invalid publish threshold; it must be <= 0 and <= gossip threshold"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
      }
      if (p.graylistThreshold > 0 || p.graylistThreshold > p.publishThreshold) {
        throw errcode17(new Error("invalid graylist threshold; it must be <= 0 and <= publish threshold"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
      }
      if (p.acceptPXThreshold < 0) {
        throw errcode17(new Error("invalid accept PX threshold; it must be >= 0"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
      }
      if (p.opportunisticGraftThreshold < 0) {
        throw errcode17(new Error("invalid opportunistic grafting threshold; it must be >= 0"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
      }
    }
    exports2.validatePeerScoreThresholds = validatePeerScoreThresholds;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/peer-stats.js
var require_peer_stats = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/peer-stats.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureTopicStats = exports2.createTopicStats = exports2.createPeerStats = void 0;
    function createPeerStats(ps = {}) {
      return Object.assign(Object.assign({ connected: false, expire: 0, ips: [], behaviourPenalty: 0 }, ps), { topics: ps.topics ? Object.entries(ps.topics).reduce((topics, [topic, topicStats]) => {
        topics[topic] = createTopicStats(topicStats);
        return topics;
      }, {}) : {} });
    }
    exports2.createPeerStats = createPeerStats;
    function createTopicStats(ts = {}) {
      return Object.assign({ inMesh: false, graftTime: 0, meshTime: 0, firstMessageDeliveries: 0, meshMessageDeliveries: 0, meshMessageDeliveriesActive: false, meshFailurePenalty: 0, invalidMessageDeliveries: 0 }, ts);
    }
    exports2.createTopicStats = createTopicStats;
    function ensureTopicStats(topic, ps, params) {
      let ts = ps.topics[topic];
      if (ts) {
        return ts;
      }
      if (!params.topics[topic]) {
        return void 0;
      }
      ps.topics[topic] = ts = createTopicStats();
      return ts;
    }
    exports2.ensureTopicStats = ensureTopicStats;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/compute-score.js
var require_compute_score = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/compute-score.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.computeScore = void 0;
    function computeScore(peer, pstats, params, peerIPs) {
      let score = 0;
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        const topicParams = params.topics[topic];
        if (!topicParams) {
          return;
        }
        let topicScore = 0;
        if (tstats.inMesh) {
          let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
          if (p1 > topicParams.timeInMeshCap) {
            p1 = topicParams.timeInMeshCap;
          }
          topicScore += p1 * topicParams.timeInMeshWeight;
        }
        const p2 = tstats.firstMessageDeliveries;
        topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
        if (tstats.meshMessageDeliveriesActive) {
          if (tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
            const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
            const p3 = deficit * deficit;
            topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
          }
        }
        const p3b = tstats.meshFailurePenalty;
        topicScore += p3b * topicParams.meshFailurePenaltyWeight;
        const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
        topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
        score += topicScore * topicParams.topicWeight;
      });
      if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
        score = params.topicScoreCap;
      }
      const p5 = params.appSpecificScore(peer);
      score += p5 * params.appSpecificWeight;
      pstats.ips.forEach((ip) => {
        if (params.IPColocationFactorWhitelist.has(ip)) {
          return;
        }
        const peersInIP = peerIPs.get(ip);
        const numPeersInIP = peersInIP ? peersInIP.size : 0;
        if (numPeersInIP > params.IPColocationFactorThreshold) {
          const surplus = numPeersInIP - params.IPColocationFactorThreshold;
          const p6 = surplus * surplus;
          score += p6 * params.IPColocationFactorWeight;
        }
      });
      const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
      score += p7 * params.behaviourPenaltyWeight;
      return score;
    }
    exports2.computeScore = computeScore;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    function Denque(array, options) {
      var options = options || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array)) {
        this._fromArray(array);
      }
    }
    Denque.prototype.peekAt = function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get6(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length5() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      for (var i = 0; i < array.length; i++)
        this.push(array[i]);
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list[i]);
      }
      return newArray;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length <<= 1;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/message-deliveries.js
var require_message_deliveries = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/message-deliveries.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessageDeliveries = exports2.DeliveryRecordStatus = void 0;
    var constants_1 = require_constants3();
    var denque_1 = __importDefault(require_denque());
    var DeliveryRecordStatus;
    (function(DeliveryRecordStatus2) {
      DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
      DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
      DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
      DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
    })(DeliveryRecordStatus = exports2.DeliveryRecordStatus || (exports2.DeliveryRecordStatus = {}));
    var MessageDeliveries = class {
      constructor() {
        this.records = /* @__PURE__ */ new Map();
        this.queue = new denque_1.default();
      }
      ensureRecord(msgIdStr) {
        let drec = this.records.get(msgIdStr);
        if (drec) {
          return drec;
        }
        drec = {
          status: DeliveryRecordStatus.unknown,
          firstSeen: Date.now(),
          validated: 0,
          peers: /* @__PURE__ */ new Set()
        };
        this.records.set(msgIdStr, drec);
        const entry = {
          msgId: msgIdStr,
          expire: Date.now() + constants_1.TimeCacheDuration
        };
        this.queue.push(entry);
        return drec;
      }
      gc() {
        const now = Date.now();
        let head = this.queue.peekFront();
        while (head && head.expire < now) {
          this.records.delete(head.msgId);
          this.queue.shift();
          head = this.queue.peekFront();
        }
      }
      clear() {
        this.records.clear();
        this.queue.clear();
      }
    };
    exports2.MessageDeliveries = MessageDeliveries;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/peer-score.js
var require_peer_score = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/peer-score.js"(exports2) {
    "use strict";
    init_globals();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve11) {
          resolve11(value);
        });
      }
      return new (P || (P = Promise))(function(resolve11, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve11(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PeerScore = void 0;
    var peer_score_params_1 = require_peer_score_params();
    var peer_stats_1 = require_peer_stats();
    var compute_score_1 = require_compute_score();
    var message_deliveries_1 = require_message_deliveries();
    var constants_1 = require_constants3();
    var peer_id_1 = __importDefault(require_src5());
    var debug50 = require_browser2();
    var pubsubErrors = require_errors2();
    var { ERR_INVALID_SIGNATURE, ERR_MISSING_SIGNATURE } = pubsubErrors.codes;
    var log48 = debug50("libp2p:gossipsub:score");
    var PeerScore = class {
      constructor(params, connectionManager) {
        peer_score_params_1.validatePeerScoreParams(params);
        this.params = params;
        this._connectionManager = connectionManager;
        this.peerStats = /* @__PURE__ */ new Map();
        this.peerIPs = /* @__PURE__ */ new Map();
        this.scoreCache = /* @__PURE__ */ new Map();
        this.deliveryRecords = new message_deliveries_1.MessageDeliveries();
      }
      start() {
        if (this._backgroundInterval) {
          log48("Peer score already running");
          return;
        }
        this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);
        log48("started");
      }
      stop() {
        if (!this._backgroundInterval) {
          log48("Peer score already stopped");
          return;
        }
        clearInterval(this._backgroundInterval);
        delete this._backgroundInterval;
        this.peerIPs.clear();
        this.peerStats.clear();
        this.deliveryRecords.clear();
        log48("stopped");
      }
      background() {
        this._refreshScores();
        this._updateIPs();
        this.deliveryRecords.gc();
      }
      _refreshScores() {
        const now = Date.now();
        const decayToZero = this.params.decayToZero;
        this.peerStats.forEach((pstats, id) => {
          if (!pstats.connected) {
            if (now > pstats.expire) {
              this._removeIPs(id, pstats.ips);
              this.peerStats.delete(id);
            }
            return;
          }
          Object.entries(pstats.topics).forEach(([topic, tstats]) => {
            const tparams = this.params.topics[topic];
            if (!tparams) {
              return;
            }
            tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
            if (tstats.firstMessageDeliveries < decayToZero) {
              tstats.firstMessageDeliveries = 0;
            }
            tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
            if (tstats.meshMessageDeliveries < decayToZero) {
              tstats.meshMessageDeliveries = 0;
            }
            tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
            if (tstats.meshFailurePenalty < decayToZero) {
              tstats.meshFailurePenalty = 0;
            }
            tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
            if (tstats.invalidMessageDeliveries < decayToZero) {
              tstats.invalidMessageDeliveries = 0;
            }
            if (tstats.inMesh) {
              tstats.meshTime = now - tstats.graftTime;
              if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
                tstats.meshMessageDeliveriesActive = true;
              }
            }
          });
          pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
          if (pstats.behaviourPenalty < decayToZero) {
            pstats.behaviourPenalty = 0;
          }
          this.scoreCache.set(id, { score: null, cacheUntil: 0 });
        });
      }
      score(id) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return 0;
        }
        const now = Date.now();
        let cacheEntry = this.scoreCache.get(id);
        if (cacheEntry === void 0) {
          cacheEntry = { score: null, cacheUntil: 0 };
          this.scoreCache.set(id, cacheEntry);
        }
        const { score, cacheUntil } = cacheEntry;
        if (cacheUntil > now && score !== null)
          return score;
        cacheEntry.score = compute_score_1.computeScore(id, pstats, this.params, this.peerIPs);
        cacheEntry.cacheUntil = now + this.params.decayInterval;
        return cacheEntry.score;
      }
      addPenalty(id, penalty) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        pstats.behaviourPenalty += penalty;
        this.scoreCache.set(id, { score: null, cacheUntil: 0 });
      }
      addPeer(id) {
        const pstats = peer_stats_1.createPeerStats({
          connected: true
        });
        this.peerStats.set(id, pstats);
        const ips = this._getIPs(id);
        this._setIPs(id, ips, pstats.ips);
        pstats.ips = ips;
      }
      removePeer(id) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        if (this.score(id) > 0) {
          this._removeIPs(id, pstats.ips);
          this.peerStats.delete(id);
          return;
        }
        this.scoreCache.delete(id);
        Object.entries(pstats.topics).forEach(([topic, tstats]) => {
          tstats.firstMessageDeliveries = 0;
          const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
          if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
            const deficit = threshold - tstats.meshMessageDeliveries;
            tstats.meshFailurePenalty += deficit * deficit;
          }
          tstats.inMesh = false;
        });
        pstats.connected = false;
        pstats.expire = Date.now() + this.params.retainScore;
      }
      graft(id, topic) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
        if (!tstats) {
          return;
        }
        tstats.inMesh = true;
        tstats.graftTime = Date.now();
        tstats.meshTime = 0;
        tstats.meshMessageDeliveriesActive = false;
        this.scoreCache.set(id, { score: null, cacheUntil: 0 });
      }
      prune(id, topic) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
        if (!tstats) {
          return;
        }
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.inMesh = false;
        this.scoreCache.set(id, { score: null, cacheUntil: 0 });
      }
      validateMessage(msgIdStr) {
        return __awaiter(this, void 0, void 0, function* () {
          this.deliveryRecords.ensureRecord(msgIdStr);
        });
      }
      deliverMessage(msg, msgIdStr) {
        return __awaiter(this, void 0, void 0, function* () {
          const id = msg.receivedFrom;
          this._markFirstMessageDelivery(id, msg);
          const drec = this.deliveryRecords.ensureRecord(msgIdStr);
          const now = Date.now();
          if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {
            log48("unexpected delivery: message from %s was first seen %s ago and has delivery status %d", id, now - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);
            return;
          }
          drec.status = message_deliveries_1.DeliveryRecordStatus.valid;
          drec.validated = now;
          drec.peers.forEach((p) => {
            if (p !== id) {
              this._markDuplicateMessageDelivery(p, msg);
            }
          });
        });
      }
      rejectMessage(msg, msgIdStr, reason) {
        return __awaiter(this, void 0, void 0, function* () {
          const id = msg.receivedFrom;
          switch (reason) {
            case ERR_MISSING_SIGNATURE:
            case ERR_INVALID_SIGNATURE:
              this._markInvalidMessageDelivery(id, msg);
              return;
          }
          const drec = this.deliveryRecords.ensureRecord(msgIdStr);
          if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {
            log48("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", id, Date.now() - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);
            return;
          }
          switch (reason) {
            case constants_1.ERR_TOPIC_VALIDATOR_IGNORE:
              drec.status = message_deliveries_1.DeliveryRecordStatus.ignored;
              return;
          }
          drec.status = message_deliveries_1.DeliveryRecordStatus.invalid;
          this._markInvalidMessageDelivery(id, msg);
          drec.peers.forEach((p) => {
            this._markInvalidMessageDelivery(p, msg);
          });
        });
      }
      duplicateMessage(msg, msgIdStr) {
        return __awaiter(this, void 0, void 0, function* () {
          const id = msg.receivedFrom;
          const drec = this.deliveryRecords.ensureRecord(msgIdStr);
          if (drec.peers.has(id)) {
            return;
          }
          switch (drec.status) {
            case message_deliveries_1.DeliveryRecordStatus.unknown:
              drec.peers.add(id);
              break;
            case message_deliveries_1.DeliveryRecordStatus.valid:
              drec.peers.add(id);
              this._markDuplicateMessageDelivery(id, msg, drec.validated);
              break;
            case message_deliveries_1.DeliveryRecordStatus.invalid:
              this._markInvalidMessageDelivery(id, msg);
              break;
          }
        });
      }
      _markInvalidMessageDelivery(id, msg) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        msg.topicIDs.forEach((topic) => {
          const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
          if (!tstats) {
            return;
          }
          tstats.invalidMessageDeliveries += 1;
        });
        this.scoreCache.set(id, { score: null, cacheUntil: 0 });
      }
      _markFirstMessageDelivery(id, msg) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        msg.topicIDs.forEach((topic) => {
          const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
          if (!tstats) {
            return;
          }
          let cap = this.params.topics[topic].firstMessageDeliveriesCap;
          tstats.firstMessageDeliveries += 1;
          if (tstats.firstMessageDeliveries > cap) {
            tstats.firstMessageDeliveries = cap;
          }
          if (!tstats.inMesh) {
            return;
          }
          cap = this.params.topics[topic].meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries += 1;
          if (tstats.meshMessageDeliveries > cap) {
            tstats.meshMessageDeliveries = cap;
          }
        });
        this.scoreCache.set(id, { score: null, cacheUntil: 0 });
      }
      _markDuplicateMessageDelivery(id, msg, validatedTime = 0) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        const now = validatedTime ? Date.now() : 0;
        msg.topicIDs.forEach((topic) => {
          const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
          if (!tstats) {
            return;
          }
          if (!tstats.inMesh) {
            return;
          }
          const tparams = this.params.topics[topic];
          if (validatedTime && now > validatedTime + tparams.meshMessageDeliveriesWindow) {
            return;
          }
          const cap = tparams.meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries += 1;
          if (tstats.meshMessageDeliveries > cap) {
            tstats.meshMessageDeliveries = cap;
          }
        });
        this.scoreCache.set(id, { score: null, cacheUntil: 0 });
      }
      _getIPs(id) {
        return this._connectionManager.getAll(peer_id_1.default.createFromB58String(id)).map((c) => c.remoteAddr.toOptions().host);
      }
      _setIPs(id, newIPs, oldIPs) {
        addNewIPs:
          for (const ip of newIPs) {
            for (const xip of oldIPs) {
              if (ip === xip) {
                continue addNewIPs;
              }
            }
            let peers = this.peerIPs.get(ip);
            if (!peers) {
              peers = /* @__PURE__ */ new Set();
              this.peerIPs.set(ip, peers);
            }
            peers.add(id);
          }
        removeOldIPs:
          for (const ip of oldIPs) {
            for (const xip of newIPs) {
              if (ip === xip) {
                continue removeOldIPs;
              }
            }
            const peers = this.peerIPs.get(ip);
            if (!peers) {
              continue;
            }
            peers.delete(id);
            if (!peers.size) {
              this.peerIPs.delete(ip);
            }
          }
        this.scoreCache.set(id, { score: null, cacheUntil: 0 });
      }
      _removeIPs(id, ips) {
        ips.forEach((ip) => {
          const peers = this.peerIPs.get(ip);
          if (!peers) {
            return;
          }
          peers.delete(id);
          if (!peers.size) {
            this.peerIPs.delete(ip);
          }
        });
        this.scoreCache.set(id, { score: null, cacheUntil: 0 });
      }
      _updateIPs() {
        this.peerStats.forEach((pstats, id) => {
          const newIPs = this._getIPs(id);
          this._setIPs(id, newIPs, pstats.ips);
          pstats.ips = newIPs;
          this.scoreCache.set(id, { score: null, cacheUntil: 0 });
        });
      }
    };
    exports2.PeerScore = PeerScore;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/index.js
var require_score = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/score/index.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_peer_score_params(), exports2);
    __exportStar(require_peer_score_thresholds(), exports2);
    __exportStar(require_peer_score(), exports2);
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/tracer.js
var require_tracer = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/tracer.js"(exports2) {
    "use strict";
    init_globals();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve11) {
          resolve11(value);
        });
      }
      return new (P || (P = Promise))(function(resolve11, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve11(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IWantTracer = void 0;
    var constants_1 = require_constants3();
    var utils_1 = require_utils4();
    var pubsubErrors = require_errors2();
    var { ERR_INVALID_SIGNATURE, ERR_MISSING_SIGNATURE } = pubsubErrors.codes;
    var IWantTracer = class {
      constructor() {
        this.promises = /* @__PURE__ */ new Map();
      }
      addPromise(p, msgIds) {
        const ix = Math.floor(Math.random() * msgIds.length);
        const msgId = msgIds[ix];
        const msgIdStr = utils_1.messageIdToString(msgId);
        let peers = this.promises.get(msgIdStr);
        if (!peers) {
          peers = /* @__PURE__ */ new Map();
          this.promises.set(msgIdStr, peers);
        }
        if (!peers.has(p)) {
          peers.set(p, Date.now() + constants_1.GossipsubIWantFollowupTime);
        }
      }
      getBrokenPromises() {
        const now = Date.now();
        const result = /* @__PURE__ */ new Map();
        this.promises.forEach((peers, msgId) => {
          peers.forEach((expire, p) => {
            if (expire < now) {
              result.set(p, (result.get(p) || 0) + 1);
              peers.delete(p);
            }
          });
          if (!peers.size) {
            this.promises.delete(msgId);
          }
        });
        return result;
      }
      deliverMessage(msgIdStr) {
        return __awaiter(this, void 0, void 0, function* () {
          this.promises.delete(msgIdStr);
        });
      }
      rejectMessage(msgIdStr, reason) {
        return __awaiter(this, void 0, void 0, function* () {
          switch (reason) {
            case ERR_INVALID_SIGNATURE:
            case ERR_MISSING_SIGNATURE:
              return;
          }
          this.promises.delete(msgIdStr);
        });
      }
      clear() {
        this.promises.clear();
      }
    };
    exports2.IWantTracer = IWantTracer;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/time-cache.js
var require_time_cache = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/utils/time-cache.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SimpleTimeCache = void 0;
    var SimpleTimeCache = class {
      constructor(options) {
        this.lastPruneTime = 0;
        this.entries = /* @__PURE__ */ new Map();
        this.validityMs = options.validityMs;
      }
      put(key, value) {
        this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs });
        this.prune();
      }
      prune() {
        const now = Date.now();
        if (now - this.lastPruneTime < 200) {
          return;
        }
        this.lastPruneTime = now;
        for (const [k, v] of this.entries.entries()) {
          if (v.validUntilMs < now) {
            this.entries.delete(k);
          } else {
            break;
          }
        }
      }
      has(key) {
        return this.entries.has(key);
      }
      get(key) {
        const value = this.entries.get(key);
        return value && value.validUntilMs >= Date.now() ? value.value : void 0;
      }
      clear() {
        this.entries = /* @__PURE__ */ new Map();
        this.lastPruneTime = 0;
      }
    };
    exports2.SimpleTimeCache = SimpleTimeCache;
  }
});

// node_modules/libp2p/src/errors.js
var require_errors3 = __commonJS({
  "node_modules/libp2p/src/errors.js"(exports2) {
    "use strict";
    init_globals();
    exports2.messages = {
      NOT_STARTED_YET: "The libp2p node is not started yet",
      DHT_DISABLED: "DHT is not available",
      CONN_ENCRYPTION_REQUIRED: "At least one connection encryption module is required",
      NOT_FOUND: "Not found"
    };
    exports2.codes = {
      DHT_DISABLED: "ERR_DHT_DISABLED",
      PUBSUB_NOT_STARTED: "ERR_PUBSUB_NOT_STARTED",
      DHT_NOT_STARTED: "ERR_DHT_NOT_STARTED",
      CONN_ENCRYPTION_REQUIRED: "ERR_CONN_ENCRYPTION_REQUIRED",
      ERR_PEER_DIAL_INTERCEPTED: "ERR_PEER_DIAL_INTERCEPTED",
      ERR_CONNECTION_INTERCEPTED: "ERR_CONNECTION_INTERCEPTED",
      ERR_INVALID_PROTOCOLS_FOR_STREAM: "ERR_INVALID_PROTOCOLS_FOR_STREAM",
      ERR_CONNECTION_ENDED: "ERR_CONNECTION_ENDED",
      ERR_CONNECTION_FAILED: "ERR_CONNECTION_FAILED",
      ERR_NODE_NOT_STARTED: "ERR_NODE_NOT_STARTED",
      ERR_ALREADY_ABORTED: "ERR_ALREADY_ABORTED",
      ERR_TOO_MANY_ADDRESSES: "ERR_TOO_MANY_ADDRESSES",
      ERR_NO_VALID_ADDRESSES: "ERR_NO_VALID_ADDRESSES",
      ERR_RELAYED_DIAL: "ERR_RELAYED_DIAL",
      ERR_DIALED_SELF: "ERR_DIALED_SELF",
      ERR_DISCOVERED_SELF: "ERR_DISCOVERED_SELF",
      ERR_DUPLICATE_TRANSPORT: "ERR_DUPLICATE_TRANSPORT",
      ERR_ENCRYPTION_FAILED: "ERR_ENCRYPTION_FAILED",
      ERR_HOP_REQUEST_FAILED: "ERR_HOP_REQUEST_FAILED",
      ERR_INVALID_KEY: "ERR_INVALID_KEY",
      ERR_INVALID_MESSAGE: "ERR_INVALID_MESSAGE",
      ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS",
      ERR_INVALID_PEER: "ERR_INVALID_PEER",
      ERR_MUXER_UNAVAILABLE: "ERR_MUXER_UNAVAILABLE",
      ERR_NOT_FOUND: "ERR_NOT_FOUND",
      ERR_TIMEOUT: "ERR_TIMEOUT",
      ERR_TRANSPORT_UNAVAILABLE: "ERR_TRANSPORT_UNAVAILABLE",
      ERR_TRANSPORT_DIAL_FAILED: "ERR_TRANSPORT_DIAL_FAILED",
      ERR_UNSUPPORTED_PROTOCOL: "ERR_UNSUPPORTED_PROTOCOL",
      ERR_INVALID_MULTIADDR: "ERR_INVALID_MULTIADDR",
      ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID",
      ERR_FIND_SELF: "ERR_FIND_SELF",
      ERR_NO_ROUTERS_AVAILABLE: "ERR_NO_ROUTERS_AVAILABLE",
      ERR_CONNECTION_NOT_MULTIPLEXED: "ERR_CONNECTION_NOT_MULTIPLEXED",
      ERR_NO_DIAL_TOKENS: "ERR_NO_DIAL_TOKENS",
      ERR_KEYCHAIN_REQUIRED: "ERR_KEYCHAIN_REQUIRED",
      ERR_INVALID_CMS: "ERR_INVALID_CMS",
      ERR_MISSING_KEYS: "ERR_MISSING_KEYS",
      ERR_NO_KEY: "ERR_NO_KEY",
      ERR_INVALID_KEY_NAME: "ERR_INVALID_KEY_NAME",
      ERR_INVALID_KEY_TYPE: "ERR_INVALID_KEY_TYPE",
      ERR_KEY_ALREADY_EXISTS: "ERR_KEY_ALREADY_EXISTS",
      ERR_INVALID_KEY_SIZE: "ERR_INVALID_KEY_SIZE",
      ERR_KEY_NOT_FOUND: "ERR_KEY_NOT_FOUND",
      ERR_OLD_KEY_NAME_INVALID: "ERR_OLD_KEY_NAME_INVALID",
      ERR_NEW_KEY_NAME_INVALID: "ERR_NEW_KEY_NAME_INVALID",
      ERR_PASSWORD_REQUIRED: "ERR_PASSWORD_REQUIRED",
      ERR_PEM_REQUIRED: "ERR_PEM_REQUIRED",
      ERR_CANNOT_READ_KEY: "ERR_CANNOT_READ_KEY",
      ERR_MISSING_PRIVATE_KEY: "ERR_MISSING_PRIVATE_KEY",
      ERR_INVALID_OLD_PASS_TYPE: "ERR_INVALID_OLD_PASS_TYPE",
      ERR_INVALID_NEW_PASS_TYPE: "ERR_INVALID_NEW_PASS_TYPE",
      ERR_INVALID_PASS_LENGTH: "ERR_INVALID_PASS_LENGTH",
      ERR_NOT_IMPLEMENTED: "ERR_NOT_IMPLEMENTED",
      ERR_WRONG_PING_ACK: "ERR_WRONG_PING_ACK"
    };
  }
});

// node_modules/libp2p/src/record/envelope/envelope.js
var require_envelope = __commonJS({
  "node_modules/libp2p/src/record/envelope/envelope.js"(exports2, module2) {
    "use strict";
    init_globals();
    var $protobuf12 = require_minimal2();
    var $Reader11 = $protobuf12.Reader;
    var $Writer11 = $protobuf12.Writer;
    var $util11 = $protobuf12.util;
    var $root11 = $protobuf12.roots["libp2p-envelope"] || ($protobuf12.roots["libp2p-envelope"] = {});
    $root11.Envelope = function() {
      function Envelope2(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Envelope2.prototype.publicKey = $util11.newBuffer([]);
      Envelope2.prototype.payloadType = $util11.newBuffer([]);
      Envelope2.prototype.payload = $util11.newBuffer([]);
      Envelope2.prototype.signature = $util11.newBuffer([]);
      Envelope2.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
          w.uint32(10).bytes(m.publicKey);
        if (m.payloadType != null && Object.hasOwnProperty.call(m, "payloadType"))
          w.uint32(18).bytes(m.payloadType);
        if (m.payload != null && Object.hasOwnProperty.call(m, "payload"))
          w.uint32(26).bytes(m.payload);
        if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
          w.uint32(42).bytes(m.signature);
        return w;
      };
      Envelope2.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.Envelope();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.publicKey = r.bytes();
              break;
            case 2:
              m.payloadType = r.bytes();
              break;
            case 3:
              m.payload = r.bytes();
              break;
            case 5:
              m.signature = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Envelope2.fromObject = function fromObject(d) {
        if (d instanceof $root11.Envelope)
          return d;
        var m = new $root11.Envelope();
        if (d.publicKey != null) {
          if (typeof d.publicKey === "string")
            $util11.base64.decode(d.publicKey, m.publicKey = $util11.newBuffer($util11.base64.length(d.publicKey)), 0);
          else if (d.publicKey.length)
            m.publicKey = d.publicKey;
        }
        if (d.payloadType != null) {
          if (typeof d.payloadType === "string")
            $util11.base64.decode(d.payloadType, m.payloadType = $util11.newBuffer($util11.base64.length(d.payloadType)), 0);
          else if (d.payloadType.length)
            m.payloadType = d.payloadType;
        }
        if (d.payload != null) {
          if (typeof d.payload === "string")
            $util11.base64.decode(d.payload, m.payload = $util11.newBuffer($util11.base64.length(d.payload)), 0);
          else if (d.payload.length)
            m.payload = d.payload;
        }
        if (d.signature != null) {
          if (typeof d.signature === "string")
            $util11.base64.decode(d.signature, m.signature = $util11.newBuffer($util11.base64.length(d.signature)), 0);
          else if (d.signature.length)
            m.signature = d.signature;
        }
        return m;
      };
      Envelope2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.publicKey = "";
          else {
            d.publicKey = [];
            if (o.bytes !== Array)
              d.publicKey = $util11.newBuffer(d.publicKey);
          }
          if (o.bytes === String)
            d.payloadType = "";
          else {
            d.payloadType = [];
            if (o.bytes !== Array)
              d.payloadType = $util11.newBuffer(d.payloadType);
          }
          if (o.bytes === String)
            d.payload = "";
          else {
            d.payload = [];
            if (o.bytes !== Array)
              d.payload = $util11.newBuffer(d.payload);
          }
          if (o.bytes === String)
            d.signature = "";
          else {
            d.signature = [];
            if (o.bytes !== Array)
              d.signature = $util11.newBuffer(d.signature);
          }
        }
        if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
          d.publicKey = o.bytes === String ? $util11.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
        }
        if (m.payloadType != null && m.hasOwnProperty("payloadType")) {
          d.payloadType = o.bytes === String ? $util11.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
        }
        if (m.payload != null && m.hasOwnProperty("payload")) {
          d.payload = o.bytes === String ? $util11.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
        }
        if (m.signature != null && m.hasOwnProperty("signature")) {
          d.signature = o.bytes === String ? $util11.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
        }
        return d;
      };
      Envelope2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      return Envelope2;
    }();
    module2.exports = $root11;
  }
});

// node_modules/libp2p/src/record/envelope/index.js
var require_envelope2 = __commonJS({
  "node_modules/libp2p/src/record/envelope/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errCode69 = require_err_code();
    var { concat: uint8arraysConcat } = (init_concat(), __toCommonJS(concat_exports));
    var { fromString: uint8arraysFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var cryptoKeys = require_keys2();
    var PeerId14 = require_src5();
    var varint7 = require_varint();
    var { equals: uint8arraysEquals } = (init_equals(), __toCommonJS(equals_exports));
    var { codes } = require_errors3();
    var { Envelope: Protobuf } = require_envelope();
    var Envelope2 = class {
      constructor({ peerId, payloadType, payload, signature }) {
        this.peerId = peerId;
        this.payloadType = payloadType;
        this.payload = payload;
        this.signature = signature;
        this._marshal = void 0;
      }
      marshal() {
        if (this._marshal) {
          return this._marshal;
        }
        const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey);
        this._marshal = Protobuf.encode({
          publicKey,
          payloadType: this.payloadType,
          payload: this.payload,
          signature: this.signature
        }).finish();
        return this._marshal;
      }
      equals(other) {
        return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) && uint8arraysEquals(this.payloadType, other.payloadType) && uint8arraysEquals(this.payload, other.payload) && uint8arraysEquals(this.signature, other.signature);
      }
      validate(domain) {
        const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
        return this.peerId.pubKey.verify(signData, this.signature);
      }
    };
    var formatSignaturePayload = (domain, payloadType, payload) => {
      const domainUint8Array = uint8arraysFromString(domain);
      const domainLength = varint7.encode(domainUint8Array.byteLength);
      const payloadTypeLength = varint7.encode(payloadType.length);
      const payloadLength = varint7.encode(payload.length);
      return uint8arraysConcat([
        new Uint8Array(domainLength),
        domainUint8Array,
        new Uint8Array(payloadTypeLength),
        payloadType,
        new Uint8Array(payloadLength),
        payload
      ]);
    };
    Envelope2.createFromProtobuf = async (data) => {
      const envelopeData = Protobuf.decode(data);
      const peerId = await PeerId14.createFromPubKey(envelopeData.publicKey);
      return new Envelope2({
        peerId,
        payloadType: envelopeData.payloadType,
        payload: envelopeData.payload,
        signature: envelopeData.signature
      });
    };
    Envelope2.seal = async (record, peerId) => {
      const domain = record.domain;
      const payloadType = record.codec;
      const payload = record.marshal();
      const signData = formatSignaturePayload(domain, payloadType, payload);
      const signature = await peerId.privKey.sign(signData);
      return new Envelope2({
        peerId,
        payloadType,
        payload,
        signature
      });
    };
    Envelope2.openAndCertify = async (data, domain) => {
      const envelope = await Envelope2.createFromProtobuf(data);
      const valid = await envelope.validate(domain);
      if (!valid) {
        throw errCode69(new Error("envelope signature is not valid for the given domain"), codes.ERR_SIGNATURE_NOT_VALID);
      }
      return envelope;
    };
    module2.exports = Envelope2;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/index.js
var require_src12 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-gossipsub/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve11) {
          resolve11(value);
        });
      }
      return new (P || (P = Promise))(function(resolve11, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve11(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var pubsub_1 = __importStar(require_pubsub());
    var message_cache_1 = require_message_cache();
    var rpc_1 = require_rpc3();
    var constants = __importStar(require_constants3());
    var heartbeat_1 = require_heartbeat();
    var get_gossip_peers_1 = require_get_gossip_peers();
    var utils_1 = require_utils4();
    var score_1 = require_score();
    var tracer_1 = require_tracer();
    var time_cache_1 = require_time_cache();
    var PeerId14 = require_src5();
    var Envelope2 = require_envelope2();
    var constants_1 = require_constants3();
    var Gossipsub = class extends pubsub_1.default {
      constructor(libp2p, options = {}) {
        var _a;
        const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];
        const opts = Object.assign(Object.assign({ gossipIncoming: true, fallbackToFloodsub: true, floodPublish: true, doPX: false, directPeers: [], D: constants.GossipsubD, Dlo: constants.GossipsubDlo, Dhi: constants.GossipsubDhi, Dscore: constants.GossipsubDscore, Dout: constants.GossipsubDout, Dlazy: constants.GossipsubDlazy, heartbeatInterval: constants.GossipsubHeartbeatInterval, fanoutTTL: constants.GossipsubFanoutTTL, mcacheLength: constants.GossipsubHistoryLength, mcacheGossip: constants.GossipsubHistoryGossip, seenTTL: constants.GossipsubSeenTTL }, options), { scoreParams: score_1.createPeerScoreParams(options.scoreParams), scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds) });
        if (opts.fallbackToFloodsub) {
          multicodecs.push(constants.FloodsubID);
        }
        super(Object.assign({
          debugName: "libp2p:gossipsub",
          multicodecs,
          libp2p
        }, opts));
        this._options = opts;
        this.direct = new Set(opts.directPeers.map((p) => p.id.toB58String()));
        this.acceptFromWhitelist = /* @__PURE__ */ new Map();
        opts.directPeers.forEach((p) => {
          libp2p.peerStore.addressBook.add(p.id, p.addrs);
        });
        this.seenCache = new time_cache_1.SimpleTimeCache({ validityMs: opts.seenTTL });
        this.mesh = /* @__PURE__ */ new Map();
        this.fanout = /* @__PURE__ */ new Map();
        this.lastpub = /* @__PURE__ */ new Map();
        this.gossip = /* @__PURE__ */ new Map();
        this.control = /* @__PURE__ */ new Map();
        this.peerhave = /* @__PURE__ */ new Map();
        this.iasked = /* @__PURE__ */ new Map();
        this.backoff = /* @__PURE__ */ new Map();
        this.outbound = /* @__PURE__ */ new Map();
        this.messageCache = options.messageCache || new message_cache_1.MessageCache(opts.mcacheGossip, opts.mcacheLength);
        this.getFastMsgIdStr = (_a = options.fastMsgIdFn) !== null && _a !== void 0 ? _a : void 0;
        this.fastMsgIdCache = options.fastMsgIdFn ? new time_cache_1.SimpleTimeCache({ validityMs: opts.seenTTL }) : void 0;
        this.heartbeat = new heartbeat_1.Heartbeat(this);
        this.heartbeatTicks = 0;
        this.gossipTracer = new tracer_1.IWantTracer();
        this._libp2p = libp2p;
        this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager);
      }
      _decodeRpc(bytes2) {
        return rpc_1.RPC.decode(bytes2);
      }
      _encodeRpc(rpc) {
        return rpc_1.RPC.encode(rpc).finish();
      }
      _addPeer(peerId, protocol) {
        const p = super._addPeer(peerId, protocol);
        this.score.addPeer(peerId.toB58String());
        let outbound = false;
        for (const c of this._libp2p.connectionManager.getAll(peerId)) {
          if (c.stat.direction === "outbound") {
            if (Array.from(c.registry.values()).some((rvalue) => protocol === rvalue.protocol)) {
              outbound = true;
              break;
            }
          }
        }
        this.outbound.set(p.id.toB58String(), outbound);
        return p;
      }
      _removePeer(peerId) {
        const peerStreams = super._removePeer(peerId);
        const id = peerId.toB58String();
        for (const peers of this.mesh.values()) {
          peers.delete(id);
        }
        for (const peers of this.fanout.values()) {
          peers.delete(id);
        }
        this.gossip.delete(id);
        this.control.delete(id);
        this.outbound.delete(id);
        this.score.removePeer(id);
        this.acceptFromWhitelist.delete(id);
        return peerStreams;
      }
      _processRpc(id, peerStreams, rpc) {
        const _super = Object.create(null, {
          _processRpc: { get: () => super._processRpc }
        });
        return __awaiter(this, void 0, void 0, function* () {
          if (yield _super._processRpc.call(this, id, peerStreams, rpc)) {
            if (rpc.control) {
              yield this._processRpcControlMessage(id, rpc.control);
            }
            return true;
          }
          return false;
        });
      }
      _processRpcControlMessage(id, controlMsg) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!controlMsg) {
            return;
          }
          const iwant = controlMsg.ihave ? this._handleIHave(id, controlMsg.ihave) : [];
          const ihave = controlMsg.iwant ? this._handleIWant(id, controlMsg.iwant) : [];
          const prune = controlMsg.graft ? yield this._handleGraft(id, controlMsg.graft) : [];
          controlMsg.prune && this._handlePrune(id, controlMsg.prune);
          if (!iwant.length && !ihave.length && !prune.length) {
            return;
          }
          const outRpc = utils_1.createGossipRpc(ihave, { iwant, prune });
          this._sendRpc(id, outRpc);
        });
      }
      _processRpcMessage(msg) {
        const _super = Object.create(null, {
          _processRpcMessage: { get: () => super._processRpcMessage }
        });
        return __awaiter(this, void 0, void 0, function* () {
          let canonicalMsgIdStr;
          if (this.getFastMsgIdStr && this.fastMsgIdCache) {
            const fastMsgIdStr = yield this.getFastMsgIdStr(msg);
            canonicalMsgIdStr = this.fastMsgIdCache.get(fastMsgIdStr);
            if (canonicalMsgIdStr !== void 0) {
              this.score.duplicateMessage(msg, canonicalMsgIdStr);
              return;
            }
            canonicalMsgIdStr = utils_1.messageIdToString(yield this.getMsgId(msg));
            this.fastMsgIdCache.put(fastMsgIdStr, canonicalMsgIdStr);
          } else {
            canonicalMsgIdStr = utils_1.messageIdToString(yield this.getMsgId(msg));
            if (this.seenCache.has(canonicalMsgIdStr)) {
              this.score.duplicateMessage(msg, canonicalMsgIdStr);
              return;
            }
          }
          this.seenCache.put(canonicalMsgIdStr);
          yield this.score.validateMessage(canonicalMsgIdStr);
          yield _super._processRpcMessage.call(this, msg);
        });
      }
      _acceptFrom(id) {
        if (this.direct.has(id)) {
          return true;
        }
        const now = Date.now();
        const entry = this.acceptFromWhitelist.get(id);
        if (entry && entry.messagesAccepted < constants_1.ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {
          entry.messagesAccepted += 1;
          return true;
        }
        const score = this.score.score(id);
        if (score >= constants_1.ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {
          this.acceptFromWhitelist.set(id, {
            messagesAccepted: 0,
            acceptUntil: now + constants_1.ACCEPT_FROM_WHITELIST_DURATION_MS
          });
        } else {
          this.acceptFromWhitelist.delete(id);
        }
        return score >= this._options.scoreThresholds.graylistThreshold;
      }
      validate(msg) {
        const _super = Object.create(null, {
          validate: { get: () => super.validate }
        });
        return __awaiter(this, void 0, void 0, function* () {
          try {
            yield _super.validate.call(this, msg);
          } catch (e) {
            const canonicalMsgIdStr = yield this.getCanonicalMsgIdStr(msg);
            this.score.rejectMessage(msg, canonicalMsgIdStr, e.code);
            this.gossipTracer.rejectMessage(canonicalMsgIdStr, e.code);
            throw e;
          }
        });
      }
      _handleIHave(id, ihave) {
        if (!ihave.length) {
          return [];
        }
        const score = this.score.score(id);
        if (score < this._options.scoreThresholds.gossipThreshold) {
          this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
          return [];
        }
        const peerhave = (this.peerhave.get(id) || 0) + 1;
        this.peerhave.set(id, peerhave);
        if (peerhave > constants.GossipsubMaxIHaveMessages) {
          this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
          return [];
        }
        const iasked = this.iasked.get(id) || 0;
        if (iasked >= constants.GossipsubMaxIHaveLength) {
          this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
          return [];
        }
        const iwant = /* @__PURE__ */ new Map();
        ihave.forEach(({ topicID, messageIDs }) => {
          if (!topicID || !messageIDs || !this.mesh.has(topicID)) {
            return;
          }
          messageIDs.forEach((msgId) => {
            const msgIdStr = utils_1.messageIdToString(msgId);
            if (this.seenCache.has(msgIdStr)) {
              return;
            }
            iwant.set(msgIdStr, msgId);
          });
        });
        if (!iwant.size) {
          return [];
        }
        let iask = iwant.size;
        if (iask + iasked > constants.GossipsubMaxIHaveLength) {
          iask = constants.GossipsubMaxIHaveLength - iasked;
        }
        this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
        let iwantList = Array.from(iwant.values());
        utils_1.shuffle(iwantList);
        iwantList = iwantList.slice(0, iask);
        this.iasked.set(id, iasked + iask);
        this.gossipTracer.addPromise(id, iwantList);
        return [{
          messageIDs: iwantList
        }];
      }
      _handleIWant(id, iwant) {
        if (!iwant.length) {
          return [];
        }
        const score = this.score.score(id);
        if (score < this._options.scoreThresholds.gossipThreshold) {
          this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
          return [];
        }
        const ihave = /* @__PURE__ */ new Map();
        iwant.forEach(({ messageIDs }) => {
          messageIDs && messageIDs.forEach((msgId) => {
            const msgIdStr = utils_1.messageIdToString(msgId);
            const [msg, count] = this.messageCache.getForPeer(msgIdStr, id);
            if (!msg) {
              return;
            }
            if (count > constants.GossipsubGossipRetransmission) {
              this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgId);
              return;
            }
            ihave.set(msgIdStr, msg);
          });
        });
        if (!ihave.size) {
          return [];
        }
        this.log("IWANT: Sending %d messages to %s", ihave.size, id);
        return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);
      }
      _handleGraft(id, graft) {
        return __awaiter(this, void 0, void 0, function* () {
          const prune = [];
          const score = this.score.score(id);
          const now = this._now();
          let doPX = this._options.doPX;
          graft.forEach(({ topicID }) => {
            var _a;
            if (!topicID) {
              return;
            }
            const peersInMesh = this.mesh.get(topicID);
            if (!peersInMesh) {
              doPX = false;
              return;
            }
            if (peersInMesh.has(id)) {
              return;
            }
            if (this.direct.has(id)) {
              this.log("GRAFT: ignoring request from direct peer %s", id);
              prune.push(topicID);
              doPX = false;
              return;
            }
            const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);
            if (typeof expire === "number" && now < expire) {
              this.log("GRAFT: ignoring backed off peer %s", id);
              this.score.addPenalty(id, 1);
              doPX = false;
              const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;
              if (now < floodCutoff) {
                this.score.addPenalty(id, 1);
              }
              this._addBackoff(id, topicID);
              prune.push(topicID);
              return;
            }
            if (score < 0) {
              this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
              prune.push(topicID);
              doPX = false;
              this._addBackoff(id, topicID);
              return;
            }
            if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {
              prune.push(topicID);
              this._addBackoff(id, topicID);
              return;
            }
            this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
            this.score.graft(id, topicID);
            peersInMesh.add(id);
          });
          if (!prune.length) {
            return [];
          }
          return Promise.all(prune.map((topic) => this._makePrune(id, topic, doPX)));
        });
      }
      _handlePrune(id, prune) {
        const score = this.score.score(id);
        prune.forEach(({ topicID, backoff, peers }) => {
          if (!topicID) {
            return;
          }
          const peersInMesh = this.mesh.get(topicID);
          if (!peersInMesh) {
            return;
          }
          this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
          this.score.prune(id, topicID);
          peersInMesh.delete(id);
          if (typeof backoff === "number" && backoff > 0) {
            this._doAddBackoff(id, topicID, backoff * 1e3);
          } else {
            this._addBackoff(id, topicID);
          }
          if (peers && peers.length) {
            if (score < this._options.scoreThresholds.acceptPXThreshold) {
              this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
              return;
            }
            this._pxConnect(peers);
          }
        });
      }
      _addBackoff(id, topic) {
        this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);
      }
      _doAddBackoff(id, topic, interval) {
        let backoff = this.backoff.get(topic);
        if (!backoff) {
          backoff = /* @__PURE__ */ new Map();
          this.backoff.set(topic, backoff);
        }
        const expire = this._now() + interval;
        const existingExpire = backoff.get(id) || 0;
        if (existingExpire < expire) {
          backoff.set(id, expire);
        }
      }
      _applyIwantPenalties() {
        this.gossipTracer.getBrokenPromises().forEach((count, p) => {
          this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p, count);
          this.score.addPenalty(p, count);
        });
      }
      _clearBackoff() {
        if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {
          return;
        }
        const now = this._now();
        this.backoff.forEach((backoff, topic) => {
          backoff.forEach((expire, id) => {
            if (expire < now) {
              backoff.delete(id);
            }
          });
          if (backoff.size === 0) {
            this.backoff.delete(topic);
          }
        });
      }
      _directConnect() {
        if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {
          return;
        }
        const toconnect = [];
        this.direct.forEach((id) => {
          const peer = this.peers.get(id);
          if (!peer || !peer.isWritable) {
            toconnect.push(id);
          }
        });
        if (toconnect.length) {
          toconnect.forEach((id) => {
            this._connect(id);
          });
        }
      }
      _pxConnect(peers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (peers.length > constants.GossipsubPrunePeers) {
            utils_1.shuffle(peers);
            peers = peers.slice(0, constants.GossipsubPrunePeers);
          }
          const toconnect = [];
          yield Promise.all(peers.map((pi) => __awaiter(this, void 0, void 0, function* () {
            if (!pi.peerID) {
              return;
            }
            const p = PeerId14.createFromBytes(pi.peerID);
            const id = p.toB58String();
            if (this.peers.has(id)) {
              return;
            }
            if (!pi.signedPeerRecord) {
              toconnect.push(id);
              return;
            }
            try {
              const envelope = yield Envelope2.openAndCertify(pi.signedPeerRecord, "libp2p-peer-record");
              const eid = envelope.peerId.toB58String();
              if (id !== eid) {
                this.log("bogus peer record obtained through px: peer ID %s doesn't match expected peer %s", eid, id);
                return;
              }
              if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {
                this.log("bogus peer record obtained through px: could not add peer record to address book");
                return;
              }
              toconnect.push(id);
            } catch (e) {
              this.log("bogus peer record obtained through px: invalid signature or not a peer record");
            }
          })));
          if (!toconnect.length) {
            return;
          }
          toconnect.forEach((id) => this._connect(id));
        });
      }
      start() {
        const _super = Object.create(null, {
          start: { get: () => super.start }
        });
        return __awaiter(this, void 0, void 0, function* () {
          yield _super.start.call(this);
          this.heartbeat.start();
          this.score.start();
          this._directPeerInitial = setTimeout(() => {
            this.direct.forEach((id) => {
              this._connect(id);
            });
          }, constants.GossipsubDirectConnectInitialDelay);
        });
      }
      stop() {
        const _super = Object.create(null, {
          stop: { get: () => super.stop }
        });
        return __awaiter(this, void 0, void 0, function* () {
          yield _super.stop.call(this);
          this.heartbeat.stop();
          this.score.stop();
          this.mesh = /* @__PURE__ */ new Map();
          this.fanout = /* @__PURE__ */ new Map();
          this.lastpub = /* @__PURE__ */ new Map();
          this.gossip = /* @__PURE__ */ new Map();
          this.control = /* @__PURE__ */ new Map();
          this.peerhave = /* @__PURE__ */ new Map();
          this.iasked = /* @__PURE__ */ new Map();
          this.backoff = /* @__PURE__ */ new Map();
          this.outbound = /* @__PURE__ */ new Map();
          this.gossipTracer.clear();
          this.seenCache.clear();
          if (this.fastMsgIdCache)
            this.fastMsgIdCache.clear();
          clearTimeout(this._directPeerInitial);
        });
      }
      _connect(id) {
        this.log("Initiating connection with %s", id);
        this._libp2p.dialProtocol(PeerId14.createFromB58String(id), this.multicodecs);
      }
      subscribe(topic) {
        super.subscribe(topic);
        this.join(topic);
      }
      unsubscribe(topic) {
        super.unsubscribe(topic);
        this.leave(topic);
      }
      join(topic) {
        if (!this.started) {
          throw new Error("Gossipsub has not started");
        }
        this.log("JOIN %s", topic);
        const fanoutPeers = this.fanout.get(topic);
        if (fanoutPeers) {
          fanoutPeers.forEach((id) => {
            if (this.score.score(id) < 0) {
              fanoutPeers.delete(id);
            }
          });
          if (fanoutPeers.size < this._options.D) {
            get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {
              return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;
            }).forEach((id) => fanoutPeers.add(id));
          }
          this.mesh.set(topic, fanoutPeers);
          this.fanout.delete(topic);
          this.lastpub.delete(topic);
        } else {
          const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, (id) => {
            return !this.direct.has(id) && this.score.score(id) >= 0;
          });
          this.mesh.set(topic, peers);
        }
        this.mesh.get(topic).forEach((id) => {
          this.log("JOIN: Add mesh link to %s in %s", id, topic);
          this._sendGraft(id, topic);
        });
      }
      leave(topic) {
        if (!this.started) {
          throw new Error("Gossipsub has not started");
        }
        this.log("LEAVE %s", topic);
        const meshPeers = this.mesh.get(topic);
        if (meshPeers) {
          meshPeers.forEach((id) => {
            this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
            this._sendPrune(id, topic);
          });
          this.mesh.delete(topic);
        }
      }
      getCanonicalMsgIdStr(msg) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          return this.fastMsgIdCache && this.getFastMsgIdStr ? (_b = (_a = this.getCachedMsgIdStr(msg)) !== null && _a !== void 0 ? _a : this.fastMsgIdCache.get(this.getFastMsgIdStr(msg))) !== null && _b !== void 0 ? _b : utils_1.messageIdToString(yield this.getMsgId(msg)) : utils_1.messageIdToString(yield this.getMsgId(msg));
        });
      }
      getCachedMsgIdStr(msg) {
        return void 0;
      }
      _publish(msg) {
        return __awaiter(this, void 0, void 0, function* () {
          const msgIdStr = yield this.getCanonicalMsgIdStr(msg);
          if (msg.receivedFrom !== this.peerId.toB58String()) {
            this.score.deliverMessage(msg, msgIdStr);
            this.gossipTracer.deliverMessage(msgIdStr);
          }
          this.seenCache.put(msgIdStr);
          this.messageCache.put(msg, msgIdStr);
          const tosend = /* @__PURE__ */ new Set();
          msg.topicIDs.forEach((topic) => {
            const peersInTopic = this.topics.get(topic);
            if (!peersInTopic) {
              return;
            }
            if (this._options.floodPublish && msg.from === this.peerId.toB58String()) {
              peersInTopic.forEach((id) => {
                if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {
                  tosend.add(id);
                }
              });
            } else {
              this.direct.forEach((id) => {
                tosend.add(id);
              });
              peersInTopic.forEach((id) => {
                const score = this.score.score(id);
                const peerStreams = this.peers.get(id);
                if (!peerStreams) {
                  return;
                }
                if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {
                  tosend.add(id);
                }
              });
              let meshPeers = this.mesh.get(topic);
              if (!meshPeers || !meshPeers.size) {
                meshPeers = this.fanout.get(topic);
                if (!meshPeers) {
                  const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, (id) => {
                    return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;
                  });
                  if (peers.size > 0) {
                    meshPeers = peers;
                    this.fanout.set(topic, peers);
                  } else {
                    meshPeers = /* @__PURE__ */ new Set();
                  }
                }
                this.lastpub.set(topic, this._now());
              }
              meshPeers.forEach((peer) => {
                tosend.add(peer);
              });
            }
          });
          const rpc = utils_1.createGossipRpc([
            pubsub_1.utils.normalizeOutRpcMessage(msg)
          ]);
          tosend.forEach((id) => {
            if (id === msg.from) {
              return;
            }
            this._sendRpc(id, rpc);
          });
        });
      }
      _sendGraft(id, topic) {
        const graft = [{
          topicID: topic
        }];
        const out = utils_1.createGossipRpc([], { graft });
        this._sendRpc(id, out);
      }
      _sendPrune(id, topic) {
        return __awaiter(this, void 0, void 0, function* () {
          const prune = [
            yield this._makePrune(id, topic, this._options.doPX)
          ];
          const out = utils_1.createGossipRpc([], { prune });
          this._sendRpc(id, out);
        });
      }
      _sendRpc(id, outRpc) {
        const peerStreams = this.peers.get(id);
        if (!peerStreams || !peerStreams.isWritable) {
          return;
        }
        const ctrl = this.control.get(id);
        if (ctrl) {
          this._piggybackControl(id, outRpc, ctrl);
          this.control.delete(id);
        }
        const ihave = this.gossip.get(id);
        if (ihave) {
          this._piggybackGossip(id, outRpc, ihave);
          this.gossip.delete(id);
        }
        peerStreams.write(rpc_1.RPC.encode(outRpc).finish());
      }
      _piggybackControl(id, outRpc, ctrl) {
        const tograft = (ctrl.graft || []).filter(({ topicID }) => (topicID && this.mesh.get(topicID) || /* @__PURE__ */ new Set()).has(id));
        const toprune = (ctrl.prune || []).filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || /* @__PURE__ */ new Set()).has(id));
        if (!tograft.length && !toprune.length) {
          return;
        }
        if (outRpc.control) {
          outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);
          outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);
        } else {
          outRpc.control = { ihave: [], iwant: [], graft: tograft, prune: toprune };
        }
      }
      _piggybackGossip(id, outRpc, ihave) {
        if (!outRpc.control) {
          outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };
        }
        outRpc.control.ihave = ihave;
      }
      _sendGraftPrune(tograft, toprune, noPX) {
        return __awaiter(this, void 0, void 0, function* () {
          const doPX = this._options.doPX;
          for (const [id, topics] of tograft) {
            const graft = topics.map((topicID) => ({ topicID }));
            let prune = [];
            const pruning = toprune.get(id);
            if (pruning) {
              prune = yield Promise.all(pruning.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id))));
              toprune.delete(id);
            }
            const outRpc = utils_1.createGossipRpc([], { graft, prune });
            this._sendRpc(id, outRpc);
          }
          for (const [id, topics] of toprune) {
            const prune = yield Promise.all(topics.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id))));
            const outRpc = utils_1.createGossipRpc([], { prune });
            this._sendRpc(id, outRpc);
          }
        });
      }
      _emitGossip(topic, exclude) {
        const messageIDs = this.messageCache.getGossipIDs(topic);
        if (!messageIDs.length) {
          return;
        }
        utils_1.shuffle(messageIDs);
        if (messageIDs.length > constants.GossipsubMaxIHaveLength) {
          this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
        }
        const peersToGossip = [];
        const topicPeers = this.topics.get(topic);
        if (!topicPeers) {
          return;
        }
        topicPeers.forEach((id) => {
          const peerStreams = this.peers.get(id);
          if (!peerStreams) {
            return;
          }
          if (!exclude.has(id) && !this.direct.has(id) && utils_1.hasGossipProtocol(peerStreams.protocol) && this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {
            peersToGossip.push(id);
          }
        });
        let target = this._options.Dlazy;
        const factor = constants.GossipsubGossipFactor * peersToGossip.length;
        if (factor > target) {
          target = factor;
        }
        if (target > peersToGossip.length) {
          target = peersToGossip.length;
        } else {
          utils_1.shuffle(peersToGossip);
        }
        peersToGossip.slice(0, target).forEach((id) => {
          let peerMessageIDs = messageIDs;
          if (messageIDs.length > constants.GossipsubMaxIHaveLength) {
            peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);
          }
          this._pushGossip(id, {
            topicID: topic,
            messageIDs: peerMessageIDs
          });
        });
      }
      _flush() {
        for (const [peer, ihave] of this.gossip.entries()) {
          this.gossip.delete(peer);
          const out = utils_1.createGossipRpc([], { ihave });
          this._sendRpc(peer, out);
        }
        for (const [peer, control] of this.control.entries()) {
          this.control.delete(peer);
          const out = utils_1.createGossipRpc([], { graft: control.graft, prune: control.prune });
          this._sendRpc(peer, out);
        }
      }
      _pushGossip(id, controlIHaveMsgs) {
        this.log("Add gossip to %s", id);
        const gossip = this.gossip.get(id) || [];
        this.gossip.set(id, gossip.concat(controlIHaveMsgs));
      }
      _now() {
        return Date.now();
      }
      _makePrune(id, topic, doPX) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.peers.get(id).protocol === constants.GossipsubIDv10) {
            return {
              topicID: topic,
              peers: []
            };
          }
          const backoff = constants.GossipsubPruneBackoff / 1e3;
          if (!doPX) {
            return {
              topicID: topic,
              peers: [],
              backoff
            };
          }
          const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, (xid) => {
            return xid !== id && this.score.score(xid) >= 0;
          });
          const px = yield Promise.all(Array.from(peers).map((p) => __awaiter(this, void 0, void 0, function* () {
            const peerId = PeerId14.createFromB58String(p);
            return {
              peerID: peerId.toBytes(),
              signedPeerRecord: yield this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)
            };
          })));
          return {
            topicID: topic,
            peers: px,
            backoff
          };
        });
      }
    };
    Gossipsub.multicodec = constants.GossipsubIDv11;
    module2.exports = Gossipsub;
  }
});

// node_modules/libp2p-delegated-peer-routing/src/index.js
var require_src13 = __commonJS({
  "node_modules/libp2p-delegated-peer-routing/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var PeerId14 = require_src5();
    var { base58btc: base58btc3 } = (init_base58(), __toCommonJS(base58_exports));
    var { default: PQueue4 } = require_dist();
    var defer = require_p_defer();
    var debug50 = require_browser2();
    var log48 = debug50("libp2p-delegated-peer-routing");
    log48.error = debug50("libp2p-delegated-peer-routing:error");
    var DEFAULT_TIMEOUT = 3e4;
    var CONCURRENT_HTTP_REQUESTS = 4;
    var DelegatedPeerRouting = class {
      constructor(client) {
        if (client == null) {
          throw new Error("missing ipfs http client");
        }
        this._client = client;
        this._httpQueue = new PQueue4({
          concurrency: CONCURRENT_HTTP_REQUESTS
        });
        const {
          protocol,
          host,
          port
        } = client.getEndpointConfig();
        log48(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`);
      }
      async findPeer(id, options = {}) {
        let idStr = id;
        if (PeerId14.isPeerId(idStr)) {
          idStr = id.toB58String();
        }
        log48("findPeer starts: " + id);
        options.timeout = options.timeout || DEFAULT_TIMEOUT;
        try {
          return await this._httpQueue.add(async () => {
            const { addrs } = await this._client.dht.findPeer(idStr, {
              timeout: options.timeout
            });
            return {
              id,
              multiaddrs: addrs
            };
          });
        } catch (err) {
          if (err.message.includes("not found")) {
            return void 0;
          }
          throw err;
        } finally {
          log48("findPeer finished: " + id);
        }
      }
      async *getClosestPeers(key, options = {}) {
        const keyStr = base58btc3.encode(key).substring(1);
        log48("getClosestPeers starts:", keyStr);
        options.timeout = options.timeout || DEFAULT_TIMEOUT;
        const onStart = defer();
        const onFinish = defer();
        this._httpQueue.add(() => {
          onStart.resolve();
          return onFinish.promise;
        });
        try {
          await onStart.promise;
          for await (const result of this._client.dht.query(keyStr, {
            timeout: options.timeout
          })) {
            switch (result.type) {
              case 1:
                for (const response of result.responses) {
                  yield {
                    id: PeerId14.parse(response.id),
                    multiaddrs: response.addrs
                  };
                }
                break;
              default:
                log48("getClosestPeers unhandled response", result);
            }
          }
        } catch (err) {
          log48.error("getClosestPeers errored:", err);
          throw err;
        } finally {
          onFinish.resolve();
          log48("getClosestPeers finished:", keyStr);
        }
      }
    };
    module2.exports = DelegatedPeerRouting;
  }
});

// node_modules/libp2p-delegated-content-routing/src/index.js
var require_src14 = __commonJS({
  "node_modules/libp2p-delegated-content-routing/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var PeerId14 = require_src5();
    var drain9 = require_it_drain();
    var { default: PQueue4 } = require_dist();
    var defer = require_p_defer();
    var log48 = debug50("libp2p-delegated-content-routing");
    log48.error = debug50("libp2p-delegated-content-routing:error");
    var DEFAULT_TIMEOUT = 3e4;
    var CONCURRENT_HTTP_REQUESTS = 4;
    var DelegatedContentRouting = class {
      constructor(peerId, client) {
        if (peerId == null) {
          throw new Error("missing self peerId");
        }
        if (client == null) {
          throw new Error("missing ipfs http client");
        }
        this._client = client;
        this.peerId = peerId;
        const concurrency = { concurrency: CONCURRENT_HTTP_REQUESTS };
        this._httpQueue = new PQueue4(concurrency);
        this._httpQueueRefs = new PQueue4(Object.assign({}, concurrency, {
          concurrency: 2
        }));
        const {
          protocol,
          host,
          port
        } = client.getEndpointConfig();
        log48(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`);
      }
      async *findProviders(key, options = {}) {
        log48(`findProviders starts: ${key}`);
        options.timeout = options.timeout || DEFAULT_TIMEOUT;
        let providers = 0;
        const onStart = defer();
        const onFinish = defer();
        this._httpQueue.add(() => {
          onStart.resolve();
          return onFinish.promise;
        });
        try {
          await onStart.promise;
          for await (const { id, addrs } of this._client.dht.findProvs(key, {
            numProviders: options.numProviders,
            timeout: options.timeout
          })) {
            yield {
              id: PeerId14.parse(id),
              multiaddrs: addrs
            };
            providers++;
          }
        } catch (err) {
          log48.error("findProviders errored:", err);
          throw err;
        } finally {
          onFinish.resolve();
          log48(`findProviders finished: ${key} found ${providers} providers`);
        }
      }
      async provide(key) {
        log48(`provide starts: ${key}`);
        await this._httpQueueRefs.add(async () => {
          await this._client.block.stat(key);
          await drain9(this._client.dht.provide(key));
        });
        log48(`provide finished: ${key}`);
      }
    };
    module2.exports = DelegatedContentRouting;
  }
});

// node_modules/stream-to-it/source.js
var require_source = __commonJS({
  "node_modules/stream-to-it/source.js"(exports2, module2) {
    init_globals();
    module2.exports = (readable) => {
      if (readable[Symbol.asyncIterator])
        return readable;
      if (readable.getReader) {
        return async function* () {
          const reader = readable.getReader();
          try {
            while (true) {
              const { done, value } = await reader.read();
              if (done)
                return;
              yield value;
            }
          } finally {
            reader.releaseLock();
          }
        }();
      }
      throw new Error("unknown stream");
    };
  }
});

// (disabled):node_modules/ipfs-utils/src/files/glob-source.js
var require_glob_source = __commonJS({
  "(disabled):node_modules/ipfs-utils/src/files/glob-source.js"() {
    init_globals();
  }
});

// node_modules/ipfs-utils/src/files/url-source.js
var require_url_source = __commonJS({
  "node_modules/ipfs-utils/src/files/url-source.js"(exports2, module2) {
    "use strict";
    init_globals();
    var HTTP5 = require_http();
    var urlSource2 = (url, options) => {
      return {
        path: decodeURIComponent(new URL(url).pathname.split("/").pop() || ""),
        content: readURLContent(url, options)
      };
    };
    async function* readURLContent(url, options) {
      const http = new HTTP5();
      const response = await http.get(url, options);
      yield* response.iterator();
    }
    module2.exports = urlSource2;
  }
});

// (disabled):node_modules/ws/browser.js
var require_browser7 = __commonJS({
  "(disabled):node_modules/ws/browser.js"() {
    init_globals();
  }
});

// node_modules/it-ws/web-socket.js
var require_web_socket = __commonJS({
  "node_modules/it-ws/web-socket.js"(exports2, module2) {
    init_globals();
    module2.exports = typeof WebSocket === "undefined" ? require_browser7() : WebSocket;
  }
});

// node_modules/event-iterator/lib/event-iterator.js
var require_event_iterator = __commonJS({
  "node_modules/event-iterator/lib/event-iterator.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var EventQueue = class {
      constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
      }
      push(value) {
        if (this.isStopped)
          return;
        const resolution = { value, done: false };
        if (this.pullQueue.length) {
          const placeholder = this.pullQueue.shift();
          if (placeholder)
            placeholder.resolve(resolution);
        } else {
          this.pushQueue.push(Promise.resolve(resolution));
          if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
            this.isPaused = true;
            if (this.eventHandlers.highWater) {
              this.eventHandlers.highWater();
            } else if (console) {
              console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
          }
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
          placeholder.resolve({ value: void 0, done: true });
        }
        this.pullQueue.length = 0;
      }
      fail(error) {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
          for (const placeholder of this.pullQueue) {
            placeholder.reject(error);
          }
          this.pullQueue.length = 0;
        } else {
          const rejection = Promise.reject(error);
          rejection.catch(() => {
          });
          this.pushQueue.push(rejection);
        }
      }
      remove() {
        Promise.resolve().then(() => {
          if (this.removeCallback)
            this.removeCallback();
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: (value) => {
            const result = this.pushQueue.shift();
            if (result) {
              if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                this.isPaused = false;
                if (this.eventHandlers.lowWater) {
                  this.eventHandlers.lowWater();
                }
              }
              return result;
            } else if (this.isStopped) {
              return Promise.resolve({ value: void 0, done: true });
            } else {
              return new Promise((resolve11, reject) => {
                this.pullQueue.push({ resolve: resolve11, reject });
              });
            }
          },
          return: () => {
            this.isStopped = true;
            this.pushQueue.length = 0;
            this.remove();
            return Promise.resolve({ value: void 0, done: true });
          }
        };
      }
    };
    var EventIterator = class {
      constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
          push: (value) => queue.push(value),
          stop: () => queue.stop(),
          fail: (error) => queue.fail(error),
          on: (event, fn) => {
            queue.eventHandlers[event] = fn;
          }
        }) || (() => {
        });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
      }
    };
    exports2.EventIterator = EventIterator;
    exports2.default = EventIterator;
  }
});

// node_modules/event-iterator/lib/dom.js
var require_dom = __commonJS({
  "node_modules/event-iterator/lib/dom.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var event_iterator_1 = require_event_iterator();
    exports2.EventIterator = event_iterator_1.EventIterator;
    function subscribe(event, options, evOptions) {
      return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
      }, evOptions);
    }
    exports2.subscribe = subscribe;
    exports2.default = event_iterator_1.EventIterator;
  }
});

// node_modules/it-ws/source.js
var require_source2 = __commonJS({
  "node_modules/it-ws/source.js"(exports2, module2) {
    init_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var { EventIterator } = require_dom();
    function isArrayBuffer(obj) {
      return obj instanceof ArrayBuffer || obj != null && obj.constructor != null && obj.constructor.name === "ArrayBuffer" && typeof obj.byteLength === "number";
    }
    module2.exports = (socket) => {
      const removeListener = socket.removeEventListener || socket.removeListener;
      const source = async function* () {
        const messages = new EventIterator(({ push, stop, fail }) => {
          socket.addEventListener("message", push);
          socket.addEventListener("error", fail);
          socket.addEventListener("close", stop);
          return () => {
            removeListener.call(socket, "message", push);
            removeListener.call(socket, "error", fail);
            removeListener.call(socket, "close", stop);
          };
        }, { highWaterMark: Infinity });
        for await (const { data } of messages) {
          yield isArrayBuffer(data) ? Buffer2.from(data) : data;
        }
      }();
      let connected = socket.readyState === 1;
      let connError;
      socket.addEventListener("open", () => {
        connected = true;
        connError = null;
      });
      socket.addEventListener("close", () => {
        connected = false;
        connError = null;
      });
      socket.addEventListener("error", (err) => {
        if (!connected)
          connError = err;
      });
      source.connected = () => new Promise((resolve11, reject) => {
        if (connected)
          return resolve11();
        if (connError)
          return reject(connError);
        const cleanUp = (cont) => {
          removeListener.call(socket, "open", onOpen);
          removeListener.call(socket, "error", onError);
          cont();
        };
        const onOpen = () => cleanUp(resolve11);
        const onError = (err) => cleanUp(() => reject(err));
        socket.addEventListener("open", onOpen);
        socket.addEventListener("error", onError);
      });
      return source;
    };
  }
});

// node_modules/it-ws/ready.js
var require_ready = __commonJS({
  "node_modules/it-ws/ready.js"(exports2, module2) {
    init_globals();
    module2.exports = async (socket) => {
      if (socket.readyState >= 2) {
        throw new Error("socket closed");
      }
      if (socket.readyState === 1) {
        return;
      }
      return new Promise((resolve11, reject) => {
        const remove = socket && (socket.removeEventListener || socket.removeListener);
        function cleanup() {
          if (typeof remove === "function") {
            remove.call(socket, "open", handleOpen);
            remove.call(socket, "error", handleErr);
          }
        }
        function handleOpen() {
          cleanup();
          resolve11();
        }
        function handleErr(evt) {
          cleanup();
          reject(evt);
        }
        socket.addEventListener("open", handleOpen);
        socket.addEventListener("error", handleErr);
      });
    };
  }
});

// node_modules/it-ws/sink.js
var require_sink = __commonJS({
  "node_modules/it-ws/sink.js"(exports2, module2) {
    init_globals();
    var ready = require_ready();
    module2.exports = (socket, options) => {
      options = options || {};
      options.closeOnEnd = options.closeOnEnd !== false;
      return async (source) => {
        for await (const data of source) {
          try {
            await ready(socket);
          } catch (err) {
            if (err.message === "socket closed")
              break;
            throw err;
          }
          socket.send(data);
        }
        if (options.closeOnEnd && socket.readyState <= 1) {
          return new Promise((resolve11, reject) => {
            socket.addEventListener("close", (event) => {
              if (event.wasClean || event.code === 1006) {
                resolve11();
              } else {
                const err = Object.assign(new Error("ws error"), { event });
                reject(err);
              }
            });
            setTimeout(() => socket.close());
          });
        }
      };
    };
  }
});

// node_modules/it-ws/duplex.js
var require_duplex = __commonJS({
  "node_modules/it-ws/duplex.js"(exports2, module2) {
    init_globals();
    var source = require_source2();
    var sink = require_sink();
    module2.exports = (socket, options) => {
      options = options || {};
      if (options.binaryType) {
        socket.binaryType = options.binaryType;
      } else if (options.binary) {
        socket.binaryType = "arraybuffer";
      }
      const duplex = {
        sink: sink(socket, options),
        source: source(socket, options),
        connected: () => duplex.source.connected()
      };
      return duplex;
    };
  }
});

// node_modules/it-ws/ws-url.js
var require_ws_url = __commonJS({
  "node_modules/it-ws/ws-url.js"(exports2, module2) {
    init_globals();
    var { relative } = require_iso_url();
    var map12 = { http: "ws", https: "wss" };
    var def = "ws";
    module2.exports = (url, location2) => relative(url, location2, map12, def);
  }
});

// node_modules/it-ws/client.js
var require_client = __commonJS({
  "node_modules/it-ws/client.js"(exports2, module2) {
    "use strict";
    init_globals();
    var WebSocket2 = require_web_socket();
    var duplex = require_duplex();
    var wsurl = require_ws_url();
    module2.exports = function(addr, opts = {}) {
      const location2 = typeof window === "undefined" ? {} : window.location;
      const url = wsurl(addr, location2);
      const socket = new WebSocket2(url, opts.websocket);
      const stream = duplex(socket, opts);
      stream.remoteAddress = url;
      stream.close = () => new Promise((resolve11, reject) => {
        socket.addEventListener("close", resolve11);
        socket.close();
      });
      stream.destroy = () => {
        if (socket.terminate) {
          socket.terminate();
        } else {
          socket.close();
        }
      };
      stream.socket = socket;
      return stream;
    };
    module2.exports.connect = module2.exports;
  }
});

// node_modules/libp2p-websockets/src/listener.browser.js
var require_listener_browser = __commonJS({
  "node_modules/libp2p-websockets/src/listener.browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = function() {
      throw new Error("WebSocket Servers can not be created in the browser!");
    };
  }
});

// node_modules/libp2p-websockets/src/constants.js
var require_constants5 = __commonJS({
  "node_modules/libp2p-websockets/src/constants.js"(exports2) {
    "use strict";
    init_globals();
    exports2.CODE_P2P = 421;
    exports2.CODE_CIRCUIT = 290;
    exports2.CODE_TCP = 6;
    exports2.CODE_WS = 477;
    exports2.CODE_WSS = 478;
    exports2.CLOSE_TIMEOUT = 2e3;
  }
});

// node_modules/ip-address/dist/cjs/lib/common.js
var require_common5 = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/common.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isCorrect = exports2.isInSubnet = void 0;
    function isInSubnet(address) {
      if (this.subnetMask < address.subnetMask) {
        return false;
      }
      if (this.mask(address.subnetMask) === address.mask()) {
        return true;
      }
      return false;
    }
    exports2.isInSubnet = isInSubnet;
    function isCorrect(defaultBits) {
      return function() {
        if (this.addressMinusSuffix !== this.correctForm()) {
          return false;
        }
        if (this.subnetMask === defaultBits && !this.parsedSubnet) {
          return true;
        }
        return this.parsedSubnet === String(this.subnetMask);
      };
    }
    exports2.isCorrect = isCorrect;
  }
});

// node_modules/ip-address/dist/cjs/lib/v4/constants.js
var require_constants6 = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/v4/constants.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_SUBNET_STRING = exports2.RE_ADDRESS = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 32;
    exports2.GROUPS = 4;
    exports2.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
    exports2.RE_SUBNET_STRING = /\/\d{1,2}$/;
  }
});

// node_modules/ip-address/dist/cjs/lib/address-error.js
var require_address_error = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/address-error.js"(exports2) {
    "use strict";
    init_globals();
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AddressError = void 0;
    var AddressError = function(_super) {
      __extends(AddressError2, _super);
      function AddressError2(message, parseMessage) {
        var _this = _super.call(this, message) || this;
        _this.name = "AddressError";
        if (parseMessage !== null) {
          _this.parseMessage = parseMessage;
        }
        return _this;
      }
      return AddressError2;
    }(Error);
    exports2.AddressError = AddressError;
  }
});

// node_modules/jsbn/index.js
var require_jsbn2 = __commonJS({
  "node_modules/jsbn/index.js"(exports2, module2) {
    init_globals();
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if (typeof a == "number")
            this.fromNumber(a, b, c);
          else if (b == null && typeof a != "string")
            this.fromString(a, 256);
          else
            this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv)
        BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i)
          r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0)
          this[0] = x;
        else if (x < -1)
          this[0] = x + this.DV;
        else
          this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 256)
          k = 8;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-")
              mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB)
            sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0)
            this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c)
          --this.t;
      }
      function bnToString(b) {
        if (this.s < 0)
          return "-" + this.negate().toString(b);
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else
          return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0)
              m = true;
            if (m)
              r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0)
          return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0)
          return this.s < 0 ? -r : r;
        while (--i >= 0)
          if ((r = this[i] - a[i]) != 0)
            return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0)
          return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i)
          r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i)
          r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i)
          r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i)
          r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0)
          r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1)
          r[i++] = this.DV + c;
        else if (c > 0)
          r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < y.t; ++i)
          r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0)
          r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0)
          return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null)
            q.fromInt(0);
          if (r != null)
            this.copyTo(r);
          return;
        }
        if (r == null)
          r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0)
          return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q == null ? nbi() : q;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys)
          y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd)
              r.subTo(t2, r);
          }
        }
        if (q != null) {
          r.drShiftTo(ys, q);
          if (ts != ms)
            BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0)
          r.rShiftTo(nsh, r);
        if (ts < 0)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0)
          return x.mod(this.m);
        else
          return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1)
          return 0;
        var x = this[0];
        if ((x & 1) == 0)
          return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1)
          return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0)
            z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven())
          z2 = new Classic(m);
        else
          z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1)
            return this[0] - this.DV;
          else if (this.t == 0)
            return -1;
        } else if (this.t == 1)
          return this[0];
        else if (this.t == 0)
          return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0)
          return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
          return 0;
        else
          return 1;
      }
      function bnpToRadix(b) {
        if (b == null)
          b = 10;
        if (this.signum() == 0 || b < 2 || b > 36)
          return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null)
          b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0)
              mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if (typeof b == "number") {
          if (a < 2)
            this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven())
              this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a)
                this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0)
            x[0] &= (1 << t2) - 1;
          else
            x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0)
              d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128))
              ++k;
            if (k > 0 || d != this.s)
              r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i)
          r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i)
            r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i)
            r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i)
          r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0)
          this.rShiftTo(-n, r);
        else
          this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0)
          this.lShiftTo(-n, r);
        else
          this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0)
          return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0)
          ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0)
            return i * this.DB + lbit(this[i]);
        if (this.s < 0)
          return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i)
          r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t)
          return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0)
          r[i++] = c;
        else if (c < -1)
          r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0)
          return;
        while (this.t <= w)
          this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t)
            this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0)
          r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i)
          r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i)
          this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0)
          r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t)
          return x.mod(this.m);
        else if (x.compareTo(this.m) < 0)
          return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0)
          x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0)
          return r;
        else if (i < 18)
          k = 1;
        else if (i < 48)
          k = 3;
        else if (i < 144)
          k = 4;
        else if (i < 768)
          k = 5;
        else
          k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1)
            w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0)
              w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0)
              z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0)
          return x;
        if (i < g)
          g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0)
            x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0)
            y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0)
          y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0)
          return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0)
            r = this[0] % n;
          else
            for (var i = this.t - 1; i >= 0; --i)
              r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0)
          return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven())
              b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven())
              d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac)
              a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac)
              c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0)
          return BigInteger.ZERO;
        if (d.compareTo(m) >= 0)
          return d.subtract(m);
        if (d.signum() < 0)
          d.addTo(m, d);
        else
          return d;
        if (d.signum() < 0)
          return d.add(m);
        else
          return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i])
              return true;
          return false;
        }
        if (x.isEven())
          return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim)
            m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j)
            if (m % lowprimes[i++] == 0)
              return false;
        }
        return x.millerRabin(t2);
      }
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0)
          return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length)
          t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0)
                return false;
            }
            if (y.compareTo(n1) != 0)
              return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize)
          rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int(new Date().getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i)
          ba[i] = rng_get_byte();
      }
      function SecureRandom() {
      }
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      if (typeof exports2 !== "undefined") {
        exports2 = module2.exports = {
          default: BigInteger,
          BigInteger,
          SecureRandom
        };
      } else {
        this.jsbn = {
          BigInteger,
          SecureRandom
        };
      }
    }).call(exports2);
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports2) {
    init_globals();
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign3;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign3 = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign3 = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign3 + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign3 + arg + pad : pad_character === "0" ? sign3 + pad + arg : pad + sign3 + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push({
              placeholder: match[0],
              param_no: match[1],
              keys: match[2],
              sign: match[3],
              pad_char: match[4],
              align: match[5],
              width: match[6],
              precision: match[7],
              type: match[8]
            });
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports2 !== "undefined") {
        exports2["sprintf"] = sprintf;
        exports2["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/ip-address/dist/cjs/lib/ipv4.js
var require_ipv4 = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/ipv4.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address4 = void 0;
    var common = __importStar(require_common5());
    var constants = __importStar(require_constants6());
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn2();
    var sprintf_js_1 = require_sprintf();
    var Address4 = function() {
      function Address42(address) {
        this.groups = constants.GROUPS;
        this.parsedAddress = [];
        this.parsedSubnet = "";
        this.subnet = "/32";
        this.subnetMask = 32;
        this.v4 = true;
        this.isCorrect = common.isCorrect(constants.BITS);
        this.isInSubnet = common.isInSubnet;
        this.address = address;
        var subnet = constants.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = "/" + this.subnetMask;
          if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants.RE_SUBNET_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(address);
      }
      Address42.isValid = function(address) {
        try {
          new Address42(address);
          return true;
        } catch (e) {
          return false;
        }
      };
      Address42.prototype.parse = function(address) {
        var groups = address.split(".");
        if (!address.match(constants.RE_ADDRESS)) {
          throw new address_error_1.AddressError("Invalid IPv4 address.");
        }
        return groups;
      };
      Address42.prototype.correctForm = function() {
        return this.parsedAddress.map(function(part) {
          return parseInt(part, 10);
        }).join(".");
      };
      Address42.fromHex = function(hex) {
        var padded = hex.replace(/:/g, "").padStart(8, "0");
        var groups = [];
        var i;
        for (i = 0; i < 8; i += 2) {
          var h = padded.slice(i, i + 2);
          groups.push(parseInt(h, 16));
        }
        return new Address42(groups.join("."));
      };
      Address42.fromInteger = function(integer) {
        return Address42.fromHex(integer.toString(16));
      };
      Address42.fromArpa = function(arpaFormAddress) {
        var leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
        var address = leader.split(".").reverse().join(".");
        return new Address42(address);
      };
      Address42.prototype.toHex = function() {
        return this.parsedAddress.map(function(part) {
          return sprintf_js_1.sprintf("%02x", parseInt(part, 10));
        }).join(":");
      };
      Address42.prototype.toArray = function() {
        return this.parsedAddress.map(function(part) {
          return parseInt(part, 10);
        });
      };
      Address42.prototype.toGroup6 = function() {
        var output = [];
        var i;
        for (i = 0; i < constants.GROUPS; i += 2) {
          var hex = sprintf_js_1.sprintf("%02x%02x", parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
          output.push(sprintf_js_1.sprintf("%x", parseInt(hex, 16)));
        }
        return output.join(":");
      };
      Address42.prototype.bigInteger = function() {
        return new jsbn_1.BigInteger(this.parsedAddress.map(function(n) {
          return sprintf_js_1.sprintf("%02x", parseInt(n, 10));
        }).join(""), 16);
      };
      Address42.prototype._startAddress = function() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants.BITS - this.subnetMask), 2);
      };
      Address42.prototype.startAddress = function() {
        return Address42.fromBigInteger(this._startAddress());
      };
      Address42.prototype.startAddressExclusive = function() {
        var adjust = new jsbn_1.BigInteger("1");
        return Address42.fromBigInteger(this._startAddress().add(adjust));
      };
      Address42.prototype._endAddress = function() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants.BITS - this.subnetMask), 2);
      };
      Address42.prototype.endAddress = function() {
        return Address42.fromBigInteger(this._endAddress());
      };
      Address42.prototype.endAddressExclusive = function() {
        var adjust = new jsbn_1.BigInteger("1");
        return Address42.fromBigInteger(this._endAddress().subtract(adjust));
      };
      Address42.fromBigInteger = function(bigInteger) {
        return Address42.fromInteger(parseInt(bigInteger.toString(), 10));
      };
      Address42.prototype.mask = function(mask) {
        if (mask === void 0) {
          mask = this.subnetMask;
        }
        return this.getBitsBase2(0, mask);
      };
      Address42.prototype.getBitsBase2 = function(start, end) {
        return this.binaryZeroPad().slice(start, end);
      };
      Address42.prototype.reverseForm = function(options) {
        if (!options) {
          options = {};
        }
        var reversed = this.correctForm().split(".").reverse().join(".");
        if (options.omitSuffix) {
          return reversed;
        }
        return sprintf_js_1.sprintf("%s.in-addr.arpa.", reversed);
      };
      Address42.prototype.isMulticast = function() {
        return this.isInSubnet(new Address42("224.0.0.0/4"));
      };
      Address42.prototype.binaryZeroPad = function() {
        return this.bigInteger().toString(2).padStart(constants.BITS, "0");
      };
      Address42.prototype.groupForV6 = function() {
        var segments = this.parsedAddress;
        return this.address.replace(constants.RE_ADDRESS, sprintf_js_1.sprintf('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
      };
      return Address42;
    }();
    exports2.Address4 = Address4;
  }
});

// node_modules/ip-address/dist/cjs/lib/v6/constants.js
var require_constants7 = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/v6/constants.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_URL_WITH_PORT = exports2.RE_URL = exports2.RE_ZONE_STRING = exports2.RE_SUBNET_STRING = exports2.RE_BAD_ADDRESS = exports2.RE_BAD_CHARACTERS = exports2.TYPES = exports2.SCOPES = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 128;
    exports2.GROUPS = 8;
    exports2.SCOPES = {
      0: "Reserved",
      1: "Interface local",
      2: "Link local",
      4: "Admin local",
      5: "Site local",
      8: "Organization local",
      14: "Global",
      15: "Reserved"
    };
    exports2.TYPES = {
      "ff01::1/128": "Multicast (All nodes on this interface)",
      "ff01::2/128": "Multicast (All routers on this interface)",
      "ff02::1/128": "Multicast (All nodes on this link)",
      "ff02::2/128": "Multicast (All routers on this link)",
      "ff05::2/128": "Multicast (All routers in this site)",
      "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
      "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
      "ff02::9/128": "Multicast (RIP routers)",
      "ff02::a/128": "Multicast (EIGRP routers)",
      "ff02::d/128": "Multicast (PIM routers)",
      "ff02::16/128": "Multicast (MLDv2 reports)",
      "ff01::fb/128": "Multicast (mDNSv6)",
      "ff02::fb/128": "Multicast (mDNSv6)",
      "ff05::fb/128": "Multicast (mDNSv6)",
      "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
      "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
      "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
      "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
      "::/128": "Unspecified",
      "::1/128": "Loopback",
      "ff00::/8": "Multicast",
      "fe80::/10": "Link-local unicast"
    };
    exports2.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
    exports2.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
    exports2.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
    exports2.RE_ZONE_STRING = /%.*$/;
    exports2.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
    exports2.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
  }
});

// node_modules/ip-address/dist/cjs/lib/v6/helpers.js
var require_helpers = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/v6/helpers.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.simpleGroup = exports2.spanLeadingZeroes = exports2.spanAll = exports2.spanAllZeroes = void 0;
    var sprintf_js_1 = require_sprintf();
    function spanAllZeroes(s) {
      return s.replace(/(0+)/g, '<span class="zero">$1</span>');
    }
    exports2.spanAllZeroes = spanAllZeroes;
    function spanAll(s, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var letters = s.split("");
      return letters.map(function(n, i) {
        return sprintf_js_1.sprintf('<span class="digit value-%s position-%d">%s</span>', n, i + offset, spanAllZeroes(n));
      }).join("");
    }
    exports2.spanAll = spanAll;
    function spanLeadingZeroesSimple(group) {
      return group.replace(/^(0+)/, '<span class="zero">$1</span>');
    }
    function spanLeadingZeroes(address) {
      var groups = address.split(":");
      return groups.map(function(g) {
        return spanLeadingZeroesSimple(g);
      }).join(":");
    }
    exports2.spanLeadingZeroes = spanLeadingZeroes;
    function simpleGroup(addressString, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var groups = addressString.split(":");
      return groups.map(function(g, i) {
        if (/group-v4/.test(g)) {
          return g;
        }
        return sprintf_js_1.sprintf('<span class="hover-group group-%d">%s</span>', i + offset, spanLeadingZeroesSimple(g));
      });
    }
    exports2.simpleGroup = simpleGroup;
  }
});

// node_modules/ip-address/dist/cjs/lib/v6/regular-expressions.js
var require_regular_expressions = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/v6/regular-expressions.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.possibleElisions = exports2.simpleRegularExpression = exports2.ADDRESS_BOUNDARY = exports2.padGroup = exports2.groupPossibilities = void 0;
    var v6 = __importStar(require_constants7());
    var sprintf_js_1 = require_sprintf();
    function groupPossibilities(possibilities) {
      return sprintf_js_1.sprintf("(%s)", possibilities.join("|"));
    }
    exports2.groupPossibilities = groupPossibilities;
    function padGroup(group) {
      if (group.length < 4) {
        return sprintf_js_1.sprintf("0{0,%d}%s", 4 - group.length, group);
      }
      return group;
    }
    exports2.padGroup = padGroup;
    exports2.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
    function simpleRegularExpression(groups) {
      var zeroIndexes = [];
      groups.forEach(function(group, i) {
        var groupInteger = parseInt(group, 16);
        if (groupInteger === 0) {
          zeroIndexes.push(i);
        }
      });
      var possibilities = zeroIndexes.map(function(zeroIndex) {
        return groups.map(function(group, i) {
          if (i === zeroIndex) {
            var elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
            return groupPossibilities([padGroup(group), elision]);
          }
          return padGroup(group);
        }).join(":");
      });
      possibilities.push(groups.map(padGroup).join(":"));
      return groupPossibilities(possibilities);
    }
    exports2.simpleRegularExpression = simpleRegularExpression;
    function possibleElisions(elidedGroups, moreLeft, moreRight) {
      var left = moreLeft ? "" : ":";
      var right = moreRight ? "" : ":";
      var possibilities = [];
      if (!moreLeft && !moreRight) {
        possibilities.push("::");
      }
      if (moreLeft && moreRight) {
        possibilities.push("");
      }
      if (moreRight && !moreLeft || !moreRight && moreLeft) {
        possibilities.push(":");
      }
      possibilities.push(sprintf_js_1.sprintf("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
      possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
      possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
      for (var groups = 1; groups < elidedGroups - 1; groups++) {
        for (var position = 1; position < elidedGroups - groups; position++) {
          possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
        }
      }
      return groupPossibilities(possibilities);
    }
    exports2.possibleElisions = possibleElisions;
  }
});

// node_modules/ip-address/dist/cjs/lib/ipv6.js
var require_ipv6 = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/ipv6.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from5) {
      for (var i = 0, il = from5.length, j = to.length; i < il; i++, j++)
        to[j] = from5[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address6 = void 0;
    var common = __importStar(require_common5());
    var constants4 = __importStar(require_constants6());
    var constants6 = __importStar(require_constants7());
    var helpers = __importStar(require_helpers());
    var ipv4_1 = require_ipv4();
    var regular_expressions_1 = require_regular_expressions();
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn2();
    var sprintf_js_1 = require_sprintf();
    function assert(condition) {
      if (!condition) {
        throw new Error("Assertion failed.");
      }
    }
    function addCommas(number) {
      var r = /(\d+)(\d{3})/;
      while (r.test(number)) {
        number = number.replace(r, "$1,$2");
      }
      return number;
    }
    function spanLeadingZeroes4(n) {
      n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
      n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
      return n;
    }
    function compact(address, slice3) {
      var s1 = [];
      var s2 = [];
      var i;
      for (i = 0; i < address.length; i++) {
        if (i < slice3[0]) {
          s1.push(address[i]);
        } else if (i > slice3[1]) {
          s2.push(address[i]);
        }
      }
      return s1.concat(["compact"]).concat(s2);
    }
    function paddedHex(octet) {
      return sprintf_js_1.sprintf("%04x", parseInt(octet, 16));
    }
    function unsignByte(b) {
      return b & 255;
    }
    var Address6 = function() {
      function Address62(address, optionalGroups) {
        this.addressMinusSuffix = "";
        this.parsedSubnet = "";
        this.subnet = "/128";
        this.subnetMask = 128;
        this.v4 = false;
        this.zone = "";
        this.isInSubnet = common.isInSubnet;
        this.isCorrect = common.isCorrect(constants6.BITS);
        if (optionalGroups === void 0) {
          this.groups = constants6.GROUPS;
        } else {
          this.groups = optionalGroups;
        }
        this.address = address;
        var subnet = constants6.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = "/" + this.subnetMask;
          if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants6.RE_SUBNET_STRING, "");
        } else if (/\//.test(address)) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        var zone = constants6.RE_ZONE_STRING.exec(address);
        if (zone) {
          this.zone = zone[0];
          address = address.replace(constants6.RE_ZONE_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(this.addressMinusSuffix);
      }
      Address62.isValid = function(address) {
        try {
          new Address62(address);
          return true;
        } catch (e) {
          return false;
        }
      };
      Address62.fromBigInteger = function(bigInteger) {
        var hex = bigInteger.toString(16).padStart(32, "0");
        var groups = [];
        var i;
        for (i = 0; i < constants6.GROUPS; i++) {
          groups.push(hex.slice(i * 4, (i + 1) * 4));
        }
        return new Address62(groups.join(":"));
      };
      Address62.fromURL = function(url) {
        var host;
        var port = null;
        var result;
        if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
          result = constants6.RE_URL_WITH_PORT.exec(url);
          if (result === null) {
            return {
              error: "failed to parse address with port",
              address: null,
              port: null
            };
          }
          host = result[1];
          port = result[2];
        } else if (url.indexOf("/") !== -1) {
          url = url.replace(/^[a-z0-9]+:\/\//, "");
          result = constants6.RE_URL.exec(url);
          if (result === null) {
            return {
              error: "failed to parse address from URL",
              address: null,
              port: null
            };
          }
          host = result[1];
        } else {
          host = url;
        }
        if (port) {
          port = parseInt(port, 10);
          if (port < 0 || port > 65536) {
            port = null;
          }
        } else {
          port = null;
        }
        return {
          address: new Address62(host),
          port
        };
      };
      Address62.fromAddress4 = function(address) {
        var address4 = new ipv4_1.Address4(address);
        var mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
        return new Address62("::ffff:" + address4.correctForm() + "/" + mask6);
      };
      Address62.fromArpa = function(arpaFormAddress) {
        var address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
        var semicolonAmount = 7;
        if (address.length !== 63) {
          throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
        }
        var parts = address.split(".").reverse();
        for (var i = semicolonAmount; i > 0; i--) {
          var insertIndex = i * 4;
          parts.splice(insertIndex, 0, ":");
        }
        address = parts.join("");
        return new Address62(address);
      };
      Address62.prototype.microsoftTranscription = function() {
        return sprintf_js_1.sprintf("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
      };
      Address62.prototype.mask = function(mask) {
        if (mask === void 0) {
          mask = this.subnetMask;
        }
        return this.getBitsBase2(0, mask);
      };
      Address62.prototype.possibleSubnets = function(subnetSize) {
        if (subnetSize === void 0) {
          subnetSize = 128;
        }
        var availableBits = constants6.BITS - this.subnetMask;
        var subnetBits = Math.abs(subnetSize - constants6.BITS);
        var subnetPowers = availableBits - subnetBits;
        if (subnetPowers < 0) {
          return "0";
        }
        return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
      };
      Address62.prototype._startAddress = function() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants6.BITS - this.subnetMask), 2);
      };
      Address62.prototype.startAddress = function() {
        return Address62.fromBigInteger(this._startAddress());
      };
      Address62.prototype.startAddressExclusive = function() {
        var adjust = new jsbn_1.BigInteger("1");
        return Address62.fromBigInteger(this._startAddress().add(adjust));
      };
      Address62.prototype._endAddress = function() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants6.BITS - this.subnetMask), 2);
      };
      Address62.prototype.endAddress = function() {
        return Address62.fromBigInteger(this._endAddress());
      };
      Address62.prototype.endAddressExclusive = function() {
        var adjust = new jsbn_1.BigInteger("1");
        return Address62.fromBigInteger(this._endAddress().subtract(adjust));
      };
      Address62.prototype.getScope = function() {
        var scope = constants6.SCOPES[this.getBits(12, 16).intValue()];
        if (this.getType() === "Global unicast" && scope !== "Link local") {
          scope = "Global";
        }
        return scope || "Unknown";
      };
      Address62.prototype.getType = function() {
        for (var _i = 0, _a = Object.keys(constants6.TYPES); _i < _a.length; _i++) {
          var subnet = _a[_i];
          if (this.isInSubnet(new Address62(subnet))) {
            return constants6.TYPES[subnet];
          }
        }
        return "Global unicast";
      };
      Address62.prototype.getBits = function(start, end) {
        return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
      };
      Address62.prototype.getBitsBase2 = function(start, end) {
        return this.binaryZeroPad().slice(start, end);
      };
      Address62.prototype.getBitsBase16 = function(start, end) {
        var length5 = end - start;
        if (length5 % 4 !== 0) {
          throw new Error("Length of bits to retrieve must be divisible by four");
        }
        return this.getBits(start, end).toString(16).padStart(length5 / 4, "0");
      };
      Address62.prototype.getBitsPastSubnet = function() {
        return this.getBitsBase2(this.subnetMask, constants6.BITS);
      };
      Address62.prototype.reverseForm = function(options) {
        if (!options) {
          options = {};
        }
        var characters = Math.floor(this.subnetMask / 4);
        var reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
        if (characters > 0) {
          if (options.omitSuffix) {
            return reversed;
          }
          return sprintf_js_1.sprintf("%s.ip6.arpa.", reversed);
        }
        if (options.omitSuffix) {
          return "";
        }
        return "ip6.arpa.";
      };
      Address62.prototype.correctForm = function() {
        var i;
        var groups = [];
        var zeroCounter = 0;
        var zeroes = [];
        for (i = 0; i < this.parsedAddress.length; i++) {
          var value = parseInt(this.parsedAddress[i], 16);
          if (value === 0) {
            zeroCounter++;
          }
          if (value !== 0 && zeroCounter > 0) {
            if (zeroCounter > 1) {
              zeroes.push([i - zeroCounter, i - 1]);
            }
            zeroCounter = 0;
          }
        }
        if (zeroCounter > 1) {
          zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
        }
        var zeroLengths = zeroes.map(function(n) {
          return n[1] - n[0] + 1;
        });
        if (zeroes.length > 0) {
          var index = zeroLengths.indexOf(Math.max.apply(Math, zeroLengths));
          groups = compact(this.parsedAddress, zeroes[index]);
        } else {
          groups = this.parsedAddress;
        }
        for (i = 0; i < groups.length; i++) {
          if (groups[i] !== "compact") {
            groups[i] = parseInt(groups[i], 16).toString(16);
          }
        }
        var correct = groups.join(":");
        correct = correct.replace(/^compact$/, "::");
        correct = correct.replace(/^compact|compact$/, ":");
        correct = correct.replace(/compact/, "");
        return correct;
      };
      Address62.prototype.binaryZeroPad = function() {
        return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
      };
      Address62.prototype.parse4in6 = function(address) {
        var groups = address.split(":");
        var lastGroup = groups.slice(-1)[0];
        var address4 = lastGroup.match(constants4.RE_ADDRESS);
        if (address4) {
          this.parsedAddress4 = address4[0];
          this.address4 = new ipv4_1.Address4(this.parsedAddress4);
          for (var i = 0; i < this.address4.groups; i++) {
            if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
              throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
            }
          }
          this.v4 = true;
          groups[groups.length - 1] = this.address4.toGroup6();
          address = groups.join(":");
        }
        return address;
      };
      Address62.prototype.parse = function(address) {
        address = this.parse4in6(address);
        var badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
        if (badCharacters) {
          throw new address_error_1.AddressError(sprintf_js_1.sprintf("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
        }
        var badAddress = address.match(constants6.RE_BAD_ADDRESS);
        if (badAddress) {
          throw new address_error_1.AddressError(sprintf_js_1.sprintf("Address failed regex: %s", badAddress.join("")), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
        }
        var groups = [];
        var halves = address.split("::");
        if (halves.length === 2) {
          var first4 = halves[0].split(":");
          var last15 = halves[1].split(":");
          if (first4.length === 1 && first4[0] === "") {
            first4 = [];
          }
          if (last15.length === 1 && last15[0] === "") {
            last15 = [];
          }
          var remaining = this.groups - (first4.length + last15.length);
          if (!remaining) {
            throw new address_error_1.AddressError("Error parsing groups");
          }
          this.elidedGroups = remaining;
          this.elisionBegin = first4.length;
          this.elisionEnd = first4.length + this.elidedGroups;
          groups = groups.concat(first4);
          for (var i = 0; i < remaining; i++) {
            groups.push("0");
          }
          groups = groups.concat(last15);
        } else if (halves.length === 1) {
          groups = address.split(":");
          this.elidedGroups = 0;
        } else {
          throw new address_error_1.AddressError("Too many :: groups found");
        }
        groups = groups.map(function(group) {
          return sprintf_js_1.sprintf("%x", parseInt(group, 16));
        });
        if (groups.length !== this.groups) {
          throw new address_error_1.AddressError("Incorrect number of groups found");
        }
        return groups;
      };
      Address62.prototype.canonicalForm = function() {
        return this.parsedAddress.map(paddedHex).join(":");
      };
      Address62.prototype.decimal = function() {
        return this.parsedAddress.map(function(n) {
          return sprintf_js_1.sprintf("%05d", parseInt(n, 16));
        }).join(":");
      };
      Address62.prototype.bigInteger = function() {
        return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
      };
      Address62.prototype.to4 = function() {
        var binary = this.binaryZeroPad().split("");
        return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
      };
      Address62.prototype.to4in6 = function() {
        var address4 = this.to4();
        var address6 = new Address62(this.parsedAddress.slice(0, 6).join(":"), 6);
        var correct = address6.correctForm();
        var infix = "";
        if (!/:$/.test(correct)) {
          infix = ":";
        }
        return correct + infix + address4.address;
      };
      Address62.prototype.inspectTeredo = function() {
        var prefix = this.getBitsBase16(0, 32);
        var udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
        var server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
        var client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
        var flags = this.getBits(64, 80);
        var flagsBase2 = this.getBitsBase2(64, 80);
        var coneNat = flags.testBit(15);
        var reserved = flags.testBit(14);
        var groupIndividual = flags.testBit(8);
        var universalLocal = flags.testBit(9);
        var nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
        return {
          prefix: sprintf_js_1.sprintf("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
          server4: server4.address,
          client4: client4.address,
          flags: flagsBase2,
          coneNat,
          microsoft: {
            reserved,
            universalLocal,
            groupIndividual,
            nonce
          },
          udpPort
        };
      };
      Address62.prototype.inspect6to4 = function() {
        var prefix = this.getBitsBase16(0, 16);
        var gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
        return {
          prefix: sprintf_js_1.sprintf("%s", prefix.slice(0, 4)),
          gateway: gateway.address
        };
      };
      Address62.prototype.to6to4 = function() {
        if (!this.is4()) {
          return null;
        }
        var addr6to4 = [
          "2002",
          this.getBitsBase16(96, 112),
          this.getBitsBase16(112, 128),
          "",
          "/16"
        ].join(":");
        return new Address62(addr6to4);
      };
      Address62.prototype.toByteArray = function() {
        var byteArray = this.bigInteger().toByteArray();
        if (byteArray.length === 17 && byteArray[0] === 0) {
          return byteArray.slice(1);
        }
        return byteArray;
      };
      Address62.prototype.toUnsignedByteArray = function() {
        return this.toByteArray().map(unsignByte);
      };
      Address62.fromByteArray = function(bytes2) {
        return this.fromUnsignedByteArray(bytes2.map(unsignByte));
      };
      Address62.fromUnsignedByteArray = function(bytes2) {
        var BYTE_MAX = new jsbn_1.BigInteger("256", 10);
        var result = new jsbn_1.BigInteger("0", 10);
        var multiplier = new jsbn_1.BigInteger("1", 10);
        for (var i = bytes2.length - 1; i >= 0; i--) {
          result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes2[i].toString(10), 10)));
          multiplier = multiplier.multiply(BYTE_MAX);
        }
        return Address62.fromBigInteger(result);
      };
      Address62.prototype.isCanonical = function() {
        return this.addressMinusSuffix === this.canonicalForm();
      };
      Address62.prototype.isLinkLocal = function() {
        if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
          return true;
        }
        return false;
      };
      Address62.prototype.isMulticast = function() {
        return this.getType() === "Multicast";
      };
      Address62.prototype.is4 = function() {
        return this.v4;
      };
      Address62.prototype.isTeredo = function() {
        return this.isInSubnet(new Address62("2001::/32"));
      };
      Address62.prototype.is6to4 = function() {
        return this.isInSubnet(new Address62("2002::/16"));
      };
      Address62.prototype.isLoopback = function() {
        return this.getType() === "Loopback";
      };
      Address62.prototype.href = function(optionalPort) {
        if (optionalPort === void 0) {
          optionalPort = "";
        } else {
          optionalPort = sprintf_js_1.sprintf(":%s", optionalPort);
        }
        return sprintf_js_1.sprintf("http://[%s]%s/", this.correctForm(), optionalPort);
      };
      Address62.prototype.link = function(options) {
        if (!options) {
          options = {};
        }
        if (options.className === void 0) {
          options.className = "";
        }
        if (options.prefix === void 0) {
          options.prefix = "/#address=";
        }
        if (options.v4 === void 0) {
          options.v4 = false;
        }
        var formFunction = this.correctForm;
        if (options.v4) {
          formFunction = this.to4in6;
        }
        if (options.className) {
          return sprintf_js_1.sprintf('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
        }
        return sprintf_js_1.sprintf('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
      };
      Address62.prototype.group = function() {
        if (this.elidedGroups === 0) {
          return helpers.simpleGroup(this.address).join(":");
        }
        assert(typeof this.elidedGroups === "number");
        assert(typeof this.elisionBegin === "number");
        var output = [];
        var _a = this.address.split("::"), left = _a[0], right = _a[1];
        if (left.length) {
          output.push.apply(output, helpers.simpleGroup(left));
        } else {
          output.push("");
        }
        var classes = ["hover-group"];
        for (var i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
          classes.push(sprintf_js_1.sprintf("group-%d", i));
        }
        output.push(sprintf_js_1.sprintf('<span class="%s"></span>', classes.join(" ")));
        if (right.length) {
          output.push.apply(output, helpers.simpleGroup(right, this.elisionEnd));
        } else {
          output.push("");
        }
        if (this.is4()) {
          assert(this.address4 instanceof ipv4_1.Address4);
          output.pop();
          output.push(this.address4.groupForV6());
        }
        return output.join(":");
      };
      Address62.prototype.regularExpressionString = function(substringSearch) {
        if (substringSearch === void 0) {
          substringSearch = false;
        }
        var output = [];
        var address6 = new Address62(this.correctForm());
        if (address6.elidedGroups === 0) {
          output.push(regular_expressions_1.simpleRegularExpression(address6.parsedAddress));
        } else if (address6.elidedGroups === constants6.GROUPS) {
          output.push(regular_expressions_1.possibleElisions(constants6.GROUPS));
        } else {
          var halves = address6.address.split("::");
          if (halves[0].length) {
            output.push(regular_expressions_1.simpleRegularExpression(halves[0].split(":")));
          }
          assert(typeof address6.elidedGroups === "number");
          output.push(regular_expressions_1.possibleElisions(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
          if (halves[1].length) {
            output.push(regular_expressions_1.simpleRegularExpression(halves[1].split(":")));
          }
          output = [output.join(":")];
        }
        if (!substringSearch) {
          output = __spreadArray(__spreadArray([
            "(?=^|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|[^\\w\\:])("
          ], output), [
            ")(?=[^\\w\\:]|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|$)"
          ]);
        }
        return output.join("");
      };
      Address62.prototype.regularExpression = function(substringSearch) {
        if (substringSearch === void 0) {
          substringSearch = false;
        }
        return new RegExp(this.regularExpressionString(substringSearch), "i");
      };
      return Address62;
    }();
    exports2.Address6 = Address6;
  }
});

// node_modules/ip-address/dist/cjs/ip-address.js
var require_ip_address = __commonJS({
  "node_modules/ip-address/dist/cjs/ip-address.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.v6 = exports2.AddressError = exports2.Address6 = exports2.Address4 = void 0;
    var ipv4_1 = require_ipv4();
    Object.defineProperty(exports2, "Address4", { enumerable: true, get: function() {
      return ipv4_1.Address4;
    } });
    var ipv6_1 = require_ipv6();
    Object.defineProperty(exports2, "Address6", { enumerable: true, get: function() {
      return ipv6_1.Address6;
    } });
    var address_error_1 = require_address_error();
    Object.defineProperty(exports2, "AddressError", { enumerable: true, get: function() {
      return address_error_1.AddressError;
    } });
    var helpers = __importStar(require_helpers());
    exports2.v6 = { helpers };
  }
});

// node_modules/libp2p-utils/src/ip-port-to-multiaddr.js
var require_ip_port_to_multiaddr = __commonJS({
  "node_modules/libp2p-utils/src/ip-port-to-multiaddr.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:ip-port-to-multiaddr"), {
      error: debug50("libp2p:ip-port-to-multiaddr:err")
    });
    var { Multiaddr: Multiaddr22 } = require_src();
    var errCode69 = require_err_code();
    var { Address4, Address6 } = require_ip_address();
    var errors2 = {
      ERR_INVALID_IP_PARAMETER: "ERR_INVALID_IP_PARAMETER",
      ERR_INVALID_PORT_PARAMETER: "ERR_INVALID_PORT_PARAMETER",
      ERR_INVALID_IP: "ERR_INVALID_IP"
    };
    function ipPortToMultiaddr(ip, port) {
      if (typeof ip !== "string") {
        throw errCode69(new Error(`invalid ip provided: ${ip}`), errors2.ERR_INVALID_IP_PARAMETER);
      }
      if (typeof port === "string") {
        port = parseInt(port);
      }
      if (isNaN(port)) {
        throw errCode69(new Error(`invalid port provided: ${port}`), errors2.ERR_INVALID_PORT_PARAMETER);
      }
      try {
        new Address4(ip);
        return new Multiaddr22(`/ip4/${ip}/tcp/${port}`);
      } catch {
      }
      try {
        const ip6 = new Address6(ip);
        return ip6.is4() ? new Multiaddr22(`/ip4/${ip6.to4().correctForm()}/tcp/${port}`) : new Multiaddr22(`/ip6/${ip}/tcp/${port}`);
      } catch (err) {
        const errMsg = `invalid ip:port for creating a multiaddr: ${ip}:${port}`;
        log48.error(errMsg);
        throw errCode69(new Error(errMsg), errors2.ERR_INVALID_IP);
      }
    }
    module2.exports = ipPortToMultiaddr;
    module2.exports.Errors = errors2;
  }
});

// node_modules/p-timeout/index.js
var require_p_timeout2 = __commonJS({
  "node_modules/p-timeout/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var TimeoutError2 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback, options) => {
      let timer;
      const cancelablePromise = new Promise((resolve11, reject) => {
        if (typeof milliseconds !== "number" || milliseconds < 0) {
          throw new TypeError("Expected `milliseconds` to be a positive number");
        }
        if (milliseconds === Infinity) {
          resolve11(promise);
          return;
        }
        options = {
          customTimers: { setTimeout, clearTimeout },
          ...options
        };
        timer = options.customTimers.setTimeout.call(void 0, () => {
          if (typeof fallback === "function") {
            try {
              resolve11(fallback());
            } catch (error) {
              reject(error);
            }
            return;
          }
          const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
          const timeoutError = fallback instanceof Error ? fallback : new TimeoutError2(message);
          if (typeof promise.cancel === "function") {
            promise.cancel();
          }
          reject(timeoutError);
        }, milliseconds);
        (async () => {
          try {
            resolve11(await promise);
          } catch (error) {
            reject(error);
          } finally {
            options.customTimers.clearTimeout.call(void 0, timer);
          }
        })();
      });
      cancelablePromise.clear = () => {
        clearTimeout(timer);
        timer = void 0;
      };
      return cancelablePromise;
    };
    module2.exports = pTimeout;
    module2.exports.default = pTimeout;
    module2.exports.TimeoutError = TimeoutError2;
  }
});

// node_modules/libp2p-websockets/src/socket-to-conn.js
var require_socket_to_conn = __commonJS({
  "node_modules/libp2p-websockets/src/socket-to-conn.js"(exports2, module2) {
    "use strict";
    init_globals();
    var abortable = require_abortable_iterator();
    var { CLOSE_TIMEOUT } = require_constants5();
    var toMultiaddr = require_ip_port_to_multiaddr();
    var pTimeout = require_p_timeout2();
    var debug50 = require_browser2();
    var log48 = debug50("libp2p:websockets:socket");
    log48.error = debug50("libp2p:websockets:socket:error");
    module2.exports = (stream, options = {}) => {
      const maConn = {
        async sink(source) {
          if (options.signal) {
            source = abortable(source, options.signal);
          }
          try {
            await stream.sink(async function* () {
              for await (const chunk of source) {
                yield chunk instanceof Uint8Array ? chunk : chunk.slice();
              }
            }());
          } catch (err) {
            if (err.type !== "aborted") {
              log48.error(err);
            }
          }
        },
        source: options.signal ? abortable(stream.source, options.signal) : stream.source,
        conn: stream,
        localAddr: options.localAddr || (stream.localAddress && stream.localPort ? toMultiaddr(stream.localAddress, stream.localPort) : void 0),
        remoteAddr: options.remoteAddr || toMultiaddr(stream.remoteAddress, stream.remotePort),
        timeline: { open: Date.now() },
        async close() {
          const start = Date.now();
          try {
            await pTimeout(stream.close(), CLOSE_TIMEOUT);
          } catch (err) {
            const { host, port } = maConn.remoteAddr.toOptions();
            log48("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
            stream.destroy();
          } finally {
            maConn.timeline.close = Date.now();
          }
        }
      };
      stream.socket.once && stream.socket.once("close", () => {
        if (!maConn.timeline.close) {
          maConn.timeline.close = Date.now();
        }
      });
      return maConn;
    };
  }
});

// node_modules/libp2p-websockets/src/filters.js
var require_filters = __commonJS({
  "node_modules/libp2p-websockets/src/filters.js"(exports2, module2) {
    "use strict";
    init_globals();
    var mafmt2 = require_src2();
    var {
      CODE_CIRCUIT,
      CODE_P2P,
      CODE_TCP,
      CODE_WS,
      CODE_WSS
    } = require_constants5();
    module2.exports = {
      all: (multiaddrs) => multiaddrs.filter((ma) => {
        if (ma.protoCodes().includes(CODE_CIRCUIT)) {
          return false;
        }
        const testMa = ma.decapsulateCode(CODE_P2P);
        return mafmt2.WebSockets.matches(testMa) || mafmt2.WebSocketsSecure.matches(testMa);
      }),
      dnsWss: (multiaddrs) => multiaddrs.filter((ma) => {
        if (ma.protoCodes().includes(CODE_CIRCUIT)) {
          return false;
        }
        const testMa = ma.decapsulateCode(CODE_P2P);
        return mafmt2.WebSocketsSecure.matches(testMa) && mafmt2.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
      }),
      dnsWsOrWss: (multiaddrs) => multiaddrs.filter((ma) => {
        if (ma.protoCodes().includes(CODE_CIRCUIT)) {
          return false;
        }
        const testMa = ma.decapsulateCode(CODE_P2P);
        if (mafmt2.WebSockets.matches(testMa)) {
          return mafmt2.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WS));
        }
        return mafmt2.WebSocketsSecure.matches(testMa) && mafmt2.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
      })
    };
  }
});

// node_modules/libp2p-websockets/src/index.js
var require_src15 = __commonJS({
  "node_modules/libp2p-websockets/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var connect = require_client();
    var withIs = require_class_is();
    var toUri2 = require_multiaddr_to_uri();
    var { AbortError } = require_abortable_iterator();
    var pDefer = require_p_defer();
    var debug50 = require_browser2();
    var log48 = debug50("libp2p:websockets");
    log48.error = debug50("libp2p:websockets:error");
    var env = require_env();
    var createListener = require_listener_browser();
    var toConnection = require_socket_to_conn();
    var filters = require_filters();
    var WebSockets = class {
      constructor({ upgrader, filter: filter10 }) {
        if (!upgrader) {
          throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");
        }
        this._upgrader = upgrader;
        this._filter = filter10;
      }
      async dial(ma, options = {}) {
        log48("dialing %s", ma);
        const socket = await this._connect(ma, options);
        const maConn = toConnection(socket, { remoteAddr: ma, signal: options.signal });
        log48("new outbound connection %s", maConn.remoteAddr);
        const conn = await this._upgrader.upgradeOutbound(maConn);
        log48("outbound connection %s upgraded", maConn.remoteAddr);
        return conn;
      }
      async _connect(ma, options = {}) {
        if (options.signal && options.signal.aborted) {
          throw new AbortError();
        }
        const cOpts = ma.toOptions();
        log48("dialing %s:%s", cOpts.host, cOpts.port);
        const errorPromise = pDefer();
        const errfn = (err) => {
          const msg = `connection error: ${err.message}`;
          log48.error(msg);
          errorPromise.reject(err);
        };
        const rawSocket = connect(toUri2(ma), Object.assign({ binary: true }, options));
        if (rawSocket.socket.on) {
          rawSocket.socket.on("error", errfn);
        } else {
          rawSocket.socket.onerror = errfn;
        }
        if (!options.signal) {
          await Promise.race([rawSocket.connected(), errorPromise.promise]);
          log48("connected %s", ma);
          return rawSocket;
        }
        let onAbort;
        const abort = new Promise((resolve11, reject) => {
          onAbort = () => {
            reject(new AbortError());
            setTimeout(() => {
              rawSocket.close();
            });
          };
          if (options.signal.aborted)
            return onAbort();
          options.signal.addEventListener("abort", onAbort);
        });
        try {
          await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);
        } finally {
          options.signal.removeEventListener("abort", onAbort);
        }
        log48("connected %s", ma);
        return rawSocket;
      }
      createListener(options = {}, handler) {
        if (typeof options === "function") {
          handler = options;
          options = {};
        }
        return createListener({ handler, upgrader: this._upgrader }, options);
      }
      filter(multiaddrs) {
        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
        if (this._filter) {
          return this._filter(multiaddrs);
        }
        if (env.isBrowser || env.isWebWorker) {
          return filters.dnsWss(multiaddrs);
        }
        return filters.all(multiaddrs);
      }
    };
    module2.exports = withIs(WebSockets, {
      className: "WebSockets",
      symbolName: "@libp2p/js-libp2p-websockets/websockets"
    });
  }
});

// node_modules/get-browser-rtc/index.js
var require_get_browser_rtc = __commonJS({
  "node_modules/get-browser-rtc/index.js"(exports2, module2) {
    init_globals();
    module2.exports = function getBrowserRTC2() {
      if (typeof globalThis === "undefined")
        return null;
      var wrtc = {
        RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
        RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
        RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
      };
      if (!wrtc.RTCPeerConnection)
        return null;
      return wrtc;
    };
  }
});

// node_modules/randombytes/browser.js
var require_browser8 = __commonJS({
  "node_modules/randombytes/browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto6 = global.crypto || global.msCrypto;
    if (crypto6 && crypto6.getRandomValues) {
      module2.exports = randomBytes;
    } else {
      module2.exports = oldBrowser;
    }
    function randomBytes(size, cb) {
      if (size > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes2 = Buffer2.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto6.getRandomValues(bytes2.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto6.getRandomValues(bytes2);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes2);
        });
      }
      return bytes2;
    }
  }
});

// node_modules/libp2p-webrtc-peer/node_modules/err-code/index.js
var require_err_code2 = __commonJS({
  "node_modules/libp2p-webrtc-peer/node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code13, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code13 === "object") {
        props = code13;
        code13 = void 0;
      }
      if (code13 != null) {
        props.code = code13;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        return assign(new ErrClass(), props);
      }
    }
    module2.exports = createError;
  }
});

// node_modules/libp2p-webrtc-peer/index.js
var require_libp2p_webrtc_peer = __commonJS({
  "node_modules/libp2p-webrtc-peer/index.js"(exports2, module2) {
    init_globals();
    var debug50 = require_browser2()("simple-peer");
    var getBrowserRTC2 = require_get_browser_rtc();
    var randombytes2 = require_browser8();
    var stream = require_readable_browser();
    var queueMicrotask2 = require_queue_microtask();
    var errCode69 = require_err_code2();
    var MAX_BUFFERED_AMOUNT2 = 64 * 1024;
    var ICECOMPLETE_TIMEOUT2 = 5 * 1e3;
    var CHANNEL_CLOSING_TIMEOUT2 = 5 * 1e3;
    function filterTrickle2(sdp) {
      return sdp.replace(/a=ice-options:trickle\s\n/g, "");
    }
    function warn2(message) {
      console.warn(message);
    }
    var Peer3 = class extends stream.Duplex {
      constructor(opts) {
        opts = Object.assign({
          allowHalfOpen: false
        }, opts);
        super(opts);
        this._id = randombytes2(4).toString("hex").slice(0, 7);
        this._debug("new peer %o", opts);
        this.channelName = opts.initiator ? opts.channelName || randombytes2(20).toString("hex") : null;
        this.initiator = opts.initiator || false;
        this.channelConfig = opts.channelConfig || Peer3.channelConfig;
        this.negotiated = this.channelConfig.negotiated;
        this.config = Object.assign({}, Peer3.config, opts.config);
        this.offerOptions = opts.offerOptions || {};
        this.answerOptions = opts.answerOptions || {};
        this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
        this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
        this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
        this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
        this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT2;
        this._connected = false;
        this.remoteAddress = void 0;
        this.remoteFamily = void 0;
        this.remotePort = void 0;
        this.localAddress = void 0;
        this.localFamily = void 0;
        this.localPort = void 0;
        this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC2();
        if (!this._wrtc) {
          if (typeof window === "undefined") {
            throw errCode69(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
          } else {
            throw errCode69(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
          }
        }
        this._pcReady = false;
        this._channelReady = false;
        this._iceComplete = false;
        this._iceCompleteTimer = null;
        this._channel = null;
        this._pendingCandidates = [];
        this._isNegotiating = this.negotiated ? false : !this.initiator;
        this._batchedNegotiation = false;
        this._queuedNegotiation = false;
        this._sendersAwaitingStable = [];
        this._senderMap = /* @__PURE__ */ new Map();
        this._firstStable = true;
        this._closingInterval = null;
        this._remoteTracks = [];
        this._remoteStreams = [];
        this._chunk = null;
        this._cb = null;
        this._interval = null;
        try {
          this._pc = new this._wrtc.RTCPeerConnection(this.config);
        } catch (err) {
          queueMicrotask2(() => this.destroy(errCode69(err, "ERR_PC_CONSTRUCTOR")));
          return;
        }
        this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
        this._pc.oniceconnectionstatechange = () => {
          this._onIceStateChange();
        };
        this._pc.onicegatheringstatechange = () => {
          this._onIceStateChange();
        };
        this._pc.onconnectionstatechange = () => {
          this._onConnectionStateChange();
        };
        this._pc.onsignalingstatechange = () => {
          this._onSignalingStateChange();
        };
        this._pc.onicecandidate = (event) => {
          this._onIceCandidate(event);
        };
        if (this.initiator || this.negotiated) {
          this._setupData({
            channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
          });
        } else {
          this._pc.ondatachannel = (event) => {
            this._setupData(event);
          };
        }
        if (this.streams) {
          this.streams.forEach((stream2) => {
            this.addStream(stream2);
          });
        }
        this._pc.ontrack = (event) => {
          this._onTrack(event);
        };
        if (this.initiator) {
          this._needsNegotiation();
        }
        this._onFinishBound = () => {
          this._onFinish();
        };
        this.once("finish", this._onFinishBound);
      }
      get bufferSize() {
        return this._channel && this._channel.bufferedAmount || 0;
      }
      get connected() {
        return this._connected && this._channel.readyState === "open";
      }
      address() {
        return { port: this.localPort, family: this.localFamily, address: this.localAddress };
      }
      signal(data) {
        if (this.destroyed)
          throw errCode69(new Error("cannot signal after peer is destroyed"), "ERR_SIGNALING");
        if (typeof data === "string") {
          try {
            data = JSON.parse(data);
          } catch (err) {
            data = {};
          }
        }
        this._debug("signal()");
        if (data.renegotiate && this.initiator) {
          this._debug("got request to renegotiate");
          this._needsNegotiation();
        }
        if (data.transceiverRequest && this.initiator) {
          this._debug("got request for transceiver");
          this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
        }
        if (data.candidate) {
          if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
            this._addIceCandidate(data.candidate);
          } else {
            this._pendingCandidates.push(data.candidate);
          }
        }
        if (data.sdp) {
          this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {
            if (this.destroyed)
              return;
            this._pendingCandidates.forEach((candidate) => {
              this._addIceCandidate(candidate);
            });
            this._pendingCandidates = [];
            if (this._pc.remoteDescription.type === "offer")
              this._createAnswer();
          }).catch((err) => {
            this.destroy(errCode69(err, "ERR_SET_REMOTE_DESCRIPTION"));
          });
        }
        if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
          this.destroy(errCode69(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
        }
      }
      _addIceCandidate(candidate) {
        var iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
        this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
          if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
            warn2("Ignoring unsupported ICE candidate.");
          } else {
            this.destroy(errCode69(err, "ERR_ADD_ICE_CANDIDATE"));
          }
        });
      }
      send(chunk) {
        this._channel.send(chunk);
      }
      addTransceiver(kind, init) {
        this._debug("addTransceiver()");
        if (this.initiator) {
          try {
            this._pc.addTransceiver(kind, init);
            this._needsNegotiation();
          } catch (err) {
            this.destroy(errCode69(err, "ERR_ADD_TRANSCEIVER"));
          }
        } else {
          this.emit("signal", {
            transceiverRequest: { kind, init }
          });
        }
      }
      addStream(stream2) {
        this._debug("addStream()");
        stream2.getTracks().forEach((track) => {
          this.addTrack(track, stream2);
        });
      }
      addTrack(track, stream2) {
        this._debug("addTrack()");
        var submap = this._senderMap.get(track) || /* @__PURE__ */ new Map();
        var sender = submap.get(stream2);
        if (!sender) {
          sender = this._pc.addTrack(track, stream2);
          submap.set(stream2, sender);
          this._senderMap.set(track, submap);
          this._needsNegotiation();
        } else if (sender.removed) {
          throw errCode69(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
        } else {
          throw errCode69(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
        }
      }
      replaceTrack(oldTrack, newTrack, stream2) {
        this._debug("replaceTrack()");
        var submap = this._senderMap.get(oldTrack);
        var sender = submap ? submap.get(stream2) : null;
        if (!sender) {
          throw errCode69(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
        }
        if (newTrack)
          this._senderMap.set(newTrack, submap);
        if (sender.replaceTrack != null) {
          sender.replaceTrack(newTrack);
        } else {
          this.destroy(errCode69(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
        }
      }
      removeTrack(track, stream2) {
        this._debug("removeSender()");
        var submap = this._senderMap.get(track);
        var sender = submap ? submap.get(stream2) : null;
        if (!sender) {
          throw errCode69(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
        }
        try {
          sender.removed = true;
          this._pc.removeTrack(sender);
        } catch (err) {
          if (err.name === "NS_ERROR_UNEXPECTED") {
            this._sendersAwaitingStable.push(sender);
          } else {
            this.destroy(errCode69(err, "ERR_REMOVE_TRACK"));
          }
        }
        this._needsNegotiation();
      }
      removeStream(stream2) {
        this._debug("removeSenders()");
        stream2.getTracks().forEach((track) => {
          this.removeTrack(track, stream2);
        });
      }
      _needsNegotiation() {
        this._debug("_needsNegotiation");
        if (this._batchedNegotiation)
          return;
        this._batchedNegotiation = true;
        queueMicrotask2(() => {
          this._batchedNegotiation = false;
          this._debug("starting batched negotiation");
          this.negotiate();
        });
      }
      negotiate() {
        if (this.initiator) {
          if (this._isNegotiating) {
            this._queuedNegotiation = true;
            this._debug("already negotiating, queueing");
          } else {
            this._debug("start negotiation");
            setTimeout(() => {
              this._createOffer();
            }, 0);
          }
        } else {
          if (this._isNegotiating) {
            this._queuedNegotiation = true;
            this._debug("already negotiating, queueing");
          } else {
            this._debug("requesting negotiation from initiator");
            this.emit("signal", {
              renegotiate: true
            });
          }
        }
        this._isNegotiating = true;
      }
      _destroy(err, cb) {
        this._debug("destroy (error: %s)", err && (err.message || err));
        this.readable = this.writable = false;
        if (!this._readableState.ended)
          this.push(null);
        if (!this._writableState.finished)
          this.end();
        this._connected = false;
        this._pcReady = false;
        this._channelReady = false;
        this._remoteTracks = null;
        this._remoteStreams = null;
        this._senderMap = null;
        clearInterval(this._closingInterval);
        this._closingInterval = null;
        clearInterval(this._interval);
        this._interval = null;
        this._chunk = null;
        this._cb = null;
        if (this._onFinishBound)
          this.removeListener("finish", this._onFinishBound);
        this._onFinishBound = null;
        if (this._channel) {
          try {
            this._channel.close();
          } catch (err2) {
          }
          this._channel.onmessage = null;
          this._channel.onopen = null;
          this._channel.onclose = null;
          this._channel.onerror = null;
        }
        if (this._pc) {
          try {
            this._pc.close();
          } catch (err2) {
          }
          this._pc.oniceconnectionstatechange = null;
          this._pc.onicegatheringstatechange = null;
          this._pc.onsignalingstatechange = null;
          this._pc.onicecandidate = null;
          this._pc.ontrack = null;
          this._pc.ondatachannel = null;
        }
        this._pc = null;
        this._channel = null;
        cb(err);
      }
      _setupData(event) {
        if (!event.channel) {
          return this.destroy(errCode69(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
        }
        this._channel = event.channel;
        this._channel.binaryType = "arraybuffer";
        if (typeof this._channel.bufferedAmountLowThreshold === "number") {
          this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT2;
        }
        this.channelName = this._channel.label;
        this._channel.onmessage = (event2) => {
          this._onChannelMessage(event2);
        };
        this._channel.onbufferedamountlow = () => {
          this._onChannelBufferedAmountLow();
        };
        this._channel.onopen = () => {
          this._onChannelOpen();
        };
        this._channel.onclose = () => {
          this._onChannelClose();
        };
        this._channel.onerror = (err) => {
          this.destroy(errCode69(err, "ERR_DATA_CHANNEL"));
        };
        var isClosing = false;
        this._closingInterval = setInterval(() => {
          if (this._channel && this._channel.readyState === "closing") {
            if (isClosing)
              this._onChannelClose();
            isClosing = true;
          } else {
            isClosing = false;
          }
        }, CHANNEL_CLOSING_TIMEOUT2);
      }
      _read() {
      }
      _write(chunk, encoding, cb) {
        if (this.destroyed)
          return cb(errCode69(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
        if (this._connected) {
          try {
            this.send(chunk);
          } catch (err) {
            return this.destroy(errCode69(err, "ERR_DATA_CHANNEL"));
          }
          if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT2) {
            this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
            this._cb = cb;
          } else {
            cb(null);
          }
        } else {
          this._debug("write before connect");
          this._chunk = chunk;
          this._cb = cb;
        }
      }
      _onFinish() {
        if (this.destroyed)
          return;
        const destroySoon = () => {
          setTimeout(() => this.destroy(), 1e3);
        };
        if (this._connected) {
          destroySoon();
        } else {
          this.once("connect", destroySoon);
        }
      }
      _startIceCompleteTimeout() {
        if (this.destroyed)
          return;
        if (this._iceCompleteTimer)
          return;
        this._debug("started iceComplete timeout");
        this._iceCompleteTimer = setTimeout(() => {
          if (!this._iceComplete) {
            this._iceComplete = true;
            this._debug("iceComplete timeout completed");
            this.emit("iceTimeout");
            this.emit("_iceComplete");
          }
        }, this.iceCompleteTimeout);
      }
      _createOffer() {
        if (this.destroyed)
          return;
        this._pc.createOffer(this.offerOptions).then((offer) => {
          if (this.destroyed)
            return;
          if (!this.trickle && !this.allowHalfTrickle)
            offer.sdp = filterTrickle2(offer.sdp);
          offer.sdp = this.sdpTransform(offer.sdp);
          const sendOffer = () => {
            if (this.destroyed)
              return;
            var signal = this._pc.localDescription || offer;
            this._debug("signal");
            this.emit("signal", {
              type: signal.type,
              sdp: signal.sdp
            });
          };
          const onSuccess = () => {
            this._debug("createOffer success");
            if (this.destroyed)
              return;
            if (this.trickle || this._iceComplete)
              sendOffer();
            else
              this.once("_iceComplete", sendOffer);
          };
          const onError = (err) => {
            this.destroy(errCode69(err, "ERR_SET_LOCAL_DESCRIPTION"));
          };
          this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
        }).catch((err) => {
          this.destroy(errCode69(err, "ERR_CREATE_OFFER"));
        });
      }
      _requestMissingTransceivers() {
        if (this._pc.getTransceivers) {
          this._pc.getTransceivers().forEach((transceiver) => {
            if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
              transceiver.requested = true;
              this.addTransceiver(transceiver.sender.track.kind);
            }
          });
        }
      }
      _createAnswer() {
        if (this.destroyed)
          return;
        this._pc.createAnswer(this.answerOptions).then((answer) => {
          if (this.destroyed)
            return;
          if (!this.trickle && !this.allowHalfTrickle)
            answer.sdp = filterTrickle2(answer.sdp);
          answer.sdp = this.sdpTransform(answer.sdp);
          const sendAnswer = () => {
            if (this.destroyed)
              return;
            var signal = this._pc.localDescription || answer;
            this._debug("signal");
            this.emit("signal", {
              type: signal.type,
              sdp: signal.sdp
            });
            if (!this.initiator)
              this._requestMissingTransceivers();
          };
          const onSuccess = () => {
            if (this.destroyed)
              return;
            if (this.trickle || this._iceComplete)
              sendAnswer();
            else
              this.once("_iceComplete", sendAnswer);
          };
          const onError = (err) => {
            this.destroy(errCode69(err, "ERR_SET_LOCAL_DESCRIPTION"));
          };
          this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
        }).catch((err) => {
          this.destroy(errCode69(err, "ERR_CREATE_ANSWER"));
        });
      }
      _onConnectionStateChange() {
        if (this.destroyed)
          return;
        if (this._pc.connectionState === "failed") {
          this.destroy(errCode69(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
        }
      }
      _onIceStateChange() {
        if (this.destroyed)
          return;
        var iceConnectionState = this._pc.iceConnectionState;
        var iceGatheringState = this._pc.iceGatheringState;
        this._debug("iceStateChange (connection: %s) (gathering: %s)", iceConnectionState, iceGatheringState);
        this.emit("iceStateChange", iceConnectionState, iceGatheringState);
        if (iceConnectionState === "connected" || iceConnectionState === "completed") {
          this._pcReady = true;
          this._maybeReady();
        }
        if (iceConnectionState === "failed") {
          this.destroy(errCode69(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
        }
        if (iceConnectionState === "closed") {
          this.destroy(errCode69(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
        }
      }
      getStats(cb) {
        const flattenValues = (report) => {
          if (Object.prototype.toString.call(report.values) === "[object Array]") {
            report.values.forEach((value) => {
              Object.assign(report, value);
            });
          }
          return report;
        };
        if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
          this._pc.getStats().then((res) => {
            var reports = [];
            res.forEach((report) => {
              reports.push(flattenValues(report));
            });
            cb(null, reports);
          }, (err) => cb(err));
        } else if (this._pc.getStats.length > 0) {
          this._pc.getStats((res) => {
            if (this.destroyed)
              return;
            var reports = [];
            res.result().forEach((result) => {
              var report = {};
              result.names().forEach((name10) => {
                report[name10] = result.stat(name10);
              });
              report.id = result.id;
              report.type = result.type;
              report.timestamp = result.timestamp;
              reports.push(flattenValues(report));
            });
            cb(null, reports);
          }, (err) => cb(err));
        } else {
          cb(null, []);
        }
      }
      _maybeReady() {
        this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
        if (this._connected || this._connecting || !this._pcReady || !this._channelReady)
          return;
        this._connecting = true;
        const findCandidatePair = () => {
          if (this.destroyed)
            return;
          this.getStats((err, items) => {
            if (this.destroyed)
              return;
            if (err)
              items = [];
            var remoteCandidates = {};
            var localCandidates = {};
            var candidatePairs = {};
            var foundSelectedCandidatePair = false;
            items.forEach((item) => {
              if (item.type === "remotecandidate" || item.type === "remote-candidate") {
                remoteCandidates[item.id] = item;
              }
              if (item.type === "localcandidate" || item.type === "local-candidate") {
                localCandidates[item.id] = item;
              }
              if (item.type === "candidatepair" || item.type === "candidate-pair") {
                candidatePairs[item.id] = item;
              }
            });
            const setSelectedCandidatePair = (selectedCandidatePair) => {
              foundSelectedCandidatePair = true;
              var local = localCandidates[selectedCandidatePair.localCandidateId];
              if (local && (local.ip || local.address)) {
                this.localAddress = local.ip || local.address;
                this.localPort = Number(local.port);
              } else if (local && local.ipAddress) {
                this.localAddress = local.ipAddress;
                this.localPort = Number(local.portNumber);
              } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
                local = selectedCandidatePair.googLocalAddress.split(":");
                this.localAddress = local[0];
                this.localPort = Number(local[1]);
              }
              if (this.localAddress) {
                this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
              }
              var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
              if (remote && (remote.ip || remote.address)) {
                this.remoteAddress = remote.ip || remote.address;
                this.remotePort = Number(remote.port);
              } else if (remote && remote.ipAddress) {
                this.remoteAddress = remote.ipAddress;
                this.remotePort = Number(remote.portNumber);
              } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
                remote = selectedCandidatePair.googRemoteAddress.split(":");
                this.remoteAddress = remote[0];
                this.remotePort = Number(remote[1]);
              }
              if (this.remoteAddress) {
                this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
              }
              this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
            };
            items.forEach((item) => {
              if (item.type === "transport" && item.selectedCandidatePairId) {
                setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
              }
              if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
                setSelectedCandidatePair(item);
              }
            });
            if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
              setTimeout(findCandidatePair, 100);
              return;
            } else {
              this._connecting = false;
              this._connected = true;
            }
            if (this._chunk) {
              try {
                this.send(this._chunk);
              } catch (err2) {
                return this.destroy(errCode69(err2, "ERR_DATA_CHANNEL"));
              }
              this._chunk = null;
              this._debug('sent chunk from "write before connect"');
              var cb = this._cb;
              this._cb = null;
              cb(null);
            }
            if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
              this._interval = setInterval(() => this._onInterval(), 150);
              if (this._interval.unref)
                this._interval.unref();
            }
            this._debug("connect");
            this.emit("connect");
          });
        };
        findCandidatePair();
      }
      _onInterval() {
        if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT2) {
          return;
        }
        this._onChannelBufferedAmountLow();
      }
      _onSignalingStateChange() {
        if (this.destroyed)
          return;
        if (this._pc.signalingState === "stable" && !this._firstStable) {
          this._isNegotiating = false;
          this._debug("flushing sender queue", this._sendersAwaitingStable);
          this._sendersAwaitingStable.forEach((sender) => {
            this._pc.removeTrack(sender);
            this._queuedNegotiation = true;
          });
          this._sendersAwaitingStable = [];
          if (this._queuedNegotiation) {
            this._debug("flushing negotiation queue");
            this._queuedNegotiation = false;
            this._needsNegotiation();
          }
          this._debug("negotiate");
          this.emit("negotiate");
        }
        this._firstStable = false;
        this._debug("signalingStateChange %s", this._pc.signalingState);
        this.emit("signalingStateChange", this._pc.signalingState);
      }
      _onIceCandidate(event) {
        if (this.destroyed)
          return;
        if (event.candidate && this.trickle) {
          this.emit("signal", {
            candidate: {
              candidate: event.candidate.candidate,
              sdpMLineIndex: event.candidate.sdpMLineIndex,
              sdpMid: event.candidate.sdpMid
            }
          });
        } else if (!event.candidate && !this._iceComplete) {
          this._iceComplete = true;
          this.emit("_iceComplete");
        }
        if (event.candidate) {
          this._startIceCompleteTimeout();
        }
      }
      _onChannelMessage(event) {
        if (this.destroyed)
          return;
        var data = event.data;
        if (data instanceof ArrayBuffer)
          data = new Uint8Array(data);
        this.push(data);
      }
      _onChannelBufferedAmountLow() {
        if (this.destroyed || !this._cb)
          return;
        this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
        var cb = this._cb;
        this._cb = null;
        cb(null);
      }
      _onChannelOpen() {
        if (this._connected || this.destroyed)
          return;
        this._debug("on channel open");
        this._channelReady = true;
        this._maybeReady();
      }
      _onChannelClose() {
        if (this.destroyed)
          return;
        this._debug("on channel close");
        this.destroy();
      }
      _onTrack(event) {
        if (this.destroyed)
          return;
        event.streams.forEach((eventStream) => {
          this._debug("on track");
          this.emit("track", event.track, eventStream);
          this._remoteTracks.push({
            track: event.track,
            stream: eventStream
          });
          if (this._remoteStreams.some((remoteStream) => {
            return remoteStream.id === eventStream.id;
          }))
            return;
          this._remoteStreams.push(eventStream);
          queueMicrotask2(() => {
            this.emit("stream", eventStream);
          });
        });
      }
      _debug() {
        var args = [].slice.call(arguments);
        args[0] = "[" + this._id + "] " + args[0];
        debug50.apply(null, args);
      }
    };
    Peer3.WEBRTC_SUPPORT = !!getBrowserRTC2();
    Peer3.config = {
      iceServers: [
        {
          urls: [
            "stun:stun.l.google.com:19302",
            "stun:global.stun.twilio.com:3478"
          ]
        }
      ],
      sdpSemantics: "unified-plan"
    };
    Peer3.channelConfig = {};
    module2.exports = Peer3;
  }
});

// node_modules/ipfs-utils/src/supports.js
var require_supports = __commonJS({
  "node_modules/ipfs-utils/src/supports.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      supportsFileReader: typeof self !== "undefined" && "FileReader" in self,
      supportsWebRTC: "RTCPeerConnection" in globalThis && (typeof navigator !== "undefined" && typeof navigator.mediaDevices !== "undefined" && "getUserMedia" in navigator.mediaDevices),
      supportsWebRTCDataChannels: "RTCPeerConnection" in globalThis
    };
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-webrtc-star/src/constants.js
var require_constants8 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-webrtc-star/src/constants.js"(exports2) {
    "use strict";
    init_globals();
    exports2.CODE_P2P = 421;
    exports2.CODE_CIRCUIT = 290;
    exports2.CLOSE_TIMEOUT = 2e3;
  }
});

// node_modules/engine.io-parser/build/cjs/commons.js
var require_commons = __commonJS({
  "node_modules/engine.io-parser/build/cjs/commons.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ERROR_PACKET = exports2.PACKET_TYPES_REVERSE = exports2.PACKET_TYPES = void 0;
    var PACKET_TYPES = /* @__PURE__ */ Object.create(null);
    exports2.PACKET_TYPES = PACKET_TYPES;
    PACKET_TYPES["open"] = "0";
    PACKET_TYPES["close"] = "1";
    PACKET_TYPES["ping"] = "2";
    PACKET_TYPES["pong"] = "3";
    PACKET_TYPES["message"] = "4";
    PACKET_TYPES["upgrade"] = "5";
    PACKET_TYPES["noop"] = "6";
    var PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
    exports2.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
    Object.keys(PACKET_TYPES).forEach((key) => {
      PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
    });
    var ERROR_PACKET = { type: "error", data: "parser error" };
    exports2.ERROR_PACKET = ERROR_PACKET;
  }
});

// node_modules/engine.io-parser/build/cjs/encodePacket.browser.js
var require_encodePacket_browser = __commonJS({
  "node_modules/engine.io-parser/build/cjs/encodePacket.browser.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commons_js_1 = require_commons();
    var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var isView = (obj) => {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
    };
    var encodePacket = ({ type, data }, supportsBinary, callback) => {
      if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
          return callback(data);
        } else {
          return encodeBlobAsBase64(data, callback);
        }
      } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
          return callback(data);
        } else {
          return encodeBlobAsBase64(new Blob([data]), callback);
        }
      }
      return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
    };
    var encodeBlobAsBase64 = (data, callback) => {
      const fileReader = new FileReader();
      fileReader.onload = function() {
        const content = fileReader.result.split(",")[1];
        callback("b" + content);
      };
      return fileReader.readAsDataURL(data);
    };
    exports2.default = encodePacket;
  }
});

// node_modules/engine.io-parser/build/cjs/contrib/base64-arraybuffer.js
var require_base64_arraybuffer = __commonJS({
  "node_modules/engine.io-parser/build/cjs/contrib/base64-arraybuffer.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = void 0;
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (let i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    var encode19 = (arraybuffer) => {
      let bytes2 = new Uint8Array(arraybuffer), i, len = bytes2.length, base643 = "";
      for (i = 0; i < len; i += 3) {
        base643 += chars[bytes2[i] >> 2];
        base643 += chars[(bytes2[i] & 3) << 4 | bytes2[i + 1] >> 4];
        base643 += chars[(bytes2[i + 1] & 15) << 2 | bytes2[i + 2] >> 6];
        base643 += chars[bytes2[i + 2] & 63];
      }
      if (len % 3 === 2) {
        base643 = base643.substring(0, base643.length - 1) + "=";
      } else if (len % 3 === 1) {
        base643 = base643.substring(0, base643.length - 2) + "==";
      }
      return base643;
    };
    exports2.encode = encode19;
    var decode22 = (base643) => {
      let bufferLength = base643.length * 0.75, len = base643.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base643[base643.length - 1] === "=") {
        bufferLength--;
        if (base643[base643.length - 2] === "=") {
          bufferLength--;
        }
      }
      const arraybuffer = new ArrayBuffer(bufferLength), bytes2 = new Uint8Array(arraybuffer);
      for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base643.charCodeAt(i)];
        encoded2 = lookup[base643.charCodeAt(i + 1)];
        encoded3 = lookup[base643.charCodeAt(i + 2)];
        encoded4 = lookup[base643.charCodeAt(i + 3)];
        bytes2[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes2[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes2[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
    exports2.decode = decode22;
  }
});

// node_modules/engine.io-parser/build/cjs/decodePacket.browser.js
var require_decodePacket_browser = __commonJS({
  "node_modules/engine.io-parser/build/cjs/decodePacket.browser.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commons_js_1 = require_commons();
    var base64_arraybuffer_js_1 = require_base64_arraybuffer();
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var decodePacket = (encodedPacket, binaryType) => {
      if (typeof encodedPacket !== "string") {
        return {
          type: "message",
          data: mapBinary(encodedPacket, binaryType)
        };
      }
      const type = encodedPacket.charAt(0);
      if (type === "b") {
        return {
          type: "message",
          data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
        };
      }
      const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
      if (!packetType) {
        return commons_js_1.ERROR_PACKET;
      }
      return encodedPacket.length > 1 ? {
        type: commons_js_1.PACKET_TYPES_REVERSE[type],
        data: encodedPacket.substring(1)
      } : {
        type: commons_js_1.PACKET_TYPES_REVERSE[type]
      };
    };
    var decodeBase64Packet = (data, binaryType) => {
      if (withNativeArrayBuffer) {
        const decoded = (0, base64_arraybuffer_js_1.decode)(data);
        return mapBinary(decoded, binaryType);
      } else {
        return { base64: true, data };
      }
    };
    var mapBinary = (data, binaryType) => {
      switch (binaryType) {
        case "blob":
          return data instanceof ArrayBuffer ? new Blob([data]) : data;
        case "arraybuffer":
        default:
          return data;
      }
    };
    exports2.default = decodePacket;
  }
});

// node_modules/engine.io-parser/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/engine.io-parser/build/cjs/index.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodePayload = exports2.decodePacket = exports2.encodePayload = exports2.encodePacket = exports2.protocol = void 0;
    var encodePacket_js_1 = require_encodePacket_browser();
    exports2.encodePacket = encodePacket_js_1.default;
    var decodePacket_js_1 = require_decodePacket_browser();
    exports2.decodePacket = decodePacket_js_1.default;
    var SEPARATOR = String.fromCharCode(30);
    var encodePayload = (packets, callback) => {
      const length5 = packets.length;
      const encodedPackets = new Array(length5);
      let count = 0;
      packets.forEach((packet, i) => {
        (0, encodePacket_js_1.default)(packet, false, (encodedPacket) => {
          encodedPackets[i] = encodedPacket;
          if (++count === length5) {
            callback(encodedPackets.join(SEPARATOR));
          }
        });
      });
    };
    exports2.encodePayload = encodePayload;
    var decodePayload = (encodedPayload, binaryType) => {
      const encodedPackets = encodedPayload.split(SEPARATOR);
      const packets = [];
      for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.default)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
          break;
        }
      }
      return packets;
    };
    exports2.decodePayload = decodePayload;
    exports2.protocol = 4;
  }
});

// node_modules/@socket.io/component-emitter/index.js
var require_component_emitter = __commonJS({
  "node_modules/@socket.io/component-emitter/index.js"(exports2) {
    init_globals();
    exports2.Emitter = Emitter;
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (arguments.length == 0) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks)
        return this;
      if (arguments.length == 1) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.emitReserved = Emitter.prototype.emit;
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/engine.io-client/build/cjs/globalThis.browser.js
var require_globalThis_browser = __commonJS({
  "node_modules/engine.io-client/build/cjs/globalThis.browser.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalThisShim = void 0;
    exports2.globalThisShim = (() => {
      if (typeof self !== "undefined") {
        return self;
      } else if (typeof window !== "undefined") {
        return window;
      } else {
        return Function("return this")();
      }
    })();
  }
});

// node_modules/engine.io-client/build/cjs/util.js
var require_util6 = __commonJS({
  "node_modules/engine.io-client/build/cjs/util.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.byteLength = exports2.installTimerFunctions = exports2.pick = void 0;
    var globalThis_js_1 = require_globalThis_browser();
    function pick(obj, ...attr) {
      return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
          acc[k] = obj[k];
        }
        return acc;
      }, {});
    }
    exports2.pick = pick;
    var NATIVE_SET_TIMEOUT = setTimeout;
    var NATIVE_CLEAR_TIMEOUT = clearTimeout;
    function installTimerFunctions(obj, opts) {
      if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1.globalThisShim);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1.globalThisShim);
      } else {
        obj.setTimeoutFn = setTimeout.bind(globalThis_js_1.globalThisShim);
        obj.clearTimeoutFn = clearTimeout.bind(globalThis_js_1.globalThisShim);
      }
    }
    exports2.installTimerFunctions = installTimerFunctions;
    var BASE64_OVERHEAD = 1.33;
    function byteLength(obj) {
      if (typeof obj === "string") {
        return utf8Length(obj);
      }
      return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
    }
    exports2.byteLength = byteLength;
    function utf8Length(str) {
      let c = 0, length5 = 0;
      for (let i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 128) {
          length5 += 1;
        } else if (c < 2048) {
          length5 += 2;
        } else if (c < 55296 || c >= 57344) {
          length5 += 3;
        } else {
          i++;
          length5 += 4;
        }
      }
      return length5;
    }
  }
});

// node_modules/engine.io-client/build/cjs/transport.js
var require_transport = __commonJS({
  "node_modules/engine.io-client/build/cjs/transport.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transport = void 0;
    var engine_io_parser_1 = require_cjs();
    var component_emitter_1 = require_component_emitter();
    var util_js_1 = require_util6();
    var debug_1 = __importDefault(require_browser2());
    var debug50 = (0, debug_1.default)("engine.io-client:transport");
    var TransportError = class extends Error {
      constructor(reason, description, context) {
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
      }
    };
    var Transport = class extends component_emitter_1.Emitter {
      constructor(opts) {
        super();
        this.writable = false;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.readyState = "";
        this.socket = opts.socket;
      }
      onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
      }
      open() {
        if (this.readyState === "closed" || this.readyState === "") {
          this.readyState = "opening";
          this.doOpen();
        }
        return this;
      }
      close() {
        if (this.readyState === "opening" || this.readyState === "open") {
          this.doClose();
          this.onClose();
        }
        return this;
      }
      send(packets) {
        if (this.readyState === "open") {
          this.write(packets);
        } else {
          debug50("transport is not open, discarding packets");
        }
      }
      onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
      }
      onData(data) {
        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);
        this.onPacket(packet);
      }
      onPacket(packet) {
        super.emitReserved("packet", packet);
      }
      onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
      }
    };
    exports2.Transport = Transport;
  }
});

// node_modules/engine.io-client/build/cjs/contrib/yeast.js
var require_yeast = __commonJS({
  "node_modules/engine.io-client/build/cjs/contrib/yeast.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.yeast = exports2.decode = exports2.encode = void 0;
    var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
    var length5 = 64;
    var map12 = {};
    var seed = 0;
    var i = 0;
    var prev;
    function encode19(num) {
      let encoded = "";
      do {
        encoded = alphabet[num % length5] + encoded;
        num = Math.floor(num / length5);
      } while (num > 0);
      return encoded;
    }
    exports2.encode = encode19;
    function decode22(str) {
      let decoded = 0;
      for (i = 0; i < str.length; i++) {
        decoded = decoded * length5 + map12[str.charAt(i)];
      }
      return decoded;
    }
    exports2.decode = decode22;
    function yeast() {
      const now = encode19(+new Date());
      if (now !== prev)
        return seed = 0, prev = now;
      return now + "." + encode19(seed++);
    }
    exports2.yeast = yeast;
    for (; i < length5; i++)
      map12[alphabet[i]] = i;
  }
});

// node_modules/engine.io-client/build/cjs/contrib/parseqs.js
var require_parseqs = __commonJS({
  "node_modules/engine.io-client/build/cjs/contrib/parseqs.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = void 0;
    function encode19(obj) {
      let str = "";
      for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (str.length)
            str += "&";
          str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
        }
      }
      return str;
    }
    exports2.encode = encode19;
    function decode22(qs) {
      let qry = {};
      let pairs = qs.split("&");
      for (let i = 0, l = pairs.length; i < l; i++) {
        let pair = pairs[i].split("=");
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    }
    exports2.decode = decode22;
  }
});

// node_modules/engine.io-client/build/cjs/contrib/has-cors.js
var require_has_cors = __commonJS({
  "node_modules/engine.io-client/build/cjs/contrib/has-cors.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasCORS = void 0;
    var value = false;
    try {
      value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
    } catch (err) {
    }
    exports2.hasCORS = value;
  }
});

// node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js
var require_xmlhttprequest_browser = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XHR = void 0;
    var has_cors_js_1 = require_has_cors();
    var globalThis_js_1 = require_globalThis_browser();
    function XHR(opts) {
      const xdomain = opts.xdomain;
      try {
        if (typeof XMLHttpRequest !== "undefined" && (!xdomain || has_cors_js_1.hasCORS)) {
          return new XMLHttpRequest();
        }
      } catch (e) {
      }
      if (!xdomain) {
        try {
          return new globalThis_js_1.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        } catch (e) {
        }
      }
    }
    exports2.XHR = XHR;
  }
});

// node_modules/engine.io-client/build/cjs/transports/polling.js
var require_polling = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/polling.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Request = exports2.Polling = void 0;
    var transport_js_1 = require_transport();
    var debug_1 = __importDefault(require_browser2());
    var yeast_js_1 = require_yeast();
    var parseqs_js_1 = require_parseqs();
    var engine_io_parser_1 = require_cjs();
    var xmlhttprequest_js_1 = require_xmlhttprequest_browser();
    var component_emitter_1 = require_component_emitter();
    var util_js_1 = require_util6();
    var globalThis_js_1 = require_globalThis_browser();
    var debug50 = (0, debug_1.default)("engine.io-client:polling");
    function empty3() {
    }
    var hasXHR2 = function() {
      const xhr = new xmlhttprequest_js_1.XHR({
        xdomain: false
      });
      return xhr.responseType != null;
    }();
    var Polling = class extends transport_js_1.Transport {
      constructor(opts) {
        super(opts);
        this.polling = false;
        if (typeof location !== "undefined") {
          const isSSL = location.protocol === "https:";
          let port = location.port;
          if (!port) {
            port = isSSL ? "443" : "80";
          }
          this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
          this.xs = opts.secure !== isSSL;
        }
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
      }
      get name() {
        return "polling";
      }
      doOpen() {
        this.poll();
      }
      pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
          debug50("paused");
          this.readyState = "paused";
          onPause();
        };
        if (this.polling || !this.writable) {
          let total = 0;
          if (this.polling) {
            debug50("we are currently polling - waiting to pause");
            total++;
            this.once("pollComplete", function() {
              debug50("pre-pause polling complete");
              --total || pause();
            });
          }
          if (!this.writable) {
            debug50("we are currently writing - waiting to pause");
            total++;
            this.once("drain", function() {
              debug50("pre-pause writing complete");
              --total || pause();
            });
          }
        } else {
          pause();
        }
      }
      poll() {
        debug50("polling");
        this.polling = true;
        this.doPoll();
        this.emitReserved("poll");
      }
      onData(data) {
        debug50("polling got data %s", data);
        const callback = (packet) => {
          if (this.readyState === "opening" && packet.type === "open") {
            this.onOpen();
          }
          if (packet.type === "close") {
            this.onClose({ description: "transport closed by the server" });
            return false;
          }
          this.onPacket(packet);
        };
        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);
        if (this.readyState !== "closed") {
          this.polling = false;
          this.emitReserved("pollComplete");
          if (this.readyState === "open") {
            this.poll();
          } else {
            debug50('ignoring poll - transport state "%s"', this.readyState);
          }
        }
      }
      doClose() {
        const close = () => {
          debug50("writing close packet");
          this.write([{ type: "close" }]);
        };
        if (this.readyState === "open") {
          debug50("transport open - closing");
          close();
        } else {
          debug50("transport not open - deferring close");
          this.once("open", close);
        }
      }
      write(packets) {
        this.writable = false;
        (0, engine_io_parser_1.encodePayload)(packets, (data) => {
          this.doWrite(data, () => {
            this.writable = true;
            this.emitReserved("drain");
          });
        });
      }
      uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "https" : "http";
        let port = "";
        if (this.opts.timestampRequests !== false) {
          query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
        }
        if (!this.supportsBinary && !query.sid) {
          query.b64 = 1;
        }
        if (this.opts.port && (schema === "https" && Number(this.opts.port) !== 443 || schema === "http" && Number(this.opts.port) !== 80)) {
          port = ":" + this.opts.port;
        }
        const encodedQuery = (0, parseqs_js_1.encode)(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
      }
      request(opts = {}) {
        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
        return new Request(this.uri(), opts);
      }
      doWrite(data, fn) {
        const req = this.request({
          method: "POST",
          data
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context) => {
          this.onError("xhr post error", xhrStatus, context);
        });
      }
      doPoll() {
        debug50("xhr poll");
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context) => {
          this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
      }
    };
    exports2.Polling = Polling;
    var Request = class extends component_emitter_1.Emitter {
      constructor(uri, opts) {
        super();
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.method = opts.method || "GET";
        this.uri = uri;
        this.async = opts.async !== false;
        this.data = opts.data !== void 0 ? opts.data : null;
        this.create();
      }
      create() {
        const opts = (0, util_js_1.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this.opts.xd;
        opts.xscheme = !!this.opts.xs;
        const xhr = this.xhr = new xmlhttprequest_js_1.XHR(opts);
        try {
          debug50("xhr open %s: %s", this.method, this.uri);
          xhr.open(this.method, this.uri, this.async);
          try {
            if (this.opts.extraHeaders) {
              xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
              for (let i in this.opts.extraHeaders) {
                if (this.opts.extraHeaders.hasOwnProperty(i)) {
                  xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                }
              }
            }
          } catch (e) {
          }
          if (this.method === "POST") {
            try {
              xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            } catch (e) {
            }
          }
          try {
            xhr.setRequestHeader("Accept", "*/*");
          } catch (e) {
          }
          if ("withCredentials" in xhr) {
            xhr.withCredentials = this.opts.withCredentials;
          }
          if (this.opts.requestTimeout) {
            xhr.timeout = this.opts.requestTimeout;
          }
          xhr.onreadystatechange = () => {
            if (xhr.readyState !== 4)
              return;
            if (xhr.status === 200 || xhr.status === 1223) {
              this.onLoad();
            } else {
              this.setTimeoutFn(() => {
                this.onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };
          debug50("xhr data %s", this.data);
          xhr.send(this.data);
        } catch (e) {
          this.setTimeoutFn(() => {
            this.onError(e);
          }, 0);
          return;
        }
        if (typeof document !== "undefined") {
          this.index = Request.requestsCount++;
          Request.requests[this.index] = this;
        }
      }
      onError(err) {
        this.emitReserved("error", err, this.xhr);
        this.cleanup(true);
      }
      cleanup(fromError) {
        if (typeof this.xhr === "undefined" || this.xhr === null) {
          return;
        }
        this.xhr.onreadystatechange = empty3;
        if (fromError) {
          try {
            this.xhr.abort();
          } catch (e) {
          }
        }
        if (typeof document !== "undefined") {
          delete Request.requests[this.index];
        }
        this.xhr = null;
      }
      onLoad() {
        const data = this.xhr.responseText;
        if (data !== null) {
          this.emitReserved("data", data);
          this.emitReserved("success");
          this.cleanup();
        }
      }
      abort() {
        this.cleanup();
      }
    };
    exports2.Request = Request;
    Request.requestsCount = 0;
    Request.requests = {};
    if (typeof document !== "undefined") {
      if (typeof attachEvent === "function") {
        attachEvent("onunload", unloadHandler);
      } else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globalThis_js_1.globalThisShim ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
      }
    }
    function unloadHandler() {
      for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
          Request.requests[i].abort();
        }
      }
    }
  }
});

// node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js
var require_websocket_constructor_browser = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultBinaryType = exports2.usingBrowserWebSocket = exports2.WebSocket = exports2.nextTick = void 0;
    var globalThis_js_1 = require_globalThis_browser();
    exports2.nextTick = (() => {
      const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
      if (isPromiseAvailable) {
        return (cb) => Promise.resolve().then(cb);
      } else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
      }
    })();
    exports2.WebSocket = globalThis_js_1.globalThisShim.WebSocket || globalThis_js_1.globalThisShim.MozWebSocket;
    exports2.usingBrowserWebSocket = true;
    exports2.defaultBinaryType = "arraybuffer";
  }
});

// node_modules/engine.io-client/build/cjs/transports/websocket.js
var require_websocket = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/websocket.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WS = void 0;
    var transport_js_1 = require_transport();
    var parseqs_js_1 = require_parseqs();
    var yeast_js_1 = require_yeast();
    var util_js_1 = require_util6();
    var websocket_constructor_js_1 = require_websocket_constructor_browser();
    var debug_1 = __importDefault(require_browser2());
    var engine_io_parser_1 = require_cjs();
    var debug50 = (0, debug_1.default)("engine.io-client:websocket");
    var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
    var WS2 = class extends transport_js_1.Transport {
      constructor(opts) {
        super(opts);
        this.supportsBinary = !opts.forceBase64;
      }
      get name() {
        return "websocket";
      }
      doOpen() {
        if (!this.check()) {
          return;
        }
        const uri = this.uri();
        const protocols = this.opts.protocols;
        const opts = isReactNative ? {} : (0, util_js_1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
          opts.headers = this.opts.extraHeaders;
        }
        try {
          this.ws = websocket_constructor_js_1.usingBrowserWebSocket && !isReactNative ? protocols ? new websocket_constructor_js_1.WebSocket(uri, protocols) : new websocket_constructor_js_1.WebSocket(uri) : new websocket_constructor_js_1.WebSocket(uri, protocols, opts);
        } catch (err) {
          return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType || websocket_constructor_js_1.defaultBinaryType;
        this.addEventListeners();
      }
      addEventListeners() {
        this.ws.onopen = () => {
          if (this.opts.autoUnref) {
            this.ws._socket.unref();
          }
          this.onOpen();
        };
        this.ws.onclose = (closeEvent) => this.onClose({
          description: "websocket connection closed",
          context: closeEvent
        });
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e) => this.onError("websocket error", e);
      }
      write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
          const packet = packets[i];
          const lastPacket = i === packets.length - 1;
          (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, (data) => {
            const opts = {};
            if (!websocket_constructor_js_1.usingBrowserWebSocket) {
              if (packet.options) {
                opts.compress = packet.options.compress;
              }
              if (this.opts.perMessageDeflate) {
                const len = typeof data === "string" ? Buffer.byteLength(data) : data.length;
                if (len < this.opts.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }
            try {
              if (websocket_constructor_js_1.usingBrowserWebSocket) {
                this.ws.send(data);
              } else {
                this.ws.send(data, opts);
              }
            } catch (e) {
              debug50("websocket closed before onclose event");
            }
            if (lastPacket) {
              (0, websocket_constructor_js_1.nextTick)(() => {
                this.writable = true;
                this.emitReserved("drain");
              }, this.setTimeoutFn);
            }
          });
        }
      }
      doClose() {
        if (typeof this.ws !== "undefined") {
          this.ws.close();
          this.ws = null;
        }
      }
      uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "wss" : "ws";
        let port = "";
        if (this.opts.port && (schema === "wss" && Number(this.opts.port) !== 443 || schema === "ws" && Number(this.opts.port) !== 80)) {
          port = ":" + this.opts.port;
        }
        if (this.opts.timestampRequests) {
          query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
        }
        if (!this.supportsBinary) {
          query.b64 = 1;
        }
        const encodedQuery = (0, parseqs_js_1.encode)(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
      }
      check() {
        return !!websocket_constructor_js_1.WebSocket;
      }
    };
    exports2.WS = WS2;
  }
});

// node_modules/engine.io-client/build/cjs/transports/index.js
var require_transports = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/index.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transports = void 0;
    var polling_js_1 = require_polling();
    var websocket_js_1 = require_websocket();
    exports2.transports = {
      websocket: websocket_js_1.WS,
      polling: polling_js_1.Polling
    };
  }
});

// node_modules/engine.io-client/build/cjs/contrib/parseuri.js
var require_parseuri = __commonJS({
  "node_modules/engine.io-client/build/cjs/contrib/parseuri.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = void 0;
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    var parts = [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ];
    function parse2(str) {
      const src3 = str, b = str.indexOf("["), e = str.indexOf("]");
      if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
      }
      let m = re.exec(str || ""), uri = {}, i = 14;
      while (i--) {
        uri[parts[i]] = m[i] || "";
      }
      if (b != -1 && e != -1) {
        uri.source = src3;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
        uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
        uri.ipv6uri = true;
      }
      uri.pathNames = pathNames(uri, uri["path"]);
      uri.queryKey = queryKey(uri, uri["query"]);
      return uri;
    }
    exports2.parse = parse2;
    function pathNames(obj, path) {
      const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
      if (path.substr(0, 1) == "/" || path.length === 0) {
        names.splice(0, 1);
      }
      if (path.substr(path.length - 1, 1) == "/") {
        names.splice(names.length - 1, 1);
      }
      return names;
    }
    function queryKey(uri, query) {
      const data = {};
      query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
        if ($1) {
          data[$1] = $2;
        }
      });
      return data;
    }
  }
});

// node_modules/engine.io-client/build/cjs/socket.js
var require_socket = __commonJS({
  "node_modules/engine.io-client/build/cjs/socket.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Socket = void 0;
    var index_js_1 = require_transports();
    var util_js_1 = require_util6();
    var parseqs_js_1 = require_parseqs();
    var parseuri_js_1 = require_parseuri();
    var debug_1 = __importDefault(require_browser2());
    var component_emitter_1 = require_component_emitter();
    var engine_io_parser_1 = require_cjs();
    var debug50 = (0, debug_1.default)("engine.io-client:socket");
    var Socket = class extends component_emitter_1.Emitter {
      constructor(uri, opts = {}) {
        super();
        if (uri && typeof uri === "object") {
          opts = uri;
          uri = null;
        }
        if (uri) {
          uri = (0, parseuri_js_1.parse)(uri);
          opts.hostname = uri.host;
          opts.secure = uri.protocol === "https" || uri.protocol === "wss";
          opts.port = uri.port;
          if (uri.query)
            opts.query = uri.query;
        } else if (opts.host) {
          opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
        }
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.secure = opts.secure != null ? opts.secure : typeof location !== "undefined" && location.protocol === "https:";
        if (opts.hostname && !opts.port) {
          opts.port = this.secure ? "443" : "80";
        }
        this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
        this.transports = opts.transports || ["polling", "websocket"];
        this.readyState = "";
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.opts = Object.assign({
          path: "/engine.io",
          agent: false,
          withCredentials: false,
          upgrade: true,
          timestampParam: "t",
          rememberUpgrade: false,
          rejectUnauthorized: true,
          perMessageDeflate: {
            threshold: 1024
          },
          transportOptions: {},
          closeOnBeforeunload: true
        }, opts);
        this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
        if (typeof this.opts.query === "string") {
          this.opts.query = (0, parseqs_js_1.decode)(this.opts.query);
        }
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        this.pingTimeoutTimer = null;
        if (typeof addEventListener === "function") {
          if (this.opts.closeOnBeforeunload) {
            addEventListener("beforeunload", () => {
              if (this.transport) {
                this.transport.removeAllListeners();
                this.transport.close();
              }
            }, false);
          }
          if (this.hostname !== "localhost") {
            this.offlineEventListener = () => {
              this.onClose("transport close", {
                description: "network connection lost"
              });
            };
            addEventListener("offline", this.offlineEventListener, false);
          }
        }
        this.open();
      }
      createTransport(name10) {
        debug50('creating transport "%s"', name10);
        const query = Object.assign({}, this.opts.query);
        query.EIO = engine_io_parser_1.protocol;
        query.transport = name10;
        if (this.id)
          query.sid = this.id;
        const opts = Object.assign({}, this.opts.transportOptions[name10], this.opts, {
          query,
          socket: this,
          hostname: this.hostname,
          secure: this.secure,
          port: this.port
        });
        debug50("options: %j", opts);
        return new index_js_1.transports[name10](opts);
      }
      open() {
        let transport;
        if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
          transport = "websocket";
        } else if (this.transports.length === 0) {
          this.setTimeoutFn(() => {
            this.emitReserved("error", "No transports available");
          }, 0);
          return;
        } else {
          transport = this.transports[0];
        }
        this.readyState = "opening";
        try {
          transport = this.createTransport(transport);
        } catch (e) {
          debug50("error while creating transport: %s", e);
          this.transports.shift();
          this.open();
          return;
        }
        transport.open();
        this.setTransport(transport);
      }
      setTransport(transport) {
        debug50("setting transport %s", transport.name);
        if (this.transport) {
          debug50("clearing existing transport %s", this.transport.name);
          this.transport.removeAllListeners();
        }
        this.transport = transport;
        transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
      }
      probe(name10) {
        debug50('probing transport "%s"', name10);
        let transport = this.createTransport(name10);
        let failed = false;
        Socket.priorWebsocketSuccess = false;
        const onTransportOpen = () => {
          if (failed)
            return;
          debug50('probe transport "%s" opened', name10);
          transport.send([{ type: "ping", data: "probe" }]);
          transport.once("packet", (msg) => {
            if (failed)
              return;
            if (msg.type === "pong" && msg.data === "probe") {
              debug50('probe transport "%s" pong', name10);
              this.upgrading = true;
              this.emitReserved("upgrading", transport);
              if (!transport)
                return;
              Socket.priorWebsocketSuccess = transport.name === "websocket";
              debug50('pausing current transport "%s"', this.transport.name);
              this.transport.pause(() => {
                if (failed)
                  return;
                if (this.readyState === "closed")
                  return;
                debug50("changing transport and sending upgrade packet");
                cleanup();
                this.setTransport(transport);
                transport.send([{ type: "upgrade" }]);
                this.emitReserved("upgrade", transport);
                transport = null;
                this.upgrading = false;
                this.flush();
              });
            } else {
              debug50('probe transport "%s" failed', name10);
              const err = new Error("probe error");
              err.transport = transport.name;
              this.emitReserved("upgradeError", err);
            }
          });
        };
        function freezeTransport() {
          if (failed)
            return;
          failed = true;
          cleanup();
          transport.close();
          transport = null;
        }
        const onerror = (err) => {
          const error = new Error("probe error: " + err);
          error.transport = transport.name;
          freezeTransport();
          debug50('probe transport "%s" failed because of error: %s', name10, err);
          this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
          onerror("transport closed");
        }
        function onclose() {
          onerror("socket closed");
        }
        function onupgrade(to) {
          if (transport && to.name !== transport.name) {
            debug50('"%s" works - aborting "%s"', to.name, transport.name);
            freezeTransport();
          }
        }
        const cleanup = () => {
          transport.removeListener("open", onTransportOpen);
          transport.removeListener("error", onerror);
          transport.removeListener("close", onTransportClose);
          this.off("close", onclose);
          this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        transport.open();
      }
      onOpen() {
        debug50("socket open");
        this.readyState = "open";
        Socket.priorWebsocketSuccess = this.transport.name === "websocket";
        this.emitReserved("open");
        this.flush();
        if (this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
          debug50("starting upgrade probes");
          let i = 0;
          const l = this.upgrades.length;
          for (; i < l; i++) {
            this.probe(this.upgrades[i]);
          }
        }
      }
      onPacket(packet) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
          debug50('socket receive: type "%s", data "%s"', packet.type, packet.data);
          this.emitReserved("packet", packet);
          this.emitReserved("heartbeat");
          switch (packet.type) {
            case "open":
              this.onHandshake(JSON.parse(packet.data));
              break;
            case "ping":
              this.resetPingTimeout();
              this.sendPacket("pong");
              this.emitReserved("ping");
              this.emitReserved("pong");
              break;
            case "error":
              const err = new Error("server error");
              err.code = packet.data;
              this.onError(err);
              break;
            case "message":
              this.emitReserved("data", packet.data);
              this.emitReserved("message", packet.data);
              break;
          }
        } else {
          debug50('packet received with socket readyState "%s"', this.readyState);
        }
      }
      onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.maxPayload = data.maxPayload;
        this.onOpen();
        if (this.readyState === "closed")
          return;
        this.resetPingTimeout();
      }
      resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.pingTimeoutTimer = this.setTimeoutFn(() => {
          this.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout);
        if (this.opts.autoUnref) {
          this.pingTimeoutTimer.unref();
        }
      }
      onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        this.prevBufferLen = 0;
        if (this.writeBuffer.length === 0) {
          this.emitReserved("drain");
        } else {
          this.flush();
        }
      }
      flush() {
        if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
          const packets = this.getWritablePackets();
          debug50("flushing %d packets in socket", packets.length);
          this.transport.send(packets);
          this.prevBufferLen = packets.length;
          this.emitReserved("flush");
        }
      }
      getWritablePackets() {
        const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
        if (!shouldCheckPayloadSize) {
          return this.writeBuffer;
        }
        let payloadSize = 1;
        for (let i = 0; i < this.writeBuffer.length; i++) {
          const data = this.writeBuffer[i].data;
          if (data) {
            payloadSize += (0, util_js_1.byteLength)(data);
          }
          if (i > 0 && payloadSize > this.maxPayload) {
            debug50("only send %d out of %d packets", i, this.writeBuffer.length);
            return this.writeBuffer.slice(0, i);
          }
          payloadSize += 2;
        }
        debug50("payload size is %d (max: %d)", payloadSize, this.maxPayload);
        return this.writeBuffer;
      }
      write(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }
      send(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }
      sendPacket(type, data, options, fn) {
        if (typeof data === "function") {
          fn = data;
          data = void 0;
        }
        if (typeof options === "function") {
          fn = options;
          options = null;
        }
        if (this.readyState === "closing" || this.readyState === "closed") {
          return;
        }
        options = options || {};
        options.compress = options.compress !== false;
        const packet = {
          type,
          data,
          options
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn)
          this.once("flush", fn);
        this.flush();
      }
      close() {
        const close = () => {
          this.onClose("forced close");
          debug50("socket closing - telling transport to close");
          this.transport.close();
        };
        const cleanupAndClose = () => {
          this.off("upgrade", cleanupAndClose);
          this.off("upgradeError", cleanupAndClose);
          close();
        };
        const waitForUpgrade = () => {
          this.once("upgrade", cleanupAndClose);
          this.once("upgradeError", cleanupAndClose);
        };
        if (this.readyState === "opening" || this.readyState === "open") {
          this.readyState = "closing";
          if (this.writeBuffer.length) {
            this.once("drain", () => {
              if (this.upgrading) {
                waitForUpgrade();
              } else {
                close();
              }
            });
          } else if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        }
        return this;
      }
      onError(err) {
        debug50("socket error %j", err);
        Socket.priorWebsocketSuccess = false;
        this.emitReserved("error", err);
        this.onClose("transport error", err);
      }
      onClose(reason, description) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
          debug50('socket close with reason: "%s"', reason);
          this.clearTimeoutFn(this.pingTimeoutTimer);
          this.transport.removeAllListeners("close");
          this.transport.close();
          this.transport.removeAllListeners();
          if (typeof removeEventListener === "function") {
            removeEventListener("offline", this.offlineEventListener, false);
          }
          this.readyState = "closed";
          this.id = null;
          this.emitReserved("close", reason, description);
          this.writeBuffer = [];
          this.prevBufferLen = 0;
        }
      }
      filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        let i = 0;
        const j = upgrades.length;
        for (; i < j; i++) {
          if (~this.transports.indexOf(upgrades[i]))
            filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
      }
    };
    exports2.Socket = Socket;
    Socket.protocol = engine_io_parser_1.protocol;
  }
});

// node_modules/engine.io-client/build/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/engine.io-client/build/cjs/index.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = exports2.installTimerFunctions = exports2.transports = exports2.Transport = exports2.protocol = exports2.Socket = void 0;
    var socket_js_1 = require_socket();
    Object.defineProperty(exports2, "Socket", { enumerable: true, get: function() {
      return socket_js_1.Socket;
    } });
    exports2.protocol = socket_js_1.Socket.protocol;
    var transport_js_1 = require_transport();
    Object.defineProperty(exports2, "Transport", { enumerable: true, get: function() {
      return transport_js_1.Transport;
    } });
    var index_js_1 = require_transports();
    Object.defineProperty(exports2, "transports", { enumerable: true, get: function() {
      return index_js_1.transports;
    } });
    var util_js_1 = require_util6();
    Object.defineProperty(exports2, "installTimerFunctions", { enumerable: true, get: function() {
      return util_js_1.installTimerFunctions;
    } });
    var parseuri_js_1 = require_parseuri();
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parseuri_js_1.parse;
    } });
  }
});

// node_modules/socket.io-client/build/cjs/url.js
var require_url = __commonJS({
  "node_modules/socket.io-client/build/cjs/url.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.url = void 0;
    var engine_io_client_1 = require_cjs2();
    var debug_1 = __importDefault(require_browser2());
    var debug50 = debug_1.default("socket.io-client:url");
    function url(uri, path = "", loc) {
      let obj = uri;
      loc = loc || typeof location !== "undefined" && location;
      if (uri == null)
        uri = loc.protocol + "//" + loc.host;
      if (typeof uri === "string") {
        if (uri.charAt(0) === "/") {
          if (uri.charAt(1) === "/") {
            uri = loc.protocol + uri;
          } else {
            uri = loc.host + uri;
          }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
          debug50("protocol-less url %s", uri);
          if (typeof loc !== "undefined") {
            uri = loc.protocol + "//" + uri;
          } else {
            uri = "https://" + uri;
          }
        }
        debug50("parse %s", uri);
        obj = engine_io_client_1.parse(uri);
      }
      if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
          obj.port = "80";
        } else if (/^(http|ws)s$/.test(obj.protocol)) {
          obj.port = "443";
        }
      }
      obj.path = obj.path || "/";
      const ipv6 = obj.host.indexOf(":") !== -1;
      const host = ipv6 ? "[" + obj.host + "]" : obj.host;
      obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
      obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
      return obj;
    }
    exports2.url = url;
  }
});

// node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/is-binary.js
var require_is_binary = __commonJS({
  "node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/is-binary.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasBinary = exports2.isBinary = void 0;
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var isView = (obj) => {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
    };
    var toString6 = Object.prototype.toString;
    var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString6.call(Blob) === "[object BlobConstructor]";
    var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString6.call(File) === "[object FileConstructor]";
    function isBinary3(obj) {
      return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
    }
    exports2.isBinary = isBinary3;
    function hasBinary(obj, toJSON) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
          if (hasBinary(obj[i])) {
            return true;
          }
        }
        return false;
      }
      if (isBinary3(obj)) {
        return true;
      }
      if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
      }
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
          return true;
        }
      }
      return false;
    }
    exports2.hasBinary = hasBinary;
  }
});

// node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/binary.js
var require_binary = __commonJS({
  "node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/binary.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reconstructPacket = exports2.deconstructPacket = void 0;
    var is_binary_js_1 = require_is_binary();
    function deconstructPacket(packet) {
      const buffers = [];
      const packetData = packet.data;
      const pack3 = packet;
      pack3.data = _deconstructPacket(packetData, buffers);
      pack3.attachments = buffers.length;
      return { packet: pack3, buffers };
    }
    exports2.deconstructPacket = deconstructPacket;
    function _deconstructPacket(data, buffers) {
      if (!data)
        return data;
      if (is_binary_js_1.isBinary(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
      } else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
          newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
      } else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
            newData[key] = _deconstructPacket(data[key], buffers);
          }
        }
        return newData;
      }
      return data;
    }
    function reconstructPacket(packet, buffers) {
      packet.data = _reconstructPacket(packet.data, buffers);
      packet.attachments = void 0;
      return packet;
    }
    exports2.reconstructPacket = reconstructPacket;
    function _reconstructPacket(data, buffers) {
      if (!data)
        return data;
      if (data && data._placeholder) {
        return buffers[data.num];
      } else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
          data[i] = _reconstructPacket(data[i], buffers);
        }
      } else if (typeof data === "object") {
        for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
            data[key] = _reconstructPacket(data[key], buffers);
          }
        }
      }
      return data;
    }
  }
});

// node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/socket.io-client/node_modules/socket.io-parser/build/cjs/index.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Decoder = exports2.Encoder = exports2.PacketType = exports2.protocol = void 0;
    var component_emitter_1 = require_component_emitter();
    var binary_js_1 = require_binary();
    var is_binary_js_1 = require_is_binary();
    var debug_1 = require_browser2();
    var debug50 = debug_1.default("socket.io-parser");
    exports2.protocol = 5;
    var PacketType;
    (function(PacketType2) {
      PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
      PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
      PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
      PacketType2[PacketType2["ACK"] = 3] = "ACK";
      PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
      PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
      PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
    })(PacketType = exports2.PacketType || (exports2.PacketType = {}));
    var Encoder3 = class {
      constructor(replacer) {
        this.replacer = replacer;
      }
      encode(obj) {
        debug50("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
          if (is_binary_js_1.hasBinary(obj)) {
            obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
            return this.encodeAsBinary(obj);
          }
        }
        return [this.encodeAsString(obj)];
      }
      encodeAsString(obj) {
        let str = "" + obj.type;
        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
          str += obj.attachments + "-";
        }
        if (obj.nsp && obj.nsp !== "/") {
          str += obj.nsp + ",";
        }
        if (obj.id != null) {
          str += obj.id;
        }
        if (obj.data != null) {
          str += JSON.stringify(obj.data, this.replacer);
        }
        debug50("encoded %j as %s", obj, str);
        return str;
      }
      encodeAsBinary(obj) {
        const deconstruction = binary_js_1.deconstructPacket(obj);
        const pack3 = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack3);
        return buffers;
      }
    };
    exports2.Encoder = Encoder3;
    var Decoder3 = class extends component_emitter_1.Emitter {
      constructor(reviver) {
        super();
        this.reviver = reviver;
      }
      add(obj) {
        let packet;
        if (typeof obj === "string") {
          packet = this.decodeString(obj);
          if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
            this.reconstructor = new BinaryReconstructor(packet);
            if (packet.attachments === 0) {
              super.emitReserved("decoded", packet);
            }
          } else {
            super.emitReserved("decoded", packet);
          }
        } else if (is_binary_js_1.isBinary(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error("got binary data when not reconstructing a packet");
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              this.reconstructor = null;
              super.emitReserved("decoded", packet);
            }
          }
        } else {
          throw new Error("Unknown type: " + obj);
        }
      }
      decodeString(str) {
        let i = 0;
        const p = {
          type: Number(str.charAt(0))
        };
        if (PacketType[p.type] === void 0) {
          throw new Error("unknown packet type " + p.type);
        }
        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
          const start = i + 1;
          while (str.charAt(++i) !== "-" && i != str.length) {
          }
          const buf3 = str.substring(start, i);
          if (buf3 != Number(buf3) || str.charAt(i) !== "-") {
            throw new Error("Illegal attachments");
          }
          p.attachments = Number(buf3);
        }
        if (str.charAt(i + 1) === "/") {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if (c === ",")
              break;
            if (i === str.length)
              break;
          }
          p.nsp = str.substring(start, i);
        } else {
          p.nsp = "/";
        }
        const next = str.charAt(i + 1);
        if (next !== "" && Number(next) == next) {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if (c == null || Number(c) != c) {
              --i;
              break;
            }
            if (i === str.length)
              break;
          }
          p.id = Number(str.substring(start, i + 1));
        }
        if (str.charAt(++i)) {
          const payload = this.tryParse(str.substr(i));
          if (Decoder3.isPayloadValid(p.type, payload)) {
            p.data = payload;
          } else {
            throw new Error("invalid payload");
          }
        }
        debug50("decoded %s as %j", str, p);
        return p;
      }
      tryParse(str) {
        try {
          return JSON.parse(str, this.reviver);
        } catch (e) {
          return false;
        }
      }
      static isPayloadValid(type, payload) {
        switch (type) {
          case PacketType.CONNECT:
            return typeof payload === "object";
          case PacketType.DISCONNECT:
            return payload === void 0;
          case PacketType.CONNECT_ERROR:
            return typeof payload === "string" || typeof payload === "object";
          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            return Array.isArray(payload) && payload.length > 0;
          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            return Array.isArray(payload);
        }
      }
      destroy() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
        }
      }
    };
    exports2.Decoder = Decoder3;
    var BinaryReconstructor = class {
      constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
      }
      takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
          const packet = binary_js_1.reconstructPacket(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      }
      finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
      }
    };
  }
});

// node_modules/socket.io-client/build/cjs/on.js
var require_on = __commonJS({
  "node_modules/socket.io-client/build/cjs/on.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.on = void 0;
    function on(obj, ev, fn) {
      obj.on(ev, fn);
      return function subDestroy() {
        obj.off(ev, fn);
      };
    }
    exports2.on = on;
  }
});

// node_modules/socket.io-client/build/cjs/socket.js
var require_socket2 = __commonJS({
  "node_modules/socket.io-client/build/cjs/socket.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Socket = void 0;
    var socket_io_parser_1 = require_cjs3();
    var on_js_1 = require_on();
    var component_emitter_1 = require_component_emitter();
    var debug_1 = __importDefault(require_browser2());
    var debug50 = debug_1.default("socket.io-client:socket");
    var RESERVED_EVENTS = Object.freeze({
      connect: 1,
      connect_error: 1,
      disconnect: 1,
      disconnecting: 1,
      newListener: 1,
      removeListener: 1
    });
    var Socket = class extends component_emitter_1.Emitter {
      constructor(io, nsp, opts) {
        super();
        this.connected = false;
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.ids = 0;
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
          this.auth = opts.auth;
        }
        if (this.io._autoConnect)
          this.open();
      }
      get disconnected() {
        return !this.connected;
      }
      subEvents() {
        if (this.subs)
          return;
        const io = this.io;
        this.subs = [
          on_js_1.on(io, "open", this.onopen.bind(this)),
          on_js_1.on(io, "packet", this.onpacket.bind(this)),
          on_js_1.on(io, "error", this.onerror.bind(this)),
          on_js_1.on(io, "close", this.onclose.bind(this))
        ];
      }
      get active() {
        return !!this.subs;
      }
      connect() {
        if (this.connected)
          return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
          this.io.open();
        if (this.io._readyState === "open")
          this.onopen();
        return this;
      }
      open() {
        return this.connect();
      }
      send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
      }
      emit(ev, ...args) {
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
          throw new Error('"' + ev + '" is a reserved event name');
        }
        args.unshift(ev);
        const packet = {
          type: socket_io_parser_1.PacketType.EVENT,
          data: args
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        if (typeof args[args.length - 1] === "function") {
          const id = this.ids++;
          debug50("emitting packet with ack id %d", id);
          const ack = args.pop();
          this._registerAckCallback(id, ack);
          packet.id = id;
        }
        const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
        if (discardPacket) {
          debug50("discard packet as the transport is not currently writable");
        } else if (this.connected) {
          this.notifyOutgoingListeners(packet);
          this.packet(packet);
        } else {
          this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
      }
      _registerAckCallback(id, ack) {
        const timeout = this.flags.timeout;
        if (timeout === void 0) {
          this.acks[id] = ack;
          return;
        }
        const timer = this.io.setTimeoutFn(() => {
          delete this.acks[id];
          for (let i = 0; i < this.sendBuffer.length; i++) {
            if (this.sendBuffer[i].id === id) {
              debug50("removing packet with ack id %d from the buffer", id);
              this.sendBuffer.splice(i, 1);
            }
          }
          debug50("event with ack id %d has timed out after %d ms", id, timeout);
          ack.call(this, new Error("operation has timed out"));
        }, timeout);
        this.acks[id] = (...args) => {
          this.io.clearTimeoutFn(timer);
          ack.apply(this, [null, ...args]);
        };
      }
      packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
      }
      onopen() {
        debug50("transport is open - connecting");
        if (typeof this.auth == "function") {
          this.auth((data) => {
            this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data });
          });
        } else {
          this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });
        }
      }
      onerror(err) {
        if (!this.connected) {
          this.emitReserved("connect_error", err);
        }
      }
      onclose(reason, description) {
        debug50("close (%s)", reason);
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
      }
      onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
          return;
        switch (packet.type) {
          case socket_io_parser_1.PacketType.CONNECT:
            if (packet.data && packet.data.sid) {
              const id = packet.data.sid;
              this.onconnect(id);
            } else {
              this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
            }
            break;
          case socket_io_parser_1.PacketType.EVENT:
          case socket_io_parser_1.PacketType.BINARY_EVENT:
            this.onevent(packet);
            break;
          case socket_io_parser_1.PacketType.ACK:
          case socket_io_parser_1.PacketType.BINARY_ACK:
            this.onack(packet);
            break;
          case socket_io_parser_1.PacketType.DISCONNECT:
            this.ondisconnect();
            break;
          case socket_io_parser_1.PacketType.CONNECT_ERROR:
            this.destroy();
            const err = new Error(packet.data.message);
            err.data = packet.data.data;
            this.emitReserved("connect_error", err);
            break;
        }
      }
      onevent(packet) {
        const args = packet.data || [];
        debug50("emitting event %j", args);
        if (packet.id != null) {
          debug50("attaching ack callback to event");
          args.push(this.ack(packet.id));
        }
        if (this.connected) {
          this.emitEvent(args);
        } else {
          this.receiveBuffer.push(Object.freeze(args));
        }
      }
      emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
          const listeners = this._anyListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, args);
          }
        }
        super.emit.apply(this, args);
      }
      ack(id) {
        const self2 = this;
        let sent = false;
        return function(...args) {
          if (sent)
            return;
          sent = true;
          debug50("sending ack %j", args);
          self2.packet({
            type: socket_io_parser_1.PacketType.ACK,
            id,
            data: args
          });
        };
      }
      onack(packet) {
        const ack = this.acks[packet.id];
        if (typeof ack === "function") {
          debug50("calling ack %s with %j", packet.id, packet.data);
          ack.apply(this, packet.data);
          delete this.acks[packet.id];
        } else {
          debug50("bad ack %s", packet.id);
        }
      }
      onconnect(id) {
        debug50("socket connected with id %s", id);
        this.id = id;
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
      }
      emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => {
          this.notifyOutgoingListeners(packet);
          this.packet(packet);
        });
        this.sendBuffer = [];
      }
      ondisconnect() {
        debug50("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
      }
      destroy() {
        if (this.subs) {
          this.subs.forEach((subDestroy) => subDestroy());
          this.subs = void 0;
        }
        this.io["_destroy"](this);
      }
      disconnect() {
        if (this.connected) {
          debug50("performing disconnect (%s)", this.nsp);
          this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
        }
        this.destroy();
        if (this.connected) {
          this.onclose("io client disconnect");
        }
        return this;
      }
      close() {
        return this.disconnect();
      }
      compress(compress) {
        this.flags.compress = compress;
        return this;
      }
      get volatile() {
        this.flags.volatile = true;
        return this;
      }
      timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
      }
      onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
      }
      prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
      }
      offAny(listener) {
        if (!this._anyListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyListeners;
          for (let i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyListeners = [];
        }
        return this;
      }
      listenersAny() {
        return this._anyListeners || [];
      }
      onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
      }
      prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
      }
      offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyOutgoingListeners;
          for (let i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyOutgoingListeners = [];
        }
        return this;
      }
      listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
      }
      notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
          const listeners = this._anyOutgoingListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, packet.data);
          }
        }
      }
    };
    exports2.Socket = Socket;
  }
});

// node_modules/socket.io-client/build/cjs/contrib/backo2.js
var require_backo2 = __commonJS({
  "node_modules/socket.io-client/build/cjs/contrib/backo2.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Backoff = void 0;
    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 1e4;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }
    exports2.Backoff = Backoff;
    Backoff.prototype.duration = function() {
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };
    Backoff.prototype.reset = function() {
      this.attempts = 0;
    };
    Backoff.prototype.setMin = function(min) {
      this.ms = min;
    };
    Backoff.prototype.setMax = function(max) {
      this.max = max;
    };
    Backoff.prototype.setJitter = function(jitter) {
      this.jitter = jitter;
    };
  }
});

// node_modules/socket.io-client/build/cjs/manager.js
var require_manager = __commonJS({
  "node_modules/socket.io-client/build/cjs/manager.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Manager = void 0;
    var engine_io_client_1 = require_cjs2();
    var socket_js_1 = require_socket2();
    var parser = __importStar(require_cjs3());
    var on_js_1 = require_on();
    var backo2_js_1 = require_backo2();
    var component_emitter_1 = require_component_emitter();
    var debug_1 = __importDefault(require_browser2());
    var debug50 = debug_1.default("socket.io-client:manager");
    var Manager = class extends component_emitter_1.Emitter {
      constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && typeof uri === "object") {
          opts = uri;
          uri = void 0;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        engine_io_client_1.installTimerFunctions(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1e3);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new backo2_js_1.Backoff({
          min: this.reconnectionDelay(),
          max: this.reconnectionDelayMax(),
          jitter: this.randomizationFactor()
        });
        this.timeout(opts.timeout == null ? 2e4 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || parser;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
          this.open();
      }
      reconnection(v) {
        if (!arguments.length)
          return this._reconnection;
        this._reconnection = !!v;
        return this;
      }
      reconnectionAttempts(v) {
        if (v === void 0)
          return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
      }
      reconnectionDelay(v) {
        var _a;
        if (v === void 0)
          return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
      }
      randomizationFactor(v) {
        var _a;
        if (v === void 0)
          return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
      }
      reconnectionDelayMax(v) {
        var _a;
        if (v === void 0)
          return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
      }
      timeout(v) {
        if (!arguments.length)
          return this._timeout;
        this._timeout = v;
        return this;
      }
      maybeReconnectOnOpen() {
        if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
          this.reconnect();
        }
      }
      open(fn) {
        debug50("readyState %s", this._readyState);
        if (~this._readyState.indexOf("open"))
          return this;
        debug50("opening %s", this.uri);
        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
        const socket = this.engine;
        const self2 = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        const openSubDestroy = on_js_1.on(socket, "open", function() {
          self2.onopen();
          fn && fn();
        });
        const errorSub = on_js_1.on(socket, "error", (err) => {
          debug50("error");
          self2.cleanup();
          self2._readyState = "closed";
          this.emitReserved("error", err);
          if (fn) {
            fn(err);
          } else {
            self2.maybeReconnectOnOpen();
          }
        });
        if (this._timeout !== false) {
          const timeout = this._timeout;
          debug50("connect attempt will timeout after %d", timeout);
          if (timeout === 0) {
            openSubDestroy();
          }
          const timer = this.setTimeoutFn(() => {
            debug50("connect attempt timed out after %d", timeout);
            openSubDestroy();
            socket.close();
            socket.emit("error", new Error("timeout"));
          }, timeout);
          if (this.opts.autoUnref) {
            timer.unref();
          }
          this.subs.push(function subDestroy() {
            clearTimeout(timer);
          });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
      }
      connect(fn) {
        return this.open(fn);
      }
      onopen() {
        debug50("open");
        this.cleanup();
        this._readyState = "open";
        this.emitReserved("open");
        const socket = this.engine;
        this.subs.push(on_js_1.on(socket, "ping", this.onping.bind(this)), on_js_1.on(socket, "data", this.ondata.bind(this)), on_js_1.on(socket, "error", this.onerror.bind(this)), on_js_1.on(socket, "close", this.onclose.bind(this)), on_js_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
      }
      onping() {
        this.emitReserved("ping");
      }
      ondata(data) {
        this.decoder.add(data);
      }
      ondecoded(packet) {
        this.emitReserved("packet", packet);
      }
      onerror(err) {
        debug50("error", err);
        this.emitReserved("error", err);
      }
      socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
          socket = new socket_js_1.Socket(this, nsp, opts);
          this.nsps[nsp] = socket;
        }
        return socket;
      }
      _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
          const socket2 = this.nsps[nsp];
          if (socket2.active) {
            debug50("socket %s is still active, skipping close", nsp);
            return;
          }
        }
        this._close();
      }
      _packet(packet) {
        debug50("writing packet %j", packet);
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
          this.engine.write(encodedPackets[i], packet.options);
        }
      }
      cleanup() {
        debug50("cleanup");
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
      }
      _close() {
        debug50("disconnect");
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
        if (this.engine)
          this.engine.close();
      }
      disconnect() {
        return this._close();
      }
      onclose(reason, description) {
        debug50("closed due to %s", reason);
        this.cleanup();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
          this.reconnect();
        }
      }
      reconnect() {
        if (this._reconnecting || this.skipReconnect)
          return this;
        const self2 = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
          debug50("reconnect failed");
          this.backoff.reset();
          this.emitReserved("reconnect_failed");
          this._reconnecting = false;
        } else {
          const delay = this.backoff.duration();
          debug50("will wait %dms before reconnect attempt", delay);
          this._reconnecting = true;
          const timer = this.setTimeoutFn(() => {
            if (self2.skipReconnect)
              return;
            debug50("attempting reconnect");
            this.emitReserved("reconnect_attempt", self2.backoff.attempts);
            if (self2.skipReconnect)
              return;
            self2.open((err) => {
              if (err) {
                debug50("reconnect attempt error");
                self2._reconnecting = false;
                self2.reconnect();
                this.emitReserved("reconnect_error", err);
              } else {
                debug50("reconnect success");
                self2.onreconnect();
              }
            });
          }, delay);
          if (this.opts.autoUnref) {
            timer.unref();
          }
          this.subs.push(function subDestroy() {
            clearTimeout(timer);
          });
        }
      }
      onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
      }
    };
    exports2.Manager = Manager;
  }
});

// node_modules/socket.io-client/build/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/socket.io-client/build/cjs/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2.connect = exports2.io = exports2.Socket = exports2.Manager = exports2.protocol = void 0;
    var url_js_1 = require_url();
    var manager_js_1 = require_manager();
    Object.defineProperty(exports2, "Manager", { enumerable: true, get: function() {
      return manager_js_1.Manager;
    } });
    var socket_js_1 = require_socket2();
    Object.defineProperty(exports2, "Socket", { enumerable: true, get: function() {
      return socket_js_1.Socket;
    } });
    var debug_1 = __importDefault(require_browser2());
    var debug50 = debug_1.default("socket.io-client");
    var cache2 = {};
    function lookup(uri, opts) {
      if (typeof uri === "object") {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      const parsed = url_js_1.url(uri, opts.path || "/socket.io");
      const source = parsed.source;
      const id = parsed.id;
      const path = parsed.path;
      const sameNamespace = cache2[id] && path in cache2[id]["nsps"];
      const newConnection = opts.forceNew || opts["force new connection"] || opts.multiplex === false || sameNamespace;
      let io;
      if (newConnection) {
        debug50("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
      } else {
        if (!cache2[id]) {
          debug50("new io instance for %s", source);
          cache2[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache2[id];
      }
      if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
      }
      return io.socket(parsed.path, opts);
    }
    exports2.io = lookup;
    exports2.connect = lookup;
    exports2.default = lookup;
    Object.assign(lookup, {
      Manager: manager_js_1.Manager,
      Socket: socket_js_1.Socket,
      io: lookup,
      connect: lookup
    });
    var socket_io_parser_1 = require_cjs3();
    Object.defineProperty(exports2, "protocol", { enumerable: true, get: function() {
      return socket_io_parser_1.protocol;
    } });
    module2.exports = lookup;
  }
});

// node_modules/stream-to-it/sink.js
var require_sink2 = __commonJS({
  "node_modules/stream-to-it/sink.js"(exports2, module2) {
    init_globals();
    var getIterator = require_get_iterator();
    module2.exports = (writable) => async (source) => {
      source = getIterator(source);
      const maybeEndSource = (source2) => {
        if (typeof source2.return === "function")
          source2.return();
      };
      let error = null;
      let errCb = null;
      const errorHandler2 = (err) => {
        error = err;
        if (errCb)
          errCb(err);
        maybeEndSource(source);
      };
      let closeCb = null;
      let closed = false;
      const closeHandler = () => {
        closed = true;
        if (closeCb)
          closeCb();
      };
      let finishCb = null;
      let finished = false;
      const finishHandler = () => {
        finished = true;
        if (finishCb)
          finishCb();
      };
      let drainCb = null;
      const drainHandler = () => {
        if (drainCb)
          drainCb();
      };
      const waitForDrainOrClose = () => {
        return new Promise((resolve11, reject) => {
          closeCb = drainCb = resolve11;
          errCb = reject;
          writable.once("drain", drainHandler);
        });
      };
      const waitForDone = () => {
        maybeEndSource(source);
        return new Promise((resolve11, reject) => {
          if (closed || finished || error)
            return resolve11();
          finishCb = closeCb = resolve11;
          errCb = reject;
        });
      };
      const cleanup = () => {
        writable.removeListener("error", errorHandler2);
        writable.removeListener("close", closeHandler);
        writable.removeListener("finish", finishHandler);
        writable.removeListener("drain", drainHandler);
      };
      writable.once("error", errorHandler2);
      writable.once("close", closeHandler);
      writable.once("finish", finishHandler);
      try {
        for await (const value of source) {
          if (!writable.writable || writable.destroyed || error)
            break;
          if (writable.write(value) === false) {
            await waitForDrainOrClose();
          }
        }
      } catch (err) {
        if (!error) {
          writable.destroy();
        }
        error = err;
      }
      try {
        if (writable.writable) {
          writable.end();
        }
        await waitForDone();
        if (error)
          throw error;
      } finally {
        cleanup();
      }
    };
  }
});

// node_modules/stream-to-it/duplex.js
var require_duplex2 = __commonJS({
  "node_modules/stream-to-it/duplex.js"(exports2, module2) {
    init_globals();
    var toSink = require_sink2();
    var toSource = require_source();
    module2.exports = (duplex) => ({ sink: toSink(duplex), source: toSource(duplex) });
  }
});

// node_modules/stream-to-it/transform.js
var require_transform = __commonJS({
  "node_modules/stream-to-it/transform.js"(exports2, module2) {
    init_globals();
    var toDuplex = require_duplex2();
    module2.exports = (transform) => async function* (source) {
      const duplex = toDuplex(transform);
      let sinkError;
      duplex.sink(source).catch((err) => {
        sinkError = err;
      });
      yield* duplex.source;
      if (sinkError)
        throw sinkError;
    };
  }
});

// node_modules/stream-to-it/index.js
var require_stream_to_it = __commonJS({
  "node_modules/stream-to-it/index.js"(exports2, module2) {
    init_globals();
    module2.exports = require_source();
    module2.exports.source = require_source();
    module2.exports.sink = require_sink2();
    module2.exports.transform = require_transform();
    module2.exports.duplex = require_duplex2();
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-webrtc-star/src/socket-to-conn.js
var require_socket_to_conn2 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-webrtc-star/src/socket-to-conn.js"(exports2, module2) {
    "use strict";
    init_globals();
    var abortable = require_abortable_iterator();
    var toIterable2 = require_stream_to_it();
    var { CLOSE_TIMEOUT } = require_constants8();
    var toMultiaddr = require_ip_port_to_multiaddr();
    var debug50 = require_browser2();
    var log48 = debug50("libp2p:webrtc-star:socket");
    log48.error = debug50("libp2p:webrtc-star:socket:error");
    var toWebrtcMultiaddr = (address, port) => {
      if (!address || !port)
        return void 0;
      try {
        return toMultiaddr(address, port);
      } catch (err) {
        log48.error(err);
        return toMultiaddr("0.0.0.0", port);
      }
    };
    module2.exports = (socket, options = {}) => {
      const { sink, source } = toIterable2.duplex(socket);
      const remoteAddr = options.remoteAddr || toWebrtcMultiaddr(socket.remoteAddress, socket.remotePort);
      const localAddr = toWebrtcMultiaddr(socket.localAddress, socket.localPort);
      const maConn = {
        async sink(source2) {
          if (options.signal) {
            source2 = abortable(source2, options.signal);
          }
          try {
            await sink(async function* () {
              for await (const chunk of source2) {
                yield chunk instanceof Uint8Array ? chunk : chunk.slice();
              }
            }());
          } catch (err) {
            if (err.type !== "aborted") {
              log48.error(err);
            }
          }
        },
        source: options.signal ? abortable(source, options.signal) : source,
        conn: socket,
        localAddr,
        remoteAddr,
        timeline: { open: Date.now() },
        close() {
          if (socket.destroyed)
            return;
          return new Promise((resolve11, reject) => {
            const start = Date.now();
            const timeout = setTimeout(() => {
              if (maConn.remoteAddr) {
                const { host, port } = maConn.remoteAddr.toOptions();
                log48("timeout closing socket to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
              }
              if (!socket.destroyed) {
                socket.destroy();
              }
            }, CLOSE_TIMEOUT);
            socket.once("close", () => {
              resolve11();
            });
            socket.end((err) => {
              clearTimeout(timeout);
              maConn.timeline.close = Date.now();
              if (err)
                return reject(err);
            });
          });
        }
      };
      socket.once("close", () => {
        if (!maConn.timeline.close) {
          maConn.timeline.close = Date.now();
        }
      });
      return maConn;
    };
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-webrtc-star/src/utils.js
var require_utils5 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-webrtc-star/src/utils.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Multiaddr: Multiaddr22 } = require_src();
    function cleanUrlSIO(ma) {
      const maStrSplit = ma.toString().split("/");
      const tcpProto = ma.protos()[1].name;
      const wsProto = ma.protos()[2].name;
      const tcpPort = ma.stringTuples()[1][1];
      if (tcpProto !== "tcp" || wsProto !== "ws" && wsProto !== "wss") {
        throw new Error("invalid multiaddr: " + ma.toString());
      }
      if (!Multiaddr22.isName(ma)) {
        return "http://" + maStrSplit[2] + ":" + maStrSplit[4];
      }
      if (wsProto === "ws") {
        return "http://" + maStrSplit[2] + (tcpPort === "80" ? "" : ":" + tcpPort);
      }
      if (wsProto === "wss") {
        return "https://" + maStrSplit[2] + (tcpPort === "443" ? "" : ":" + tcpPort);
      }
    }
    function cleanMultiaddr(maStr) {
      const legacy = "/libp2p-webrtc-star";
      if (maStr.indexOf(legacy) !== -1) {
        maStr = maStr.substring(legacy.length, maStr.length);
        let ma = new Multiaddr22(maStr);
        const tuppleIPFS = ma.stringTuples().filter((tupple) => {
          return tupple[0] === 421;
        })[0];
        ma = ma.decapsulate("p2p");
        ma = ma.encapsulate("/p2p-webrtc-star");
        ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`);
        maStr = ma.toString();
      }
      return maStr;
    }
    module2.exports = {
      cleanUrlSIO,
      cleanMultiaddr
    };
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-webrtc-star/src/listener.js
var require_listener = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-webrtc-star/src/listener.js"(exports2, module2) {
    "use strict";
    init_globals();
    var EventEmitter4 = require_events();
    var debug50 = require_browser2();
    var log48 = debug50("libp2p:webrtc-star:listener");
    log48.error = debug50("libp2p:webrtc-star:listener:error");
    var errCode69 = require_err_code();
    var io = require_cjs4();
    var SimplePeer = require_libp2p_webrtc_peer();
    var pDefer = require_p_defer();
    var toConnection = require_socket_to_conn2();
    var { cleanUrlSIO } = require_utils5();
    var { CODE_P2P } = require_constants8();
    var sioOptions = {
      transports: ["websocket"],
      "force new connection": true,
      path: "/socket.io-next/"
    };
    module2.exports = ({ handler, upgrader }, WebRTCStar2, options = {}) => {
      const listener = new EventEmitter4();
      let listeningAddr;
      let signallingUrl;
      listener.__connections = [];
      listener.__spChannels = /* @__PURE__ */ new Map();
      listener.__pendingIntents = /* @__PURE__ */ new Map();
      listener.listen = (ma) => {
        if (listeningAddr) {
          throw errCode69(new Error("listener already in use"), "ERR_ALREADY_LISTENING");
        }
        const defer = pDefer();
        listeningAddr = ma;
        let signallingAddr;
        if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {
          signallingAddr = ma.encapsulate(`/p2p/${upgrader.localPeer.toB58String()}`);
        } else {
          signallingAddr = ma;
        }
        listener.on("error", () => defer.reject());
        signallingUrl = cleanUrlSIO(ma);
        log48("Dialing to Signalling Server on: " + signallingUrl);
        listener.io = io.connect(signallingUrl, sioOptions);
        const incomingDial = (offer) => {
          if (offer.answer || offer.err || !offer.intentId) {
            return;
          }
          const intentId = offer.intentId;
          let pendings = listener.__pendingIntents.get(intentId);
          if (!pendings) {
            pendings = [];
            listener.__pendingIntents.set(intentId, pendings);
          }
          let channel = listener.__spChannels.get(intentId);
          if (channel) {
            channel.signal(offer.signal);
            return;
          } else if (offer.signal.type !== "offer") {
            pendings.push(offer);
            return;
          }
          const spOptions = {
            trickle: false,
            ...options
          };
          if (WebRTCStar2.wrtc) {
            spOptions.wrtc = WebRTCStar2.wrtc;
          }
          channel = new SimplePeer(spOptions);
          const onError = (err) => {
            log48.error("incoming connection errored", err);
          };
          channel.on("error", onError);
          channel.once("close", (...args) => {
            channel.removeListener("error", onError);
          });
          channel.on("signal", (signal) => {
            offer.signal = signal;
            offer.answer = true;
            listener.io.emit("ss-handshake", offer);
          });
          channel.signal(offer.signal);
          for (const pendingOffer of pendings) {
            channel.signal(pendingOffer.signal);
          }
          listener.__pendingIntents.set(intentId, []);
          channel.once("connect", async () => {
            const maConn = toConnection(channel);
            log48("new inbound connection %s", maConn.remoteAddr);
            let conn;
            try {
              conn = await upgrader.upgradeInbound(maConn);
            } catch (err) {
              log48.error("inbound connection failed to upgrade", err);
              return maConn.close();
            }
            if (!conn.remoteAddr) {
              try {
                conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toB58String()}`);
              } catch (err) {
                log48.error("could not determine remote address", err);
              }
            }
            log48("inbound connection %s upgraded", maConn.remoteAddr);
            trackConn(listener, maConn, intentId);
            listener.emit("connection", conn);
            handler(conn);
          });
          listener.__spChannels.set(intentId, channel);
        };
        listener.io.once("connect_error", (err) => defer.reject(err));
        listener.io.once("error", (err) => {
          listener.emit("error", err);
          listener.emit("close");
        });
        listener.io.on("ws-handshake", incomingDial);
        listener.io.on("ws-peer", WebRTCStar2._peerDiscovered);
        listener.io.on("connect", () => {
          listener.io.emit("ss-join", signallingAddr.toString());
        });
        listener.io.once("connect", () => {
          listener.emit("listening");
          defer.resolve();
        });
        WebRTCStar2.sigReferences.set(signallingUrl, {
          listener,
          signallingAddr
        });
        return defer.promise;
      };
      listener.close = async () => {
        const ref = WebRTCStar2.sigReferences.get(signallingUrl);
        if (ref && ref.listener.io) {
          ref.listener.io.emit("ss-leave");
          ref.listener.io.close();
        }
        await Promise.all(listener.__connections.map((maConn) => maConn.close()));
        listener.emit("close");
        listener.removeAllListeners();
        listeningAddr = void 0;
        WebRTCStar2.sigReferences.delete(signallingUrl);
      };
      listener.getAddrs = () => {
        return [listeningAddr];
      };
      return listener;
    };
    function trackConn(listener, maConn, intentId) {
      listener.__connections.push(maConn);
      const untrackConn = () => {
        listener.__connections = listener.__connections.filter((c) => c !== maConn);
        listener.__spChannels.delete(intentId);
        listener.__pendingIntents.delete(intentId);
      };
      maConn.conn.once("close", untrackConn);
    }
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-webrtc-star/src/index.js
var require_src16 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-webrtc-star/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = debug50("libp2p:webrtc-star");
    log48.error = debug50("libp2p:webrtc-star:error");
    var { EventEmitter: EventEmitter4 } = require_events();
    var errcode17 = require_err_code();
    var withIs = require_class_is();
    var { AbortError } = require_abortable_iterator();
    var SimplePeer = require_libp2p_webrtc_peer();
    var { supportsWebRTCDataChannels: webrtcSupport } = require_supports();
    var { Multiaddr: Multiaddr22 } = require_src();
    var mafmt2 = require_src2();
    var PeerId14 = require_src5();
    var { CODE_CIRCUIT } = require_constants8();
    var createListener = require_listener();
    var toConnection = require_socket_to_conn2();
    var { cleanMultiaddr, cleanUrlSIO } = require_utils5();
    function noop2() {
    }
    var WebRTCStar2 = class {
      constructor(options = {}) {
        if (!options.upgrader) {
          throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");
        }
        this._upgrader = options.upgrader;
        this.sioOptions = {
          transports: ["websocket"],
          "force new connection": true
        };
        if (options.wrtc) {
          this.wrtc = options.wrtc;
        }
        this.sigReferences = /* @__PURE__ */ new Map();
        this.discovery = new EventEmitter4();
        this.discovery.tag = "webRTCStar";
        this.discovery._isStarted = false;
        this.discovery.start = () => {
          this.discovery._isStarted = true;
        };
        this.discovery.stop = () => {
          this.discovery._isStarted = false;
        };
        this._peerDiscovered = this._peerDiscovered.bind(this);
      }
      async dial(ma, options = {}) {
        const rawConn = await this._connect(ma, options);
        const maConn = toConnection(rawConn, { remoteAddr: ma, signal: options.signal });
        log48("new outbound connection %s", maConn.remoteAddr);
        const conn = await this._upgrader.upgradeOutbound(maConn);
        log48("outbound connection %s upgraded", maConn.remoteAddr);
        return conn;
      }
      _connect(ma, options = {}) {
        if (options.signal && options.signal.aborted) {
          throw new AbortError();
        }
        const spOptions = {
          initiator: true,
          trickle: false,
          ...options.spOptions || {}
        };
        if (this.wrtc) {
          spOptions.wrtc = this.wrtc;
        }
        const cOpts = ma.toOptions();
        const intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now();
        return new Promise((resolve11, reject) => {
          const sio = this.sigReferences.get(cleanUrlSIO(ma));
          if (!sio || !sio.listener) {
            return reject(errcode17(new Error("unknown signal server to use"), "ERR_UNKNOWN_SIGNAL_SERVER"));
          }
          const sioClient = sio.listener.io;
          const start = Date.now();
          let connected;
          log48("dialing %s:%s", cOpts.host, cOpts.port);
          const channel = new SimplePeer(spOptions);
          const onError = (err) => {
            if (!connected) {
              const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err.message}`;
              log48.error(msg);
              done(err);
            }
          };
          const onTimeout = () => {
            log48("connnection timeout %s:%s", cOpts.host, cOpts.port);
            const err = errcode17(new Error(`connection timeout after ${Date.now() - start}ms`), "ERR_CONNECT_TIMEOUT");
            channel.emit("error", err);
          };
          const onConnect = () => {
            connected = true;
            log48("connection opened %s:%s", cOpts.host, cOpts.port);
            done(null);
          };
          const onAbort = () => {
            log48.error("connection aborted %s:%s", cOpts.host, cOpts.port);
            channel.destroy();
            done(new AbortError());
          };
          const done = (err) => {
            channel.removeListener("timeout", onTimeout);
            channel.removeListener("connect", onConnect);
            options.signal && options.signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve11(channel);
          };
          channel.on("error", onError);
          channel.once("timeout", onTimeout);
          channel.once("connect", onConnect);
          channel.on("close", () => {
            channel.removeListener("error", onError);
          });
          options.signal && options.signal.addEventListener("abort", onAbort);
          channel.on("signal", (signal) => {
            sioClient.emit("ss-handshake", {
              intentId,
              srcMultiaddr: sio.signallingAddr.toString(),
              dstMultiaddr: ma.toString(),
              signal
            });
          });
          sioClient.on("ws-handshake", (offer) => {
            if (offer.intentId === intentId && offer.err) {
              channel.destroy();
              reject(errcode17(offer.err instanceof Error ? offer.err : new Error(offer.err), "ERR_SIGNALLING_FAILED"));
            }
            if (offer.intentId !== intentId || !offer.answer || channel.destroyed) {
              return;
            }
            channel.signal(offer.signal);
          });
        });
      }
      createListener(options = {}, handler) {
        if (!webrtcSupport && !this.wrtc) {
          throw errcode17(new Error("no WebRTC support"), "ERR_NO_WEBRTC_SUPPORT");
        }
        if (typeof options === "function") {
          handler = options;
          options = {};
        }
        handler = handler || noop2;
        return createListener({ handler, upgrader: this._upgrader }, this, options);
      }
      filter(multiaddrs) {
        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
        return multiaddrs.filter((ma) => {
          if (ma.protoCodes().includes(CODE_CIRCUIT)) {
            return false;
          }
          return mafmt2.WebRTCStar.matches(ma);
        });
      }
      _peerDiscovered(maStr) {
        if (!this.discovery._isStarted)
          return;
        log48("Peer Discovered:", maStr);
        maStr = cleanMultiaddr(maStr);
        const ma = new Multiaddr22(maStr);
        const peerId = PeerId14.createFromB58String(ma.getPeerId());
        this.discovery.emit("peer", {
          id: peerId,
          multiaddrs: [ma]
        });
      }
    };
    module2.exports = withIs(WebRTCStar2, { className: "WebRTCStar", symbolName: "@libp2p/js-libp2p-webrtc-star/webrtcstar" });
  }
});

// node_modules/libp2p-mplex/src/coder/encode.browser.js
var require_encode_browser = __commonJS({
  "node_modules/libp2p-mplex/src/coder/encode.browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    var varint7 = require_varint();
    var BufferList3 = require_BufferList();
    var POOL_SIZE = 10 * 1024;
    var Encoder3 = class {
      constructor() {
        this._pool = new Uint8Array(POOL_SIZE);
        this._poolOffset = 0;
      }
      write(msg) {
        const pool = this._pool;
        let offset = this._poolOffset;
        varint7.encode(msg.id << 3 | msg.type, pool, offset);
        offset += varint7.encode.bytes;
        varint7.encode(msg.data ? msg.data.length : 0, pool, offset);
        offset += varint7.encode.bytes;
        const header = pool.subarray(this._poolOffset, offset);
        if (POOL_SIZE - offset < 100) {
          this._pool = new Uint8Array(POOL_SIZE);
          this._poolOffset = 0;
        } else {
          this._poolOffset = offset;
        }
        if (!msg.data)
          return header;
        return [header, msg.data];
      }
    };
    var encoder = new Encoder3();
    module2.exports = (source) => async function* encode19() {
      for await (const msg of source) {
        if (Array.isArray(msg)) {
          yield new BufferList3(msg.map((m) => encoder.write(m)));
        } else {
          yield new BufferList3(encoder.write(msg));
        }
      }
    }();
  }
});

// node_modules/libp2p-mplex/src/coder/decode.js
var require_decode3 = __commonJS({
  "node_modules/libp2p-mplex/src/coder/decode.js"(exports2, module2) {
    "use strict";
    init_globals();
    var varint7 = require_varint();
    var BufferList3 = require_BufferList();
    module2.exports = (source) => async function* decode22() {
      const decoder = new Decoder3();
      for await (const chunk of source) {
        const msgs = decoder.write(chunk);
        if (msgs.length)
          yield msgs;
      }
    }();
    var Decoder3 = class {
      constructor() {
        this._buffer = new BufferList3();
        this._bufferProxy = new Proxy({}, {
          get: (_, prop) => prop[0] === "l" ? this._buffer[prop] : this._buffer.get(parseInt(prop))
        });
        this._headerInfo = null;
      }
      write(chunk) {
        if (!chunk || !chunk.length)
          return [];
        this._buffer.append(chunk);
        const msgs = [];
        while (this._buffer.length) {
          if (!this._headerInfo) {
            try {
              this._headerInfo = this._decodeHeader(this._bufferProxy);
            } catch (_) {
              break;
            }
          }
          const { id, type, length: length5, offset } = this._headerInfo;
          const bufferedDataLength = this._buffer.length - offset;
          if (bufferedDataLength < length5)
            break;
          msgs.push({ id, type, data: this._buffer.shallowSlice(offset, offset + length5) });
          this._buffer.consume(offset + length5);
          this._headerInfo = null;
        }
        return msgs;
      }
      _decodeHeader(data) {
        const h = varint7.decode(data);
        let offset = varint7.decode.bytes;
        const length5 = varint7.decode(data, offset);
        offset += varint7.decode.bytes;
        return { id: h >> 3, type: h & 7, offset, length: length5 };
      }
    };
  }
});

// node_modules/libp2p-mplex/src/coder/index.js
var require_coder = __commonJS({
  "node_modules/libp2p-mplex/src/coder/index.js"(exports2) {
    "use strict";
    init_globals();
    exports2.encode = require_encode_browser();
    exports2.decode = require_decode3();
  }
});

// node_modules/libp2p-mplex/src/restrict-size.js
var require_restrict_size = __commonJS({
  "node_modules/libp2p-mplex/src/restrict-size.js"(exports2, module2) {
    "use strict";
    init_globals();
    var MAX_MSG_SIZE = 1 << 20;
    module2.exports = (max) => {
      max = max || MAX_MSG_SIZE;
      const checkSize = (msg) => {
        if (msg.data && msg.data.length > max) {
          throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
        }
      };
      return (source) => {
        return async function* restrictSize() {
          for await (const msg of source) {
            if (Array.isArray(msg)) {
              msg.forEach(checkSize);
            } else {
              checkSize(msg);
            }
            yield msg;
          }
        }();
      };
    };
    module2.exports.MAX_MSG_SIZE = MAX_MSG_SIZE;
  }
});

// node_modules/libp2p-mplex/src/message-types.js
var require_message_types = __commonJS({
  "node_modules/libp2p-mplex/src/message-types.js"(exports2) {
    "use strict";
    init_globals();
    var MessageTypes = Object.freeze({
      NEW_STREAM: 0,
      MESSAGE_RECEIVER: 1,
      MESSAGE_INITIATOR: 2,
      CLOSE_RECEIVER: 3,
      CLOSE_INITIATOR: 4,
      RESET_RECEIVER: 5,
      RESET_INITIATOR: 6
    });
    exports2.MessageTypes = MessageTypes;
    exports2.InitiatorMessageTypes = Object.freeze({
      NEW_STREAM: MessageTypes.NEW_STREAM,
      MESSAGE: MessageTypes.MESSAGE_INITIATOR,
      CLOSE: MessageTypes.CLOSE_INITIATOR,
      RESET: MessageTypes.RESET_INITIATOR
    });
    exports2.ReceiverMessageTypes = Object.freeze({
      MESSAGE: MessageTypes.MESSAGE_RECEIVER,
      CLOSE: MessageTypes.CLOSE_RECEIVER,
      RESET: MessageTypes.RESET_RECEIVER
    });
    exports2.MessageTypeNames = Object.freeze(Object.entries(MessageTypes).reduce((obj, e) => {
      obj[e[1]] = e[0];
      return obj;
    }, {}));
  }
});

// node_modules/libp2p-mplex/src/stream.js
var require_stream = __commonJS({
  "node_modules/libp2p-mplex/src/stream.js"(exports2, module2) {
    "use strict";
    init_globals();
    var abortable = require_abortable_iterator();
    var log48 = require_browser2()("libp2p:mplex:stream");
    var pushable5 = require_it_pushable();
    var BufferList3 = require_BufferList();
    var errCode69 = require_err_code();
    var { MAX_MSG_SIZE } = require_restrict_size();
    var { InitiatorMessageTypes, ReceiverMessageTypes } = require_message_types();
    var ERR_MPLEX_STREAM_RESET = "ERR_MPLEX_STREAM_RESET";
    var ERR_MPLEX_STREAM_ABORT = "ERR_MPLEX_STREAM_ABORT";
    module2.exports = ({ id, name: name10, send, onEnd = () => {
    }, type = "initiator", maxMsgSize = MAX_MSG_SIZE }) => {
      const abortController = new AbortController();
      const resetController = new AbortController();
      const Types2 = type === "initiator" ? InitiatorMessageTypes : ReceiverMessageTypes;
      const externalId = type === "initiator" ? `i${id}` : `r${id}`;
      name10 = String(name10 == null ? id : name10);
      let sourceEnded = false;
      let sinkEnded = false;
      let endErr;
      const onSourceEnd = (err) => {
        if (sourceEnded)
          return;
        sourceEnded = true;
        log48("%s stream %s source end", type, name10, err);
        if (err && !endErr)
          endErr = err;
        if (sinkEnded) {
          stream.timeline.close = Date.now();
          onEnd(endErr);
        }
      };
      const onSinkEnd = (err) => {
        if (sinkEnded)
          return;
        sinkEnded = true;
        log48("%s stream %s sink end", type, name10, err);
        if (err && !endErr)
          endErr = err;
        if (sourceEnded) {
          stream.timeline.close = Date.now();
          onEnd(endErr);
        }
      };
      const stream = {
        close: () => stream.source.end(),
        abort: (err) => {
          log48("%s stream %s abort", type, name10, err);
          stream.source.end(err);
          abortController.abort();
          onSinkEnd(err);
        },
        reset: () => {
          const err = errCode69(new Error("stream reset"), ERR_MPLEX_STREAM_RESET);
          resetController.abort();
          stream.source.end(err);
          onSinkEnd(err);
        },
        sink: async (source) => {
          source = abortable(source, [
            { signal: abortController.signal, options: { abortMessage: "stream aborted", abortCode: ERR_MPLEX_STREAM_ABORT } },
            { signal: resetController.signal, options: { abortMessage: "stream reset", abortCode: ERR_MPLEX_STREAM_RESET } }
          ]);
          if (type === "initiator") {
            send({ id, type: Types2.NEW_STREAM, data: name10 });
          }
          try {
            for await (let data of source) {
              while (data.length) {
                if (data.length <= maxMsgSize) {
                  send({ id, type: Types2.MESSAGE, data });
                  break;
                }
                data = BufferList3.isBufferList(data) ? data : new BufferList3(data);
                send({ id, type: Types2.MESSAGE, data: data.shallowSlice(0, maxMsgSize) });
                data.consume(maxMsgSize);
              }
            }
          } catch (err) {
            if (err.code === ERR_MPLEX_STREAM_RESET) {
              log48("%s stream %s reset", type, name10);
            } else {
              log48("%s stream %s error", type, name10, err);
              send({ id, type: Types2.RESET });
            }
            stream.source.end(err);
            return onSinkEnd(err);
          }
          send({ id, type: Types2.CLOSE });
          onSinkEnd();
        },
        source: pushable5(onSourceEnd),
        timeline: {
          open: Date.now(),
          close: null
        },
        id: externalId
      };
      return stream;
    };
  }
});

// node_modules/libp2p-mplex/src/mplex.js
var require_mplex = __commonJS({
  "node_modules/libp2p-mplex/src/mplex.js"(exports2, module2) {
    "use strict";
    init_globals();
    var pipe8 = require_it_pipe();
    var pushable5 = require_it_pushable();
    var log48 = require_browser2()("libp2p:mplex");
    var abortable = require_abortable_iterator();
    var Coder = require_coder();
    var restrictSize = require_restrict_size();
    var { MessageTypes, MessageTypeNames } = require_message_types();
    var createStream = require_stream();
    var Mplex = class {
      constructor(options) {
        options = options || {};
        options = typeof options === "function" ? { onStream: options } : options;
        this._streamId = 0;
        this._streams = {
          initiators: /* @__PURE__ */ new Map(),
          receivers: /* @__PURE__ */ new Map()
        };
        this._options = options;
        this.sink = this._createSink();
        this.source = this._createSource();
        this.onStream = options.onStream;
        this.onStreamEnd = options.onStreamEnd;
      }
      get streams() {
        const streams = [];
        this._streams.initiators.forEach((stream) => {
          streams.push(stream);
        });
        this._streams.receivers.forEach((stream) => {
          streams.push(stream);
        });
        return streams;
      }
      newStream(name10) {
        const id = this._streamId++;
        name10 = name10 == null ? id.toString() : String(name10);
        const registry = this._streams.initiators;
        return this._newStream({ id, name: name10, type: "initiator", registry });
      }
      _newReceiverStream({ id, name: name10 }) {
        const registry = this._streams.receivers;
        return this._newStream({ id, name: name10, type: "receiver", registry });
      }
      _newStream({ id, name: name10, type, registry }) {
        if (registry.has(id)) {
          throw new Error(`${type} stream ${id} already exists!`);
        }
        log48("new %s stream %s %s", type, id, name10);
        const send = (msg) => {
          if (log48.enabled) {
            log48("%s stream %s %s send", type, id, name10, { ...msg, type: MessageTypeNames[msg.type], data: msg.data && msg.data.slice() });
          }
          return this.source.push(msg);
        };
        const onEnd = () => {
          log48("%s stream %s %s ended", type, id, name10);
          registry.delete(id);
          this.onStreamEnd && this.onStreamEnd(stream);
        };
        const stream = createStream({ id, name: name10, send, type, onEnd, maxMsgSize: this._options.maxMsgSize });
        registry.set(id, stream);
        return stream;
      }
      _createSink() {
        return async (source) => {
          if (this._options.signal) {
            source = abortable(source, this._options.signal);
          }
          try {
            await pipe8(source, Coder.decode, restrictSize(this._options.maxMsgSize), async (source2) => {
              for await (const msgs of source2) {
                for (const msg of msgs) {
                  this._handleIncoming(msg);
                }
              }
            });
          } catch (err) {
            log48("error in sink", err);
            return this.source.end(err);
          }
          this.source.end();
        };
      }
      _createSource() {
        const onEnd = (err) => {
          const { initiators, receivers } = this._streams;
          for (const s of initiators.values())
            s.abort(err);
          for (const s of receivers.values())
            s.abort(err);
        };
        const source = pushable5({ onEnd, writev: true });
        return Object.assign(Coder.encode(source), {
          push: source.push,
          end: source.end,
          return: source.return
        });
      }
      _handleIncoming({ id, type, data }) {
        if (log48.enabled) {
          log48("incoming message", { id, type: MessageTypeNames[type], data: data.slice() });
        }
        if (type === MessageTypes.NEW_STREAM && this.onStream) {
          const stream2 = this._newReceiverStream({ id, name: data.toString() });
          return this.onStream(stream2);
        }
        const list = type & 1 ? this._streams.initiators : this._streams.receivers;
        const stream = list.get(id);
        if (!stream)
          return log48("missing stream %s", id);
        switch (type) {
          case MessageTypes.MESSAGE_INITIATOR:
          case MessageTypes.MESSAGE_RECEIVER:
            stream.source.push(data);
            break;
          case MessageTypes.CLOSE_INITIATOR:
          case MessageTypes.CLOSE_RECEIVER:
            stream.close();
            break;
          case MessageTypes.RESET_INITIATOR:
          case MessageTypes.RESET_RECEIVER:
            stream.reset();
            break;
          default:
            log48("unknown message type %s", type);
        }
      }
    };
    Mplex.multicodec = "/mplex/6.7.0";
    module2.exports = Mplex;
  }
});

// node_modules/libp2p-mplex/src/index.js
var require_src17 = __commonJS({
  "node_modules/libp2p-mplex/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = require_mplex();
  }
});

// node_modules/@stablelib/random/lib/source/browser.js
var require_browser9 = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var QUOTA = 65536;
    var BrowserRandomSource = function() {
      function BrowserRandomSource2() {
        this.isAvailable = false;
        this.isInstantiated = false;
        var browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      BrowserRandomSource2.prototype.randomBytes = function(length5) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        var out = new Uint8Array(length5);
        for (var i = 0; i < out.length; i += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
      };
      return BrowserRandomSource2;
    }();
    exports2.BrowserRandomSource = BrowserRandomSource;
  }
});

// node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function wipe(array) {
      for (var i = 0; i < array.length; i++) {
        array[i] = 0;
      }
      return array;
    }
    exports2.wipe = wipe;
  }
});

// node_modules/@stablelib/random/lib/source/node.js
var require_node2 = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var wipe_1 = require_wipe();
    var NodeRandomSource = function() {
      function NodeRandomSource2() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          var nodeCrypto = require_crypto();
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      NodeRandomSource2.prototype.randomBytes = function(length5) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        var buffer3 = this._crypto.randomBytes(length5);
        if (buffer3.length !== length5) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        var out = new Uint8Array(length5);
        for (var i = 0; i < out.length; i++) {
          out[i] = buffer3[i];
        }
        wipe_1.wipe(buffer3);
        return out;
      };
      return NodeRandomSource2;
    }();
    exports2.NodeRandomSource = NodeRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var browser_1 = require_browser9();
    var node_1 = require_node2();
    var SystemRandomSource = function() {
      function SystemRandomSource2() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      SystemRandomSource2.prototype.randomBytes = function(length5) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length5);
      };
      return SystemRandomSource2;
    }();
    exports2.SystemRandomSource = SystemRandomSource;
  }
});

// node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function imulShim(a, b) {
      var ah = a >>> 16 & 65535, al = a & 65535;
      var bh = b >>> 16 & 65535, bl = b & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports2.mul = Math.imul || imulShim;
    function add(a, b) {
      return a + b | 0;
    }
    exports2.add = add;
    function sub(a, b) {
      return a - b | 0;
    }
    exports2.sub = sub;
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    exports2.rotl = rotl;
    function rotr(x, n) {
      return x << 32 - n | x >>> n;
    }
    exports2.rotr = rotr;
    function isIntegerShim(n) {
      return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    }
    exports2.isInteger = Number.isInteger || isIntegerShim;
    exports2.MAX_SAFE_INTEGER = 9007199254740991;
    exports2.isSafeInteger = function(n) {
      return exports2.isInteger(n) && (n >= -exports2.MAX_SAFE_INTEGER && n <= exports2.MAX_SAFE_INTEGER);
    };
  }
});

// node_modules/@stablelib/binary/lib/binary.js
var require_binary2 = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    exports2.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    exports2.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    exports2.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports2.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    exports2.writeUint16BE = writeUint16BE;
    exports2.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    exports2.writeUint16LE = writeUint16LE;
    exports2.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    exports2.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    exports2.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    exports2.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports2.readUint32LE = readUint32LE;
    function writeUint32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    exports2.writeUint32BE = writeUint32BE;
    exports2.writeInt32BE = writeUint32BE;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    exports2.writeUint32LE = writeUint32LE;
    exports2.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value / 4294967296 >>> 0, out, offset);
      writeUint32BE(value >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64BE = writeUint64BE;
    exports2.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64LE = writeUint64LE;
    exports2.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        result += array[i] * mul;
        mul *= 256;
      }
      return result;
    }
    exports2.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        result += array[i] * mul;
        mul *= 256;
      }
      return result;
    }
    exports2.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    exports2.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    exports2.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    exports2.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    exports2.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    exports2.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    exports2.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    exports2.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    exports2.writeFloat64LE = writeFloat64LE;
  }
});

// node_modules/@stablelib/random/lib/random.js
var require_random2 = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var system_1 = require_system();
    var binary_1 = require_binary2();
    var wipe_1 = require_wipe();
    exports2.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes(length5, prng) {
      if (prng === void 0) {
        prng = exports2.defaultRandomSource;
      }
      return prng.randomBytes(length5);
    }
    exports2.randomBytes = randomBytes;
    function randomUint32(prng) {
      if (prng === void 0) {
        prng = exports2.defaultRandomSource;
      }
      var buf3 = randomBytes(4, prng);
      var result = binary_1.readUint32LE(buf3);
      wipe_1.wipe(buf3);
      return result;
    }
    exports2.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length5, charset, prng) {
      if (charset === void 0) {
        charset = ALPHANUMERIC;
      }
      if (prng === void 0) {
        prng = exports2.defaultRandomSource;
      }
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      var out = "";
      var charsLen = charset.length;
      var maxByte = 256 - 256 % charsLen;
      while (length5 > 0) {
        var buf3 = randomBytes(Math.ceil(length5 * 256 / maxByte), prng);
        for (var i = 0; i < buf3.length && length5 > 0; i++) {
          var randomByte = buf3[i];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length5--;
          }
        }
        wipe_1.wipe(buf3);
      }
      return out;
    }
    exports2.randomString = randomString;
    function randomStringForEntropy(bits, charset, prng) {
      if (charset === void 0) {
        charset = ALPHANUMERIC;
      }
      if (prng === void 0) {
        prng = exports2.defaultRandomSource;
      }
      var length5 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length5, charset, prng);
    }
    exports2.randomStringForEntropy = randomStringForEntropy;
  }
});

// node_modules/@stablelib/x25519/lib/x25519.js
var require_x25519 = __commonJS({
  "node_modules/@stablelib/x25519/lib/x25519.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var random_1 = require_random2();
    var wipe_1 = require_wipe();
    exports2.PUBLIC_KEY_LENGTH = 32;
    exports2.SECRET_KEY_LENGTH = 32;
    exports2.SHARED_KEY_LENGTH = 32;
    function gf(init) {
      var r = new Float64Array(16);
      if (init) {
        for (var i = 0; i < init.length; i++) {
          r[i] = init[i];
        }
      }
      return r;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var _121665 = gf([56129, 1]);
    function car25519(o) {
      var c = 1;
      for (var i = 0; i < 16; i++) {
        var v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      var c = ~(b - 1);
      for (var i = 0; i < 16; i++) {
        var t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    function pack25519(o, n) {
      var m = gf();
      var t = gf();
      for (var i = 0; i < 16; i++) {
        t[i] = n[i];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (var j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (var i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        var b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (var i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function unpack25519(o, n) {
      for (var i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }
      o[15] &= 32767;
    }
    function add(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
      }
    }
    function sub(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
      }
    }
    function mul(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function square(o, a) {
      mul(o, a, a);
    }
    function inv25519(o, inp) {
      var c = gf();
      for (var i = 0; i < 16; i++) {
        c[i] = inp[i];
      }
      for (var i = 253; i >= 0; i--) {
        square(c, c);
        if (i !== 2 && i !== 4) {
          mul(c, c, inp);
        }
      }
      for (var i = 0; i < 16; i++) {
        o[i] = c[i];
      }
    }
    function scalarMult(n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80);
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
      for (var i = 0; i < 31; i++) {
        z[i] = n[i];
      }
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (var i = 0; i < 16; i++) {
        b[i] = x[i];
      }
      a[0] = d[0] = 1;
      for (var i = 254; i >= 0; --i) {
        var r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (var i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      mul(x16, x16, x32);
      var q = new Uint8Array(32);
      pack25519(q, x16);
      return q;
    }
    exports2.scalarMult = scalarMult;
    function scalarMultBase(n) {
      return scalarMult(n, _9);
    }
    exports2.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed(seed) {
      if (seed.length !== exports2.SECRET_KEY_LENGTH) {
        throw new Error("x25519: seed must be " + exports2.SECRET_KEY_LENGTH + " bytes");
      }
      var secretKey = new Uint8Array(seed);
      var publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    exports2.generateKeyPairFromSeed = generateKeyPairFromSeed;
    function generateKeyPair(prng) {
      var seed = random_1.randomBytes(32, prng);
      var result = generateKeyPairFromSeed(seed);
      wipe_1.wipe(seed);
      return result;
    }
    exports2.generateKeyPair = generateKeyPair;
    function sharedKey(mySecretKey, theirPublicKey, rejectZero) {
      if (rejectZero === void 0) {
        rejectZero = false;
      }
      if (mySecretKey.length !== exports2.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports2.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      var result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        var zeros = 0;
        for (var i = 0; i < result.length; i++) {
          zeros |= result[i];
        }
        if (zeros === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    exports2.sharedKey = sharedKey;
  }
});

// node_modules/it-handshake/src/index.js
var require_src18 = __commonJS({
  "node_modules/it-handshake/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Reader = require_it_reader();
    var Writer = require_it_pushable();
    var defer = require_p_defer();
    module2.exports = (stream) => {
      const writer = Writer();
      const reader = Reader(stream.source);
      const sourcePromise = defer();
      let sinkErr;
      const sinkPromise = stream.sink(async function* () {
        yield* writer;
        const source = await sourcePromise.promise;
        yield* source;
      }());
      sinkPromise.catch((err) => {
        sinkErr = err;
      });
      const rest = {
        sink: (source) => {
          if (sinkErr) {
            return Promise.reject(sinkErr);
          }
          sourcePromise.resolve(source);
          return sinkPromise;
        },
        source: reader
      };
      return {
        reader,
        writer,
        stream: rest,
        rest: () => writer.end(),
        write: writer.push,
        read: async () => {
          return (await reader.next()).value;
        }
      };
    };
  }
});

// node_modules/@chainsafe/libp2p-noise/node_modules/it-pb-rpc/src/index.js
var require_src19 = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/node_modules/it-pb-rpc/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Shake = require_src18();
    var lp2 = require_src11();
    module2.exports = (duplex, opts = {}) => {
      const shake = Shake(duplex);
      const lpReader = lp2.decode.fromReader(shake.reader, opts);
      let isDone = false;
      const W = {
        read: async (bytes2) => {
          const { value, done } = await shake.reader.next(bytes2);
          if (done && value.length < bytes2) {
            throw new Error("Couldn't read enough bytes");
          }
          isDone = done;
          if (!value) {
            throw new Error("Value is null");
          }
          return value;
        },
        readLP: async () => {
          const { value, done } = await lpReader.next();
          isDone = done;
          if (!value) {
            throw new Error("Value is null");
          }
          return value;
        },
        readPB: async (proto) => {
          const value = await W.readLP();
          if (!value) {
            throw new Error("Value is null");
          }
          const buf3 = value instanceof Uint8Array ? value : value.slice();
          return proto.decode(buf3);
        },
        write: (data) => {
          shake.writer.push(data);
        },
        writeLP: (data) => {
          W.write(lp2.encode.single(data, opts));
        },
        writePB: (data, proto) => {
          W.writeLP(proto.encode(data));
        },
        pb: (proto) => {
          return {
            read: () => W.readPB(proto),
            write: (d) => W.writePB(d, proto)
          };
        },
        unwrap: () => {
          shake.rest();
          return shake.stream;
        }
      };
      return W;
    };
  }
});

// node_modules/it-pair/index.js
var require_it_pair = __commonJS({
  "node_modules/it-pair/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var getIterator = require_get_iterator();
    module2.exports = function pair() {
      let _source, onSource;
      const sink = async (source2) => {
        if (_source)
          throw new Error("already piped");
        _source = getIterator(source2);
        if (onSource)
          onSource(_source);
      };
      const source = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next() {
          if (_source)
            return _source.next();
          return new Promise((resolve11) => {
            onSource = (source2) => {
              onSource = null;
              resolve11(source2.next());
            };
          });
        }
      };
      return { sink, source };
    };
  }
});

// node_modules/it-pair/duplex.js
var require_duplex3 = __commonJS({
  "node_modules/it-pair/duplex.js"(exports2, module2) {
    init_globals();
    var Pair = require_it_pair();
    module2.exports = function() {
      var a = Pair();
      var b = Pair();
      return [
        {
          source: a.source,
          sink: b.sink
        },
        {
          source: b.source,
          sink: a.sink
        }
      ];
    };
  }
});

// node_modules/it-buffer/index.js
var require_it_buffer = __commonJS({
  "node_modules/it-buffer/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var BufferList3 = require_BufferList();
    module2.exports = async function* (source) {
      for await (const b of source) {
        if (Buffer2.isBuffer(b)) {
          yield b;
        } else if (BufferList3.isBufferList(b)) {
          yield b.slice();
        } else {
          yield Buffer2.from(b);
        }
      }
    };
    module2.exports.toBuffer = module2.exports;
    module2.exports.toList = async function* (source) {
      for await (const b of source) {
        if (Buffer2.isBuffer(b)) {
          yield new BufferList3().append(b);
        } else if (BufferList3.isBufferList(b)) {
          yield b;
        } else {
          yield new BufferList3().append(Buffer2.from(b));
        }
      }
    };
  }
});

// node_modules/@stablelib/hash/lib/hash.js
var require_hash = __commonJS({
  "node_modules/@stablelib/hash/lib/hash.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isSerializableHash(h) {
      return typeof h.saveState !== "undefined" && typeof h.restoreState !== "undefined" && typeof h.cleanSavedState !== "undefined";
    }
    exports2.isSerializableHash = isSerializableHash;
  }
});

// node_modules/@stablelib/constant-time/lib/constant-time.js
var require_constant_time = __commonJS({
  "node_modules/@stablelib/constant-time/lib/constant-time.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    function select(subject, resultIfOne, resultIfZero) {
      return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
    }
    exports2.select = select;
    function lessOrEqual(a, b) {
      return (a | 0) - (b | 0) - 1 >>> 31 & 1;
    }
    exports2.lessOrEqual = lessOrEqual;
    function compare4(a, b) {
      if (a.length !== b.length) {
        return 0;
      }
      var result = 0;
      for (var i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
      }
      return 1 & result - 1 >>> 8;
    }
    exports2.compare = compare4;
    function equal(a, b) {
      if (a.length === 0 || b.length === 0) {
        return false;
      }
      return compare4(a, b) !== 0;
    }
    exports2.equal = equal;
  }
});

// node_modules/@stablelib/hmac/lib/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/@stablelib/hmac/lib/hmac.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hash_1 = require_hash();
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    var HMAC = function() {
      function HMAC2(hash2, key) {
        this._finished = false;
        this._inner = new hash2();
        this._outer = new hash2();
        this.blockSize = this._outer.blockSize;
        this.digestLength = this._outer.digestLength;
        var pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
          this._inner.update(key).finish(pad).clean();
        } else {
          pad.set(key);
        }
        for (var i = 0; i < pad.length; i++) {
          pad[i] ^= 54;
        }
        this._inner.update(pad);
        for (var i = 0; i < pad.length; i++) {
          pad[i] ^= 54 ^ 92;
        }
        this._outer.update(pad);
        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
          this._innerKeyedState = this._inner.saveState();
          this._outerKeyedState = this._outer.saveState();
        }
        wipe_1.wipe(pad);
      }
      HMAC2.prototype.reset = function() {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
          throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
        }
        this._inner.restoreState(this._innerKeyedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
      };
      HMAC2.prototype.clean = function() {
        if (hash_1.isSerializableHash(this._inner)) {
          this._inner.cleanSavedState(this._innerKeyedState);
        }
        if (hash_1.isSerializableHash(this._outer)) {
          this._outer.cleanSavedState(this._outerKeyedState);
        }
        this._inner.clean();
        this._outer.clean();
      };
      HMAC2.prototype.update = function(data) {
        this._inner.update(data);
        return this;
      };
      HMAC2.prototype.finish = function(out) {
        if (this._finished) {
          this._outer.finish(out);
          return this;
        }
        this._inner.finish(out);
        this._outer.update(out.subarray(0, this.digestLength)).finish(out);
        this._finished = true;
        return this;
      };
      HMAC2.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      HMAC2.prototype.saveState = function() {
        if (!hash_1.isSerializableHash(this._inner)) {
          throw new Error("hmac: can't saveState() because hash doesn't implement it");
        }
        return this._inner.saveState();
      };
      HMAC2.prototype.restoreState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
          throw new Error("hmac: can't restoreState() because hash doesn't implement it");
        }
        this._inner.restoreState(savedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
      };
      HMAC2.prototype.cleanSavedState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner)) {
          throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
        }
        this._inner.cleanSavedState(savedState);
      };
      return HMAC2;
    }();
    exports2.HMAC = HMAC;
    function hmac(hash2, key, data) {
      var h = new HMAC(hash2, key);
      h.update(data);
      var digest3 = h.digest();
      h.clean();
      return digest3;
    }
    exports2.hmac = hmac;
    exports2.equal = constant_time_1.equal;
  }
});

// node_modules/@stablelib/hkdf/lib/hkdf.js
var require_hkdf = __commonJS({
  "node_modules/@stablelib/hkdf/lib/hkdf.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hmac_1 = require_hmac2();
    var wipe_1 = require_wipe();
    var HKDF = function() {
      function HKDF2(hash2, key, salt, info) {
        if (salt === void 0) {
          salt = new Uint8Array(0);
        }
        this._counter = new Uint8Array(1);
        this._hash = hash2;
        this._info = info;
        var okm = hmac_1.hmac(this._hash, salt, key);
        this._hmac = new hmac_1.HMAC(hash2, okm);
        this._buffer = new Uint8Array(this._hmac.digestLength);
        this._bufpos = this._buffer.length;
      }
      HKDF2.prototype._fillBuffer = function() {
        this._counter[0]++;
        var ctr = this._counter[0];
        if (ctr === 0) {
          throw new Error("hkdf: cannot expand more");
        }
        this._hmac.reset();
        if (ctr > 1) {
          this._hmac.update(this._buffer);
        }
        if (this._info) {
          this._hmac.update(this._info);
        }
        this._hmac.update(this._counter);
        this._hmac.finish(this._buffer);
        this._bufpos = 0;
      };
      HKDF2.prototype.expand = function(length5) {
        var out = new Uint8Array(length5);
        for (var i = 0; i < out.length; i++) {
          if (this._bufpos === this._buffer.length) {
            this._fillBuffer();
          }
          out[i] = this._buffer[this._bufpos++];
        }
        return out;
      };
      HKDF2.prototype.clean = function() {
        this._hmac.clean();
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._counter);
        this._bufpos = 0;
      };
      return HKDF2;
    }();
    exports2.HKDF = HKDF;
  }
});

// node_modules/@stablelib/sha256/lib/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/@stablelib/sha256/lib/sha256.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var binary_1 = require_binary2();
    var wipe_1 = require_wipe();
    exports2.DIGEST_LENGTH = 32;
    exports2.BLOCK_SIZE = 64;
    var SHA256 = function() {
      function SHA2562() {
        this.digestLength = exports2.DIGEST_LENGTH;
        this.blockSize = exports2.BLOCK_SIZE;
        this._state = new Int32Array(8);
        this._temp = new Int32Array(64);
        this._buffer = new Uint8Array(128);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      SHA2562.prototype._initState = function() {
        this._state[0] = 1779033703;
        this._state[1] = 3144134277;
        this._state[2] = 1013904242;
        this._state[3] = 2773480762;
        this._state[4] = 1359893119;
        this._state[5] = 2600822924;
        this._state[6] = 528734635;
        this._state[7] = 1541459225;
      };
      SHA2562.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._temp);
        this.reset();
      };
      SHA2562.prototype.update = function(data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }
        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA2562.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left] = 128;
          for (var i = left + 1; i < padLength - 8; i++) {
            this._buffer[i] = 0;
          }
          binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 4; i++) {
          binary_1.writeUint32BE(this._state[i], out, i * 4);
        }
        return this;
      };
      SHA2562.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA2562.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA2562.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.cleanSavedState = function(savedState) {
        wipe_1.wipe(savedState.state);
        if (savedState.buffer) {
          wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA2562;
    }();
    exports2.SHA256 = SHA256;
    var K = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w, v, p, pos, len) {
      while (len >= 64) {
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f = v[5];
        var g = v[6];
        var h = v[7];
        for (var i = 0; i < 16; i++) {
          var j = pos + i * 4;
          w[i] = binary_1.readUint32BE(p, j);
        }
        for (var i = 16; i < 64; i++) {
          var u = w[i - 2];
          var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i - 15];
          var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }
        for (var i = 0; i < 64; i++) {
          var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
          var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    function hash2(data) {
      var h = new SHA256();
      h.update(data);
      var digest3 = h.digest();
      h.clean();
      return digest3;
    }
    exports2.hash = hash2;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
var require_payload = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js"(exports2, module2) {
    "use strict";
    init_globals();
    (function(global2, factory) {
      if (typeof define === "function" && define.amd)
        define(["protobufjs/minimal"], factory);
      else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2.exports)
        module2.exports = factory(require_minimal2());
    })(exports2, function($protobuf12) {
      "use strict";
      var $Reader11 = $protobuf12.Reader, $Writer11 = $protobuf12.Writer, $util11 = $protobuf12.util;
      var $root11 = $protobuf12.roots["libp2p-noise"] || ($protobuf12.roots["libp2p-noise"] = {});
      $root11.pb = function() {
        var pb = {};
        pb.NoiseHandshakePayload = function() {
          function NoiseHandshakePayload(properties) {
            if (properties) {
              for (var keys2 = Object.keys(properties), i = 0; i < keys2.length; ++i)
                if (properties[keys2[i]] != null)
                  this[keys2[i]] = properties[keys2[i]];
            }
          }
          NoiseHandshakePayload.prototype.identityKey = $util11.newBuffer([]);
          NoiseHandshakePayload.prototype.identitySig = $util11.newBuffer([]);
          NoiseHandshakePayload.prototype.data = $util11.newBuffer([]);
          NoiseHandshakePayload.create = function create9(properties) {
            return new NoiseHandshakePayload(properties);
          };
          NoiseHandshakePayload.encode = function encode19(message, writer) {
            if (!writer)
              writer = $Writer11.create();
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
              writer.uint32(10).bytes(message.identityKey);
            if (message.identitySig != null && Object.hasOwnProperty.call(message, "identitySig"))
              writer.uint32(18).bytes(message.identitySig);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
              writer.uint32(26).bytes(message.data);
            return writer;
          };
          NoiseHandshakePayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          NoiseHandshakePayload.decode = function decode22(reader, length5) {
            if (!(reader instanceof $Reader11))
              reader = $Reader11.create(reader);
            var end = length5 === void 0 ? reader.len : reader.pos + length5, message = new $root11.pb.NoiseHandshakePayload();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.identityKey = reader.bytes();
                  break;
                case 2:
                  message.identitySig = reader.bytes();
                  break;
                case 3:
                  message.data = reader.bytes();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          NoiseHandshakePayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader11))
              reader = new $Reader11(reader);
            return this.decode(reader, reader.uint32());
          };
          NoiseHandshakePayload.verify = function verify2(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.identityKey != null && message.hasOwnProperty("identityKey")) {
              if (!(message.identityKey && typeof message.identityKey.length === "number" || $util11.isString(message.identityKey)))
                return "identityKey: buffer expected";
            }
            if (message.identitySig != null && message.hasOwnProperty("identitySig")) {
              if (!(message.identitySig && typeof message.identitySig.length === "number" || $util11.isString(message.identitySig)))
                return "identitySig: buffer expected";
            }
            if (message.data != null && message.hasOwnProperty("data")) {
              if (!(message.data && typeof message.data.length === "number" || $util11.isString(message.data)))
                return "data: buffer expected";
            }
            return null;
          };
          NoiseHandshakePayload.fromObject = function fromObject(object) {
            if (object instanceof $root11.pb.NoiseHandshakePayload)
              return object;
            var message = new $root11.pb.NoiseHandshakePayload();
            if (object.identityKey != null) {
              if (typeof object.identityKey === "string")
                $util11.base64.decode(object.identityKey, message.identityKey = $util11.newBuffer($util11.base64.length(object.identityKey)), 0);
              else if (object.identityKey.length)
                message.identityKey = object.identityKey;
            }
            if (object.identitySig != null) {
              if (typeof object.identitySig === "string")
                $util11.base64.decode(object.identitySig, message.identitySig = $util11.newBuffer($util11.base64.length(object.identitySig)), 0);
              else if (object.identitySig.length)
                message.identitySig = object.identitySig;
            }
            if (object.data != null) {
              if (typeof object.data === "string")
                $util11.base64.decode(object.data, message.data = $util11.newBuffer($util11.base64.length(object.data)), 0);
              else if (object.data.length)
                message.data = object.data;
            }
            return message;
          };
          NoiseHandshakePayload.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              if (options.bytes === String)
                object.identityKey = "";
              else {
                object.identityKey = [];
                if (options.bytes !== Array)
                  object.identityKey = $util11.newBuffer(object.identityKey);
              }
              if (options.bytes === String)
                object.identitySig = "";
              else {
                object.identitySig = [];
                if (options.bytes !== Array)
                  object.identitySig = $util11.newBuffer(object.identitySig);
              }
              if (options.bytes === String)
                object.data = "";
              else {
                object.data = [];
                if (options.bytes !== Array)
                  object.data = $util11.newBuffer(object.data);
              }
            }
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
              object.identityKey = options.bytes === String ? $util11.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.identitySig != null && message.hasOwnProperty("identitySig"))
              object.identitySig = options.bytes === String ? $util11.base64.encode(message.identitySig, 0, message.identitySig.length) : options.bytes === Array ? Array.prototype.slice.call(message.identitySig) : message.identitySig;
            if (message.data != null && message.hasOwnProperty("data"))
              object.data = options.bytes === String ? $util11.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
          };
          NoiseHandshakePayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
          };
          return NoiseHandshakePayload;
        }();
        return pb;
      }();
      return $root11;
    });
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
var require_utils6 = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/utils.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidPublicKey = exports2.getHkdf = exports2.verifySignedPayload = exports2.getHandshakePayload = exports2.decodePayload = exports2.getPeerIdFromPayload = exports2.signPayload = exports2.createHandshakePayload = exports2.getPayload = exports2.generateKeypair = void 0;
    var hkdf_1 = require_hkdf();
    var sha256_1 = require_sha2562();
    var x25519 = __importStar(require_x25519());
    var peer_id_1 = __importDefault(require_src5());
    var payload_1 = require_payload();
    var equals_1 = (init_equals(), __toCommonJS(equals_exports));
    var from_string_1 = (init_from_string(), __toCommonJS(from_string_exports));
    var concat_1 = (init_concat(), __toCommonJS(concat_exports));
    var NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;
    function generateKeypair() {
      const keypair = x25519.generateKeyPair();
      return {
        publicKey: keypair.publicKey,
        privateKey: keypair.secretKey
      };
    }
    exports2.generateKeypair = generateKeypair;
    async function getPayload(localPeer, staticPublicKey, earlyData) {
      const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
      const earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : new Uint8Array(0);
      return createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);
    }
    exports2.getPayload = getPayload;
    function createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {
      const payloadInit = NoiseHandshakePayloadProto.create({
        identityKey: libp2pPublicKey,
        identitySig: signedPayload,
        data: earlyData !== null && earlyData !== void 0 ? earlyData : null
      });
      return NoiseHandshakePayloadProto.encode(payloadInit).finish();
    }
    exports2.createHandshakePayload = createHandshakePayload;
    async function signPayload(peerId, payload) {
      return await peerId.privKey.sign(payload);
    }
    exports2.signPayload = signPayload;
    async function getPeerIdFromPayload(payload) {
      return await peer_id_1.default.createFromPubKey(payload.identityKey);
    }
    exports2.getPeerIdFromPayload = getPeerIdFromPayload;
    function decodePayload(payload) {
      return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(payload));
    }
    exports2.decodePayload = decodePayload;
    function getHandshakePayload(publicKey) {
      const prefix = (0, from_string_1.fromString)("noise-libp2p-static-key:");
      return (0, concat_1.concat)([prefix, publicKey], prefix.length + publicKey.length);
    }
    exports2.getHandshakePayload = getHandshakePayload;
    async function isValidPeerId(peerId, publicKeyProtobuf) {
      const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);
      return (0, equals_1.equals)(generatedPeerId.id, peerId);
    }
    async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
      const identityKey = payload.identityKey;
      if (!await isValidPeerId(remotePeer.id, identityKey)) {
        throw new Error("Peer ID doesn't match libp2p public key.");
      }
      const generatedPayload = getHandshakePayload(noiseStaticKey);
      const peerId = await peer_id_1.default.createFromPubKey(identityKey);
      if (!payload.identitySig || !await peerId.pubKey.verify(generatedPayload, payload.identitySig)) {
        throw new Error("Static key doesn't match to peer that signed payload!");
      }
      return peerId;
    }
    exports2.verifySignedPayload = verifySignedPayload;
    function getHkdf(ck, ikm) {
      const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);
      const okmU8Array = hkdf.expand(96);
      const okm = okmU8Array;
      const k1 = okm.slice(0, 32);
      const k2 = okm.slice(32, 64);
      const k3 = okm.slice(64, 96);
      return [k1, k2, k3];
    }
    exports2.getHkdf = getHkdf;
    function isValidPublicKey(pk) {
      if (!(pk instanceof Uint8Array)) {
        return false;
      }
      if (pk.length !== 32) {
        return false;
      }
      return true;
    }
    exports2.isValidPublicKey = isValidPublicKey;
  }
});

// node_modules/@stablelib/chacha/lib/chacha.js
var require_chacha = __commonJS({
  "node_modules/@stablelib/chacha/lib/chacha.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var binary_1 = require_binary2();
    var wipe_1 = require_wipe();
    var ROUNDS = 20;
    function core(out, input, key) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j2 = 2036477234;
      var j3 = 1797285236;
      var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
      var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
      var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
      var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
      var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
      var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
      var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
      var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
      var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
      var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
      var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
      var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
      var x0 = j0;
      var x1 = j1;
      var x2 = j2;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i = 0; i < ROUNDS; i += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
      binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
      binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
      binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
      binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
      binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
      binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
      binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
      binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
      binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
      binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
      binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
      binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
      binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
      binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
      binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    function streamXOR(key, nonce, src3, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
      }
      if (dst.length < src3.length) {
        throw new Error("ChaCha: destination is shorter than source");
      }
      var nc;
      var counterLength;
      if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        counterLength = nc.length - nonce.length;
        nc.set(nonce, counterLength);
      } else {
        if (nonce.length !== 16) {
          throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
      }
      var block = new Uint8Array(64);
      for (var i = 0; i < src3.length; i += 64) {
        core(block, nc, key);
        for (var j = i; j < i + 64 && j < src3.length; j++) {
          dst[j] = src3[j] ^ block[j - i];
        }
        incrementCounter(nc, 0, counterLength);
      }
      wipe_1.wipe(block);
      if (nonceInplaceCounterLength === 0) {
        wipe_1.wipe(nc);
      }
      return dst;
    }
    exports2.streamXOR = streamXOR;
    function stream(key, nonce, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      wipe_1.wipe(dst);
      return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
    }
    exports2.stream = stream;
    function incrementCounter(counter, pos, len) {
      var carry = 1;
      while (len--) {
        carry = carry + (counter[pos] & 255) | 0;
        counter[pos] = carry & 255;
        carry >>>= 8;
        pos++;
      }
      if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
      }
    }
  }
});

// node_modules/@stablelib/poly1305/lib/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/@stablelib/poly1305/lib/poly1305.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    exports2.DIGEST_LENGTH = 16;
    var Poly1305 = function() {
      function Poly13052(key) {
        this.digestLength = exports2.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this._r[5] = t4 >>> 1 & 8190;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this._r[9] = t7 >>> 5 & 127;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
      }
      Poly13052.prototype._blocks = function(m, mpos, bytes2) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes2 >= 16) {
          var t0 = m[mpos + 0] | m[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m[mpos + 2] | m[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m[mpos + 4] | m[mpos + 5] << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m[mpos + 6] | m[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m[mpos + 8] | m[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          var t5 = m[mpos + 10] | m[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m[mpos + 12] | m[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m[mpos + 14] | m[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          var c = 0;
          var d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          var d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          var d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          var d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          var d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          var d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          var d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          var d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          var d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          var d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes2 -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };
      Poly13052.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }
        var g = new Uint16Array(10);
        var c;
        var mask;
        var f;
        var i;
        if (this._leftover) {
          i = this._leftover;
          this._buffer[i++] = 1;
          for (; i < 16; i++) {
            this._buffer[i] = 0;
          }
          this._fin = 1;
          this._blocks(this._buffer, 0, 16);
        }
        c = this._h[1] >>> 13;
        this._h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this._h[i] += c;
          c = this._h[i] >>> 13;
          this._h[i] &= 8191;
        }
        this._h[0] += c * 5;
        c = this._h[0] >>> 13;
        this._h[0] &= 8191;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 8191;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this._h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) {
          g[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
          this._h[i] = this._h[i] & mask | g[i];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this._h[i] + this._pad[i] | 0) + (f >>> 16) | 0;
          this._h[i] = f & 65535;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };
      Poly13052.prototype.update = function(m) {
        var mpos = 0;
        var bytes2 = m.length;
        var want;
        if (this._leftover) {
          want = 16 - this._leftover;
          if (want > bytes2) {
            want = bytes2;
          }
          for (var i = 0; i < want; i++) {
            this._buffer[this._leftover + i] = m[mpos + i];
          }
          bytes2 -= want;
          mpos += want;
          this._leftover += want;
          if (this._leftover < 16) {
            return this;
          }
          this._blocks(this._buffer, 0, 16);
          this._leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this._blocks(m, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (var i = 0; i < bytes2; i++) {
            this._buffer[this._leftover + i] = m[mpos + i];
          }
          this._leftover += bytes2;
        }
        return this;
      };
      Poly13052.prototype.digest = function() {
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };
      Poly13052.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true;
        return this;
      };
      return Poly13052;
    }();
    exports2.Poly1305 = Poly1305;
    function oneTimeAuth(key, data) {
      var h = new Poly1305(key);
      h.update(data);
      var digest3 = h.digest();
      h.clean();
      return digest3;
    }
    exports2.oneTimeAuth = oneTimeAuth;
    function equal(a, b) {
      if (a.length !== exports2.DIGEST_LENGTH || b.length !== exports2.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a, b);
    }
    exports2.equal = equal;
  }
});

// node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js
var require_chacha20poly1305 = __commonJS({
  "node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var chacha_1 = require_chacha();
    var poly1305_1 = require_poly1305();
    var wipe_1 = require_wipe();
    var binary_1 = require_binary2();
    var constant_time_1 = require_constant_time();
    exports2.KEY_LENGTH = 32;
    exports2.NONCE_LENGTH = 12;
    exports2.TAG_LENGTH = 16;
    var ZEROS = new Uint8Array(16);
    var ChaCha20Poly1305 = function() {
      function ChaCha20Poly13052(key) {
        this.nonceLength = exports2.NONCE_LENGTH;
        this.tagLength = exports2.TAG_LENGTH;
        if (key.length !== exports2.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key);
      }
      ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        }
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.clean = function() {
        wipe_1.wipe(this._key);
        return this;
      };
      ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h = new poly1305_1.Poly1305(authKey);
        if (associatedData) {
          h.update(associatedData);
          if (associatedData.length % 16 > 0) {
            h.update(ZEROS.subarray(associatedData.length % 16));
          }
        }
        h.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
          h.update(ZEROS.subarray(ciphertext.length % 16));
        }
        var length5 = new Uint8Array(8);
        if (associatedData) {
          binary_1.writeUint64LE(associatedData.length, length5);
        }
        h.update(length5);
        binary_1.writeUint64LE(ciphertext.length, length5);
        h.update(length5);
        var tag = h.digest();
        for (var i = 0; i < tag.length; i++) {
          tagOut[i] = tag[i];
        }
        h.clean();
        wipe_1.wipe(tag);
        wipe_1.wipe(length5);
      };
      return ChaCha20Poly13052;
    }();
    exports2.ChaCha20Poly1305 = ChaCha20Poly1305;
  }
});

// node_modules/uint8arrays/esm/src/xor.js
var xor_exports = {};
__export(xor_exports, {
  xor: () => xor
});
function xor(a, b) {
  if (a.length !== b.length) {
    throw new Error("Inputs should have the same length");
  }
  const result = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = a[i] ^ b[i];
  }
  return result;
}
var init_xor = __esm({
  "node_modules/uint8arrays/esm/src/xor.js"() {
    init_globals();
  }
});

// node_modules/uint8arrays/esm/src/index.js
var src_exports6 = {};
__export(src_exports6, {
  compare: () => compare2,
  concat: () => concat2,
  equals: () => equals3,
  fromString: () => fromString3,
  toString: () => toString3,
  xor: () => xor
});
var init_src4 = __esm({
  "node_modules/uint8arrays/esm/src/index.js"() {
    init_globals();
    init_compare();
    init_concat();
    init_equals();
    init_from_string();
    init_to_string();
    init_xor();
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
var require_constants9 = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/constants.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DUMP_SESSION_KEYS = exports2.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = exports2.NOISE_MSG_MAX_LENGTH_BYTES = void 0;
    exports2.NOISE_MSG_MAX_LENGTH_BYTES = 65535;
    exports2.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = exports2.NOISE_MSG_MAX_LENGTH_BYTES - 16;
    exports2.DUMP_SESSION_KEYS = process.env.DUMP_SESSION_KEYS;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
var require_logger = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/logger.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logCipherState = exports2.logRemoteEphemeralKey = exports2.logRemoteStaticKey = exports2.logLocalEphemeralKeys = exports2.logLocalStaticKeys = exports2.logger = void 0;
    var debug_1 = __importDefault(require_browser2());
    var constants_1 = require_constants9();
    var to_string_1 = (init_to_string(), __toCommonJS(to_string_exports));
    exports2.logger = (0, debug_1.default)("libp2p:noise");
    var keyLogger;
    if (constants_1.DUMP_SESSION_KEYS) {
      keyLogger = exports2.logger;
    } else {
      keyLogger = () => {
      };
    }
    function logLocalStaticKeys(s) {
      keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${(0, to_string_1.toString)(s.publicKey, "hex")}`);
      keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${(0, to_string_1.toString)(s.privateKey, "hex")}`);
    }
    exports2.logLocalStaticKeys = logLocalStaticKeys;
    function logLocalEphemeralKeys(e) {
      if (e) {
        keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${(0, to_string_1.toString)(e.publicKey, "hex")}`);
        keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${(0, to_string_1.toString)(e.privateKey, "hex")}`);
      } else {
        keyLogger("Missing local ephemeral keys.");
      }
    }
    exports2.logLocalEphemeralKeys = logLocalEphemeralKeys;
    function logRemoteStaticKey(rs) {
      keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${(0, to_string_1.toString)(rs, "hex")}`);
    }
    exports2.logRemoteStaticKey = logRemoteStaticKey;
    function logRemoteEphemeralKey(re) {
      keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${(0, to_string_1.toString)(re, "hex")}`);
    }
    exports2.logRemoteEphemeralKey = logRemoteEphemeralKey;
    function logCipherState(session) {
      if (session.cs1 && session.cs2) {
        keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${(0, to_string_1.toString)(session.cs1.k, "hex")}`);
        keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${(0, to_string_1.toString)(session.cs2.k, "hex")}`);
      } else {
        keyLogger("Missing cipher state.");
      }
    }
    exports2.logCipherState = logCipherState;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js
var require_abstract_handshake = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractHandshake = exports2.MAX_NONCE = exports2.MIN_NONCE = void 0;
    var x25519 = __importStar(require_x25519());
    var SHA256 = __importStar(require_sha2562());
    var chacha20poly1305_1 = require_chacha20poly1305();
    var equals_1 = (init_equals(), __toCommonJS(equals_exports));
    var concat_1 = (init_concat(), __toCommonJS(concat_exports));
    var uint8arrays_1 = (init_src4(), __toCommonJS(src_exports6));
    var utils_1 = require_utils6();
    var logger_1 = require_logger();
    exports2.MIN_NONCE = 0;
    exports2.MAX_NONCE = Number.MAX_SAFE_INTEGER;
    var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
    var AbstractHandshake = class {
      encryptWithAd(cs, ad, plaintext) {
        const e = this.encrypt(cs.k, cs.n, ad, plaintext);
        this.setNonce(cs, this.incrementNonce(cs.n));
        return e;
      }
      decryptWithAd(cs, ad, ciphertext) {
        const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext);
        this.setNonce(cs, this.incrementNonce(cs.n));
        return { plaintext, valid };
      }
      hasKey(cs) {
        return !this.isEmptyKey(cs.k);
      }
      setNonce(cs, nonce) {
        cs.n = nonce;
      }
      createEmptyKey() {
        return new Uint8Array(32);
      }
      isEmptyKey(k) {
        const emptyKey = this.createEmptyKey();
        return (0, equals_1.equals)(emptyKey, k);
      }
      incrementNonce(n) {
        return n + 1;
      }
      nonceToBytes(n) {
        const nonce = new Uint8Array(12);
        new DataView(nonce.buffer, nonce.byteOffset, nonce.byteLength).setUint32(4, n, true);
        return nonce;
      }
      encrypt(k, n, ad, plaintext) {
        if (n > exports2.MAX_NONCE) {
          throw new Error(ERR_MAX_NONCE);
        }
        const nonce = this.nonceToBytes(n);
        const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);
        return ctx.seal(nonce, plaintext, ad);
      }
      encryptAndHash(ss, plaintext) {
        let ciphertext;
        if (this.hasKey(ss.cs)) {
          ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
        } else {
          ciphertext = plaintext;
        }
        this.mixHash(ss, ciphertext);
        return ciphertext;
      }
      decrypt(k, n, ad, ciphertext) {
        if (n > exports2.MAX_NONCE) {
          throw new Error(ERR_MAX_NONCE);
        }
        const nonce = this.nonceToBytes(n);
        const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);
        const encryptedMessage = ctx.open(nonce, ciphertext, ad);
        if (encryptedMessage) {
          return {
            plaintext: encryptedMessage,
            valid: true
          };
        } else {
          return {
            plaintext: new Uint8Array(0),
            valid: false
          };
        }
      }
      decryptAndHash(ss, ciphertext) {
        let plaintext;
        let valid = true;
        if (this.hasKey(ss.cs)) {
          ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));
        } else {
          plaintext = ciphertext;
        }
        this.mixHash(ss, ciphertext);
        return { plaintext, valid };
      }
      dh(privateKey, publicKey) {
        try {
          const derivedU8 = x25519.sharedKey(privateKey, publicKey);
          if (derivedU8.length === 32) {
            return derivedU8;
          }
          return derivedU8.slice(0, 32);
        } catch (e) {
          (0, logger_1.logger)(e.message);
          return new Uint8Array(32);
        }
      }
      mixHash(ss, data) {
        ss.h = this.getHash(ss.h, data);
      }
      getHash(a, b) {
        const u = SHA256.hash((0, concat_1.concat)([a, b], a.length + b.length));
        return u;
      }
      mixKey(ss, ikm) {
        const [ck, tempK] = (0, utils_1.getHkdf)(ss.ck, ikm);
        ss.cs = this.initializeKey(tempK);
        ss.ck = ck;
      }
      initializeKey(k) {
        const n = exports2.MIN_NONCE;
        return { k, n };
      }
      initializeSymmetric(protocolName) {
        const protocolNameBytes = (0, uint8arrays_1.fromString)(protocolName, "utf-8");
        const h = this.hashProtocolName(protocolNameBytes);
        const ck = h;
        const key = this.createEmptyKey();
        const cs = this.initializeKey(key);
        return { cs, ck, h };
      }
      hashProtocolName(protocolName) {
        if (protocolName.length <= 32) {
          const h = new Uint8Array(32);
          h.set(protocolName);
          return h;
        } else {
          return this.getHash(protocolName, new Uint8Array(0));
        }
      }
      split(ss) {
        const [tempk1, tempk2] = (0, utils_1.getHkdf)(ss.ck, new Uint8Array(0));
        const cs1 = this.initializeKey(tempk1);
        const cs2 = this.initializeKey(tempk2);
        return { cs1, cs2 };
      }
      writeMessageRegular(cs, payload) {
        const ciphertext = this.encryptWithAd(cs, new Uint8Array(0), payload);
        const ne = this.createEmptyKey();
        const ns = new Uint8Array(0);
        return { ne, ns, ciphertext };
      }
      readMessageRegular(cs, message) {
        return this.decryptWithAd(cs, new Uint8Array(0), message.ciphertext);
      }
    };
    exports2.AbstractHandshake = AbstractHandshake;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/xx.js
var require_xx = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/xx.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XX = void 0;
    var utils_1 = require_utils6();
    var abstract_handshake_1 = require_abstract_handshake();
    var XX = class extends abstract_handshake_1.AbstractHandshake {
      initializeInitiator(prologue, s, rs, psk) {
        const name10 = "Noise_XX_25519_ChaChaPoly_SHA256";
        const ss = this.initializeSymmetric(name10);
        this.mixHash(ss, prologue);
        const re = new Uint8Array(32);
        return { ss, s, rs, psk, re };
      }
      initializeResponder(prologue, s, rs, psk) {
        const name10 = "Noise_XX_25519_ChaChaPoly_SHA256";
        const ss = this.initializeSymmetric(name10);
        this.mixHash(ss, prologue);
        const re = new Uint8Array(32);
        return { ss, s, rs, psk, re };
      }
      writeMessageA(hs, payload, e) {
        const ns = new Uint8Array(0);
        if (e !== void 0) {
          hs.e = e;
        } else {
          hs.e = (0, utils_1.generateKeypair)();
        }
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        return { ne, ns, ciphertext };
      }
      writeMessageB(hs, payload) {
        hs.e = (0, utils_1.generateKeypair)();
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        const spk = hs.s.publicKey;
        const ns = this.encryptAndHash(hs.ss, spk);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        return { ne, ns, ciphertext };
      }
      writeMessageC(hs, payload) {
        const spk = hs.s.publicKey;
        const ns = this.encryptAndHash(hs.ss, spk);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        const ne = this.createEmptyKey();
        const messageBuffer = { ne, ns, ciphertext };
        const { cs1, cs2 } = this.split(hs.ss);
        return { h: hs.ss.h, messageBuffer, cs1, cs2 };
      }
      readMessageA(hs, message) {
        if ((0, utils_1.isValidPublicKey)(message.ne)) {
          hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        return this.decryptAndHash(hs.ss, message.ciphertext);
      }
      readMessageB(hs, message) {
        if ((0, utils_1.isValidPublicKey)(message.ne)) {
          hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        if (!hs.e) {
          throw new Error("Handshake state `e` param is missing.");
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
        if (valid1 && ns.length === 32 && (0, utils_1.isValidPublicKey)(ns)) {
          hs.rs = ns;
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
        return { plaintext, valid: valid1 && valid2 };
      }
      readMessageC(hs, message) {
        const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
        if (valid1 && ns.length === 32 && (0, utils_1.isValidPublicKey)(ns)) {
          hs.rs = ns;
        }
        if (!hs.e) {
          throw new Error("Handshake state `e` param is missing.");
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
        const { cs1, cs2 } = this.split(hs.ss);
        return { h: hs.ss.h, plaintext, valid: valid1 && valid2, cs1, cs2 };
      }
      initSession(initiator, prologue, s) {
        const psk = this.createEmptyKey();
        const rs = new Uint8Array(32);
        let hs;
        if (initiator) {
          hs = this.initializeInitiator(prologue, s, rs, psk);
        } else {
          hs = this.initializeResponder(prologue, s, rs, psk);
        }
        return {
          hs,
          i: initiator,
          mc: 0
        };
      }
      sendMessage(session, message, ephemeral) {
        let messageBuffer;
        if (session.mc === 0) {
          messageBuffer = this.writeMessageA(session.hs, message, ephemeral);
        } else if (session.mc === 1) {
          messageBuffer = this.writeMessageB(session.hs, message);
        } else if (session.mc === 2) {
          const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message);
          messageBuffer = resultingBuffer;
          session.h = h;
          session.cs1 = cs1;
          session.cs2 = cs2;
        } else if (session.mc > 2) {
          if (session.i) {
            if (!session.cs1) {
              throw new Error("CS1 (cipher state) is not defined");
            }
            messageBuffer = this.writeMessageRegular(session.cs1, message);
          } else {
            if (!session.cs2) {
              throw new Error("CS2 (cipher state) is not defined");
            }
            messageBuffer = this.writeMessageRegular(session.cs2, message);
          }
        } else {
          throw new Error("Session invalid.");
        }
        session.mc++;
        return messageBuffer;
      }
      recvMessage(session, message) {
        let plaintext = new Uint8Array(0);
        let valid = false;
        if (session.mc === 0) {
          ({ plaintext, valid } = this.readMessageA(session.hs, message));
        } else if (session.mc === 1) {
          ({ plaintext, valid } = this.readMessageB(session.hs, message));
        } else if (session.mc === 2) {
          const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message);
          plaintext = resultingPlaintext;
          valid = resultingValid;
          session.h = h;
          session.cs1 = cs1;
          session.cs2 = cs2;
        }
        session.mc++;
        return { plaintext, valid };
      }
    };
    exports2.XX = XX;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode2 = exports2.decode1 = exports2.decode0 = exports2.encode2 = exports2.encode1 = exports2.encode0 = exports2.uint16BEDecode = exports2.uint16BEEncode = void 0;
    var BufferList_1 = __importDefault(require_BufferList());
    var concat_1 = (init_concat(), __toCommonJS(concat_exports));
    var allocUnsafe = (len) => {
      if (globalThis.Buffer) {
        return globalThis.Buffer.allocUnsafe(len);
      }
      return new Uint8Array(len);
    };
    var uint16BEEncode = (value, target, offset) => {
      target = target || allocUnsafe(2);
      new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(offset, value, false);
      return target;
    };
    exports2.uint16BEEncode = uint16BEEncode;
    exports2.uint16BEEncode.bytes = 2;
    var uint16BEDecode = (data) => {
      if (data.length < 2)
        throw RangeError("Could not decode int16BE");
      if (data instanceof BufferList_1.default) {
        return data.readUInt16BE(0);
      }
      return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);
    };
    exports2.uint16BEDecode = uint16BEDecode;
    exports2.uint16BEDecode.bytes = 2;
    function encode0(message) {
      return (0, concat_1.concat)([message.ne, message.ciphertext], message.ne.length + message.ciphertext.length);
    }
    exports2.encode0 = encode0;
    function encode1(message) {
      return (0, concat_1.concat)([message.ne, message.ns, message.ciphertext], message.ne.length + message.ns.length + message.ciphertext.length);
    }
    exports2.encode1 = encode1;
    function encode22(message) {
      return (0, concat_1.concat)([message.ns, message.ciphertext], message.ns.length + message.ciphertext.length);
    }
    exports2.encode2 = encode22;
    function decode0(input) {
      if (input.length < 32) {
        throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
      }
      return {
        ne: input.slice(0, 32),
        ciphertext: input.slice(32, input.length),
        ns: new Uint8Array(0)
      };
    }
    exports2.decode0 = decode0;
    function decode1(input) {
      if (input.length < 80) {
        throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
      }
      return {
        ne: input.slice(0, 32),
        ns: input.slice(32, 80),
        ciphertext: input.slice(80, input.length)
      };
    }
    exports2.decode1 = decode1;
    function decode22(input) {
      if (input.length < 48) {
        throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
      }
      return {
        ne: new Uint8Array(0),
        ns: input.slice(0, 48),
        ciphertext: input.slice(48, input.length)
      };
    }
    exports2.decode2 = decode22;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx.js
var require_handshake_xx = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XXHandshake = void 0;
    var xx_1 = require_xx();
    var utils_1 = require_utils6();
    var logger_1 = require_logger();
    var encoder_1 = require_encoder();
    var XXHandshake = class {
      constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {
        this.isInitiator = isInitiator;
        this.payload = payload;
        this.prologue = prologue;
        this.staticKeypair = staticKeypair;
        this.connection = connection;
        if (remotePeer) {
          this.remotePeer = remotePeer;
        }
        this.xx = handshake !== null && handshake !== void 0 ? handshake : new xx_1.XX();
        this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
        this.remoteEarlyData = new Uint8Array(0);
      }
      async propose() {
        (0, logger_1.logLocalStaticKeys)(this.session.hs.s);
        if (this.isInitiator) {
          (0, logger_1.logger)("Stage 0 - Initiator starting to send first message.");
          const messageBuffer = this.xx.sendMessage(this.session, new Uint8Array(0));
          this.connection.writeLP((0, encoder_1.encode0)(messageBuffer));
          (0, logger_1.logger)("Stage 0 - Initiator finished sending first message.");
          (0, logger_1.logLocalEphemeralKeys)(this.session.hs.e);
        } else {
          (0, logger_1.logger)("Stage 0 - Responder waiting to receive first message...");
          const receivedMessageBuffer = (0, encoder_1.decode0)((await this.connection.readLP()).slice());
          const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
          if (!valid) {
            throw new Error("xx handshake stage 0 validation fail");
          }
          (0, logger_1.logger)("Stage 0 - Responder received first message.");
          (0, logger_1.logRemoteEphemeralKey)(this.session.hs.re);
        }
      }
      async exchange() {
        if (this.isInitiator) {
          (0, logger_1.logger)("Stage 1 - Initiator waiting to receive first message from responder...");
          const receivedMessageBuffer = (0, encoder_1.decode1)((await this.connection.readLP()).slice());
          const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
          if (!valid) {
            throw new Error("xx handshake stage 1 validation fail");
          }
          (0, logger_1.logger)("Stage 1 - Initiator received the message.");
          (0, logger_1.logRemoteEphemeralKey)(this.session.hs.re);
          (0, logger_1.logRemoteStaticKey)(this.session.hs.rs);
          (0, logger_1.logger)("Initiator going to check remote's signature...");
          try {
            const decodedPayload = await (0, utils_1.decodePayload)(plaintext);
            this.remotePeer = this.remotePeer || await (0, utils_1.getPeerIdFromPayload)(decodedPayload);
            this.remotePeer = await (0, utils_1.verifySignedPayload)(this.session.hs.rs, decodedPayload, this.remotePeer);
            this.setRemoteEarlyData(decodedPayload.data);
          } catch (e) {
            const err = e;
            throw new Error(`Error occurred while verifying signed payload: ${err.message}`);
          }
          (0, logger_1.logger)("All good with the signature!");
        } else {
          (0, logger_1.logger)("Stage 1 - Responder sending out first message with signed payload and static key.");
          const messageBuffer = this.xx.sendMessage(this.session, this.payload);
          this.connection.writeLP((0, encoder_1.encode1)(messageBuffer));
          (0, logger_1.logger)("Stage 1 - Responder sent the second handshake message with signed payload.");
          (0, logger_1.logLocalEphemeralKeys)(this.session.hs.e);
        }
      }
      async finish() {
        if (this.isInitiator) {
          (0, logger_1.logger)("Stage 2 - Initiator sending third handshake message.");
          const messageBuffer = this.xx.sendMessage(this.session, this.payload);
          this.connection.writeLP((0, encoder_1.encode2)(messageBuffer));
          (0, logger_1.logger)("Stage 2 - Initiator sent message with signed payload.");
        } else {
          (0, logger_1.logger)("Stage 2 - Responder waiting for third handshake message...");
          const receivedMessageBuffer = (0, encoder_1.decode2)((await this.connection.readLP()).slice());
          const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
          if (!valid) {
            throw new Error("xx handshake stage 2 validation fail");
          }
          (0, logger_1.logger)("Stage 2 - Responder received the message, finished handshake.");
          try {
            const decodedPayload = await (0, utils_1.decodePayload)(plaintext);
            this.remotePeer = this.remotePeer || await (0, utils_1.getPeerIdFromPayload)(decodedPayload);
            await (0, utils_1.verifySignedPayload)(this.session.hs.rs, decodedPayload, this.remotePeer);
            this.setRemoteEarlyData(decodedPayload.data);
          } catch (e) {
            const err = e;
            throw new Error(`Error occurred while verifying signed payload: ${err.message}`);
          }
        }
        (0, logger_1.logCipherState)(this.session);
      }
      encrypt(plaintext, session) {
        const cs = this.getCS(session);
        return this.xx.encryptWithAd(cs, new Uint8Array(0), plaintext);
      }
      decrypt(ciphertext, session) {
        const cs = this.getCS(session, false);
        return this.xx.decryptWithAd(cs, new Uint8Array(0), ciphertext);
      }
      getRemoteStaticKey() {
        return this.session.hs.rs;
      }
      getCS(session, encryption = true) {
        if (!session.cs1 || !session.cs2) {
          throw new Error("Handshake not completed properly, cipher state does not exist.");
        }
        if (this.isInitiator) {
          return encryption ? session.cs1 : session.cs2;
        } else {
          return encryption ? session.cs2 : session.cs1;
        }
      }
      setRemoteEarlyData(data) {
        if (data) {
          this.remoteEarlyData = data;
        }
      }
    };
    exports2.XXHandshake = XXHandshake;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/ik.js
var require_ik = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/ik.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IK = void 0;
    var utils_1 = require_utils6();
    var abstract_handshake_1 = require_abstract_handshake();
    var IK = class extends abstract_handshake_1.AbstractHandshake {
      initSession(initiator, prologue, s, rs) {
        const psk = this.createEmptyKey();
        let hs;
        if (initiator) {
          hs = this.initializeInitiator(prologue, s, rs, psk);
        } else {
          hs = this.initializeResponder(prologue, s, rs, psk);
        }
        return {
          hs,
          i: initiator,
          mc: 0
        };
      }
      sendMessage(session, message) {
        let messageBuffer;
        if (session.mc === 0) {
          messageBuffer = this.writeMessageA(session.hs, message);
        } else if (session.mc === 1) {
          const { messageBuffer: mb, h, cs1, cs2 } = this.writeMessageB(session.hs, message);
          messageBuffer = mb;
          session.h = h;
          session.cs1 = cs1;
          session.cs2 = cs2;
        } else if (session.mc > 1) {
          if (session.i) {
            if (!session.cs1) {
              throw new Error("CS1 (cipher state) is not defined");
            }
            messageBuffer = this.writeMessageRegular(session.cs1, message);
          } else {
            if (!session.cs2) {
              throw new Error("CS2 (cipher state) is not defined");
            }
            messageBuffer = this.writeMessageRegular(session.cs2, message);
          }
        } else {
          throw new Error("Session invalid.");
        }
        session.mc++;
        return messageBuffer;
      }
      recvMessage(session, message) {
        let plaintext = new Uint8Array(0);
        let valid = false;
        if (session.mc === 0) {
          ({ plaintext, valid } = this.readMessageA(session.hs, message));
        }
        if (session.mc === 1) {
          const { plaintext: pt, valid: v, h, cs1, cs2 } = this.readMessageB(session.hs, message);
          plaintext = pt;
          valid = v;
          session.h = h;
          session.cs1 = cs1;
          session.cs2 = cs2;
        }
        session.mc++;
        return { plaintext, valid };
      }
      writeMessageA(hs, payload) {
        hs.e = (0, utils_1.generateKeypair)();
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const spk = hs.s.publicKey;
        const ns = this.encryptAndHash(hs.ss, spk);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        return { ne, ns, ciphertext };
      }
      writeMessageB(hs, payload) {
        hs.e = (0, utils_1.generateKeypair)();
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        const ns = this.createEmptyKey();
        const messageBuffer = { ne, ns, ciphertext };
        const { cs1, cs2 } = this.split(hs.ss);
        return { messageBuffer, cs1, cs2, h: hs.ss.h };
      }
      readMessageA(hs, message) {
        if ((0, utils_1.isValidPublicKey)(message.ne)) {
          hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
        if (valid1 && ns.length === 32 && (0, utils_1.isValidPublicKey)(ns)) {
          hs.rs = ns;
        }
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));
        const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
        return { plaintext, valid: valid1 && valid2 };
      }
      readMessageB(hs, message) {
        if ((0, utils_1.isValidPublicKey)(message.ne)) {
          hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        if (!hs.e) {
          throw new Error("Handshake state should contain ephemeral key by now.");
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const { plaintext, valid } = this.decryptAndHash(hs.ss, message.ciphertext);
        const { cs1, cs2 } = this.split(hs.ss);
        return { h: hs.ss.h, valid, plaintext, cs1, cs2 };
      }
      initializeInitiator(prologue, s, rs, psk) {
        const name10 = "Noise_IK_25519_ChaChaPoly_SHA256";
        const ss = this.initializeSymmetric(name10);
        this.mixHash(ss, prologue);
        this.mixHash(ss, rs);
        const re = new Uint8Array(32);
        return { ss, s, rs, re, psk };
      }
      initializeResponder(prologue, s, rs, psk) {
        const name10 = "Noise_IK_25519_ChaChaPoly_SHA256";
        const ss = this.initializeSymmetric(name10);
        this.mixHash(ss, prologue);
        this.mixHash(ss, s.publicKey);
        const re = new Uint8Array(32);
        return { ss, s, rs, re, psk };
      }
    };
    exports2.IK = IK;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/errors.js
var require_errors4 = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/errors.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FailedIKError = void 0;
    var FailedIKError = class extends Error {
      constructor(initialMsg, message) {
        super(message);
        this.initialMsg = initialMsg;
        this.name = "FailedIKhandshake";
      }
    };
    exports2.FailedIKError = FailedIKError;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshake-ik.js
var require_handshake_ik = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshake-ik.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IKHandshake = void 0;
    var ik_1 = require_ik();
    var encoder_1 = require_encoder();
    var utils_1 = require_utils6();
    var errors_1 = require_errors4();
    var logger_1 = require_logger();
    var IKHandshake = class {
      constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {
        this.isInitiator = isInitiator;
        this.payload = payload;
        this.prologue = prologue;
        this.staticKeypair = staticKeypair;
        this.connection = connection;
        if (remotePeer) {
          this.remotePeer = remotePeer;
        }
        this.ik = handshake !== null && handshake !== void 0 ? handshake : new ik_1.IK();
        this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);
        this.remoteEarlyData = new Uint8Array();
      }
      async stage0() {
        (0, logger_1.logLocalStaticKeys)(this.session.hs.s);
        (0, logger_1.logRemoteStaticKey)(this.session.hs.rs);
        if (this.isInitiator) {
          (0, logger_1.logger)("IK Stage 0 - Initiator sending message...");
          const messageBuffer = this.ik.sendMessage(this.session, this.payload);
          this.connection.writeLP((0, encoder_1.encode1)(messageBuffer));
          (0, logger_1.logger)("IK Stage 0 - Initiator sent message.");
          (0, logger_1.logLocalEphemeralKeys)(this.session.hs.e);
        } else {
          (0, logger_1.logger)("IK Stage 0 - Responder receiving message...");
          const receivedMsg = await this.connection.readLP();
          try {
            const receivedMessageBuffer = (0, encoder_1.decode1)(receivedMsg.slice());
            const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);
            if (!valid) {
              throw new Error("ik handshake stage 0 decryption validation fail");
            }
            (0, logger_1.logger)("IK Stage 0 - Responder got message, going to verify payload.");
            const decodedPayload = await (0, utils_1.decodePayload)(plaintext);
            this.remotePeer = this.remotePeer || await (0, utils_1.getPeerIdFromPayload)(decodedPayload);
            await (0, utils_1.verifySignedPayload)(this.session.hs.rs, decodedPayload, this.remotePeer);
            this.setRemoteEarlyData(decodedPayload.data);
            (0, logger_1.logger)("IK Stage 0 - Responder successfully verified payload!");
            (0, logger_1.logRemoteEphemeralKey)(this.session.hs.re);
          } catch (e) {
            const err = e;
            (0, logger_1.logger)("Responder breaking up with IK handshake in stage 0.");
            throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${err.message}`);
          }
        }
      }
      async stage1() {
        if (this.isInitiator) {
          (0, logger_1.logger)("IK Stage 1 - Initiator receiving message...");
          const receivedMsg = (await this.connection.readLP()).slice();
          const receivedMessageBuffer = (0, encoder_1.decode0)(receivedMsg);
          const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);
          (0, logger_1.logger)("IK Stage 1 - Initiator got message, going to verify payload.");
          try {
            if (!valid) {
              throw new Error("ik stage 1 decryption validation fail");
            }
            const decodedPayload = await (0, utils_1.decodePayload)(plaintext);
            this.remotePeer = this.remotePeer || await (0, utils_1.getPeerIdFromPayload)(decodedPayload);
            await (0, utils_1.verifySignedPayload)(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);
            this.setRemoteEarlyData(decodedPayload.data);
            (0, logger_1.logger)("IK Stage 1 - Initiator successfully verified payload!");
            (0, logger_1.logRemoteEphemeralKey)(this.session.hs.re);
          } catch (e) {
            const err = e;
            (0, logger_1.logger)("Initiator breaking up with IK handshake in stage 1.");
            throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${err.message}`);
          }
        } else {
          (0, logger_1.logger)("IK Stage 1 - Responder sending message...");
          const messageBuffer = this.ik.sendMessage(this.session, this.payload);
          this.connection.writeLP((0, encoder_1.encode0)(messageBuffer));
          (0, logger_1.logger)("IK Stage 1 - Responder sent message...");
          (0, logger_1.logLocalEphemeralKeys)(this.session.hs.e);
        }
        (0, logger_1.logCipherState)(this.session);
      }
      decrypt(ciphertext, session) {
        const cs = this.getCS(session, false);
        return this.ik.decryptWithAd(cs, new Uint8Array(0), ciphertext);
      }
      encrypt(plaintext, session) {
        const cs = this.getCS(session);
        return this.ik.encryptWithAd(cs, new Uint8Array(0), plaintext);
      }
      getLocalEphemeralKeys() {
        if (!this.session.hs.e) {
          throw new Error("Ephemeral keys do not exist.");
        }
        return this.session.hs.e;
      }
      getCS(session, encryption = true) {
        if (!session.cs1 || !session.cs2) {
          throw new Error("Handshake not completed properly, cipher state does not exist.");
        }
        if (this.isInitiator) {
          return encryption ? session.cs1 : session.cs2;
        } else {
          return encryption ? session.cs2 : session.cs1;
        }
      }
      setRemoteEarlyData(data) {
        if (data) {
          this.remoteEarlyData = data;
        }
      }
    };
    exports2.IKHandshake = IKHandshake;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx-fallback.js
var require_handshake_xx_fallback = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx-fallback.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XXFallbackHandshake = void 0;
    var handshake_xx_1 = require_handshake_xx();
    var utils_1 = require_utils6();
    var logger_1 = require_logger();
    var encoder_1 = require_encoder();
    var XXFallbackHandshake = class extends handshake_xx_1.XXHandshake {
      constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {
        super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);
        if (ephemeralKeys) {
          this.ephemeralKeys = ephemeralKeys;
        }
        this.initialMsg = initialMsg;
      }
      async propose() {
        if (this.isInitiator) {
          this.xx.sendMessage(this.session, new Uint8Array(0), this.ephemeralKeys);
          (0, logger_1.logger)("XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.");
          (0, logger_1.logLocalEphemeralKeys)(this.session.hs.e);
        } else {
          (0, logger_1.logger)("XX Fallback Stage 0 - Responder decoding initial msg from IK.");
          const receivedMessageBuffer = (0, encoder_1.decode0)(this.initialMsg);
          const { valid } = this.xx.recvMessage(this.session, {
            ne: receivedMessageBuffer.ne,
            ns: new Uint8Array(0),
            ciphertext: new Uint8Array(0)
          });
          if (!valid) {
            throw new Error("xx fallback stage 0 decryption validation fail");
          }
          (0, logger_1.logger)("XX Fallback Stage 0 - Responder used received message from IK.");
          (0, logger_1.logRemoteEphemeralKey)(this.session.hs.re);
        }
      }
      async exchange() {
        if (this.isInitiator) {
          const receivedMessageBuffer = (0, encoder_1.decode1)(this.initialMsg);
          const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
          if (!valid) {
            throw new Error("xx fallback stage 1 decryption validation fail");
          }
          (0, logger_1.logger)("XX Fallback Stage 1 - Initiator used received message from IK.");
          (0, logger_1.logRemoteEphemeralKey)(this.session.hs.re);
          (0, logger_1.logRemoteStaticKey)(this.session.hs.rs);
          (0, logger_1.logger)("Initiator going to check remote's signature...");
          try {
            const decodedPayload = await (0, utils_1.decodePayload)(plaintext);
            this.remotePeer = this.remotePeer || await (0, utils_1.getPeerIdFromPayload)(decodedPayload);
            await (0, utils_1.verifySignedPayload)(this.session.hs.rs, decodedPayload, this.remotePeer);
            this.setRemoteEarlyData(decodedPayload.data);
          } catch (e) {
            const err = e;
            throw new Error(`Error occurred while verifying signed payload from responder: ${err.message}`);
          }
          (0, logger_1.logger)("All good with the signature!");
        } else {
          (0, logger_1.logger)("XX Fallback Stage 1 - Responder start");
          await super.exchange();
          (0, logger_1.logger)("XX Fallback Stage 1 - Responder end");
        }
      }
    };
    exports2.XXFallbackHandshake = XXFallbackHandshake;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decryptStream = exports2.encryptStream = void 0;
    var constants_1 = require_constants9();
    function encryptStream(handshake) {
      return async function* (source) {
        for await (const chunk of source) {
          for (let i = 0; i < chunk.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
            let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
            if (end > chunk.length) {
              end = chunk.length;
            }
            const data = handshake.encrypt(chunk.slice(i, end), handshake.session);
            yield data;
          }
        }
      };
    }
    exports2.encryptStream = encryptStream;
    function decryptStream(handshake) {
      return async function* (source) {
        for await (const chunk of source) {
          for (let i = 0; i < chunk.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {
            let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;
            if (end > chunk.length) {
              end = chunk.length;
            }
            const { plaintext: decrypted, valid } = await handshake.decrypt(chunk.slice(i, end), handshake.session);
            if (!valid) {
              throw new Error("Failed to validate decrypted chunk");
            }
            yield decrypted;
          }
        }
      };
    }
    exports2.decryptStream = decryptStream;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/keycache.js
var require_keycache = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/keycache.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyCache = void 0;
    var Keycache = class {
      constructor() {
        this.storage = /* @__PURE__ */ new Map();
      }
      store(peerId, key) {
        this.storage.set(peerId.id, key);
      }
      load(peerId) {
        var _a;
        if (!peerId) {
          return null;
        }
        return (_a = this.storage.get(peerId.id)) !== null && _a !== void 0 ? _a : null;
      }
      resetStorage() {
        this.storage.clear();
      }
    };
    var KeyCache = new Keycache();
    exports2.KeyCache = KeyCache;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
var require_noise = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/noise.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Noise = void 0;
    var x25519 = __importStar(require_x25519());
    var it_pb_rpc_1 = __importDefault(require_src19());
    var duplex_1 = __importDefault(require_duplex3());
    var it_buffer_1 = __importDefault(require_it_buffer());
    var it_pipe_1 = __importDefault(require_it_pipe());
    var it_length_prefixed_1 = require_src11();
    var handshake_xx_1 = require_handshake_xx();
    var handshake_ik_1 = require_handshake_ik();
    var handshake_xx_fallback_1 = require_handshake_xx_fallback();
    var utils_1 = require_utils6();
    var encoder_1 = require_encoder();
    var crypto_1 = require_crypto2();
    var keycache_1 = require_keycache();
    var logger_1 = require_logger();
    var constants_1 = require_constants9();
    var Noise = class {
      constructor(staticNoiseKey, earlyData) {
        this.protocol = "/noise";
        this.prologue = new Uint8Array(0);
        this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : new Uint8Array(0);
        this.useNoisePipes = false;
        if (staticNoiseKey) {
          const keyPair = x25519.generateKeyPairFromSeed(staticNoiseKey);
          this.staticKeys = {
            privateKey: keyPair.secretKey,
            publicKey: keyPair.publicKey
          };
        } else {
          this.staticKeys = (0, utils_1.generateKeypair)();
        }
      }
      async secureOutbound(localPeer, connection, remotePeer) {
        const wrappedConnection = (0, it_pb_rpc_1.default)(connection, {
          lengthEncoder: encoder_1.uint16BEEncode,
          lengthDecoder: encoder_1.uint16BEDecode,
          maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES
        });
        const handshake = await this.performHandshake({
          connection: wrappedConnection,
          isInitiator: true,
          localPeer,
          remotePeer
        });
        const conn = await this.createSecureConnection(wrappedConnection, handshake);
        return {
          conn,
          remoteEarlyData: handshake.remoteEarlyData,
          remotePeer: handshake.remotePeer
        };
      }
      async secureInbound(localPeer, connection, remotePeer) {
        const wrappedConnection = (0, it_pb_rpc_1.default)(connection, {
          lengthEncoder: encoder_1.uint16BEEncode,
          lengthDecoder: encoder_1.uint16BEDecode,
          maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES
        });
        const handshake = await this.performHandshake({
          connection: wrappedConnection,
          isInitiator: false,
          localPeer,
          remotePeer
        });
        const conn = await this.createSecureConnection(wrappedConnection, handshake);
        return {
          conn,
          remoteEarlyData: handshake.remoteEarlyData,
          remotePeer: handshake.remotePeer
        };
      }
      async performHandshake(params) {
        var _a;
        const payload = await (0, utils_1.getPayload)(params.localPeer, this.staticKeys.publicKey, this.earlyData);
        let tryIK = this.useNoisePipes;
        if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {
          tryIK = false;
        }
        if (tryIK) {
          const { remotePeer, connection, isInitiator } = params;
          const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, (_a = keycache_1.KeyCache.load(params.remotePeer)) !== null && _a !== void 0 ? _a : new Uint8Array(32), remotePeer);
          try {
            return await this.performIKHandshake(ikHandshake);
          } catch (e) {
            let ephemeralKeys;
            if (params.isInitiator) {
              ephemeralKeys = ikHandshake.getLocalEphemeralKeys();
            }
            return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);
          }
        } else {
          return await this.performXXHandshake(params, payload);
        }
      }
      async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {
        const { isInitiator, remotePeer, connection } = params;
        const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);
        try {
          await handshake.propose();
          await handshake.exchange();
          await handshake.finish();
        } catch (e) {
          (0, logger_1.logger)(e);
          const err = e;
          throw new Error(`Error occurred during XX Fallback handshake: ${err.message}`);
        }
        return handshake;
      }
      async performXXHandshake(params, payload) {
        const { isInitiator, remotePeer, connection } = params;
        const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);
        try {
          await handshake.propose();
          await handshake.exchange();
          await handshake.finish();
          if (this.useNoisePipes && handshake.remotePeer) {
            keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());
          }
        } catch (e) {
          const err = e;
          throw new Error(`Error occurred during XX handshake: ${err.message}`);
        }
        return handshake;
      }
      async performIKHandshake(handshake) {
        await handshake.stage0();
        await handshake.stage1();
        return handshake;
      }
      async createSecureConnection(connection, handshake) {
        const [secure, user] = (0, duplex_1.default)();
        const network = connection.unwrap();
        await (0, it_pipe_1.default)(secure, it_buffer_1.default, (0, crypto_1.encryptStream)(handshake), (0, it_length_prefixed_1.encode)({ lengthEncoder: encoder_1.uint16BEEncode }), network, (0, it_length_prefixed_1.decode)({ lengthDecoder: encoder_1.uint16BEDecode }), it_buffer_1.default, (0, crypto_1.decryptStream)(handshake), secure);
        return user;
      }
    };
    exports2.Noise = Noise;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/index.js
var require_src20 = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/index.js"(exports2) {
    "use strict";
    init_globals();
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NOISE = void 0;
    var noise_1 = require_noise();
    __exportStar(require_noise(), exports2);
    exports2.NOISE = new noise_1.Noise();
  }
});

// node_modules/k-bucket/index.js
var require_k_bucket = __commonJS({
  "node_modules/k-bucket/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var randomBytes = require_browser8();
    var { EventEmitter: EventEmitter4 } = require_events();
    function arrayEquals(array1, array2) {
      if (array1 === array2) {
        return true;
      }
      if (array1.length !== array2.length) {
        return false;
      }
      for (let i = 0, length5 = array1.length; i < length5; ++i) {
        if (array1[i] !== array2[i]) {
          return false;
        }
      }
      return true;
    }
    function createNode4() {
      return { contacts: [], dontSplit: false, left: null, right: null };
    }
    function ensureInt8(name10, val) {
      if (!(val instanceof Uint8Array)) {
        throw new TypeError(name10 + " is not a Uint8Array");
      }
    }
    var KBucket = class extends EventEmitter4 {
      constructor(options = {}) {
        super();
        this.localNodeId = options.localNodeId || randomBytes(20);
        this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20;
        this.numberOfNodesToPing = options.numberOfNodesToPing || 3;
        this.distance = options.distance || KBucket.distance;
        this.arbiter = options.arbiter || KBucket.arbiter;
        this.metadata = Object.assign({}, options.metadata);
        ensureInt8("option.localNodeId as parameter 1", this.localNodeId);
        this.root = createNode4();
      }
      static arbiter(incumbent, candidate) {
        return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate;
      }
      static distance(firstId, secondId) {
        let distance = 0;
        let i = 0;
        const min = Math.min(firstId.length, secondId.length);
        const max = Math.max(firstId.length, secondId.length);
        for (; i < min; ++i) {
          distance = distance * 256 + (firstId[i] ^ secondId[i]);
        }
        for (; i < max; ++i)
          distance = distance * 256 + 255;
        return distance;
      }
      add(contact) {
        ensureInt8("contact.id", (contact || {}).id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, contact.id, bitIndex++);
        }
        const index = this._indexOf(node, contact.id);
        if (index >= 0) {
          this._update(node, index, contact);
          return this;
        }
        if (node.contacts.length < this.numberOfNodesPerKBucket) {
          node.contacts.push(contact);
          this.emit("added", contact);
          return this;
        }
        if (node.dontSplit) {
          this.emit("ping", node.contacts.slice(0, this.numberOfNodesToPing), contact);
          return this;
        }
        this._split(node, bitIndex);
        return this.add(contact);
      }
      closest(id, n = Infinity) {
        ensureInt8("id", id);
        if (!Number.isInteger(n) && n !== Infinity || n <= 0) {
          throw new TypeError("n is not positive number");
        }
        let contacts = [];
        for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            const detNode = this._determineNode(node, id, bitIndex++);
            nodes.push(node.left === detNode ? node.right : node.left);
            nodes.push(detNode);
          } else {
            contacts = contacts.concat(node.contacts);
          }
        }
        return contacts.map((a) => [this.distance(a.id, id), a]).sort((a, b) => a[0] - b[0]).slice(0, n).map((a) => a[1]);
      }
      count() {
        let count = 0;
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            count += node.contacts.length;
        }
        return count;
      }
      _determineNode(node, id, bitIndex) {
        const bytesDescribedByBitIndex = bitIndex >> 3;
        const bitIndexWithinByte = bitIndex % 8;
        if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {
          return node.left;
        }
        const byteUnderConsideration = id[bytesDescribedByBitIndex];
        if (byteUnderConsideration & 1 << 7 - bitIndexWithinByte) {
          return node.right;
        }
        return node.left;
      }
      get(id) {
        ensureInt8("id", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        return index >= 0 ? node.contacts[index] : null;
      }
      _indexOf(node, id) {
        for (let i = 0; i < node.contacts.length; ++i) {
          if (arrayEquals(node.contacts[i].id, id))
            return i;
        }
        return -1;
      }
      remove(id) {
        ensureInt8("the id as parameter 1", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        if (index >= 0) {
          const contact = node.contacts.splice(index, 1)[0];
          this.emit("removed", contact);
        }
        return this;
      }
      _split(node, bitIndex) {
        node.left = createNode4();
        node.right = createNode4();
        for (const contact of node.contacts) {
          this._determineNode(node, contact.id, bitIndex).contacts.push(contact);
        }
        node.contacts = null;
        const detNode = this._determineNode(node, this.localNodeId, bitIndex);
        const otherNode = node.left === detNode ? node.right : node.left;
        otherNode.dontSplit = true;
      }
      toArray() {
        let result = [];
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            result = result.concat(node.contacts);
        }
        return result;
      }
      *toIterable() {
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            nodes.push(node.right, node.left);
          } else {
            yield* node.contacts;
          }
        }
      }
      _update(node, index, contact) {
        if (!arrayEquals(node.contacts[index].id, contact.id)) {
          throw new Error("wrong index for _update");
        }
        const incumbent = node.contacts[index];
        const selection = this.arbiter(incumbent, contact);
        if (selection === incumbent && incumbent !== contact)
          return;
        node.contacts.splice(index, 1);
        node.contacts.push(selection);
        this.emit("updated", incumbent, selection);
      }
    };
    module2.exports = KBucket;
  }
});

// node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "node_modules/netmask/lib/netmask.js"(exports2) {
    init_globals();
    (function() {
      var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a, b, c, d;
        a = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c = (long & 255 << 8) >>> 8;
        d = long & 255;
        return [a, b, c, d].join(".");
      };
      ip2long = function(ip) {
        var b, c, i, j, n, ref;
        b = [];
        for (i = j = 0; j <= 3; i = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob = function(s) {
        var base4, dmax, i, n, start;
        n = 0;
        base4 = 10;
        dmax = "9";
        i = 0;
        if (s.length > 1 && s[i] === "0") {
          if (s[i + 1] === "x" || s[i + 1] === "X") {
            i += 2;
            base4 = 16;
          } else if ("0" <= s[i + 1] && s[i + 1] <= "9") {
            i++;
            base4 = 8;
            dmax = "7";
          }
        }
        start = i;
        while (i < s.length) {
          if ("0" <= s[i] && s[i] <= dmax) {
            n = n * base4 + (chr(s[i]) - chr0) >>> 0;
          } else if (base4 === 16) {
            if ("a" <= s[i] && s[i] <= "f") {
              n = n * base4 + (10 + chr(s[i]) - chra) >>> 0;
            } else if ("A" <= s[i] && s[i] <= "F") {
              n = n * base4 + (10 + chr(s[i]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 4294967295) {
            throw new Error("too large");
          }
          i++;
        }
        if (i === start) {
          throw new Error("empty octet");
        }
        return [n, i];
      };
      Netmask = function() {
        function Netmask2(net, mask) {
          var error, i, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i = j = 32; j >= 0; i = --j) {
              if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                this.bitmask = i;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask2.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask2(ip);
          }
          if (ip instanceof Netmask2) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask2.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask2.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask2.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask2;
      }();
      exports2.ip2long = ip2long;
      exports2.long2ip = long2ip;
      exports2.Netmask = Netmask;
    }).call(exports2);
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    init_globals();
    (function(root) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string3, parts) {
        if (string3.indexOf("::") !== string3.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string3.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string3 = string3.replace(/%.+$/, "");
        }
        while ((lastColon = string3.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string3.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string3.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string3 = string3.replace("::", replacement);
        if (string3[0] === ":") {
          string3 = string3.slice(1);
        }
        if (string3[string3.length - 1] === ":") {
          string3 = string3.slice(0, -1);
        }
        parts = function() {
          const ref = string3.split(":");
          const results = [];
          for (let i = 0; i < ref.length; i++) {
            results.push(parseInt(ref[i], 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      }
      function matchCIDR(first4, second, partSize, cidrBits) {
        if (first4.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first4[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string3) {
        if (hexRegex.test(string3)) {
          return parseInt(string3, 16);
        }
        if (string3[0] === "0" && !isNaN(parseInt(string3[1], 10))) {
          if (octalRegex.test(string3)) {
            return parseInt(string3, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string3} as octal`);
        }
        return parseInt(string3, 10);
      }
      function padPart(part, length5) {
        while (part.length < length5) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr = {};
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3; i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string3) {
        try {
          const cidr = this.parseCIDR(string3);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.isIPv4 = function(string3) {
        return this.parser(string3) !== null;
      };
      ipaddr.IPv4.isValid = function(string3) {
        try {
          new this(this.parser(string3));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string3) {
        if (ipaddr.IPv4.isValid(string3) && string3.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string3) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string3);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.parse = function(string3) {
        const parts = this.parser(string3);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr.IPv4.parseCIDR = function(string3) {
        let match;
        if (match = string3.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.parser = function(string3) {
        let match, part, value;
        if (match = string3.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i = 0; i < ref.length; i++) {
              part = ref[i];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string3.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string3.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else if (match = string3.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0; i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0; i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7; i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes2 = [];
          const ref = this.parts;
          for (let i = 0; i < ref.length; i++) {
            part = ref[i];
            bytes2.push(part >> 8);
            bytes2.push(part & 255);
          }
          return bytes2;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string3 = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string3)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string3;
          }
          return `${string3.substring(0, bestMatchIndex)}::${string3.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        return IPv6;
      }();
      ipaddr.IPv6.broadcastAddressFromCIDR = function(string3) {
        try {
          const cidr = this.parseCIDR(string3);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.isIPv6 = function(string3) {
        return this.parser(string3) !== null;
      };
      ipaddr.IPv6.isValid = function(string3) {
        if (typeof string3 === "string" && string3.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string3);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv6.networkAddressFromCIDR = function(string3) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string3);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.parse = function(string3) {
        const addr = this.parser(string3);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv6.parseCIDR = function(string3) {
        let maskLength, match, parsed;
        if (match = string3.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.IPv6.parser = function(string3) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string3.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string3)) {
          return expandIPv6(string3, 8);
        }
        if (match = string3.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.fromByteArray = function(bytes2) {
        const length5 = bytes2.length;
        if (length5 === 4) {
          return new ipaddr.IPv4(bytes2);
        } else if (length5 === 16) {
          return new ipaddr.IPv6(bytes2);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.isValid = function(string3) {
        return ipaddr.IPv6.isValid(string3) || ipaddr.IPv4.isValid(string3);
      };
      ipaddr.parse = function(string3) {
        if (ipaddr.IPv6.isValid(string3)) {
          return ipaddr.IPv6.parse(string3);
        } else if (ipaddr.IPv4.isValid(string3)) {
          return ipaddr.IPv4.parse(string3);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string3) {
        try {
          return ipaddr.IPv6.parseCIDR(string3);
        } catch (e) {
          try {
            return ipaddr.IPv4.parseCIDR(string3);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.process = function(string3) {
        const addr = this.parse(string3);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0; i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = ipaddr;
      } else {
        root.ipaddr = ipaddr;
      }
    })(exports2);
  }
});

// node_modules/private-ip/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/private-ip/lib/index.js"(exports2) {
    "use strict";
    init_globals();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var netmask_1 = require_netmask();
    var ip_regex_1 = __importDefault(require_ip_regex());
    var is_ip_1 = __importDefault(require_is_ip());
    var ipaddr_js_1 = require_ipaddr();
    var PRIVATE_IP_RANGES = [
      "0.0.0.0/8",
      "10.0.0.0/8",
      "100.64.0.0/10",
      "127.0.0.0/8",
      "169.254.0.0/16",
      "172.16.0.0/12",
      "192.0.0.0/24",
      "192.0.0.0/29",
      "192.0.0.8/32",
      "192.0.0.9/32",
      "192.0.0.10/32",
      "192.0.0.170/32",
      "192.0.0.171/32",
      "192.0.2.0/24",
      "192.31.196.0/24",
      "192.52.193.0/24",
      "192.88.99.0/24",
      "192.168.0.0/16",
      "192.175.48.0/24",
      "198.18.0.0/15",
      "198.51.100.0/24",
      "203.0.113.0/24",
      "240.0.0.0/4",
      "255.255.255.255/32"
    ];
    var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ip_range) => new netmask_1.Netmask(ip_range));
    function ipv4_check(ip_addr) {
      for (let r of NETMASK_RANGES) {
        if (r.contains(ip_addr))
          return true;
      }
      return false;
    }
    function ipv6_check(ip_addr) {
      return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
    }
    exports2.default = (ip) => {
      if (ipaddr_js_1.isValid(ip)) {
        const parsed = ipaddr_js_1.parse(ip);
        if (parsed.kind() === "ipv4")
          return ipv4_check(parsed.toNormalizedString());
        else if (parsed.kind() === "ipv6")
          return ipv6_check(ip);
      } else if (is_ip_1.default(ip) && ip_regex_1.default.v6().test(ip))
        return ipv6_check(ip);
      return void 0;
    };
  }
});

// node_modules/private-ip/index.js
var require_private_ip = __commonJS({
  "node_modules/private-ip/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = require_lib7().default;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/utils.js
var require_utils7 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/utils.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    var { base58btc: base58btc3 } = (init_base58(), __toCommonJS(base58_exports));
    var { base32: base323 } = (init_base32(), __toCommonJS(base32_exports));
    var { Key: Key2 } = (init_key(), __toCommonJS(key_exports));
    var { Record: Record2 } = require_src7();
    var PeerId14 = require_src5();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { concat: uint8ArrayConcat } = (init_concat(), __toCommonJS(concat_exports));
    var isPrivateIp = require_private_ip();
    var PK_PREFIX = uint8ArrayFromString("/pk/");
    function removePrivateAddresses({ id, multiaddrs }) {
      return {
        id,
        multiaddrs: multiaddrs.filter((multiaddr) => {
          const [[type, addr]] = multiaddr.stringTuples();
          if (type !== 4 && type !== 6) {
            return false;
          }
          return !isPrivateIp(addr);
        })
      };
    }
    function removePublicAddresses({ id, multiaddrs }) {
      return {
        id,
        multiaddrs: multiaddrs.filter((multiaddr) => {
          const [[type, addr]] = multiaddr.stringTuples();
          if (type !== 4 && type !== 6) {
            return false;
          }
          return isPrivateIp(addr);
        })
      };
    }
    var convertBuffer = async (buf3) => {
      return (await sha2563.digest(buf3)).digest;
    };
    var convertPeerId = async (peer) => {
      return (await sha2563.digest(peer.id)).digest;
    };
    var bufferToKey = (buf3) => {
      return new Key2("/" + uint8ArrayToString(buf3, "base32"), false);
    };
    var keyForPublicKey = (peer) => {
      return uint8ArrayConcat([
        PK_PREFIX,
        peer.id
      ]);
    };
    var isPublicKeyKey = (key) => {
      return uint8ArrayToString(key.slice(0, 4)) === "/pk/";
    };
    var isIPNSKey = (key) => {
      return uint8ArrayToString(key.slice(0, 4)) === "/ipns/";
    };
    var fromPublicKeyKey = (key) => {
      return new PeerId14(key.slice(4));
    };
    var createPutRecord = (key, value) => {
      const timeReceived = new Date();
      const rec = new Record2(key, value, timeReceived);
      return rec.serialize();
    };
    var logger2 = (name10) => {
      debug50.formatters.b = (v) => {
        return base58btc3.baseEncode(v);
      };
      debug50.formatters.t = (v) => {
        return base323.baseEncode(v);
      };
      debug50.formatters.p = (p) => {
        return p.toB58String();
      };
      const logger3 = Object.assign(debug50(name10), {
        error: debug50(`${name10}:error`)
      });
      return logger3;
    };
    module2.exports = {
      removePrivateAddresses,
      removePublicAddresses,
      convertBuffer,
      convertPeerId,
      bufferToKey,
      keyForPublicKey,
      isPublicKeyKey,
      isIPNSKey,
      fromPublicKeyKey,
      createPutRecord,
      logger: logger2
    };
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/constants.js
var require_constants10 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/constants.js"(exports2) {
    "use strict";
    init_globals();
    var second = exports2.second = 1e3;
    var minute2 = exports2.minute = 60 * second;
    var hour2 = exports2.hour = 60 * minute2;
    exports2.MAX_RECORD_AGE = 36 * hour2;
    exports2.PROTOCOL_DHT = "/kad/1.0.0";
    exports2.RECORD_KEY_PREFIX = "/dht/record";
    exports2.PROVIDER_KEY_PREFIX = "/dht/provider";
    exports2.PROVIDERS_LRU_CACHE_SIZE = 256;
    exports2.PROVIDERS_VALIDITY = 24 * hour2;
    exports2.PROVIDERS_CLEANUP_INTERVAL = hour2;
    exports2.READ_MESSAGE_TIMEOUT = 10 * second;
    exports2.GET_MANY_RECORD_COUNT = 16;
    exports2.K = 20;
    exports2.ALPHA = 3;
    exports2.QUERY_SELF_INTERVAL = Number(5 * minute2);
    exports2.QUERY_SELF_TIMEOUT = Number(30 * second);
    exports2.TABLE_REFRESH_INTERVAL = Number(5 * minute2);
    exports2.TABLE_REFRESH_QUERY_TIMEOUT = Number(30 * second);
    exports2.DEFAULT_QUERY_TIMEOUT = Number(30 * second);
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/routing-table/index.js
var require_routing_table = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/routing-table/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var KBuck = require_k_bucket();
    var utils = require_utils7();
    var { default: Queue4 } = require_dist();
    var { PROTOCOL_DHT } = require_constants10();
    var { TimeoutController: TimeoutController3 } = require_timeout_abort_controller();
    var METRIC_ROUTING_TABLE_SIZE = "routing-table-size";
    var RoutingTable = class {
      constructor({ peerId, dialer, kBucketSize, pingTimeout, lan, metrics }) {
        this._log = utils.logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table`);
        this._peerId = peerId;
        this._dialer = dialer;
        this._kBucketSize = kBucketSize || 20;
        this._pingTimeout = pingTimeout || 1e4;
        this._lan = lan;
        this._metrics = metrics;
        this.kb;
        this.commonPrefixLengthRefreshedAt = [];
        this._onPing = this._onPing.bind(this);
        this._pingQueue = new Queue4({ concurrency: 1 });
        this._running = false;
      }
      async start() {
        this._running = true;
        this.kb = new KBuck({
          localNodeId: await utils.convertPeerId(this._peerId),
          numberOfNodesPerKBucket: this._kBucketSize,
          numberOfNodesToPing: 1
        });
        this.kb.on("ping", this._onPing);
      }
      async stop() {
        this._running = false;
        this._pingQueue.clear();
      }
      _onPing(oldContacts, newContact) {
        this._pingQueue.add(async () => {
          if (!this._running) {
            return;
          }
          let responded = 0;
          try {
            await Promise.all(oldContacts.map(async (oldContact) => {
              let timeoutController;
              try {
                timeoutController = new TimeoutController3(this._pingTimeout);
                this._log(`pinging old contact ${oldContact.peer}`);
                const { stream } = await this._dialer.dialProtocol(oldContact.peer, PROTOCOL_DHT, {
                  signal: timeoutController.signal
                });
                await stream.close();
                responded++;
              } catch (err) {
                if (this._running) {
                  this._log.error("could not ping peer %p", oldContact.peer, err);
                  this._log(`evicting old contact after ping failed ${oldContact.peer}`);
                  this.kb.remove(oldContact.id);
                }
              } finally {
                if (timeoutController) {
                  timeoutController.clear();
                }
                this._metrics && this._metrics.updateComponentMetric({ component: `kad-dht-${this._lan ? "lan" : "wan"}`, metric: METRIC_ROUTING_TABLE_SIZE, value: this.size });
              }
            }));
            if (this._running && responded < oldContacts.length) {
              this._log(`adding new contact ${newContact.peer}`);
              this.kb.add(newContact);
            }
          } catch (err) {
            this._log.error("could not process k-bucket ping event", err);
          }
        });
      }
      get size() {
        return this.kb.count();
      }
      async find(peer) {
        const key = await utils.convertPeerId(peer);
        const closest = this.closestPeer(key);
        if (closest && peer.equals(closest)) {
          return closest;
        }
      }
      closestPeer(key) {
        const res = this.closestPeers(key, 1);
        if (res.length > 0) {
          return res[0];
        }
      }
      closestPeers(key, count = this._kBucketSize) {
        const closest = this.kb.closest(key, count);
        return closest.map((p) => p.peer);
      }
      async add(peer) {
        const id = await utils.convertPeerId(peer);
        this.kb.add({ id, peer });
        this._log("added %p with kad id %b", peer, id);
        this._metrics && this._metrics.updateComponentMetric({ component: `kad-dht-${this._lan ? "lan" : "wan"}`, metric: METRIC_ROUTING_TABLE_SIZE, value: this.size });
      }
      async remove(peer) {
        const id = await utils.convertPeerId(peer);
        this.kb.remove(id);
        this._metrics && this._metrics.updateComponentMetric({ component: `kad-dht-${this._lan ? "lan" : "wan"}`, metric: METRIC_ROUTING_TABLE_SIZE, value: this.size });
      }
    };
    module2.exports.RoutingTable = RoutingTable;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/routing-table/generated-prefix-list-browser.json
var require_generated_prefix_list_browser = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/routing-table/generated-prefix-list-browser.json"(exports2, module2) {
    module2.exports = [
      77591,
      22417,
      43971,
      28421,
      740,
      29829,
      71467,
      228973,
      196661,
      78537,
      27689,
      36431,
      44415,
      14362,
      19456,
      106025,
      96308,
      2882,
      49509,
      21149,
      87173,
      131409,
      75844,
      23676,
      121838,
      30291,
      17492,
      2953,
      7564,
      110620,
      129477,
      127283,
      53113,
      72417,
      165166,
      109690,
      21200,
      102125,
      24049,
      71504,
      90342,
      25307,
      72039,
      26812,
      26715,
      32264,
      133800,
      71161,
      88956,
      171987,
      51779,
      24425,
      16671,
      30251,
      186294,
      247761,
      14202,
      2121,
      8465,
      35024,
      4876,
      85917,
      169730,
      3638,
      256836,
      96184,
      943,
      18678,
      6583,
      52907,
      35807,
      112254,
      214097,
      18796,
      11595,
      9243,
      23554,
      887,
      268203,
      382004,
      24590,
      111335,
      11625,
      16619,
      29039,
      102425,
      69006,
      97976,
      92362,
      32552,
      63717,
      41433,
      128974,
      137630,
      59943,
      10019,
      13986,
      35430,
      33665,
      108037,
      43799,
      43280,
      38195,
      29078,
      58629,
      18265,
      14425,
      46832,
      235538,
      40830,
      77881,
      110717,
      58937,
      3463,
      325358,
      51300,
      47623,
      117252,
      19007,
      10170,
      20540,
      91237,
      294813,
      4951,
      79841,
      56232,
      36270,
      128547,
      69209,
      66275,
      100156,
      32063,
      73531,
      34439,
      80937,
      28892,
      44466,
      88595,
      216307,
      32583,
      49620,
      16605,
      82127,
      45807,
      21630,
      78726,
      20235,
      40163,
      111007,
      96926,
      5567,
      72083,
      21665,
      58844,
      39419,
      179767,
      48328,
      42662,
      51550,
      5251,
      37811,
      49608,
      81056,
      50854,
      55513,
      20922,
      18891,
      197409,
      164656,
      32593,
      71449,
      220474,
      58919,
      85682,
      67854,
      13758,
      35066,
      3565,
      61905,
      214793,
      119572,
      141419,
      21504,
      10302,
      27354,
      67003,
      46131,
      32668,
      15165,
      64871,
      34450,
      17821,
      2757,
      11452,
      34189,
      5160,
      12257,
      85523,
      560,
      53385,
      65887,
      119549,
      135620,
      312353,
      115979,
      122356,
      10867,
      193231,
      124537,
      54783,
      90675,
      120791,
      4715,
      142253,
      50943,
      17271,
      43358,
      25331,
      4917,
      120566,
      34580,
      12878,
      33786,
      160528,
      32523,
      4869,
      301307,
      104817,
      81491,
      23276,
      8832,
      97911,
      31265,
      52065,
      7998,
      49622,
      9715,
      43998,
      34091,
      84587,
      20664,
      69041,
      29419,
      53205,
      10838,
      58288,
      116145,
      6185,
      5154,
      141795,
      35924,
      21307,
      144738,
      43730,
      12085,
      8279,
      10002,
      119,
      133779,
      199668,
      72938,
      31768,
      39176,
      67875,
      38453,
      9700,
      44144,
      4121,
      116048,
      41733,
      12868,
      82669,
      92308,
      128,
      34262,
      11332,
      7712,
      90764,
      36141,
      13553,
      71312,
      77470,
      117314,
      96549,
      49135,
      23602,
      54468,
      28605,
      6327,
      62308,
      17171,
      67531,
      21319,
      14105,
      894,
      107722,
      46157,
      8503,
      51069,
      100472,
      45138,
      15246,
      14577,
      35609,
      191464,
      1757,
      13364,
      161349,
      32067,
      91705,
      81144,
      52339,
      5408,
      91066,
      21983,
      14157,
      100545,
      4372,
      26630,
      129112,
      1423,
      29676,
      213626,
      4397,
      88436,
      99190,
      6877,
      49958,
      26122,
      114348,
      60661,
      29818,
      293118,
      50042,
      179738,
      16400,
      163423,
      89627,
      31040,
      43973,
      36638,
      45952,
      5153,
      1894,
      109322,
      1898,
      134021,
      12402,
      112077,
      68309,
      190269,
      69866,
      31938,
      107383,
      11522,
      105232,
      11248,
      14868,
      39852,
      71707,
      186525,
      16530,
      38162,
      106212,
      11700,
      5130,
      16608,
      26998,
      59586,
      108399,
      230033,
      43683,
      48135,
      82179,
      2073,
      5015,
      196684,
      189293,
      16378,
      23452,
      8301,
      35640,
      11632,
      214551,
      29240,
      57644,
      33137,
      91949,
      55157,
      52384,
      117313,
      5090,
      17717,
      89668,
      49363,
      82238,
      241035,
      66216,
      29066,
      184088,
      97206,
      62820,
      26595,
      4241,
      135635,
      173672,
      8202,
      459,
      71355,
      146294,
      29587,
      3008,
      135385,
      141203,
      14803,
      6634,
      45094,
      69362,
      50925,
      546,
      51884,
      62011,
      83296,
      234584,
      44515,
      56050,
      89476,
      87751,
      19373,
      12691,
      149923,
      19794,
      13833,
      35846,
      87557,
      58339,
      2884,
      19145,
      25647,
      12224,
      11024,
      77338,
      64608,
      122297,
      53025,
      7205,
      36189,
      36294,
      170779,
      21750,
      7739,
      173883,
      75192,
      35664,
      224240,
      113121,
      30181,
      26267,
      27036,
      117827,
      92015,
      106516,
      55628,
      203549,
      67949,
      60462,
      60844,
      35911,
      20457,
      1820,
      920,
      19773,
      8738,
      73173,
      181993,
      38521,
      98254,
      76257,
      46008,
      92796,
      5384,
      26868,
      151566,
      22124,
      2411,
      15919,
      186872,
      180021,
      28099,
      152961,
      78811,
      80237,
      62352,
      102653,
      74259,
      184890,
      16792,
      123702,
      224945,
      29940,
      19512,
      75283,
      14059,
      112691,
      92811,
      233329,
      20411,
      138569,
      53341,
      109802,
      50600,
      134528,
      66747,
      5529,
      166531,
      31578,
      64732,
      67189,
      1596,
      126357,
      967,
      167999,
      206598,
      109752,
      119431,
      207825,
      78791,
      91938,
      10301,
      27311,
      24233,
      252343,
      28831,
      32812,
      66002,
      112267,
      90895,
      8786,
      8095,
      16824,
      22866,
      21813,
      60507,
      174833,
      19549,
      130985,
      117051,
      52110,
      6938,
      81923,
      123864,
      38061,
      919,
      18680,
      53534,
      46739,
      112893,
      161529,
      85429,
      26761,
      11900,
      81121,
      91968,
      15390,
      217947,
      56524,
      1713,
      6654,
      37089,
      85630,
      138866,
      61850,
      16491,
      75577,
      16884,
      98296,
      73523,
      6140,
      44645,
      6062,
      36366,
      29844,
      57946,
      37932,
      42472,
      5266,
      20834,
      19309,
      33753,
      127182,
      134259,
      35810,
      41805,
      45878,
      312001,
      14881,
      47757,
      49251,
      120050,
      44252,
      3708,
      25856,
      107864,
      120347,
      1228,
      36550,
      41682,
      34496,
      47025,
      8393,
      173365,
      246526,
      12894,
      161607,
      35670,
      90785,
      126572,
      2095,
      124731,
      157033,
      58694,
      554,
      12786,
      9642,
      4817,
      16136,
      47864,
      174698,
      66992,
      4639,
      69284,
      10625,
      40710,
      27763,
      51738,
      30404,
      264105,
      137904,
      109882,
      52487,
      42824,
      57514,
      2740,
      10479,
      146799,
      107390,
      16586,
      88038,
      174951,
      9410,
      16185,
      44158,
      5568,
      40658,
      46108,
      12763,
      97385,
      26175,
      108859,
      664,
      230732,
      67470,
      46663,
      14395,
      50750,
      141320,
      93140,
      15361,
      47997,
      55784,
      6791,
      307840,
      118569,
      107326,
      18056,
      58281,
      260415,
      54691,
      8790,
      73332,
      45633,
      7511,
      45674,
      143373,
      14031,
      11799,
      94491,
      35646,
      96544,
      14560,
      26049,
      32983,
      25791,
      83814,
      42094,
      231370,
      63955,
      139212,
      2359,
      169908,
      3108,
      183486,
      105867,
      28197,
      32941,
      124968,
      26402,
      88267,
      149768,
      23053,
      3078,
      19091,
      52924,
      25383,
      19209,
      111548,
      97361,
      3959,
      24880,
      235061,
      9099,
      24921,
      161254,
      151405,
      20508,
      7159,
      34381,
      20133,
      11434,
      74036,
      19974,
      34769,
      36585,
      1076,
      22454,
      17354,
      38727,
      235160,
      111547,
      96454,
      117448,
      156940,
      91330,
      37299,
      7310,
      26915,
      117060,
      51369,
      22620,
      61861,
      322264,
      106850,
      111694,
      15091,
      2624,
      40345,
      300446,
      177064,
      1707,
      27389,
      54792,
      327783,
      132669,
      183543,
      59003,
      17744,
      20603,
      151134,
      106923,
      53084,
      71803,
      279424,
      319816,
      11579,
      21946,
      16728,
      38274,
      72711,
      5085,
      83391,
      88646,
      40159,
      25027,
      34680,
      10752,
      12988,
      54126,
      30365,
      18338,
      100445,
      230674,
      44874,
      84974,
      143877,
      123253,
      139372,
      28082,
      91477,
      144002,
      13096,
      219729,
      46016,
      50029,
      42377,
      14601,
      6660,
      58244,
      58978,
      23918,
      88206,
      113611,
      64452,
      17541,
      41032,
      10942,
      12021,
      49189,
      10978,
      40175,
      37156,
      10947,
      71709,
      106894,
      112538,
      57007,
      137486,
      150608,
      152719,
      40615,
      7746,
      279716,
      13101,
      19524,
      28708,
      40578,
      72320,
      1096,
      182051,
      94527,
      51275,
      22833,
      45164,
      81917,
      77519,
      48508,
      5421,
      140302,
      37845,
      149830,
      5587,
      27579,
      5357,
      428725,
      248187,
      6326,
      206760,
      39814,
      32585,
      89923,
      44341,
      288753,
      284443,
      96368,
      31201,
      94189,
      119504,
      20359,
      52073,
      103216,
      179,
      27934,
      32801,
      96035,
      34111,
      34309,
      101326,
      18198,
      20704,
      210266,
      37643,
      27880,
      141873,
      106e3,
      19414,
      56614,
      167714,
      66483,
      107885,
      86602,
      4379,
      20796,
      75467,
      4987,
      5017,
      118857,
      26003,
      34308,
      114428,
      29198,
      6686,
      29697,
      73632,
      3739,
      69795,
      16798,
      41504,
      7207,
      30722,
      21436,
      36735,
      28067,
      28545,
      3239,
      11221,
      36031,
      41889,
      100010,
      19247,
      317673,
      29495,
      174554,
      6424,
      129725,
      53845,
      94986,
      7955,
      59676,
      2604,
      191497,
      19735,
      102214,
      62954,
      23844,
      11872,
      179525,
      261436,
      34492,
      428,
      78404,
      142035,
      16747,
      17246,
      27578,
      37021,
      33672,
      57944,
      26056,
      135760,
      2369,
      61674,
      122066,
      31327,
      19374,
      157065,
      40553,
      130982,
      69619,
      71290,
      38855,
      72100,
      92903,
      95940,
      51422,
      165999,
      65713,
      57873,
      50726,
      7288,
      20272,
      2081,
      42326,
      22624,
      81120,
      57914,
      79352,
      19447,
      1684,
      72302,
      11774,
      302559,
      161481,
      96396,
      13692,
      414988,
      3721,
      79066,
      56627,
      46883,
      21150,
      11747,
      12184,
      5856,
      113458,
      176117,
      84416,
      52079,
      27933,
      3354,
      59765,
      141359,
      2212,
      216309,
      2555,
      23458,
      196722,
      142463,
      45701,
      44548,
      28798,
      19418,
      215,
      29916,
      9396,
      10574,
      114226,
      84475,
      13520,
      18694,
      34056,
      4524,
      90302,
      62930,
      13539,
      19407,
      77209,
      7728,
      38088,
      9535,
      2263,
      23875,
      183945,
      17750,
      26274,
      67172,
      10585,
      28042,
      22199,
      7478,
      51331,
      66030,
      26774,
      192929,
      31434,
      25850,
      50197,
      52926,
      178158,
      4679,
      181256,
      70184,
      229600,
      9959,
      105594,
      72158,
      73974,
      2726,
      35085,
      78087,
      23284,
      35568,
      51713,
      155676,
      5401,
      27254,
      11966,
      17569,
      223253,
      71993,
      103357,
      111477,
      55722,
      30504,
      26034,
      46774,
      35392,
      36285,
      214814,
      41143,
      163465,
      1051,
      16094,
      81044,
      6636,
      76489,
      179102,
      20712,
      39178,
      35683,
      125177,
      54219,
      30617,
      52994,
      25324,
      50123,
      2543,
      87529,
      58995,
      10688,
      125199,
      12388,
      60158,
      125481,
      131646,
      7642,
      133350,
      65874,
      3438,
      97277,
      101450,
      10075,
      56344,
      116821,
      50778,
      60547,
      98016,
      106135,
      13859,
      14255,
      16300,
      77373,
      173521,
      8285,
      45932,
      37426,
      4054,
      114295,
      55947,
      7703,
      39114,
      52,
      51119,
      128135,
      19714,
      60715,
      9554,
      50492,
      88180,
      2823,
      118271,
      52993,
      122625,
      97919,
      23859,
      37895,
      25040,
      33614,
      32102,
      20431,
      3577,
      9275,
      15686,
      43031,
      157741,
      110358,
      1884,
      40291,
      125391,
      13736,
      5008,
      64881,
      87336,
      77381,
      70711,
      43032,
      49155,
      118587,
      70494,
      4318,
      10168,
      30126,
      12580,
      10524,
      280104,
      104001,
      145413,
      2862,
      84140,
      6603,
      106005,
      13566,
      12780,
      11251,
      42830,
      571,
      179910,
      82443,
      13146,
      469,
      42714,
      32591,
      265217,
      424024,
      92553,
      54721,
      134100,
      6007,
      15242,
      114681,
      59030,
      16718,
      85465,
      200214,
      85982,
      55174,
      165013,
      23493,
      56964,
      82529,
      109150,
      32706,
      27568,
      82442,
      5350,
      14976,
      13165,
      44890,
      60021,
      21343,
      33978,
      17264,
      4655,
      22328,
      27819,
      75730,
      16567,
      55483,
      14510,
      17926,
      45827,
      150609,
      3704,
      7385,
      272531,
      161543,
      76904,
      122163,
      52405,
      2039,
      19165,
      41623,
      14423,
      228354,
      3369,
      176360,
      85491,
      7122,
      35789,
      303724,
      4465,
      13628,
      2233,
      55311,
      118771,
      20713,
      10006,
      221519,
      45115,
      71021,
      35650,
      29775,
      7337,
      10864,
      20665,
      21142,
      1746,
      15080,
      1624,
      32449,
      10905,
      105743,
      229797,
      7701,
      3940,
      22997,
      178467,
      57208,
      389057,
      39683,
      59403,
      63344,
      63125,
      54847,
      69691,
      18336,
      56448,
      3362,
      37202,
      18282,
      29648,
      138224,
      35867,
      10495,
      5911,
      28814,
      26653,
      31514,
      176702,
      26550,
      45621,
      11734,
      4525,
      40543,
      73944,
      121080,
      27858,
      155561,
      14887,
      44670,
      30742,
      8796,
      107455,
      113472,
      56369,
      75581,
      183777,
      240095,
      133699,
      153299,
      8768,
      160464,
      26058,
      49078,
      103971,
      21875,
      71486,
      44888,
      17156,
      9678,
      89541,
      123019,
      102337,
      3972,
      83930,
      21245,
      87852,
      109660,
      287918,
      183019,
      686,
      10100,
      39177,
      283941,
      11274,
      24736,
      26793,
      26214,
      25995,
      77011,
      141580,
      4070,
      23742,
      46285,
      46632,
      30700,
      26669,
      19056,
      35951,
      115575,
      174034,
      56097,
      35463,
      87425,
      24575,
      44245,
      38701,
      82317,
      85922,
      281616,
      100333,
      147697,
      61503,
      7730,
      84330,
      8530,
      59917,
      61597,
      17173,
      9092,
      32658,
      90288,
      193136,
      39023,
      20381,
      56654,
      31132,
      7779,
      1919,
      1375,
      117128,
      30819,
      11169,
      40938,
      23935,
      115201,
      101155,
      151034,
      4835,
      11231,
      74550,
      89388,
      59951,
      91704,
      107312,
      167882,
      115062,
      12732,
      72738,
      88703,
      464019,
      158267,
      57995,
      60496,
      737,
      14371,
      123867,
      4174,
      243339,
      159946,
      7568,
      16025,
      134556,
      110916,
      38103,
      191,
      80226,
      88794,
      29688,
      27230,
      10454,
      76308,
      57647,
      77409,
      113483,
      66864,
      14745,
      19808,
      12023,
      46583,
      84805,
      16015,
      17102,
      2231,
      20611,
      3547,
      95740,
      250131,
      34559,
      108894,
      8498,
      15853,
      159169,
      148920,
      20942,
      2813,
      93160,
      45188,
      210613,
      45531,
      52587,
      149062,
      39782,
      28194,
      57849,
      60965,
      84954,
      89766,
      84453,
      100927,
      16501,
      27658,
      165311,
      103841,
      54192,
      207341,
      19558,
      20084,
      319622,
      5672,
      205467,
      98462,
      61849,
      36279,
      13609,
      147177,
      24726,
      165015,
      209489,
      59591,
      31157,
      6551,
      117580,
      75060,
      141146,
      277310,
      21072,
      22023,
      106474,
      63041,
      137443,
      122965,
      68371,
      5383,
      42146,
      98961,
      113467,
      30863,
      23794,
      4843,
      99630,
      30392,
      82679,
      13699,
      241612,
      33601,
      93146,
      24319,
      18643,
      32155,
      95669,
      40440,
      15333,
      34089,
      67799,
      142144,
      58245,
      38633,
      114531,
      117400,
      77861,
      188726,
      5507,
      2568,
      8853,
      10987,
      107222,
      2663,
      2421,
      11530,
      13345,
      30075,
      41785,
      118661,
      104786,
      17459,
      12490,
      16281,
      71936,
      193555,
      17431,
      5944,
      71758,
      26485,
      77317,
      20803,
      367167,
      158,
      7362,
      93430,
      11735,
      172445,
      46002,
      11532,
      54482,
      930,
      62911,
      2235,
      23004,
      179236,
      4764,
      101859,
      208113,
      22477,
      55163,
      95579,
      14098,
      67320,
      162556,
      90709,
      156949,
      3826,
      57492,
      4025,
      34092,
      87442,
      104565,
      6718,
      186015,
      28214,
      14209,
      10039,
      107186,
      233912,
      58877,
      81637,
      55265,
      39828,
      6194,
      145813,
      50831,
      105849,
      4974,
      88319,
      122296,
      10272,
      197216,
      95714,
      51540,
      72418,
      23324,
      91555,
      8743,
      140452,
      250249,
      51666,
      34124,
      7229,
      38592,
      129641,
      78169,
      174242,
      22464,
      149964,
      51450,
      14034,
      10026,
      95376,
      26190,
      120062,
      14401,
      8700,
      265,
      31386,
      143573,
      7203,
      229889,
      61567,
      4227,
      140981,
      2466,
      72052,
      10787,
      10062,
      30958,
      6099,
      38471,
      30103,
      23202,
      208101,
      70847,
      467,
      58934,
      32271,
      32984,
      36637,
      24107,
      30771,
      17109,
      73353,
      13650,
      2098,
      157040,
      67366,
      66904,
      106018,
      265380,
      107238,
      18535,
      44025,
      32681,
      144983,
      62505,
      91295,
      56120,
      3082,
      77508,
      10322,
      63023,
      36700,
      81885,
      224127,
      16721,
      45023,
      239261,
      111272,
      13852,
      7866,
      149243,
      204199,
      32309,
      22084,
      42029,
      38316,
      126644,
      104973,
      14406,
      43454,
      67322,
      61310,
      15789,
      40285,
      24026,
      181047,
      6301,
      70927,
      23319,
      115823,
      27248,
      66693,
      115875,
      278566,
      63007,
      146844,
      56841,
      59007,
      87368,
      180001,
      22370,
      42114,
      80605,
      12022,
      10374,
      308,
      25079,
      14689,
      12618,
      63368,
      7936,
      264973,
      212291,
      136713,
      95999,
      105801,
      18965,
      32075,
      48700,
      52230,
      35119,
      96912,
      32992,
      8586,
      16606,
      101333,
      101812,
      14969,
      39930,
      759,
      193090,
      27387,
      42914,
      12937,
      5058,
      62646,
      64528,
      38624,
      25743,
      37502,
      3716,
      4435,
      30352,
      178687,
      26461,
      132611,
      42002,
      138442,
      35833,
      59582,
      16345,
      8048,
      60319,
      49349,
      309,
      47800,
      49739,
      90482,
      26405,
      34470,
      63786,
      32479,
      85028,
      39866,
      47846,
      11649,
      23934,
      29466,
      2816,
      42864,
      31828,
      7410,
      74885,
      49632,
      47629,
      111801,
      90749,
      19536,
      18767,
      105764,
      59606,
      21223,
      10746,
      76298,
      22220,
      39408,
      7190,
      79654,
      64856,
      11602,
      82156,
      272765,
      17079,
      70089,
      245473,
      51813,
      184407,
      384678,
      1576,
      122249,
      5064,
      27481,
      6188,
      25790,
      74361,
      27541,
      318284,
      45430,
      31488,
      620,
      93579,
      45723,
      192118,
      22670,
      51913,
      4162,
      70244,
      35966,
      26397,
      16199,
      50899,
      209613,
      121702,
      287507,
      2993,
      36101,
      132229,
      67345,
      33062,
      76295,
      118628,
      78705,
      52316,
      34375,
      107083,
      107454,
      44863,
      127561,
      33964,
      3073,
      154010,
      190914,
      55967,
      39074,
      6272,
      31047,
      5550,
      41123,
      26154,
      98638,
      47110,
      19998,
      148091,
      50229,
      31329,
      59900,
      195442,
      19106,
      61347,
      73497,
      70015,
      682,
      45850,
      25776,
      38022,
      148951,
      6288,
      37411,
      232526,
      109277,
      27286,
      32342,
      9262,
      5220,
      16651,
      23175,
      46740,
      129438,
      78614,
      121925,
      66914,
      88710,
      127952,
      5563,
      21500,
      34521,
      10739,
      14863,
      191006,
      62956,
      17359,
      16749,
      67027,
      56284,
      69134,
      43301,
      35039,
      58883,
      54466,
      60823,
      404451,
      75743,
      59856,
      86979,
      7923,
      34273,
      83785,
      32142,
      7693,
      268986,
      197428,
      282681,
      17049,
      22346,
      22990,
      92245,
      107180,
      3357,
      37104,
      96724,
      49153,
      7683,
      31197,
      43267,
      82231,
      164276,
      23696,
      20848,
      188364,
      22309,
      24821,
      158707,
      1018,
      22514,
      70922,
      27792,
      45589,
      59709,
      10765,
      736,
      35218,
      63479,
      51987,
      24275,
      63588,
      55361,
      92929,
      81964,
      4658,
      20122,
      12330,
      44058,
      13065,
      311456,
      72224,
      8337,
      211229,
      38979,
      22590,
      138478,
      52757,
      32595,
      133600,
      8838,
      31549,
      94412,
      43391,
      90056,
      1585,
      94802,
      127271,
      6223,
      31889,
      137038,
      132910,
      2165,
      57616,
      230152,
      6080,
      10748,
      36737,
      74579,
      134062,
      50525,
      180532,
      119270,
      34556,
      76155,
      82394,
      52595,
      29258,
      31435,
      87820,
      67996,
      26943,
      183878,
      38007,
      2410,
      13526,
      180297,
      69856,
      3503,
      187396,
      167700,
      7838,
      16701,
      9199,
      56267,
      3661,
      37407,
      65994,
      23767,
      5708,
      62508,
      221700,
      67088,
      86978,
      46776,
      84434,
      32088,
      5612,
      9149,
      88244,
      21685,
      95151,
      46750,
      189612,
      2979,
      506311,
      2594,
      3628,
      40074,
      105039,
      78243,
      28523,
      6651,
      38058,
      71999,
      30992,
      12764,
      68261,
      108991,
      6165,
      26450,
      61961,
      13400,
      22426,
      7490,
      60890,
      109623,
      2070,
      12958,
      50355,
      67979,
      257096,
      7213,
      42578,
      52121,
      35716,
      65461,
      7516,
      124758,
      39268,
      302,
      64712,
      14977,
      1467,
      219452,
      2840,
      34229,
      11121,
      21602,
      19270,
      63574,
      8024,
      1532,
      17331,
      79839,
      78885,
      52029,
      180767,
      57957,
      6069,
      91265,
      61380,
      55767,
      8927,
      32881,
      287603,
      22149,
      35029,
      68876,
      6428,
      199567,
      46926,
      13412,
      104132,
      21434,
      366616,
      45060,
      110046,
      81924,
      128910,
      45886,
      52821,
      130416,
      29416,
      77342,
      21762,
      67329,
      121432,
      79924,
      11724,
      38625,
      81006,
      102033,
      28338,
      13326,
      3250,
      82056,
      82526,
      38212,
      21112,
      12382,
      111495,
      3263,
      7414,
      86274,
      93490,
      40844,
      30224,
      45212,
      24019,
      48411,
      71367,
      24941,
      76729,
      57776,
      3769,
      38114,
      202019,
      197745,
      31953,
      237533,
      33270,
      201580,
      255648,
      100798,
      44741,
      32241,
      98468,
      106931,
      10085,
      15090,
      170358,
      33154,
      66787,
      18819,
      69760,
      25061,
      234005,
      82660,
      6295,
      131975,
      16874,
      9076,
      4094,
      25005,
      17740,
      40908,
      19533,
      220019,
      44330,
      99792,
      50040,
      19619,
      13950,
      55228,
      24423,
      31253,
      95308,
      103177,
      184795,
      28590,
      82285,
      5059,
      3210,
      75525,
      49894,
      70007,
      56178,
      10580,
      36051,
      139681,
      21617,
      98736,
      3555,
      106306,
      164189,
      37352,
      63915,
      47824,
      24883,
      145530,
      61904,
      28444,
      11483,
      19837,
      145446,
      30420,
      112972,
      85939,
      11835,
      191233,
      2262,
      20705,
      58630,
      1753,
      148334,
      1197,
      144714,
      6887,
      11223,
      107667,
      60879,
      77914,
      4151,
      57417,
      81594,
      96681,
      169430,
      1784,
      20444,
      95138,
      254041,
      27038,
      596,
      7117,
      72808,
      13759,
      3353,
      126776,
      21074,
      55322,
      27081,
      36942,
      39547,
      139830,
      179275,
      4453,
      713,
      8722,
      71399,
      19204,
      25785,
      22794,
      23923,
      104114,
      11291,
      25458,
      102309,
      88396,
      75288,
      230440,
      206396,
      104551,
      58447,
      130857,
      37247,
      94734,
      31548,
      176529,
      226077,
      65159,
      20104,
      10096,
      66881,
      94191,
      237909,
      27109,
      37404,
      1520,
      27421,
      25220,
      113003,
      23423,
      24884,
      50585,
      6286,
      231877,
      150800,
      11789,
      3226,
      90004,
      60642,
      5053,
      202400,
      61442,
      132531,
      175329,
      57138,
      30116,
      103847,
      9973,
      75367,
      16452,
      32360,
      59119,
      21246,
      10191,
      164804,
      23305,
      61051,
      37348,
      154530,
      13214,
      5468,
      50403,
      66754,
      130976,
      50559,
      80515,
      14436,
      155492,
      84017,
      5472,
      43107,
      41240,
      2890,
      90431,
      70188,
      382,
      76234,
      48040,
      50211,
      281038,
      237007,
      32115,
      142178,
      1536,
      22761,
      96429,
      1811,
      31243,
      1679,
      49143,
      55209,
      17402,
      235054,
      61494,
      7462,
      77030,
      34925,
      87609,
      78002,
      9499,
      9027,
      73289,
      201078,
      101379,
      63544,
      27666,
      5469,
      10642,
      30029,
      49816,
      132979,
      95620,
      58086,
      351930,
      116300,
      2110,
      2043,
      30845,
      6154,
      11279,
      16727,
      4122,
      2277,
      27281,
      4971,
      3650,
      39060,
      61970,
      65951,
      39674,
      75686,
      38151,
      11370,
      130809,
      177895,
      32665,
      63725,
      122267,
      7857,
      39618,
      118483,
      44792,
      157755,
      178624,
      136994,
      24260,
      41308,
      22471,
      12404,
      21707,
      12486,
      30473,
      52781,
      50246,
      20247,
      39065,
      909,
      56825,
      103158,
      128603,
      31542,
      1089,
      41935,
      32744,
      12428,
      37963,
      84420,
      33134,
      72921,
      208449,
      42622,
      168151,
      127335,
      147107,
      46699,
      38216,
      12591,
      94342,
      85814,
      31423,
      24944,
      2605,
      87542,
      67473,
      192551,
      4496,
      56321,
      91819,
      17630,
      6300,
      256183,
      114569,
      202090,
      33209,
      35289,
      34897,
      24967,
      40520,
      43470,
      5344,
      10199,
      34810,
      14283,
      10381,
      10017,
      62923,
      49924,
      23233,
      64539,
      13051,
      35686,
      19698,
      11570,
      135555,
      120868,
      44924,
      87065,
      52318,
      52335,
      47586,
      140906,
      245885,
      109834,
      78668,
      9065,
      46990,
      25258,
      72022,
      61243,
      40838,
      4545,
      146387,
      10537,
      11557,
      17470,
      36930,
      68104,
      46711,
      24264,
      79401,
      81043,
      18225,
      120488,
      24746,
      84338,
      81652,
      28266,
      13776,
      21878,
      46973,
      1047,
      230465,
      73357,
      95777,
      24973,
      210160,
      62210,
      58404,
      110633,
      169651,
      6937,
      41870,
      9909,
      26822,
      191062,
      76553,
      27519,
      96256,
      239070,
      2478,
      205678,
      67955,
      58532,
      20601,
      50120,
      19148,
      78501,
      195724,
      110740,
      8249,
      109665,
      27446,
      30568,
      57631,
      31425,
      49752,
      32820,
      65504,
      50079,
      3663,
      102256,
      219898,
      23849,
      211315,
      14645,
      4359,
      91767,
      9528,
      12449,
      49366,
      7941,
      49763,
      107848,
      8930,
      27086,
      50686,
      9744,
      10447,
      81935,
      39513,
      46514,
      1670,
      29229,
      6172,
      22312,
      137280,
      97759,
      9806,
      14445,
      22976,
      56458,
      73391,
      34983,
      93760,
      174219,
      52573,
      33149,
      59747,
      2429,
      136277,
      75123,
      165263,
      91040,
      7446,
      57632,
      48633,
      97140,
      246081,
      84766,
      151684,
      79918,
      93268,
      120346,
      54059,
      54875,
      77858,
      32996,
      103590,
      45276,
      11968,
      19600,
      25849,
      17159,
      132907,
      42828,
      16817,
      4913,
      99462,
      103303,
      27395,
      5737,
      74184,
      20749,
      21160,
      14377,
      77062,
      131403,
      158735,
      10999,
      27799,
      77785,
      9320,
      34366,
      51593,
      61070,
      33746,
      47048,
      29268,
      36675,
      30262,
      53297,
      9832,
      82e3,
      20188,
      122292,
      39917,
      7331,
      18160,
      68301,
      185935,
      134830,
      15031,
      4935,
      10004,
      165845,
      185534,
      46923,
      30109,
      44134,
      122631,
      18874,
      22903,
      112790,
      26561,
      18549,
      348902,
      82871,
      140345,
      255565,
      135390,
      63556,
      103747,
      145055,
      179600,
      145662,
      296111,
      61661,
      211987,
      23952,
      52342,
      126343,
      48450,
      32919,
      44277,
      82185,
      9591,
      62139,
      205363,
      376969,
      394874,
      108461,
      18040,
      120885,
      14798,
      39863,
      16571,
      16794,
      58271,
      81025,
      55206,
      14640,
      118656,
      6361,
      44092,
      85970,
      6262,
      153863,
      108244,
      180200,
      72264,
      79947,
      38044,
      10050,
      5735,
      61221,
      80712,
      5471,
      115689,
      11391,
      11661,
      184257,
      20010,
      60116,
      30320,
      19327,
      134598,
      45455,
      27542,
      18004,
      125092,
      452272,
      1549,
      91523,
      46567,
      180063,
      156026,
      2608,
      11174,
      58848,
      37788,
      65907,
      80194,
      30490,
      5786,
      40775,
      119519,
      106241,
      11323,
      156297,
      8425,
      61495,
      2617,
      29675,
      2425,
      59886,
      112582,
      49142,
      59618,
      4863,
      50597,
      86710,
      50650,
      168632,
      27693,
      85641,
      83643,
      18993,
      25768,
      84284,
      28090,
      93592,
      36627,
      312804,
      43381,
      9887,
      9402,
      100931,
      97165,
      3311,
      173330,
      66805,
      28935,
      4963,
      184460,
      3201,
      78102,
      19126,
      21607,
      37496,
      24938,
      22615,
      16153,
      32862,
      134792,
      153318,
      61120,
      6067,
      2812,
      12826,
      12792,
      23825,
      37559,
      64662,
      202250,
      102694,
      155488,
      85881,
      149193,
      46233,
      65383,
      15521,
      106982,
      11358,
      176786,
      25752,
      39717,
      34208,
      24510,
      32464,
      77742,
      39371,
      72028,
      138229,
      60688,
      71386,
      102834,
      132477,
      2208,
      11548,
      63670,
      271279,
      28351,
      30338,
      38620,
      32491,
      99845,
      143885,
      152266,
      13252,
      2825,
      178663,
      108097,
      1775,
      78201,
      14897,
      113573,
      163346,
      62292,
      171129,
      22183,
      96598,
      38733,
      64971,
      166776,
      117445,
      9968,
      146393,
      44677,
      74867,
      20908,
      97328,
      12761,
      25656,
      26785,
      9148,
      112344,
      26115,
      99176,
      110121,
      22437,
      49547,
      6180,
      79320,
      5835,
      31392,
      43328,
      33377,
      75870,
      119860,
      69497,
      80273,
      7325,
      155219,
      43167,
      111173,
      28347,
      20222,
      3763,
      71752,
      55041,
      47252,
      14618,
      28088,
      15012,
      97805,
      194698,
      54636,
      2036,
      41349,
      6173,
      96604,
      61530,
      51859,
      43782,
      13361,
      24334,
      22668,
      24792,
      7070,
      23441,
      16789,
      3209,
      36211,
      208475,
      26242,
      32880,
      122181,
      182407,
      21444,
      31060,
      88459,
      29929,
      77907,
      12716,
      10934,
      97005,
      20599,
      31690,
      8403,
      58445,
      30303,
      22700,
      10336,
      86731,
      103115,
      337709,
      72556,
      46788,
      112566,
      47684,
      67089,
      53548,
      36874,
      56487,
      41387,
      125985,
      26893,
      40071,
      106683,
      73712,
      18787,
      40105,
      72992,
      67246,
      137276,
      50802,
      36790,
      70328,
      138827,
      22466,
      39263,
      183295,
      29858,
      50975,
      9322,
      57397,
      10654,
      24364,
      30383,
      55799,
      41600,
      23584,
      127295,
      296610,
      129078,
      143558,
      244131,
      86397,
      36049,
      1085,
      80677,
      3820,
      108139,
      5476,
      34767,
      24683,
      7758,
      13060,
      7239,
      131671,
      250593,
      59556,
      103392,
      29810,
      4188,
      252323,
      39404,
      116877,
      7651,
      43600,
      40338,
      13554,
      157253,
      39196,
      25978,
      144387,
      61211,
      234,
      50104,
      6129,
      10449,
      93777,
      9240,
      356378,
      274148,
      4439,
      72970,
      3724,
      147770,
      78680,
      62570,
      115877,
      40027,
      40547,
      36817,
      224392,
      64609,
      34795,
      165027,
      67440,
      2477,
      37206,
      23431,
      50754,
      164797,
      46018,
      94995,
      170982,
      27051,
      7957,
      22767,
      3674,
      27900,
      56419,
      18930,
      60701,
      41302,
      2692,
      84749,
      339721,
      61996,
      111094,
      80221,
      50129,
      1045,
      8153,
      62945,
      19202,
      8250,
      37208,
      37418,
      32560,
      79477,
      41106,
      88569,
      33963,
      36693,
      5892,
      30570,
      1581,
      66471,
      49647,
      11922,
      160717,
      29442,
      5643,
      114865,
      82962,
      95982,
      132098,
      22633,
      22838,
      94726,
      54556,
      28566,
      205039,
      162340,
      33216,
      16849,
      35847,
      221339,
      94851,
      26533,
      71469,
      1805,
      3804,
      12935,
      45483,
      71020,
      36310,
      65381,
      192960,
      34240,
      35165,
      59773,
      1248,
      46954,
      155332,
      96864,
      4246,
      388800,
      16129,
      57133,
      74592,
      44807,
      442014,
      38203,
      42574,
      80818,
      91592,
      26377,
      36424,
      65760,
      977,
      77387,
      22628,
      147610,
      28018,
      30561,
      98454,
      6969,
      119628,
      63648,
      18170,
      36854,
      26601,
      64018,
      22027,
      37279,
      51395,
      152934,
      21153,
      9430,
      58760,
      194742,
      5330,
      55115,
      34158,
      28917,
      174111,
      13171,
      122326,
      1526,
      43896,
      66094,
      25325,
      4234,
      148354,
      11450,
      275,
      18999,
      112191,
      44365,
      22723,
      68409,
      8733,
      57746,
      96565,
      75007,
      14196,
      108844,
      29475,
      88599,
      177563,
      100792,
      106156,
      86323,
      93726,
      14248,
      135341,
      194131,
      40126,
      47099,
      14779,
      8272,
      39597,
      95983,
      171398,
      65882,
      28052,
      10393,
      47213,
      40689,
      22120,
      72212,
      106829,
      34964,
      109146,
      753,
      648,
      21660,
      30047,
      17527,
      181025,
      5619,
      145357,
      4085,
      216883,
      9359,
      186951,
      24779,
      53931,
      24545,
      36197,
      223296,
      62628,
      168101,
      4243,
      107313,
      30321,
      26642,
      13049,
      51059,
      31027,
      107912,
      807,
      73550,
      26551,
      84369,
      122422,
      165872,
      49754,
      74213,
      234264,
      33151,
      52014,
      33100,
      87183,
      22365,
      52500,
      40013,
      23302,
      5652,
      72723,
      21404,
      26107,
      48434,
      587,
      94049,
      168493,
      96418,
      32871,
      70860,
      31709,
      25128,
      443,
      71597,
      166253,
      15670,
      70994,
      26341,
      133675,
      28280,
      75491,
      54756,
      47955,
      56028,
      26182,
      11952,
      113272,
      472197,
      64640,
      110753,
      17919,
      337,
      50642,
      22576,
      142,
      87371,
      53391,
      93210,
      126694,
      15285,
      19642,
      85667,
      14148,
      1506,
      42092,
      52962,
      33243,
      11970,
      20734,
      135843,
      57044,
      58880,
      13002,
      219134,
      22876,
      64754,
      232519,
      4257,
      43120,
      321573,
      24799,
      64526,
      124728,
      52579,
      81472,
      70831,
      276848,
      17403,
      74359,
      23021,
      182101,
      74597,
      23744,
      148267,
      12055,
      7976,
      5349,
      11772,
      67540,
      167347,
      65318,
      18720,
      127832,
      108238,
      22828,
      90233,
      9987,
      259080,
      118185,
      73209,
      79270,
      13775,
      90100,
      137742,
      90799,
      70569,
      15699,
      19961,
      9087,
      67475,
      57872,
      39731,
      8810,
      134897,
      131868,
      146849,
      19898,
      3334,
      2281,
      167061,
      91073,
      60356,
      467742,
      74712,
      188,
      53179,
      137679,
      92769,
      29241,
      9537,
      132595,
      80119,
      1041,
      88962,
      5976,
      40171,
      44911,
      102859,
      139059,
      104558,
      98987,
      47761,
      19272,
      71472,
      113864,
      175377,
      73338,
      10857,
      23402,
      23758,
      1591,
      139864,
      5644,
      4076,
      118760,
      16427,
      134198,
      18853,
      20291,
      100849,
      37423,
      22038,
      36677,
      19071,
      195521,
      57445,
      11069,
      31869,
      55718,
      66882,
      148490,
      44,
      41296,
      75242,
      49704,
      166810,
      9906,
      20943,
      122258,
      49112,
      105667,
      15969,
      10344,
      6408,
      187694,
      21399,
      72742,
      58970,
      14867,
      14376,
      81889,
      41856,
      23225,
      15042,
      56993,
      16074,
      131389,
      74276,
      72407,
      53875,
      383108,
      53597,
      37363,
      68993,
      44854,
      122548,
      430927,
      198279,
      38430,
      80409,
      12245,
      2981,
      628,
      2818,
      17760,
      37437,
      238229,
      7968,
      46892,
      2200,
      3730,
      34190,
      65983,
      37959,
      112291,
      87850,
      70827,
      6522,
      20750,
      73913,
      111621,
      41652,
      19587,
      2780,
      58668,
      25916,
      85259,
      18200,
      168962,
      95781,
      42445,
      102050,
      7776,
      57662,
      103313,
      47742,
      96358,
      41964,
      66174,
      100396,
      29069,
      204735,
      19679,
      27978,
      7479,
      40264,
      22534,
      61183,
      36081,
      107436,
      58223,
      14680,
      23002,
      101311,
      24716,
      124108,
      12908,
      5646,
      31750,
      40380,
      14215,
      232799,
      102772,
      14122,
      96775,
      61398,
      50917,
      12096,
      149880,
      67833,
      598749,
      124194,
      155871,
      49216,
      790,
      14677,
      65319,
      56917,
      7440,
      145744,
      95701,
      12206,
      49405,
      129269,
      76199,
      45732,
      9767,
      11058,
      9047,
      210885,
      11051,
      7392,
      26307,
      2130,
      8132,
      147526,
      20802,
      232698,
      115660,
      50060,
      59789,
      57344,
      107623,
      80343,
      112676,
      23291,
      9866,
      160971,
      34032,
      118291,
      15719,
      59730,
      164911,
      28975,
      2659,
      58046,
      78480,
      21854,
      66209,
      53863,
      109085,
      116045,
      29021,
      46481,
      107552,
      22130,
      18764,
      70254,
      31272,
      11300,
      52460,
      43933,
      84738,
      20721,
      53869,
      190840,
      79673,
      105300,
      7561,
      321817,
      66924,
      13940,
      33281,
      101046,
      183181,
      32176,
      71878,
      5678,
      62924,
      79535,
      56646,
      40303,
      19559,
      27703,
      93042,
      73368,
      42187,
      3670,
      37376,
      46440,
      7023,
      36816,
      109628,
      20680,
      5940,
      276440,
      275233,
      170848,
      112093,
      136996,
      14984,
      20226,
      111441,
      77693,
      112960,
      48577,
      39370,
      55707,
      50314,
      123404,
      26570,
      54281,
      61372,
      123391,
      4857,
      35928,
      246740,
      132507,
      106646,
      44241,
      7196,
      92258,
      9825,
      37688,
      51197,
      303141,
      5590,
      15476,
      132986,
      10955,
      85782,
      34486,
      26696,
      7991,
      28813,
      18858,
      39546,
      11703,
      11365,
      38185,
      5716,
      93555,
      11925,
      40121,
      60002,
      6985,
      10976,
      171384,
      3887,
      43394,
      13337,
      56346,
      6381,
      252336,
      39573,
      75042,
      53711,
      1028,
      31781,
      44295,
      95925,
      131713,
      7214,
      68125,
      43571,
      70954,
      213234,
      1628,
      8760,
      13391,
      65485,
      17320,
      56038,
      1710,
      25248,
      60803,
      57399,
      19839,
      3870,
      326,
      281556,
      50945,
      72400,
      21460,
      316244,
      75619,
      56246,
      98775,
      481,
      13513,
      55765,
      50427,
      7388,
      123519,
      32929,
      57908,
      27124,
      61316,
      101097,
      57467,
      30228,
      48792,
      10788,
      20402,
      37318,
      50526,
      155730,
      34456,
      158065,
      145305,
      17832,
      43733,
      64052,
      4506,
      35072,
      205355,
      177028,
      184004,
      187081,
      68616,
      35938,
      83703,
      10367,
      36892,
      93186,
      260137,
      51934,
      89970,
      4985,
      23445,
      26755,
      21558,
      7948,
      78741,
      23376,
      124405,
      85594,
      68596,
      57536,
      49351,
      12619,
      56593,
      132668,
      99924,
      109728,
      71844,
      71935,
      196018,
      65464,
      17617,
      14987,
      89701,
      143773,
      33997,
      8687,
      22701,
      33258,
      2914,
      4436,
      72108,
      85610,
      9671,
      49067,
      2327,
      82988,
      1361,
      1672,
      44033,
      35777,
      30269,
      24057,
      10605,
      82236,
      616,
      15793,
      13919,
      47249,
      112086,
      116698,
      9484,
      80207,
      90574,
      33304,
      68624,
      93127,
      56101,
      42210,
      160929,
      4827,
      38995,
      38095,
      4701,
      125119,
      5027,
      33680,
      9236,
      231236,
      14135,
      87837,
      23318,
      70261,
      78893,
      30151,
      81482,
      14332,
      1084,
      74256,
      27532,
      46644,
      79185,
      3148,
      62615,
      6981,
      55672,
      31668,
      36825,
      1849,
      14536,
      37446,
      14738,
      23779,
      43058,
      162749,
      72199,
      1168,
      21346,
      5592,
      85932,
      85302,
      9668,
      18351,
      57135,
      150360,
      2080,
      228015,
      77953,
      34670,
      119302,
      151751,
      31009,
      106725,
      84265,
      45214,
      59289,
      74178,
      113071,
      263206,
      111009,
      4021,
      44449,
      188119,
      192629,
      123592,
      392506,
      292847,
      114487,
      12831,
      205858,
      9852,
      20780,
      79648,
      75767,
      357014,
      97721,
      18166,
      21005,
      67950,
      33226,
      204009,
      16536,
      2987,
      11335,
      66717,
      144910,
      47950,
      17262,
      55060,
      15063,
      2934,
      51038,
      26775,
      178497,
      66008,
      3427,
      49433,
      128592,
      20036,
      157553,
      63861,
      3089,
      23015,
      51210,
      28696,
      35933,
      49942,
      71135,
      231518,
      99620,
      17248,
      21835,
      176536,
      20676,
      16944,
      38700,
      165831,
      233253,
      295625,
      36723,
      13023,
      52745,
      10907,
      19423,
      67972,
      125868,
      95473,
      82875,
      1183,
      108455,
      52685,
      33417,
      64095,
      21433,
      52438,
      33191,
      127809,
      44505,
      211823,
      7810,
      2752,
      95548,
      162031,
      7185,
      91196,
      47563,
      61721,
      33359,
      17897,
      23682,
      42806,
      178101,
      22874,
      49707,
      199897,
      75419,
      82456,
      8618,
      11171,
      79712,
      116847,
      18783,
      44190,
      46564,
      5346,
      59046,
      95032,
      7893,
      14916,
      3214,
      26800,
      24172,
      121453,
      34362,
      10250,
      17408,
      18888,
      4840,
      68696,
      22831,
      13162,
      36005,
      32512,
      14800,
      62357,
      41723,
      45046,
      27247,
      37486,
      5372,
      2564,
      34261,
      298500,
      66509,
      133920,
      89138,
      31305,
      117697,
      19097,
      108304,
      81386,
      84106,
      23802,
      46411,
      63304,
      946,
      51417,
      41777,
      41041,
      19501,
      115864,
      60743,
      294354,
      37955,
      94165,
      18116,
      1156,
      17937,
      20645,
      57114,
      90804,
      58042,
      48643,
      92288,
      9861,
      2557,
      88546,
      61333,
      101008,
      12853,
      5148,
      87856,
      4152,
      144503,
      73841,
      18718,
      9789,
      147565,
      10846,
      42085,
      12789,
      30223,
      8993,
      56352,
      67203,
      2448,
      28215,
      6052,
      23540,
      126319,
      75933,
      36689,
      80235,
      23231,
      23561,
      21383,
      38800,
      77548,
      102798,
      21234,
      31468,
      158608,
      46188,
      63960,
      191679,
      8051,
      67014,
      11185,
      170078,
      42186,
      28827,
      34777,
      41930,
      212079,
      12421,
      34750,
      24111,
      110344,
      73918,
      45171,
      70826,
      141949,
      40063,
      23979,
      24254,
      37309,
      26724,
      27179,
      24718,
      83648,
      54938,
      14591,
      17425,
      29525,
      102675,
      48975,
      48654,
      12316,
      8929,
      60640,
      41709,
      50168,
      63264,
      89812,
      50716,
      48632,
      38755,
      138583,
      160123,
      55579,
      71829,
      24230,
      233277,
      46322,
      39650,
      166388,
      34718,
      24108,
      98252,
      7031,
      106695,
      62498,
      18258,
      35062,
      217827,
      78731,
      34824,
      33354,
      19520,
      60852,
      2432,
      60224,
      8587,
      2836,
      62955,
      702,
      20227,
      42285,
      40560,
      95592,
      62486,
      11094,
      53035,
      143291,
      18842,
      46177,
      77994,
      1770,
      9657,
      107422,
      172915,
      32655,
      128716,
      25886,
      25164,
      156740,
      119928,
      165875,
      85817,
      11007,
      89110,
      33956,
      12652,
      65156,
      180266,
      8494,
      36889,
      19958,
      20955,
      96,
      1264,
      118288,
      135769,
      44754,
      86671,
      5632,
      19026,
      168220,
      289120,
      33569,
      93821,
      66144,
      70635,
      7687,
      5642,
      2714,
      55445,
      56636,
      71545,
      184182,
      93133,
      7332,
      37389,
      12643,
      52315,
      22729,
      11014,
      158742,
      17050,
      152889,
      50178,
      34601,
      41945,
      52136,
      9948,
      26914,
      63548,
      95721,
      115951,
      40759,
      8960,
      158258,
      38938,
      49232,
      48325,
      42234,
      81523,
      253019,
      66128,
      40978,
      20048,
      238048,
      38760,
      62928,
      122560,
      118532,
      43687,
      137472,
      163689,
      26680,
      9878,
      17448,
      51035,
      16211,
      60834,
      36749,
      29178,
      14241,
      59868,
      150086,
      2305,
      26477,
      42422,
      34342,
      165341,
      83279,
      33894,
      14257,
      29928,
      12743,
      13957,
      125571,
      89134,
      66712,
      10952,
      16507,
      147839,
      30146,
      7249,
      16565,
      45399,
      39874,
      114565,
      215780,
      31990,
      230881,
      171477,
      102,
      196546,
      44538,
      10880,
      84948,
      281705,
      86651,
      10617,
      31395,
      2342,
      453658,
      43569,
      60561,
      132901,
      21845,
      17727,
      58556,
      258242,
      22262,
      58728,
      4008,
      77997,
      11806,
      37431,
      30599,
      81375,
      109137,
      185787,
      114085,
      217292,
      97453,
      169085,
      30593,
      60212,
      11544,
      102056,
      65580,
      2384,
      91655,
      4855,
      95725,
      7295,
      157994,
      16228,
      20669,
      53276,
      141590,
      105246,
      17334,
      25440,
      76067,
      17967,
      39321,
      38911,
      11362,
      28559,
      63807,
      21627,
      26468,
      85816,
      40120,
      1025,
      15234,
      58319,
      69516,
      66512,
      124548,
      75845,
      78873,
      22137,
      46681,
      51242,
      85683,
      32909,
      76747,
      35555,
      43396,
      101465,
      1765,
      73094,
      1077,
      2962,
      39028,
      66777,
      57831,
      42048,
      15828,
      13962,
      36041,
      63657,
      52412,
      5242,
      58846,
      2141,
      5506,
      219012,
      134451,
      3936,
      182230,
      17558,
      17153,
      152237,
      22621,
      49377,
      170216,
      35257,
      68233,
      65374,
      6510,
      11126,
      212151,
      7184,
      2480,
      22517,
      3437,
      33073,
      30156,
      16557,
      3768,
      55067,
      86829,
      91e3,
      12350,
      148650,
      66017,
      79424,
      70885,
      49066,
      28250,
      21369,
      51213,
      34533,
      11510,
      3258,
      18176,
      18465,
      84413,
      6315,
      36411,
      163765,
      4346,
      356,
      107618,
      598,
      13727,
      285026,
      162695,
      8749,
      14583,
      7132,
      63521,
      184253,
      32378,
      25991,
      5604,
      30961,
      53675,
      4874,
      84693,
      5086,
      34811,
      26978,
      56564,
      7904,
      33519,
      51221,
      113942,
      69253,
      6664,
      125563,
      22055,
      220680,
      102008,
      742,
      51930,
      19494,
      176108,
      44424,
      35123,
      13025,
      75685,
      11759,
      74335,
      22250,
      181453,
      131147,
      16984,
      132115,
      154311,
      11991,
      76452,
      52609,
      85351,
      196,
      30969,
      9198,
      74919,
      2529,
      56838,
      71779,
      29187,
      116304,
      3504,
      62330,
      41190,
      86153,
      28393,
      254926,
      104228,
      105189,
      13264,
      84359,
      3574,
      12415,
      8534,
      57147,
      10175,
      188174,
      59504,
      60932,
      66318,
      16407,
      107921,
      17638,
      99103,
      49278,
      28403,
      39786,
      145865,
      8462,
      3558,
      43406,
      142271,
      29139,
      21989,
      36552,
      93955,
      72365,
      7176,
      13556,
      106185,
      37957,
      321774,
      17782,
      129017,
      51154,
      27938,
      24952,
      1935,
      39366,
      2791,
      33489,
      41582,
      56078,
      24558,
      9311,
      5449,
      218786,
      27808,
      190429,
      68013,
      36020,
      86003,
      29735,
      3404,
      87348,
      119357,
      115714,
      2324,
      86796,
      81973,
      40992,
      43376,
      93621,
      28784,
      16808,
      36367,
      2517,
      2909,
      191926,
      24978,
      55303,
      53308,
      205724,
      60068,
      3098,
      21375,
      64784,
      23949,
      26579,
      63121,
      12319,
      80145,
      39967,
      97861,
      6757,
      70143,
      67642,
      37082,
      34698,
      69140,
      122883,
      46151,
      62187,
      80934,
      429,
      19437,
      135071,
      137885,
      222647,
      13331,
      154065,
      327,
      61778,
      74257,
      40116,
      37493,
      14855,
      85079,
      237641,
      42342,
      102164,
      199965,
      71204,
      4662,
      29368,
      5042,
      113914,
      122214,
      8955,
      13149,
      102503,
      43173,
      5659,
      163787,
      69003,
      307084,
      63392,
      171080,
      21390,
      81918,
      86666,
      36622,
      24126,
      28887,
      5736,
      28054,
      207170,
      163428,
      79891,
      346467,
      95363,
      38980,
      111806,
      80828,
      9200,
      19288,
      294896,
      114468,
      87405,
      111715,
      141705,
      7015,
      72754,
      68463,
      48738,
      243147,
      33397,
      101210,
      37051,
      98801,
      82847,
      20397,
      4940,
      185559,
      18716,
      54718,
      83491,
      11725,
      40803,
      1128,
      12128,
      23060,
      5174,
      7745,
      67007,
      46701,
      1571,
      27807,
      180186,
      256996,
      18975,
      16837,
      7877,
      212758,
      250379,
      15440,
      87954,
      57755,
      24719,
      124057,
      83461,
      258,
      50864,
      8874,
      29038,
      71289,
      31627,
      15429,
      9005,
      4061,
      113851,
      107716,
      82819,
      13651,
      79656,
      117851,
      17539,
      111446,
      12938,
      39724,
      190787,
      4352,
      15402,
      21070,
      62708,
      8539,
      23777,
      73853,
      13552,
      38810,
      86117,
      16285,
      56400,
      1718,
      75342,
      142863,
      29033,
      378,
      110113,
      180321,
      32586,
      23606,
      26393,
      160984,
      207987,
      23783,
      8406,
      16904,
      24596,
      47274,
      11693,
      46539,
      60524,
      78595,
      48423,
      31718,
      20170,
      9009,
      146268,
      15183,
      191060,
      172765,
      1349,
      138436,
      37365,
      10970,
      40509,
      225817,
      20021,
      70394,
      152138,
      21541,
      66559,
      66544,
      89352,
      2725,
      17258,
      91345,
      7313,
      3815,
      115868,
      8660,
      40362,
      4071,
      103524,
      39388,
      118275,
      21950,
      6549,
      38226,
      32754,
      209574,
      29201,
      43495,
      18028,
      20296,
      40597,
      18370,
      47520,
      202450,
      24134,
      2219,
      8195,
      69545,
      38041,
      136934,
      46374,
      19041,
      159811,
      84865,
      58620,
      846,
      98749,
      13569,
      30714,
      97246,
      32186,
      4479,
      27355,
      92973,
      35214,
      151491,
      75963,
      37631,
      1561,
      27200,
      238083,
      23182,
      60756,
      12291,
      25766,
      39355,
      102333,
      87362,
      65741,
      59906,
      19538,
      201575,
      48772,
      102938,
      24438,
      292580,
      39964,
      66366,
      9004,
      61379,
      50548,
      37622,
      38732,
      28379,
      68180,
      76622,
      17488,
      69849,
      5963,
      7219,
      48143,
      43413,
      55358,
      540,
      58691,
      29506,
      19245,
      52193,
      48621,
      5518,
      13048,
      118625,
      44755,
      191081,
      42061,
      89197,
      2259,
      60665,
      66994,
      71210,
      51232,
      3585,
      142096,
      55024,
      7892,
      8345,
      58653,
      463307,
      65658,
      64319,
      137941,
      136323,
      53499,
      12746,
      43492,
      6978,
      95163,
      29925,
      60175,
      5128,
      7352,
      41463,
      184756,
      121146,
      20473,
      18426,
      4598,
      5309,
      54580,
      14277,
      121151,
      10691,
      56711,
      43880,
      63409,
      76682,
      11830,
      172218,
      264898,
      32632,
      66536,
      81062,
      31649,
      25788,
      92774,
      60222,
      11100,
      63159,
      9432,
      224657,
      25240,
      53613,
      152,
      138620,
      163829,
      2397,
      85345,
      12501,
      37507,
      64932,
      38575,
      43522,
      65789,
      80198,
      78796,
      35226,
      3851,
      108891,
      73311,
      3060,
      28391,
      93671,
      39663,
      46142,
      30982,
      66041,
      37281,
      68157,
      26553,
      71872,
      81142,
      211527,
      39747,
      118119,
      22695,
      2859,
      11066,
      20232,
      168911,
      7933,
      197005,
      17066,
      111071,
      44434,
      133994,
      120798,
      12766,
      227798,
      45756,
      132852,
      29917,
      36076,
      55352,
      65281,
      129800,
      41958,
      18944,
      84678,
      18580,
      168093,
      132621,
      39997,
      54092,
      27740,
      32354,
      3770,
      114118,
      103242,
      43918,
      15899,
      18574,
      145944,
      3190,
      123469,
      219903,
      24169,
      100571,
      62403,
      16776,
      92779,
      14535,
      17168,
      16475,
      14304,
      37231,
      1712,
      28218,
      242754,
      61688,
      28980,
      1318,
      51359,
      222657,
      99200,
      67989,
      31772,
      23932,
      35351,
      201251,
      49041,
      27306,
      19128,
      40135,
      3986,
      77333,
      19649,
      120683,
      151927,
      21081,
      7076,
      78375,
      77501,
      101599,
      8011,
      89585,
      96715,
      58179,
      5378,
      102138,
      106793,
      26051,
      217276,
      4197,
      16297,
      27014,
      46721,
      13322,
      22806,
      5278,
      29629,
      70632,
      9647,
      71519,
      58818,
      40603,
      128530,
      8903,
      36770,
      56900,
      31483,
      26935,
      43845,
      34265,
      34920,
      87658,
      6114,
      84767,
      64250,
      47318,
      50720,
      19264,
      162514,
      33357,
      13117,
      6705,
      46696,
      75032,
      71054,
      87004,
      42035,
      69138,
      11903,
      99854,
      102328,
      19611,
      34525,
      69312,
      6431,
      49842,
      101600,
      133178,
      108751,
      41829,
      89939,
      225664,
      48916,
      99556,
      9195,
      130387,
      5960,
      36857,
      116724,
      53518,
      94002,
      39077,
      53996,
      6945,
      22261,
      64291,
      8314,
      152785,
      57588,
      16522,
      9091,
      5048,
      87671,
      35441,
      39509,
      1945,
      12423,
      158923,
      178413,
      37549,
      14095,
      1475,
      73188,
      62878,
      4819,
      24012,
      68534,
      42606,
      4010,
      120809,
      57497,
      59564,
      101758,
      103718,
      32701,
      80116,
      12345,
      95834,
      46918,
      21468,
      53213,
      15665,
      31200,
      3867,
      5140,
      96013,
      250744,
      21016,
      10069,
      13968,
      35449,
      180829,
      27683,
      39704,
      59956,
      22893,
      3115,
      26293,
      32785,
      75934,
      62445,
      141162,
      62720,
      2018,
      83638,
      19949,
      114012,
      95006,
      3330,
      99829,
      130935,
      309272,
      9565,
      55874,
      121727,
      37017,
      23586,
      319858,
      40970,
      27602,
      8625,
      112329,
      61060,
      100088,
      118525,
      25922,
      16232,
      1907,
      60671,
      51583,
      44553,
      80993,
      5262,
      94679,
      8676,
      940,
      20736,
      11823,
      3020,
      16476,
      12340,
      152600,
      97416,
      3703,
      25744,
      66826,
      16245,
      16876,
      46446,
      84798,
      74227,
      176020,
      45192,
      61955,
      75496,
      23946,
      23626,
      40372,
      26036,
      6149,
      11822,
      30582,
      16541,
      41914,
      82385,
      232823,
      40921,
      80773,
      14930,
      3631,
      7517,
      39619,
      4348,
      36180,
      126106,
      138939,
      62611,
      1477,
      113512,
      47321,
      25052,
      14546,
      118881,
      29060,
      23589,
      128322,
      36795,
      18401,
      137921,
      104699,
      267929,
      36194,
      172791,
      18113,
      4766,
      188215,
      30083,
      332586,
      94089,
      5805,
      77909,
      22194,
      68234,
      154976,
      43220,
      40660,
      70001,
      184893,
      138095,
      11128,
      103010,
      22663,
      5108,
      212615,
      8485,
      5565,
      49222,
      54614,
      26530,
      42639,
      16319,
      55062,
      152662,
      105595,
      21114,
      22216,
      10294,
      68158,
      10436,
      86950,
      7206,
      62115,
      3977,
      3657,
      59874,
      456,
      118617,
      18156,
      106663,
      112229,
      80992,
      17442,
      8217,
      55551,
      5133,
      34344,
      251927,
      51153,
      39364,
      201321,
      7816,
      66803,
      23057,
      156724,
      145664,
      14276,
      95705,
      979,
      2796,
      6875,
      13429,
      212525,
      50602,
      26276,
      28284,
      3424,
      19465,
      52397,
      46963,
      31420,
      51399,
      206476,
      92317,
      48851,
      637,
      100820,
      83349,
      10317,
      60227,
      21972,
      6908,
      282439,
      32857,
      224767,
      95629,
      83882,
      42106,
      87338,
      69757,
      29840,
      68709,
      37665,
      45244,
      114577,
      49188,
      175943,
      54009,
      186746,
      106158,
      70168,
      3358,
      234002,
      50555,
      9221,
      129338,
      9562,
      20118,
      32923,
      78479,
      118280,
      65752,
      4977,
      10474,
      102174,
      60947,
      129006,
      10570,
      83451,
      8598,
      8078,
      159367,
      123785,
      80438,
      16742,
      5905,
      5281,
      181513,
      42402,
      6977,
      163136,
      93179,
      42191,
      14968,
      50421,
      112401,
      105440,
      33456,
      57347,
      121611,
      4221,
      94954,
      36517,
      24046,
      27796,
      6255,
      33394,
      72990,
      135408,
      116627,
      1233,
      57874,
      25654,
      95419,
      68156,
      401399,
      313338,
      55208,
      45573,
      93124,
      119251,
      47200,
      38196,
      11909,
      130667,
      45391,
      73904,
      64964,
      167846,
      4137,
      115606,
      52036,
      62214,
      7969,
      160925,
      7187,
      1132,
      134835,
      40309,
      73195,
      64494,
      80472,
      444841,
      61111,
      26500,
      45323,
      40743,
      53625,
      52797,
      22659,
      15631,
      29739,
      36706,
      28841,
      39147,
      102836,
      26794,
      10536,
      14845,
      87305,
      45874,
      12241,
      127587,
      83833,
      57183,
      79722,
      30844,
      41304,
      84655,
      20825,
      92500,
      3722,
      25655,
      27811,
      10157,
      81634,
      31362,
      34088,
      92487,
      70123,
      22190,
      185100,
      72658,
      139035,
      192523,
      88241,
      2078,
      230490,
      44528,
      85638,
      100198,
      22088,
      29982,
      291233,
      241062,
      13865,
      4445,
      137791,
      37835,
      107218,
      31726,
      19718,
      38234,
      72528,
      23046,
      19177,
      66695,
      5109,
      17251,
      28077,
      5617,
      21554,
      47839,
      72425,
      133825,
      1486,
      73065,
      181275,
      141508,
      21768,
      62971,
      63082,
      2512,
      34200,
      9904,
      120309,
      6392,
      91243,
      68416,
      268253,
      41199,
      116757,
      138551,
      185526,
      41246,
      28986,
      4093,
      19057,
      17295,
      4148,
      245766,
      122360,
      35356,
      112075,
      20301,
      75441,
      10998,
      7977,
      19769,
      62922,
      937,
      63547,
      100196,
      26427,
      157820,
      20983,
      236696,
      22935,
      8140,
      90315,
      156004,
      47204,
      140973,
      7726,
      45097,
      52725,
      22636,
      23436,
      257282,
      105247,
      522,
      88389,
      216031,
      202204,
      46812,
      211666,
      19693,
      68828,
      81691,
      45925,
      11256,
      30292,
      372,
      5236,
      167826,
      88328,
      232776,
      151611,
      5360,
      82104,
      18841,
      80393,
      25465,
      18285,
      20320,
      72377,
      31730,
      33160,
      45803,
      38715,
      27705,
      37379,
      24163,
      18360,
      103586,
      4015,
      32305,
      269494,
      91252,
      20080,
      36567,
      54650,
      7797,
      57073,
      12650,
      31164,
      42209,
      6375,
      261663,
      105528,
      81661,
      106002,
      2800,
      5375,
      17247,
      43151,
      4442,
      15727,
      194619,
      100855,
      144898,
      62320,
      78465,
      39929,
      16454,
      1967,
      28311,
      61363,
      17219,
      9395,
      8745,
      121445,
      76939,
      80385,
      162380,
      22009,
      54191,
      44248,
      16299,
      122830,
      48151,
      74429,
      78291,
      64755,
      14238,
      44966,
      2511,
      17712,
      67954,
      93583,
      829,
      105899,
      49935,
      84750,
      11591,
      33185,
      85447,
      42717,
      27409,
      208542,
      28965,
      62052,
      52525,
      5597,
      25694,
      65594,
      16343,
      63224,
      276188,
      12475,
      9331,
      127507,
      38522,
      57287,
      24128,
      133161,
      79723,
      105548,
      133695,
      48917,
      27558,
      43278,
      46520,
      13778,
      141954,
      110785,
      83366,
      17715,
      46317,
      105763,
      66298,
      147013,
      41086,
      94180,
      16478,
      220447,
      44611,
      730,
      19722,
      78975,
      117889,
      125643,
      26254,
      16574,
      18480,
      65006,
      15806,
      38549,
      246418,
      46052,
      36056,
      8440,
      34984,
      30170,
      3163,
      59800,
      4458,
      115442,
      4283,
      41970,
      33507,
      104078,
      1653,
      22,
      121158,
      276486,
      3655,
      6338,
      24048,
      133421,
      23641,
      2161,
      24422,
      36006,
      8086,
      10675,
      181474,
      12307,
      29514,
      59143,
      14729,
      52509,
      87128,
      122470,
      19446,
      80852,
      33314,
      24573,
      119864,
      14237,
      9652,
      57779,
      6612,
      51851,
      15284,
      98871,
      90581,
      124466,
      156831,
      21190,
      22015,
      71380,
      161906,
      87247,
      69201,
      18392,
      17908,
      108470,
      72962,
      40719,
      14338,
      17911,
      95260,
      43339,
      20610,
      78916,
      20710,
      72451,
      11315,
      31448,
      17263,
      58853,
      178878,
      48111,
      116002,
      45497,
      80506,
      82605,
      85880,
      36300,
      121755,
      25215,
      36118,
      301929,
      88728,
      405223,
      276136,
      553,
      34704,
      212438,
      49970,
      78329,
      922,
      20711,
      25036,
      257130,
      38295,
      145369,
      18128,
      15385,
      30829,
      55656,
      48345,
      8012,
      3561,
      28004,
      122041,
      192900,
      58338,
      112508,
      41085,
      29976,
      87040,
      47117,
      23905,
      4336,
      92061,
      138880,
      97407,
      42083,
      172121,
      6256,
      25192,
      172671,
      5,
      93568,
      1420,
      12677,
      31605,
      56743,
      40620,
      6015,
      78415,
      231077,
      31298,
      80026,
      13902,
      19048,
      24924,
      170586,
      32955,
      176119,
      87859,
      36731,
      6773,
      27711,
      24658,
      26475,
      115216,
      133207,
      93250,
      95820,
      88522,
      8317,
      5714,
      124047,
      55219,
      86860,
      19677,
      23961,
      22928,
      162209,
      8904,
      225992,
      359835,
      56084,
      96201,
      29392,
      96558,
      86071,
      93643,
      55114,
      13347,
      8183,
      95129,
      82012,
      2017,
      123336,
      34219,
      115554,
      157159,
      47747,
      101684,
      41008,
      18735,
      193781,
      104151,
      226906,
      7552,
      179874,
      124113,
      31159,
      21162,
      44010,
      14771,
      51268,
      166128,
      31382,
      73124,
      77438,
      92830,
      205709,
      12113,
      1292,
      38937,
      13114,
      1334,
      2118,
      15597,
      69581,
      14449,
      21934,
      76618,
      48728,
      67038,
      14967,
      51495,
      24243,
      87736,
      147249,
      26720,
      11119,
      46063,
      43749,
      5843,
      44147,
      152629,
      133428,
      65703,
      14269,
      45604,
      57982,
      28672,
      55616,
      45957,
      8438,
      95433,
      37698,
      220862,
      132034,
      39456,
      61870,
      4161,
      26501,
      73560,
      56418,
      9845,
      4654,
      20916,
      10456,
      88920,
      119358,
      9015,
      65931,
      96507,
      48029,
      38534,
      21676,
      109081,
      43078,
      34943,
      25089,
      6131,
      28766,
      23665,
      5477,
      10255,
      16695,
      67,
      45778,
      42443,
      42770,
      29534,
      23733,
      100513,
      62617,
      42630,
      48746,
      14191,
      43753,
      50295,
      26007,
      8792,
      57243,
      43119,
      54725,
      164253,
      58250,
      112304,
      131796,
      25165,
      4651,
      3188,
      24831,
      47748,
      3705,
      19540,
      13211,
      102095,
      5593,
      18699,
      23666,
      32005,
      117571,
      33541,
      60584,
      74573,
      86311,
      99443,
      25172,
      27222,
      168938,
      7143,
      11853,
      53560,
      18834,
      19960,
      86522,
      28217,
      53266,
      117700,
      72989,
      34323,
      18721,
      66450,
      34346,
      74056,
      47217,
      202002,
      46269,
      9429,
      68582,
      75458,
      37823,
      82843,
      96652,
      32549,
      145144,
      27958,
      19820,
      158086,
      31955,
      201406,
      135379,
      31207,
      192545,
      12950,
      51704,
      9094,
      248263,
      76147,
      64028,
      110009,
      79407,
      89345,
      99284,
      223492,
      47966,
      26848,
      15359,
      201137,
      2861,
      110507,
      71231,
      72297,
      31851,
      118777,
      71039,
      151051,
      240855,
      16333,
      50766,
      14727,
      7939,
      4149,
      80908,
      418780,
      88378,
      59276,
      1327,
      7284,
      38576,
      79814,
      65820,
      42199,
      84860,
      49574,
      62596,
      12396,
      70598,
      40117,
      8648,
      7994,
      16836,
      7630,
      14047,
      359699,
      106878,
      525,
      29037,
      28064,
      13380,
      11675,
      50669,
      74216,
      103539,
      180314,
      27449,
      56299,
      172344,
      19274,
      7301,
      246099,
      32043,
      19422,
      36506,
      129317,
      6806,
      30140,
      4614,
      46639,
      66926,
      932,
      86600,
      6322,
      27847,
      233103,
      10541,
      39025,
      34887,
      3517,
      12972,
      26220,
      2031,
      66561,
      115015,
      48658,
      47596,
      12714,
      33845,
      3893,
      16165,
      35237,
      89983,
      14769,
      11962,
      147224,
      47018,
      29977,
      27979,
      5552,
      82338,
      86023,
      131368,
      1218,
      24853,
      237840,
      132193,
      15455,
      40873,
      3668,
      65351,
      53388,
      15229,
      59889,
      272245,
      47934,
      11858,
      34347,
      18038,
      90853,
      86981,
      300602,
      19343,
      114181,
      29362,
      84921,
      6095,
      106059,
      79472,
      38015,
      1206,
      48741,
      6208,
      8e4,
      21916,
      17423,
      6002,
      108083,
      24479,
      34931,
      56661,
      9511,
      26995,
      100694,
      163853,
      35997,
      81254,
      58321,
      18919,
      171890,
      86877,
      91341,
      74503,
      70477,
      53412,
      7027,
      59281,
      39892,
      131302,
      5864,
      15947,
      61301,
      67466,
      162369,
      47956,
      27874,
      35624,
      282324,
      21270,
      111847,
      102548,
      41482,
      30955,
      116737,
      28264,
      8592,
      55458,
      22301,
      75090,
      29821,
      30697,
      51709,
      3041,
      19208,
      8038,
      24634,
      30467,
      87509,
      126428,
      19389,
      18814,
      152686,
      20701,
      83474,
      45832,
      80891,
      105808,
      11378,
      153223,
      120770,
      98186,
      150633,
      49838,
      9141,
      12755,
      30962,
      5260,
      74490,
      21256,
      31678,
      65062,
      33326,
      289838,
      187831,
      20595,
      89768,
      2805,
      58535,
      10844,
      70085,
      12090,
      2451,
      138068,
      98544,
      24461,
      4511,
      6754,
      41684,
      28203,
      3383,
      65355,
      82833,
      30161,
      83924,
      234361,
      128424,
      28921,
      222594,
      33975,
      125491,
      34069,
      11508,
      67464,
      144226,
      41850,
      98703,
      34371,
      7901,
      21254,
      38398,
      65651,
      23549,
      53883,
      213340,
      123269,
      12028,
      71764,
      177701,
      28758,
      2623,
      68395,
      11549,
      15232,
      68603,
      9660,
      63116,
      36079,
      57093,
      31198,
      20475,
      48467,
      89984,
      35619,
      186847,
      107469,
      31389,
      43631,
      73867,
      41949,
      68841,
      114250,
      1605,
      30564,
      63403,
      17588,
      27680,
      99533,
      12641,
      70325,
      50428,
      73426,
      78379,
      11855,
      91651,
      72081,
      91720,
      60198,
      15743,
      12065,
      83398,
      140046,
      6761,
      46598,
      45900,
      5068,
      886,
      62448,
      148968,
      37347,
      19405,
      9680,
      15819,
      43496,
      63370,
      75667,
      163700,
      37639,
      3633,
      22774,
      34341,
      183131,
      134335,
      37200,
      23915,
      7054,
      14194,
      12970,
      26438,
      13350,
      285521,
      25594,
      8219,
      104410,
      91039,
      168804,
      138480,
      149734,
      15907,
      33818,
      61132,
      60082,
      4622,
      110187,
      56736,
      13551,
      73571,
      3945,
      73463,
      65498,
      17758,
      263266,
      17593,
      2710,
      27585,
      54469,
      38200,
      45367,
      63754,
      28881,
      3473,
      12791,
      98287,
      31895,
      65787,
      4463,
      94536,
      24951,
      36332,
      59901,
      28803,
      52130,
      86403,
      7668,
      181822,
      74831,
      18977,
      9850,
      177206,
      145485,
      109798,
      7292,
      31421,
      26280,
      77211,
      58511,
      12507,
      127004,
      11113,
      147,
      8729,
      56208,
      43066,
      79926,
      129937,
      31345,
      83947,
      39915,
      46146,
      98763,
      42566,
      1337,
      13192,
      18323,
      105163,
      80570,
      117753,
      16555,
      72883,
      11077,
      159438,
      40764,
      70933,
      83329,
      26066,
      12276,
      72059,
      21655,
      173836,
      126713,
      69454,
      153482,
      91585,
      70644,
      102558,
      110483,
      6764,
      127864,
      190133,
      3961,
      101798,
      20945,
      71138,
      82402,
      90884,
      69669,
      44753,
      923,
      16939,
      59700,
      164258,
      25969,
      27082,
      31399,
      43846,
      6306,
      246093,
      51342,
      6153,
      151581,
      202801,
      182731,
      56475,
      162188,
      89426,
      141356,
      14355,
      121815,
      27536,
      28023,
      65257,
      77523,
      106668,
      127314,
      24947,
      12790,
      38796,
      169698,
      23555,
      10725,
      44573,
      183083,
      42088,
      62716,
      43265,
      105958,
      32050,
      44067,
      50118,
      1668,
      3874,
      6243,
      318411,
      16599,
      1691,
      94999,
      52378,
      28671,
      216728,
      123258,
      2059,
      34969,
      69225,
      5913,
      136280,
      171443,
      141515,
      91662,
      22175,
      135282,
      80020,
      92270,
      1663,
      4808,
      4482,
      3495,
      34691,
      5226,
      109830,
      108512,
      17342,
      107488,
      11606,
      123190,
      100247,
      29666,
      146527,
      113014,
      15794,
      30894,
      13224,
      39585,
      243192,
      22351,
      9903,
      7836,
      47699,
      11078,
      25468,
      122291,
      48821,
      26780,
      122679,
      75521,
      81450,
      630,
      4895,
      92900,
      55074,
      74293,
      17441,
      3563,
      111657,
      103102,
      51613,
      12318,
      52370,
      36191,
      68245,
      34269,
      40445,
      41354,
      122901,
      168604,
      182500,
      62012,
      42557,
      11259,
      24428,
      115113,
      86345,
      12362,
      3909,
      78430,
      86852,
      134602,
      20459,
      47853,
      93879,
      22577,
      7659,
      3688,
      38555,
      13349,
      17381,
      56715,
      91639,
      12493,
      10895,
      92438,
      3142,
      37057,
      28928,
      2004,
      36427,
      32268,
      34222,
      209974,
      10432,
      67436,
      41989,
      173518,
      107930,
      27079,
      62729,
      30908,
      55558,
      5828,
      45031,
      14902,
      53546,
      8204,
      144263,
      60255,
      14520,
      88212,
      86582,
      109589,
      69356,
      8064,
      47449,
      8505,
      66558,
      16886,
      4844,
      52817,
      111260,
      215129,
      12941,
      91118,
      650,
      20770,
      6273,
      73089,
      40618,
      62790,
      2873,
      35002,
      14023,
      97208,
      19386,
      102646,
      36993,
      143736,
      135457,
      35385,
      113601,
      17893,
      32627,
      84439,
      100619,
      56016,
      6581,
      57264,
      172160,
      45452,
      111710,
      203627,
      70131,
      24100,
      322787,
      1996,
      35665,
      70078,
      22358,
      90922,
      83658,
      4097,
      63200,
      58499,
      14542,
      99153,
      52159,
      6615,
      12414,
      63415,
      31986,
      16823,
      1579,
      65405,
      137809,
      8841,
      16898,
      48082,
      259,
      33014,
      42375,
      12260,
      179850,
      73667,
      91389,
      98882,
      29532,
      17311,
      326251,
      41092,
      5928,
      20742,
      44964,
      48019,
      43505,
      9317,
      49265,
      6643,
      192712,
      48424,
      163487,
      19861,
      20113,
      70848,
      31928,
      105333,
      23685,
      78563,
      14638,
      54755,
      7158,
      24142,
      44018,
      20774,
      125255,
      20331,
      24280,
      10163,
      1285,
      2336,
      39851,
      4299,
      117269,
      46714,
      63816,
      87779,
      159624,
      11731,
      9971,
      990,
      137317,
      108831,
      50994,
      74554,
      162680,
      23640,
      131597,
      146962,
      170620,
      34829,
      91205,
      21184,
      1913,
      63616,
      18427,
      93136,
      156592,
      17519,
      67565,
      115882,
      138220,
      78622,
      88535,
      18115,
      2711,
      33554,
      109492,
      54298,
      971,
      24914,
      25863,
      36363,
      45715,
      27099,
      194995,
      14299,
      178181,
      111488,
      72395,
      322385,
      157719,
      130787,
      11897,
      81843,
      83999,
      11369,
      49280,
      118604,
      40922,
      61332,
      110343,
      53407,
      75639,
      40582,
      300440,
      54722,
      25637,
      13694,
      48248,
      48278,
      194521,
      56203,
      52779,
      48783,
      72627,
      10953,
      376,
      16733,
      280238,
      26351,
      230789,
      15132,
      25168,
      137270,
      3588,
      63704,
      73376,
      94031,
      74284,
      19443,
      159557,
      9697,
      39901,
      13351,
      119050,
      15406,
      146455,
      3460,
      29556,
      75195,
      37673,
      102524,
      92329,
      47289,
      98413,
      15311,
      100684,
      56345,
      7116,
      95480,
      11590,
      7200,
      167,
      23610,
      58426,
      17730,
      136656,
      27944,
      53151,
      2701,
      8824,
      103124,
      3017,
      90744,
      113588,
      53216,
      79736,
      65940,
      26931,
      498,
      29568,
      80540,
      143543,
      21292,
      1740,
      59268,
      16561,
      180816,
      42323,
      50174,
      40890,
      52866,
      10703,
      57169,
      4700,
      17191,
      4424,
      93511,
      49698,
      166650,
      26972,
      48631,
      165169,
      82879,
      69326,
      202970,
      4007,
      2376,
      231325,
      139592,
      22119,
      62851,
      37504,
      68816,
      58345,
      67398,
      186643,
      43331,
      277416,
      53749,
      15746,
      23102,
      17432,
      4793,
      151138,
      48822,
      54265,
      48203,
      198688,
      14305,
      54287,
      2291,
      18018,
      113378,
      123260,
      7180,
      97549,
      87027,
      120085,
      2920,
      76080,
      8190,
      102005,
      5641,
      64580,
      14955,
      59802,
      54028,
      58884,
      19367,
      81779,
      412567,
      85957,
      97053,
      103637,
      78871,
      29364,
      27637,
      141728,
      4767,
      30686,
      112738,
      130146,
      42745,
      12730,
      105040,
      14844,
      232,
      210944,
      36581,
      152317,
      135543,
      29744,
      3129,
      55647,
      58149,
      46319,
      27265,
      17499,
      28005,
      59948,
      7170,
      34138,
      5702,
      293047,
      110892,
      408,
      91760,
      218674,
      18469,
      46095,
      81403,
      14389,
      4610,
      35672,
      73060,
      11006,
      74848,
      104820,
      118143,
      190357,
      20043,
      105358,
      141735,
      5115,
      27093,
      45924,
      123073,
      52599,
      29433,
      9616,
      238350,
      78610,
      24851,
      58858,
      26769,
      31969,
      24613,
      18294,
      4982,
      32735,
      39639,
      143563,
      112073,
      202205,
      12567,
      4873,
      88601,
      44897,
      81503,
      101648,
      81362,
      34662,
      85277,
      17574,
      48173,
      21435,
      221188,
      40215,
      39576,
      80786,
      26544,
      64668,
      81841,
      10731,
      37733,
      247986,
      149188,
      127703,
      495,
      18382,
      54388,
      72446,
      43071,
      30974,
      198723,
      89608,
      41360,
      190,
      33045,
      8386,
      31658,
      19992,
      237838,
      119015,
      137622,
      50890,
      100913,
      6460,
      116233,
      267230,
      26621,
      104129,
      65114,
      14190,
      41542,
      14888,
      85962,
      23342,
      23041,
      26453,
      43725,
      71809,
      45186,
      4770,
      46452,
      53894,
      56616,
      221286,
      18973,
      9038,
      109299,
      55365,
      19366,
      26863,
      18808,
      60909,
      69353,
      41738,
      83463,
      12100,
      68561,
      72860,
      3980,
      13796,
      49340,
      12332,
      31311,
      27418,
      4255,
      53430,
      18976,
      45523,
      510,
      14224,
      30477,
      26581,
      4530,
      3651,
      101663,
      139840,
      22709,
      150861,
      31996,
      63923,
      120623,
      262522,
      3076,
      10528,
      2929,
      14672,
      130238,
      18087,
      9816,
      121894,
      100308,
      25085,
      55111,
      14565,
      18952,
      53293,
      2042,
      369988,
      23674,
      61789,
      133529,
      28783,
      108293,
      35477,
      47119,
      36448,
      71049,
      40015,
      33055,
      78598,
      198442,
      1833,
      159937,
      40654,
      77444,
      189245,
      113153,
      8621,
      18599,
      38553,
      35223,
      166072,
      2375,
      11659,
      21786,
      89523,
      6032,
      12116,
      63046,
      159398,
      18454,
      3678,
      32521,
      47626,
      11411,
      103527,
      38896,
      42946,
      15696,
      26370,
      10185,
      8413,
      37080,
      165583,
      4331,
      63555,
      14907,
      72220,
      50056,
      6623,
      62236,
      36565,
      49783,
      10049,
      17503,
      100581,
      55951,
      146244,
      24724,
      9626,
      17969,
      25524,
      109300,
      173965,
      99994,
      101056,
      46459,
      43647,
      53737,
      277968,
      8347,
      123521,
      74858,
      33829,
      44762,
      77574,
      877,
      81377,
      222525,
      123532,
      30602,
      43881,
      53145,
      2973,
      16284,
      81940,
      61281,
      127044,
      63620,
      9875,
      14756,
      114829,
      19032,
      9202,
      52759,
      119141,
      23928,
      120551,
      19607,
      3599,
      33401,
      76821,
      73233,
      117430,
      39968,
      36539,
      7071,
      5446,
      121735,
      194059,
      15206,
      45283,
      6706,
      15603,
      65615,
      1207,
      165723,
      92275,
      34773,
      104447,
      8396,
      32353,
      205240,
      164323,
      13600,
      60555,
      79205,
      25532,
      22907,
      33410,
      57480,
      107111,
      69630,
      32137,
      47832,
      70913,
      33161,
      20321,
      2371,
      117348,
      10714,
      86246,
      1625,
      11763,
      17900,
      268,
      78457,
      99175,
      97940,
      101092,
      86660,
      32221,
      14041,
      128504,
      125080,
      53744,
      124263,
      31017,
      13897,
      403,
      31859,
      21964,
      5633,
      111630,
      5547,
      77329,
      17961,
      18241,
      84995,
      25984,
      12983,
      67491,
      62168,
      47262,
      5241,
      297,
      51191,
      7351,
      8967,
      147212,
      82060,
      16821,
      782,
      11033,
      82431,
      62957,
      5026,
      43459,
      77963,
      203477,
      53528,
      6247,
      191852,
      87774,
      74164,
      215654,
      13467,
      1522,
      219964,
      28589,
      244104,
      16242,
      117821,
      67725,
      72570,
      156792,
      17186,
      15979,
      26990,
      44128,
      193014,
      35276,
      57125,
      16212,
      166451,
      68017,
      6905,
      77608,
      16364,
      53777,
      75921,
      76426,
      37975,
      26203,
      269296,
      64099,
      84122,
      12077,
      38533,
      830,
      4407,
      20139,
      963,
      43028,
      38902,
      42911,
      37503,
      83343,
      85045,
      16979,
      1165,
      60835,
      137387,
      58380,
      86990,
      110066,
      134540,
      56331,
      193845,
      81238,
      17922,
      163093,
      38744,
      110641,
      12502,
      56404,
      34862,
      26865,
      125964,
      12965,
      111648,
      25547,
      7771,
      27196,
      136980,
      9555,
      29551,
      107158,
      57885,
      18831,
      37705,
      35505,
      101742,
      13970,
      102109,
      62548,
      124657,
      23328,
      11124,
      89592,
      146376,
      248050,
      6241,
      22033,
      18337,
      80685,
      29898,
      11908,
      216623,
      67721,
      106162,
      146610,
      21377,
      15085,
      91552,
      42041,
      62560,
      122532,
      125336,
      102365,
      121537,
      142559,
      29693,
      223919,
      11515,
      110495,
      18776,
      22494,
      5895,
      185059,
      103592,
      229351,
      51220,
      100102,
      37027,
      257855,
      29359,
      54123,
      36066,
      106493,
      12244,
      79258,
      32002,
      432,
      56205,
      94836,
      90182,
      6726,
      14762,
      29391,
      48938,
      26864,
      38083,
      60364,
      3310,
      60192,
      14766,
      205567,
      57504,
      110760,
      22649,
      24666,
      46333,
      21517,
      3430,
      13135,
      28873,
      27052,
      158809,
      11597,
      20529,
      6695,
      23138,
      22960,
      37137,
      45574,
      6545,
      305877,
      43423,
      26153,
      24769,
      59844,
      14501,
      10430,
      134352,
      56169,
      13213,
      103432,
      49523,
      35181,
      13435,
      12408,
      129475,
      64620,
      230854,
      77390,
      51990,
      15653,
      83248,
      33466,
      44571,
      117828,
      51481,
      2187,
      10559,
      68019,
      18021,
      54895,
      48247,
      18354,
      33737,
      4554,
      108595,
      37288,
      39767,
      116707,
      9175,
      3726,
      108877,
      21616,
      83684,
      49862,
      1938,
      8543,
      276466,
      20134,
      108498,
      48770,
      102254,
      31914,
      131520,
      185291,
      100559,
      51890,
      209,
      19526,
      76471,
      50544,
      71814,
      99351,
      8172,
      198526,
      28816,
      20419,
      9109,
      98389,
      136777,
      76479,
      75596,
      30635,
      165417,
      48216,
      120220,
      25955,
      211071,
      39314,
      24308,
      32164,
      2559,
      146280,
      43403,
      9233,
      17947,
      90585,
      1786,
      86920,
      125662,
      2457,
      64741,
      32152,
      32918,
      122882,
      78538,
      44001,
      31723,
      56426,
      23375,
      103172,
      88177,
      145697,
      52506,
      49319,
      68016,
      31664,
      41488,
      18486,
      110400,
      7030,
      28241,
      986,
      109199,
      19900,
      42147,
      56864,
      65287,
      49183,
      7858,
      24e3,
      30453,
      840,
      16673,
      25907,
      68916,
      89927,
      6309,
      158335,
      36407,
      199737,
      130464,
      13137,
      59603,
      201778,
      195292,
      21015,
      42466,
      179062,
      172561,
      89492,
      11075,
      180407,
      31868,
      72493,
      20998,
      60217,
      9865,
      19530,
      39274,
      130266,
      54539,
      21623,
      12535,
      13505,
      40641,
      73375,
      4087,
      85633,
      2153,
      3117,
      70680,
      55788,
      92096,
      47509,
      98493,
      37490,
      271936,
      151475,
      3032,
      16171,
      96642,
      34106,
      78425,
      125761,
      19591,
      3366,
      19316,
      54508,
      24183,
      50786,
      194248,
      91528,
      33253,
      34622,
      108355,
      41741,
      705,
      3814,
      3883,
      108929,
      13203,
      67831,
      10142,
      59754,
      68208,
      29128,
      84820,
      56880,
      38794,
      24972,
      48571,
      40821,
      40476,
      18137,
      164254,
      24064,
      236309,
      79181,
      11282,
      395,
      39169,
      2013,
      51587,
      28551,
      9645,
      701,
      109513,
      115899,
      113566,
      12762,
      62045,
      58322,
      103726,
      41343,
      40866,
      244102,
      143816,
      2490,
      70346,
      40973,
      52618,
      15412,
      30720,
      104315,
      38917,
      42027,
      93676,
      17513,
      107418,
      20706,
      123890,
      13399,
      97727,
      24044,
      87962,
      65606,
      44250,
      98044,
      65276,
      74790,
      101473,
      19350,
      91570,
      1326,
      87790,
      172042,
      7577,
      100813,
      86896,
      85891,
      41512,
      108130,
      27794,
      14875,
      71431,
      12835,
      156250,
      58135,
      3759,
      22476,
      42176,
      115873,
      34686,
      56523,
      73643,
      108505,
      51491,
      20838,
      12721,
      32863,
      45700,
      29496,
      13700,
      34294,
      55360,
      29206,
      155942,
      123812,
      7706,
      163234,
      203,
      132720,
      49358,
      144431,
      8130,
      175788,
      35818,
      3270,
      76832,
      25710,
      54095,
      97274,
      28779,
      94621,
      74396,
      19092,
      128242,
      58067,
      20885,
      14670,
      93255,
      15107,
      63291,
      23654,
      126900,
      129421,
      59294,
      262659,
      9798,
      3251,
      67344,
      28600,
      44629,
      50672,
      29072,
      26999,
      31526,
      23183,
      49175,
      165843,
      175455,
      17282,
      175411,
      32022,
      45989,
      30298,
      90690,
      78118,
      83156,
      23749,
      35636,
      31317,
      7069,
      80381,
      94561,
      133756,
      14960,
      97404,
      6138,
      41065,
      78041,
      32843,
      16601,
      34123,
      9559,
      146529,
      123377,
      96395,
      54441,
      42012,
      84257,
      123541,
      10745,
      22139,
      106459,
      11720,
      150883,
      172651,
      154996,
      110538,
      4728,
      53447,
      25704,
      2009,
      71152,
      119354,
      21166,
      66604,
      1429,
      216162,
      8637,
      122250,
      63520,
      27180,
      29172,
      36124,
      276428,
      107787,
      77184,
      4680,
      14952,
      104903,
      24418,
      14793,
      51561,
      52931,
      8371,
      26342,
      48526,
      7118,
      92066,
      67280,
      40653,
      8847,
      34597,
      105438,
      14198,
      50163,
      61188,
      146286,
      50315,
      41205,
      170829,
      161496,
      585,
      197359,
      95056,
      1687,
      365794,
      91349,
      48507,
      5804,
      49263,
      5146,
      104902,
      96365,
      117343,
      132222,
      46084,
      96919,
      16875,
      8073,
      262381,
      79982,
      52663,
      13928,
      16056,
      153908,
      15145,
      109256,
      132308,
      18763,
      24904,
      167644,
      13618,
      40750,
      18686,
      147124,
      114709,
      150038,
      52849,
      2938,
      12568,
      48617,
      8778,
      5459,
      44202,
      44591,
      74914,
      17183,
      248689,
      13878,
      7822,
      80060,
      23116,
      194037,
      18487,
      2067,
      7798,
      43077,
      33678,
      244028,
      31320,
      74273,
      2794,
      19466,
      8218,
      36280,
      183997,
      48124,
      19416,
      29656,
      19280,
      98734,
      7715,
      18311,
      30701,
      133602,
      150307,
      126956,
      7378,
      2933,
      79903,
      13178,
      12593,
      86571,
      26604,
      92446,
      13574,
      44205,
      65699,
      427599,
      21118,
      8245,
      14407,
      27877,
      47936,
      33542,
      7916,
      26460,
      117762,
      21596,
      37818,
      2249,
      127359,
      209394,
      60044,
      47677,
      308089,
      36791,
      154971,
      31417,
      6998,
      150042,
      174360,
      12255,
      43009,
      29335,
      48739,
      3912,
      101398,
      53340,
      2580,
      146939,
      151295,
      45360,
      125275,
      15273,
      45383,
      27456,
      48761,
      23314,
      8750,
      60801,
      85823,
      104759,
      27894,
      123685,
      66968,
      39480,
      26917,
      55290,
      83305,
      2696,
      98390,
      57569,
      145853,
      340733,
      4919,
      20024,
      52268,
      30884,
      7413,
      203685,
      70989,
      112855,
      4129,
      50536,
      349518,
      68205,
      332641,
      159581,
      135361,
      236026,
      37563,
      176404,
      64899,
      6578,
      122033,
      63871,
      1850,
      85234,
      82089,
      66124,
      74145,
      121098,
      107351,
      12687,
      36881,
      117334,
      13136,
      14698,
      85933,
      93866,
      18047,
      32620,
      310,
      15094,
      46e3,
      88451,
      23632,
      36645,
      27940,
      87618,
      80520,
      58892,
      20976,
      27702,
      140090,
      96075,
      67841,
      103292,
      238964,
      87778,
      107338,
      17019,
      83427,
      67522,
      7302,
      8261,
      47570,
      116787,
      8730,
      80484,
      61772,
      174422,
      56005,
      131193,
      52875,
      14588,
      28471,
      59817,
      9586,
      15720,
      158155,
      51307,
      109734,
      15196,
      11025,
      59331,
      3884,
      52626,
      102602,
      84797,
      25158,
      27314,
      4437,
      20488,
      76214,
      189248,
      35023,
      114952,
      157376,
      2827,
      62439,
      102878,
      129749,
      36405,
      10329,
      109339,
      108633,
      36662,
      1254,
      13267,
      5470,
      87105,
      58004,
      15397,
      10434,
      159667,
      21864,
      52022,
      179464,
      3013,
      32147,
      31496,
      116832,
      18494,
      105502,
      129227,
      107267,
      50033,
      13481,
      9954,
      24267,
      22141,
      16257,
      116154,
      36185,
      950,
      115685,
      11305,
      176708,
      2048,
      178671,
      112573,
      287867,
      162328,
      497663,
      95170,
      50979,
      193861,
      50987,
      30368,
      136257,
      31830,
      46549,
      15119,
      169876,
      23788,
      17462,
      249887,
      57377,
      1949,
      35448,
      14791,
      43769,
      210091,
      3783,
      34612,
      282103,
      88380,
      245190,
      5457,
      20491,
      98908,
      11402,
      86899,
      117916,
      16028,
      162584,
      60644,
      320177,
      156096,
      31065,
      55876,
      22e3,
      77655,
      9992,
      23397,
      13757,
      317623,
      63978,
      215255,
      2443,
      17648,
      93231,
      27388,
      104529,
      93807,
      55505,
      140477,
      12046,
      112040,
      70887,
      40152,
      94365,
      112353,
      25063,
      114679,
      266061,
      71248,
      119555,
      15589,
      2244,
      617,
      14129,
      211431,
      70110,
      100652,
      7777,
      4383,
      85911,
      89221,
      21010,
      120615,
      58357,
      86405,
      37554,
      41647,
      18,
      15143,
      69662,
      60491,
      14714,
      186134,
      148344,
      42347,
      5410,
      168175,
      44535,
      42449,
      343894,
      129417,
      99682,
      20659,
      27272,
      140483,
      63455,
      222159,
      17536,
      13722,
      42637,
      62324,
      11976,
      114691,
      148109,
      2283,
      32057,
      182393,
      4295,
      147364,
      33705,
      2075,
      44303,
      30274,
      28331,
      63740,
      69740,
      29148,
      10346,
      44862,
      33716,
      73937,
      153333,
      12930,
      38784,
      247159,
      2515,
      41053,
      20256,
      83368,
      256189,
      54639,
      115240,
      5096,
      24661,
      175419,
      153552,
      26516,
      141,
      138176,
      63885,
      34115,
      47222,
      55709,
      2765,
      28479,
      38875,
      236608,
      12229,
      22921,
      77291,
      54426,
      45388,
      2860,
      57787,
      114579,
      295139,
      105782,
      17826,
      71066,
      19119,
      54364,
      69385,
      16568,
      12323,
      28057,
      33346,
      34919,
      124763,
      155533,
      101386,
      31644,
      8627,
      49001,
      303600,
      29868,
      63213,
      9103,
      77280,
      71333,
      9696,
      138789,
      37059,
      24823,
      5057,
      21352,
      32368,
      114208,
      56803,
      19424,
      10445,
      58514,
      8661,
      209508,
      26187,
      171838,
      10460,
      63454,
      14016,
      122504,
      41328,
      21329,
      46618,
      32493,
      38225,
      7855,
      31763,
      7945,
      29876,
      8734,
      6438,
      24205,
      97490,
      139977,
      130740,
      47323,
      33195,
      85390,
      57194,
      13813,
      60600,
      21313,
      96251,
      7699,
      27584,
      170521,
      139271,
      1363,
      4402,
      336738,
      129223,
      84983,
      69150,
      13147,
      3590,
      163929,
      207225,
      155260,
      55916,
      20288,
      4503,
      8398,
      98490,
      11773,
      27512,
      37113,
      84976,
      86558,
      28365,
      11756,
      116005,
      182148,
      13733,
      115313,
      47644,
      67208,
      85069,
      9347,
      14995,
      226141,
      14704,
      101835,
      41159,
      35314,
      13113,
      63526,
      214039,
      29978,
      50446,
      83339,
      17440,
      129441,
      72522,
      118641,
      97816,
      24907,
      73844,
      15717,
      118884,
      167255,
      96509,
      162793,
      30847,
      36849,
      51297,
      78974,
      77793,
      10427,
      1873,
      2972,
      9999,
      35074,
      28190,
      64297,
      146836,
      46298,
      60038,
      163007,
      108919,
      61219,
      2403,
      75022,
      127339,
      4233,
      110389,
      69022,
      9833,
      128097,
      88016,
      79390,
      222936,
      22570,
      94657,
      28462,
      56956,
      38803,
      81536,
      30474,
      152794,
      19566,
      16481,
      147408,
      74574,
      81895,
      20731,
      1918,
      1366,
      76367,
      187321,
      54494,
      24366,
      21690,
      61696,
      33283,
      107477,
      77499,
      31112,
      414383,
      74362,
      18463,
      218441,
      120929,
      59848,
      258629,
      201924,
      69269,
      454,
      19989,
      13054,
      59894,
      3623,
      58908,
      20681,
      35723,
      78523,
      102680,
      38988,
      184112,
      108087,
      50944,
      132704,
      52966,
      21699,
      18860,
      96349,
      201411,
      82697,
      85395,
      95658,
      5093,
      6427,
      177894,
      44191,
      32755,
      26961,
      155739,
      6249,
      31310,
      81030,
      26574,
      84311,
      120155,
      86730,
      113535,
      7424,
      48888,
      13516,
      45747,
      98098,
      20077,
      183995,
      81945,
      43210,
      26704,
      40420,
      75831,
      45648,
      11180,
      6855,
      57927,
      65528,
      124096,
      34851,
      2598,
      156633,
      107572,
      127352,
      38169,
      123845,
      60142,
      62722,
      105584,
      232364,
      23211,
      68120,
      1601,
      22169,
      89299,
      747,
      258039,
      80572,
      7258,
      152249,
      11862,
      101204,
      8834,
      121434,
      33761,
      19175,
      133142,
      46343,
      40178,
      48723,
      3589,
      41977,
      30210,
      38868,
      62257,
      10087,
      82658,
      87827,
      90646,
      16415,
      47552,
      351723,
      28298,
      72225,
      91146,
      272760,
      1701,
      11295,
      1652,
      109651,
      300747,
      51863,
      198800,
      29446,
      11794,
      32345,
      37538,
      22356,
      33102,
      37590,
      113544,
      37970,
      11478,
      179743,
      25454,
      103417,
      59905,
      221970,
      105196,
      145604,
      7817,
      164809,
      102360,
      16974,
      75840,
      255333,
      56902,
      6659,
      1954,
      645,
      59400,
      67769,
      7689,
      18675,
      5215,
      13793,
      20536,
      27852,
      3387,
      29523,
      259718,
      16860,
      94625,
      43143,
      29245,
      15848,
      233581,
      22685,
      63631,
      78557,
      22836,
      133302,
      84513,
      1348,
      51826,
      47129,
      98836,
      58284,
      1830,
      1749,
      94642,
      10933,
      6145,
      12506,
      10975,
      13879,
      103781,
      144434,
      10268,
      28409,
      32346,
      52968,
      121567,
      107374,
      77268,
      23686,
      35097,
      10501,
      155275,
      15303,
      47136,
      21102,
      168741,
      55332,
      90385,
      15996,
      84817,
      681,
      137803,
      25054,
      142275,
      6163,
      38175,
      8056,
      124296,
      240642,
      65621,
      4934,
      178205,
      16101,
      62803,
      60964,
      18230,
      100622,
      76465,
      44689,
      14545,
      9543,
      47514,
      16852,
      93380,
      28048,
      12047,
      107106,
      37575,
      101485,
      77047,
      57326,
      34819,
      96137,
      76916,
      6469,
      46264,
      115983,
      75768,
      87668,
      69942,
      13027,
      165,
      8373,
      114231,
      26434,
      52844,
      42799,
      182044,
      23580,
      146254,
      38081,
      43236,
      33883,
      146220,
      382894,
      14606,
      46035,
      36481,
      166621,
      35417,
      95382,
      2957,
      59384,
      60428,
      36358,
      66343,
      75378,
      22267,
      22950,
      83528,
      17577,
      56474,
      25285,
      4619,
      179691,
      75355,
      95836,
      53295,
      34588,
      171410,
      4487,
      14679,
      84208,
      44015,
      18562,
      109133,
      54101,
      11531,
      86052,
      174479,
      303157,
      28095,
      9953,
      35642,
      14564,
      39802,
      16145,
      77606,
      117406,
      53038,
      121117,
      53624,
      22062,
      1212,
      7632,
      127157,
      237292,
      189087,
      10478,
      127345,
      102515,
      181997,
      86752,
      87623,
      10966,
      121602,
      68783,
      68681,
      83042,
      114380,
      138349,
      191305,
      67176,
      50085,
      39016,
      1427,
      42384,
      1412,
      67118,
      122616,
      72389,
      25260,
      2237,
      13576,
      137346,
      19938,
      20304,
      2191,
      68759,
      5373,
      61364,
      238507,
      75814,
      23931,
      69565,
      38993,
      131741,
      38364,
      12528,
      87762,
      5679,
      129853,
      5310,
      186831,
      32653,
      90338,
      260176,
      389531,
      108118,
      26843,
      43985,
      50175,
      30563,
      25106,
      56965,
      18130,
      140428,
      4542,
      165503,
      117991,
      24219,
      229605,
      1819,
      129663,
      1240,
      3797,
      76093,
      18398,
      71339,
      51919,
      93043,
      27175,
      47060,
      216257,
      6483,
      35051,
      1217,
      16512,
      80798,
      129064,
      13225,
      69339,
      8548,
      237079,
      72298,
      2575,
      34280,
      51379,
      117910,
      55671,
      53345,
      247552,
      29486,
      39328,
      140821,
      34681,
      57045,
      60177,
      5004,
      90269,
      78522,
      2479,
      322607,
      48474,
      61296,
      13057,
      31558,
      4678,
      59271,
      6699,
      27044,
      31988,
      35944,
      12503,
      83480,
      4389,
      136508,
      3781,
      114121,
      70279,
      4488,
      155829,
      42214,
      2898,
      68191,
      75695,
      305850,
      45041,
      74344,
      106509,
      30087,
      17429,
      93292,
      12477,
      290,
      23080,
      114802,
      35714,
      18751,
      26554,
      105424,
      17775,
      2144,
      2412,
      100610,
      65192,
      113975,
      52975,
      180272,
      135050,
      129815,
      76238,
      106483,
      21440,
      63186,
      4260,
      46189,
      9711,
      28249,
      4169,
      23429,
      23390,
      8324,
      141585,
      63809,
      67668,
      38457,
      38063,
      39226,
      59972,
      1189,
      203916,
      62368,
      14403,
      16949,
      61767,
      85801,
      1739,
      40147,
      35049,
      76757,
      33124,
      62102,
      15780,
      103593,
      103009,
      53484,
      22952,
      67973,
      114645,
      6566,
      5245,
      50462,
      7601,
      8288,
      3513,
      194571,
      80276,
      1908,
      54592,
      5124,
      58571,
      2513,
      6800,
      273997,
      193904,
      1119,
      17991,
      117245,
      2508,
      129156,
      82366,
      26278,
      71465,
      63341,
      56943,
      39662,
      106116,
      94966,
      156875,
      9736,
      2204,
      122308,
      94418,
      27134,
      1280,
      24539,
      49022,
      45314,
      3764,
      50904,
      46424,
      30699,
      28087,
      293839,
      9400,
      33646,
      40165,
      822,
      147499,
      50263,
      116179,
      29085,
      11863,
      31314,
      5578,
      17797,
      5104,
      12454,
      1604,
      15342,
      219206,
      10232,
      67800,
      94261,
      25872,
      13565,
      90339,
      78971,
      75377,
      26649,
      41184,
      47695,
      11514,
      35369,
      20767,
      14227,
      41953,
      309396,
      148270,
      147938,
      33074,
      14453,
      27499,
      109019,
      39018,
      25738,
      240196,
      158931,
      52820,
      8612,
      95853,
      21524,
      137010,
      84901,
      70869,
      70021,
      116794,
      48404,
      38771,
      6732,
      1070,
      70990,
      187297,
      49140,
      5238,
      576,
      3564,
      253975,
      16027,
      16483,
      2811,
      37775,
      19034,
      25259,
      4053,
      2e3,
      70083,
      95774,
      19713,
      33431,
      92703,
      91314,
      42381,
      288770,
      48194,
      95985,
      3991,
      77418,
      13406,
      241328,
      245086,
      56533,
      35275,
      62725,
      9246,
      51924,
      70181,
      95331,
      16163,
      31410,
      79016,
      39312,
      120878,
      119371,
      275987,
      80124,
      27712,
      9186,
      220,
      23598,
      146167,
      85209,
      68238,
      282190,
      57048,
      31273,
      30555,
      80913,
      17594,
      75779,
      59160,
      135002,
      101219,
      189377,
      29225,
      96735,
      60126,
      62522,
      104e3,
      27620,
      86814,
      17240,
      147533,
      11001,
      5425,
      43682,
      410,
      49460,
      87270,
      69480,
      46315,
      59448,
      1816,
      76201,
      9431,
      11788,
      87960,
      29063,
      65539,
      47347,
      11678,
      33846,
      7008,
      196704,
      9895,
      6753,
      8633,
      120892,
      59970,
      572824,
      115934,
      6646,
      202559,
      892,
      48351,
      37611,
      251282,
      57823,
      67263,
      57750,
      26527,
      34485,
      90747,
      7685,
      88370,
      6144,
      64182,
      1709,
      41969,
      21458,
      62327,
      181657,
      49247,
      225330,
      122600,
      114574,
      107124,
      85361,
      111833,
      63243,
      71420,
      15655,
      191178,
      72430,
      18063,
      51425,
      54002,
      12364,
      53225,
      86557,
      18193,
      97580,
      41232,
      138398,
      67821,
      128724,
      8944,
      233212,
      101353,
      52099,
      42127,
      14006,
      120107,
      32789,
      32132,
      3498,
      18123,
      33758,
      56058,
      5779,
      128760,
      59888,
      98869,
      18445,
      84702,
      51911,
      13234,
      218379,
      20093,
      39031,
      8074,
      70195,
      20708,
      23462,
      24355,
      131384,
      60189,
      26390,
      10403,
      41060,
      7140,
      10781,
      49410,
      42261,
      87202,
      82566,
      41663,
      43105,
      60276,
      2768,
      5733,
      74176,
      28329,
      2297,
      145430,
      131632,
      83615,
      122915,
      105441,
      655,
      224102,
      5284,
      136426,
      67763,
      16294,
      188511,
      32538,
      61049,
      27893,
      3394,
      13951,
      159099,
      28542,
      17930,
      145360,
      9492,
      190122,
      32285,
      78855,
      26440,
      13570,
      58648,
      73908,
      4239,
      124561,
      2444,
      74172,
      53131,
      11468,
      10794,
      73566,
      11623,
      35343,
      64710,
      30481,
      4163,
      10328,
      38309,
      29901,
      10538,
      154377,
      76132,
      92405,
      24839,
      11679,
      3465,
      13449,
      11637,
      7824,
      2337,
      57754,
      1260,
      14458,
      41118,
      19878,
      38661,
      13416,
      159180,
      37074,
      163164,
      54137,
      28627,
      52134,
      184900,
      8520,
      40385,
      29546,
      30502,
      22386,
      66527,
      107458,
      6850,
      24022,
      47983,
      30603,
      35083,
      8934,
      304066,
      39500,
      9,
      28261,
      33026,
      77251,
      9374,
      44833,
      116312,
      34990,
      29236,
      63563,
      125639,
      135405,
      165398,
      159055,
      55690,
      88141,
      69643,
      236964,
      31983,
      25572,
      20436,
      36746,
      60896,
      31850,
      16179,
      11828,
      5888,
      3043,
      66368,
      9750,
      31167,
      7915,
      53111,
      36430,
      1333,
      64344,
      93659,
      20061,
      60596,
      180191,
      51630,
      6792,
      30244,
      43509,
      101058,
      22409,
      420,
      44210,
      109783,
      43223,
      27030,
      72477,
      72831,
      32679,
      29235,
      7675,
      47556,
      12258,
      39907,
      149412,
      84926,
      118247,
      24692,
      71717,
      105038,
      86009,
      45941,
      41189,
      89453,
      29856,
      52543,
      30627,
      226798,
      67303,
      59230,
      67415,
      34408,
      1367,
      99685,
      16867,
      128419,
      52147,
      4111,
      125381,
      117881,
      16173,
      44093,
      102224,
      31575,
      23234,
      24870,
      83790,
      127407,
      239098,
      3200,
      994,
      1255,
      100903,
      242275,
      117266,
      55116,
      38205,
      16140,
      29662,
      11307,
      40414,
      208793,
      123355,
      56470,
      4862,
      75600,
      30119,
      58218,
      70828,
      24075,
      26974,
      7802,
      192353,
      4851,
      5475,
      78720,
      66596,
      3409,
      28573,
      64396,
      30381,
      30690,
      59859,
      88256,
      5406,
      99945,
      103064,
      34463,
      37727,
      24238,
      86643,
      60088,
      4057,
      23741,
      5967,
      162904,
      38240,
      28356,
      93858,
      25510,
      122879,
      6897,
      3278,
      7057,
      11971,
      4400,
      35461,
      211413,
      21395,
      59615,
      39471,
      87233,
      55795,
      128426,
      3051,
      22470,
      41950,
      14705,
      3974,
      180108,
      80476,
      78442,
      204996,
      91987,
      15634,
      67610,
      139015,
      142373,
      35611,
      51134,
      10387,
      4353,
      153456,
      57749,
      181039,
      14183,
      68447,
      151532,
      21107,
      36452,
      20551,
      3186,
      46247,
      46383,
      129666,
      88736,
      140662,
      146243,
      2066,
      8360,
      7978,
      64818,
      106963,
      17896,
      47801,
      10723,
      114821,
      223295,
      74192,
      3293,
      3393,
      16987,
      74064,
      11277,
      91622,
      4270,
      29828,
      27951,
      387869,
      103235,
      1374,
      61988,
      120083,
      477,
      145892,
      128378,
      11779,
      211263,
      61354,
      18221,
      17869,
      46530,
      83061,
      108538,
      157981,
      90608,
      67199,
      95080,
      49064,
      195814,
      12302,
      66307,
      10348,
      231346,
      160732,
      112859,
      63633,
      146558,
      21271,
      31037,
      198802,
      47622,
      12862,
      95710,
      3910,
      77850,
      73961,
      85585,
      34752,
      61e3,
      4082,
      24595,
      103679,
      71107,
      8208,
      79568,
      150019,
      16615,
      24961,
      139857,
      32664,
      197366,
      4559,
      54735,
      32696,
      4126,
      162019,
      75698,
      13916,
      70108,
      159638,
      19834,
      9349,
      24675,
      175560,
      49643,
      18206,
      52459,
      27992,
      10809,
      88865,
      401975,
      133172,
      29e3,
      34558,
      30915,
      3658,
      25834,
      42430,
      36562,
      125265,
      18182,
      10155,
      40149,
      97082,
      208980,
      19575,
      60853,
      90529,
      66545,
      9600,
      789,
      46420,
      2317,
      88593,
      55595,
      98980,
      115302,
      5742,
      169155,
      1073,
      177901,
      3472,
      11189,
      63711,
      78643,
      65472,
      50459,
      127979,
      93,
      42202,
      67053,
      21720,
      157650,
      11145,
      141378,
      42033,
      22824,
      85705,
      79114,
      35584,
      15974,
      1510,
      54172,
      28562,
      12451,
      104226,
      19190,
      97151,
      73024,
      20948,
      5151,
      81741,
      21499,
      29006,
      84183,
      198074,
      54003,
      45120,
      170125,
      26240,
      35177,
      28389,
      64863,
      79974,
      60778,
      176915,
      232183,
      45342,
      2038,
      80253,
      41564,
      40703,
      32689,
      5430,
      100689,
      5366,
      23007,
      134279,
      14266,
      26712,
      73993,
      24934,
      64242,
      52113,
      102887,
      61801,
      46415,
      201049,
      54251,
      62133,
      122757,
      164883,
      30815,
      139966,
      2319,
      30842,
      766,
      13362,
      10287,
      134518,
      86111,
      81665,
      82440,
      28333,
      43019,
      18963,
      8804,
      161944,
      23439,
      102144,
      101145,
      80029,
      39052,
      248708,
      30350,
      117340,
      11878,
      128467,
      974,
      138625,
      63961,
      5237,
      74778,
      61834,
      67040,
      43814,
      13690,
      65947,
      33809,
      232476,
      115258,
      181745,
      28824,
      94013,
      9510,
      10246,
      93722,
      81976,
      7217,
      114383,
      3493,
      16014,
      69045,
      72692,
      12145,
      80981,
      9507,
      6692,
      1620,
      60820,
      330444,
      35474,
      33962,
      4797,
      7053,
      295463,
      46445,
      27026,
      12491,
      77988,
      49524,
      35675,
      90947,
      29114,
      166705,
      101385,
      133782,
      32704,
      6186,
      84595,
      176031,
      185623,
      45966,
      151302,
      63069,
      1699,
      107491,
      947,
      15458,
      74452,
      196212,
      6046,
      10498,
      12163,
      10239,
      35191,
      243951,
      9277,
      9090,
      29539,
      54460,
      22820,
      26514,
      112549,
      60372,
      51753,
      48756,
      21812,
      70861,
      260326,
      41,
      44222,
      10441,
      16961,
      48148,
      138771,
      216194,
      5914,
      52153,
      53400,
      212036,
      56519,
      26245,
      10117,
      45888,
      15294,
      138019,
      90913,
      26368,
      43842,
      42111,
      23348,
      6082,
      194845,
      161089,
      156206,
      51546,
      11647,
      30759,
      302912,
      262094,
      8635,
      78876,
      26535,
      35283,
      54183,
      31183,
      85484,
      147873,
      12989,
      5197,
      6356,
      72894,
      65347,
      20150,
      27370,
      73787,
      1493,
      45918,
      12366,
      190217,
      20724,
      13858,
      10981,
      67449,
      81213,
      7553,
      14115,
      72242,
      271517,
      11842,
      48310,
      88743,
      143726,
      22177,
      3290,
      243231,
      58452,
      62937,
      12592,
      1654,
      40066,
      33477,
      13751,
      9921,
      128442,
      15868,
      7106,
      75236,
      83773,
      10775,
      36938,
      10482,
      170465,
      17368,
      17469,
      161508,
      32752,
      98340,
      800,
      19824,
      264456,
      3901,
      87319,
      2867,
      26782,
      9630,
      113102,
      185815,
      24197,
      44584,
      86366,
      40224,
      3636,
      140916,
      31731,
      267731,
      9567,
      53678,
      72984,
      29389,
      27963,
      17106,
      50282,
      284911,
      60170,
      8322,
      12608,
      23374,
      89652,
      5268,
      39044,
      229766,
      8869,
      151350,
      31436,
      177342,
      12269,
      183212,
      120418,
      116270,
      2843,
      78888,
      69192,
      7865,
      184099,
      1086,
      129897,
      18383,
      70508,
      20242,
      18508,
      229924,
      124569,
      35749,
      50589,
      55626,
      9884,
      83115,
      40971,
      30671,
      18135,
      14452,
      38861,
      17844,
      201826,
      5549,
      26413,
      17189,
      13561,
      38539,
      10679,
      143331,
      3314,
      36785,
      171194,
      49685,
      187713,
      67506,
      4618,
      104039,
      17060,
      195080,
      50648,
      33159,
      19238,
      67559,
      134840,
      28599,
      157523,
      17130,
      38064,
      117398,
      94355,
      31918,
      13575,
      34538,
      40326,
      13997,
      3494,
      348283,
      62481,
      26862,
      3603,
      104426,
      244363,
      153709,
      112487,
      304612,
      199674,
      41239,
      35545,
      54869,
      293005,
      28223,
      26277,
      26899,
      4533,
      18518,
      15492,
      38587,
      80488,
      70485,
      160395,
      263,
      60162,
      11382,
      222152,
      4696,
      250751,
      51921,
      182609,
      10707,
      48463,
      46243,
      1227,
      49111,
      111564,
      46502,
      33342,
      56846,
      68541,
      63559,
      858,
      139927,
      16654,
      229375,
      76759,
      26478,
      33205,
      95828,
      23399,
      92945,
      2637,
      35630,
      28470,
      143992,
      50214,
      14174,
      21456,
      166191,
      65665,
      1711,
      21594,
      78019,
      97599,
      111701,
      36,
      147151,
      110246,
      189022,
      43021,
      30397,
      40757,
      131935,
      42065,
      73335,
      48039,
      26596,
      28984,
      15102,
      2361,
      7421,
      202167,
      69744,
      43766,
      52826,
      3642,
      83304,
      33873,
      75140,
      63169,
      192389,
      36551,
      92748,
      13039,
      123959,
      233220,
      21738,
      84447,
      77230,
      20228,
      187852,
      19095,
      25799,
      92136,
      108774,
      29237,
      53947,
      2299,
      118106,
      2687,
      8830,
      42331,
      202924,
      33667,
      2023,
      73763,
      30704,
      19363,
      19779,
      16737,
      35629,
      48081,
      24068,
      101013,
      162338,
      291912,
      13749,
      24745,
      328289,
      167679,
      70086,
      48299,
      23306,
      16732,
      17801,
      43322,
      54589,
      3586,
      63653,
      43624,
      53474,
      925,
      109177,
      251316,
      43805,
      13082,
      19511,
      86565,
      142182,
      92461,
      17117,
      101033,
      103319,
      64589,
      4022,
      4351,
      235897,
      5352,
      82705,
      107142,
      46391,
      156084,
      5860,
      61365,
      10558,
      13045,
      7717,
      18357,
      33922,
      12590,
      33065,
      6928,
      46993,
      783,
      46937,
      67846,
      8952,
      26295,
      6107,
      119656,
      18799,
      17458,
      50747,
      4229,
      179559,
      112727,
      118080,
      20683,
      41464,
      125468,
      51560,
      49749,
      44231,
      7359,
      35339,
      62988,
      136487,
      67015,
      5208,
      29150,
      24956,
      105186,
      48858,
      6143,
      18097,
      6972,
      16404,
      73489,
      58742,
      97196,
      36357,
      164616,
      5834,
      32267,
      13746,
      147733,
      15113,
      132091,
      34127,
      106298,
      39729,
      106426,
      22294,
      9780,
      15602,
      36213,
      71502,
      42808,
      66802,
      599,
      60755,
      5851,
      39120,
      67363,
      108623,
      126368,
      72770,
      91263,
      32486,
      30596,
      151717,
      7951,
      52002,
      43103,
      11768,
      68942,
      40901,
      39344,
      24037,
      127500,
      116890,
      48403,
      16926,
      86750,
      17745,
      48648,
      159545,
      34460,
      58419,
      5634,
      114317,
      67865,
      31462,
      23352,
      24010,
      98185,
      125708,
      69686,
      68337,
      13610,
      26271,
      70691,
      2980,
      4768,
      27225,
      102402,
      75453,
      28106,
      8104,
      6931,
      1176,
      6274,
      6475,
      112635,
      22498,
      6176,
      238686,
      26832,
      28893,
      90319,
      14441,
      15682,
      15087,
      39517,
      45270,
      109134,
      104440,
      45965,
      47645,
      81772,
      7876,
      52683,
      87720,
      12898,
      4505,
      185665,
      2769,
      113401,
      15664,
      57592,
      105229,
      137381,
      97059,
      119268,
      6876,
      43309,
      33886,
      128363,
      35476,
      144249,
      67013,
      143587,
      83367,
      25703,
      91436,
      59347,
      53236,
      2289,
      16519,
      19844,
      46309,
      58558,
      99834,
      23313,
      218816,
      231303,
      36388,
      51333,
      183535,
      109792,
      139277,
      54306,
      90139,
      18235,
      8275,
      32710,
      37677,
      82464,
      86025,
      92204,
      88842,
      117723,
      37570,
      128723,
      234242,
      76350,
      73795,
      34896,
      148247,
      58424,
      11105,
      11744,
      45746,
      63372,
      17118,
      49772,
      199520,
      81902,
      38004,
      22911,
      33752,
      3125,
      1995,
      53792,
      4689,
      26909,
      108150,
      146062,
      69674,
      41811,
      161444,
      84855,
      8999,
      28561,
      16731,
      93937,
      3189,
      21967,
      24890,
      22943,
      1356,
      145300,
      51569,
      28802,
      517,
      118679,
      31703,
      40607,
      48098,
      108854,
      25003,
      10233,
      73969,
      177495,
      5248,
      24516,
      215347,
      146192,
      48712,
      60626,
      69188,
      40735,
      5866,
      586,
      101541,
      6509,
      47590,
      52129,
      5969,
      222045,
      110933,
      25733,
      24223,
      65339,
      62812,
      2414,
      155418,
      35819,
      16022,
      78423,
      43138,
      20995,
      128255,
      240673,
      46745,
      236093,
      72176,
      57085,
      97841,
      61248,
      107,
      36068,
      193177,
      105427,
      55726,
      215229,
      20446,
      47228,
      100420,
      87091,
      14429,
      121708,
      23605,
      21157,
      187721,
      21880,
      2997,
      203976,
      99166,
      95068,
      25877,
      7724,
      98925,
      83401,
      4829,
      13182,
      18229,
      13718,
      239662,
      38653,
      116505,
      153497,
      30589,
      89029,
      38962,
      181302,
      43853,
      78872,
      180301,
      4786,
      248240,
      7401,
      106136,
      112590,
      77745,
      19731,
      60880,
      77789,
      125748,
      135487,
      5975,
      48627,
      34084,
      12419,
      215770,
      47557,
      254582,
      10364,
      106495,
      21856,
      67539,
      88981,
      38805,
      21428,
      48732,
      42316,
      12149,
      16078,
      52808,
      25327,
      51322,
      33850,
      51147,
      12253,
      122354,
      46077,
      56483,
      254553,
      115417,
      81834,
      150991,
      94662,
      86668,
      7381,
      12841,
      100650,
      18218,
      15741,
      22372,
      68294,
      50705,
      15535,
      84660,
      61887,
      22553,
      72299,
      31361,
      24824,
      17743,
      46820,
      64288,
      31582,
      77006,
      111674,
      116384,
      30760,
      80920,
      86149,
      77192,
      51979,
      79691,
      60342,
      122805,
      103800,
      240873,
      160744,
      233114,
      78962,
      54920,
      8608,
      3484,
      316104,
      72548,
      24337,
      5088,
      230040,
      21926,
      10172,
      36838,
      26,
      86221,
      83458,
      102176,
      12062,
      17571,
      41929,
      41170,
      28428,
      68239,
      41750,
      103930,
      2634,
      18313,
      53019,
      34825,
      97837,
      63115,
      24606,
      73157,
      152474,
      14715,
      91439,
      37033,
      109806,
      140259,
      30668,
      174760,
      380,
      135597,
      95673,
      136073,
      65073,
      134249,
      13829,
      17279,
      122305,
      4420,
      46444,
      10237,
      64848,
      203623,
      70728,
      10349,
      182885,
      65075,
      24519,
      25783,
      40318,
      34139,
      22222,
      63394,
      55266,
      102764,
      41422,
      20126,
      65100,
      90408,
      53640,
      35128,
      48932,
      11192,
      38935,
      96839,
      34782,
      39492,
      19396,
      41332,
      6250,
      5511,
      19492,
      51304,
      25936,
      104466,
      54099,
      73771,
      86115,
      5080,
      7669,
      30891,
      111700,
      13931,
      25276,
      72289,
      135447,
      14820,
      258641,
      25265,
      31005,
      281179,
      75286,
      393,
      95359,
      14623,
      13584,
      6680,
      101227,
      80173,
      44933,
      76666,
      54542,
      13244,
      39348,
      458,
      25379,
      109451,
      134348,
      81143,
      6959,
      65554,
      12027,
      51311,
      8716,
      57589,
      140731,
      28467,
      23316,
      17272,
      30458,
      25980,
      55229,
      77197,
      83798,
      28302,
      114784,
      7428,
      34548,
      26241,
      14712,
      39336,
      103304,
      18928,
      54080,
      12870,
      334,
      87722,
      15208,
      16895,
      142098,
      114262,
      39820,
      83913,
      57817,
      28682,
      7721,
      14900,
      108672,
      11250,
      62246,
      42849,
      415188,
      1724,
      26555,
      24549,
      25505,
      26443,
      107450,
      145899,
      61035,
      43528,
      6901,
      60726,
      65906,
      267741,
      21338,
      147590,
      42079,
      18924,
      73017,
      135236,
      15393,
      5206,
      4026,
      84185,
      1531,
      5988,
      113890,
      82647,
      303391,
      7386,
      69844,
      71611,
      189865,
      76523,
      31877,
      13315,
      19314,
      198575,
      32821,
      1928,
      67641,
      25913,
      104475,
      103489,
      3297,
      70391,
      18406,
      15446,
      113347,
      19295,
      93790,
      27856,
      1792,
      167471,
      116449,
      8541,
      4408,
      41757,
      63233,
      25765,
      86680,
      64501,
      27034,
      24816,
      34975,
      6079,
      4486,
      49693,
      36229,
      16917,
      21581,
      62426,
      27862,
      11612,
      54284,
      35702,
      194034,
      355,
      24277,
      48262,
      87411,
      70504,
      310164,
      118018,
      12516,
      47559,
      43502,
      57433,
      107139,
      9290,
      66533,
      80863,
      14634,
      34312,
      91725,
      28606,
      21342,
      67241,
      72355,
      43244,
      375789,
      37402,
      174015,
      105070,
      8342,
      44167,
      67494,
      1890,
      16365,
      11723,
      271002,
      1865,
      47918,
      8350,
      45564,
      27742,
      25110,
      125803,
      8553,
      49504,
      81925,
      62211,
      4534,
      15491,
      19011,
      80373,
      206920,
      667,
      102405,
      128623,
      245524,
      5553,
      113309,
      192739,
      65766,
      19567,
      22832,
      261958,
      29679,
      21293,
      71134,
      20962,
      105123,
      24721,
      860,
      21752,
      33448,
      18372,
      157167,
      94822,
      35770,
      173224,
      232737,
      75729,
      28937,
      46828,
      28062,
      25453,
      5207,
      140366,
      36665,
      30652,
      6169,
      67920,
      150458,
      92040,
      23186,
      184604,
      92330,
      20891,
      176492,
      49427,
      27828,
      38305,
      42495,
      143982,
      49560,
      25503,
      90043,
      29747,
      65328,
      47830,
      12932,
      11068,
      77721,
      9003,
      25213,
      94205,
      140426,
      46090,
      89945,
      138173,
      192691,
      33329,
      112232,
      129905,
      35709,
      27514,
      1841,
      19957,
      31411,
      127476,
      53572,
      17497,
      173549,
      55063,
      175135,
      19841,
      69314,
      5192,
      237921,
      117660,
      150697,
      4060,
      273045,
      50414,
      98940,
      65348,
      153665,
      164423,
      58804,
      156695,
      48994,
      213928,
      86036,
      28608,
      8355,
      39574,
      34540,
      16927,
      135680,
      18374,
      151587,
      10830,
      53805,
      16878,
      16623,
      4282,
      48030,
      8537,
      14986,
      46102,
      13062,
      72897,
      72,
      33050,
      108227,
      39451,
      45935,
      651,
      113320,
      40535,
      95176,
      57450,
      48843,
      5003,
      19019,
      10407,
      211163,
      3848,
      1068,
      4988,
      32091,
      30095,
      41692,
      15099,
      43602,
      107434,
      50744,
      7627,
      171349,
      16313,
      150832,
      352665,
      207750,
      33937,
      38256,
      51091,
      156e3,
      87889,
      90663,
      84175,
      24908,
      114900,
      50365,
      31494,
      83829,
      5398,
      169342,
      47521,
      54818,
      18935,
      8356,
      43094,
      41212,
      174536,
      10082,
      92550,
      6678,
      60614,
      23355,
      69721,
      14796,
      34149,
      128830,
      58187,
      3179,
      208,
      40325,
      28399,
      225029,
      401412,
      51150,
      31580,
      207268,
      6657,
      10993,
      69818,
      64282,
      289845,
      23308,
      12961,
      38447,
      6681,
      52944,
      31855,
      2572,
      47646,
      120728,
      179148,
      37240,
      45196,
      218274,
      4816,
      3695,
      21961,
      50084,
      35209,
      18073,
      51452,
      27004,
      6100,
      33941,
      1377,
      84831,
      171214,
      85,
      141510,
      9078,
      99227,
      32610,
      6417,
      11718,
      49868,
      65579,
      87902,
      73018,
      49062,
      46280,
      61742,
      21512,
      40862,
      107733,
      15941,
      29168,
      157765,
      144919,
      14487,
      5767,
      158014,
      140070,
      7241,
      573,
      71584,
      16921,
      223566,
      40331,
      179473,
      35081,
      47926,
      140885,
      41508,
      52104,
      59180,
      42310,
      32811,
      29048,
      123517,
      102413,
      80208,
      10104,
      14746,
      12649,
      153641,
      126022,
      37965,
      113017,
      4171,
      83,
      142592,
      2809,
      6362,
      50416,
      71323,
      116894,
      260776,
      16204,
      1524,
      5760,
      30351,
      12658,
      20703,
      54403,
      36083,
      45408,
      74772,
      4946,
      14485,
      50759,
      111222,
      10890,
      2195,
      167147,
      92962,
      130534,
      16283,
      177256,
      35016,
      15472,
      210156,
      151187,
      73922,
      117691,
      43250,
      52051,
      37392,
      24811,
      24358,
      30830,
      5775,
      818,
      21969,
      1476,
      127322,
      151783,
      58392,
      31021,
      106913,
      65215,
      89407,
      90802,
      28531,
      11690,
      20234,
      95249,
      44602,
      37256,
      18707,
      11928,
      5161,
      4410,
      26571,
      51903,
      49768,
      22008,
      25252,
      65780,
      209499,
      68769,
      203726,
      13249,
      137363,
      48845,
      86823,
      6658,
      5674,
      31881,
      1083,
      1823,
      108676,
      34518,
      166752,
      13791,
      14287,
      91576,
      91429,
      8665,
      11529,
      26401,
      16191,
      91972,
      30964,
      5254,
      28486,
      54697,
      79613,
      66520,
      18447,
      22870,
      45203,
      194466,
      22822,
      51703,
      12278,
      76716,
      44595,
      73455,
      33546,
      12235,
      144843,
      36154,
      51247,
      11116,
      33040,
      3180,
      225753,
      60864,
      1972,
      28469,
      12891,
      28879,
      10338,
      144157,
      56294,
      353058,
      38302,
      41447,
      87532,
      110616,
      27065,
      168438,
      6557,
      1213,
      50804,
      144643,
      24817,
      2390,
      136531,
      38174,
      247513,
      16190,
      4059,
      122791,
      131994,
      137430,
      39506,
      57650,
      16305,
      5188,
      54309,
      106128,
      20628,
      88071,
      67394,
      395446,
      250285,
      66176,
      91254,
      1399,
      114196,
      43915,
      60230,
      44853,
      27206,
      106353,
      43013,
      18733,
      345105,
      226453,
      51202,
      16607,
      57106,
      117175,
      35492,
      10476,
      89598,
      127439,
      15187,
      39624,
      13688,
      61570,
      10615,
      31111,
      59370,
      6238,
      175252,
      32143,
      224492,
      41388,
      95408,
      34384,
      148238,
      78307,
      38959,
      9340,
      160091,
      61443,
      15737,
      11216,
      41244,
      170,
      38299,
      102443,
      113097,
      26382,
      14027,
      33707,
      3957,
      76300,
      66160,
      19431,
      18900,
      6952,
      1717,
      108656,
      82206,
      188021,
      257335,
      27295,
      43999,
      41210,
      31777,
      46956,
      57457,
      12657,
      11489,
      15697,
      48060,
      204748,
      53583,
      82422,
      284790,
      30503,
      137341,
      8120,
      19615,
      220311,
      15991,
      10217,
      63424,
      9808,
      67431,
      70976,
      98221,
      4491,
      15177,
      28535,
      144789,
      751,
      13230,
      2394,
      1504,
      33977,
      132104,
      30316,
      22230,
      931,
      97193,
      185240,
      24826,
      22687,
      174322,
      15307,
      22988,
      1390,
      188745,
      180325,
      29580,
      59068,
      74903,
      18994,
      29195,
      79,
      15436,
      7622,
      38462,
      11566,
      138710,
      44828,
      45774,
      37768,
      99236,
      68137,
      84083,
      19282,
      22698,
      17134,
      74807,
      126662,
      173497,
      46248,
      16938,
      119735,
      3212,
      28292,
      213652,
      49013,
      9975,
      32180,
      45660,
      86250,
      4801,
      68788,
      95490,
      77482,
      113751,
      11994,
      44624,
      94452,
      46839,
      128497,
      100316,
      5798,
      58588,
      73184,
      202987,
      65417,
      37790,
      88524,
      1606,
      43156,
      97964,
      105717,
      34947,
      11203,
      100060,
      37742,
      130074,
      93653,
      107799,
      94311,
      196106,
      41347,
      8035,
      10780,
      16390,
      27883,
      118236,
      167395,
      1979,
      25006,
      19375,
      31628,
      18916,
      144723,
      78502,
      114047,
      103107,
      86492,
      107686,
      5844,
      20934,
      206963,
      23556,
      22591,
      16562,
      146333,
      20167,
      10471,
      117434,
      33085,
      2863,
      9740,
      36669,
      41849,
      37271,
      22790,
      18209,
      28979,
      8231,
      12952,
      54408,
      21731,
      25130,
      45208,
      55748,
      138120,
      75826,
      414,
      29593,
      9925,
      292865,
      25999,
      683,
      123149,
      7036,
      92159,
      86055,
      61827,
      103680,
      23176,
      54918,
      58466,
      57578,
      13305,
      5709,
      86479,
      16697,
      31064,
      17660,
      200919,
      10770,
      49793,
      33423,
      32370,
      52047,
      16488,
      62555,
      6459,
      8426,
      83493,
      7763,
      59725,
      82812,
      18628,
      67760,
      79405,
      68557,
      9612,
      7673,
      28102,
      56517,
      69620,
      171797,
      32458,
      29541,
      15870,
      81109,
      32080,
      207644,
      71495,
      21202,
      11039,
      91036,
      61230,
      2810,
      130800,
      32260,
      4613,
      60590,
      37112,
      75214,
      33979,
      126402,
      155062,
      30642,
      63875,
      12810,
      194463,
      82799,
      47664,
      16725,
      36685,
      43367,
      61099,
      449,
      172150,
      102867,
      21691,
      301838,
      36745,
      7130,
      18671,
      57316,
      34852,
      38034,
      54182,
      35578,
      65900,
      99486,
      19771,
      3456,
      2658,
      16914,
      99866,
      28390,
      28109,
      8262,
      21147,
      34353,
      20006,
      4228,
      137085,
      1675,
      203023,
      283196,
      198286,
      214375,
      163329,
      290603,
      152574,
      40471,
      83506,
      30068,
      14730,
      23177,
      131539,
      34759,
      27668,
      32178,
      71896,
      104799,
      116305,
      85430,
      119262,
      42860,
      25160,
      8911,
      23428,
      49437,
      105322,
      6519,
      16203,
      6349,
      74711,
      1230,
      38045,
      8540,
      75165,
      44736,
      25909,
      51026,
      317034,
      4984,
      32281,
      91312,
      27060,
      44431,
      17817,
      45363,
      155937,
      239085,
      35697,
      59784,
      91993,
      29531,
      126740,
      213757,
      76560,
      167776,
      285273,
      24262,
      8237,
      65030,
      41160,
      74437,
      48804,
      118916,
      13159,
      37842,
      1031,
      75349,
      1478,
      11655,
      108777,
      23435,
      277425,
      101734,
      67469,
      70231,
      124711,
      43532,
      28514,
      65526,
      54956,
      1e3,
      21882,
      17728,
      25302,
      40952,
      52214,
      149632,
      1999,
      2111,
      3259,
      63362,
      89961,
      220561,
      39777,
      26335,
      9063,
      10572,
      12416,
      34551,
      34623,
      38604,
      24723,
      5947,
      15588,
      69927,
      66252,
      119177,
      69173,
      46629,
      28714,
      70715,
      212408,
      20521,
      406913,
      74380,
      11716,
      50659,
      50862,
      37009,
      88460,
      130101,
      7210,
      53853,
      538,
      65120,
      151950,
      55806,
      163748,
      52837,
      13153,
      21100,
      16674,
      64536,
      6091,
      138201,
      44837,
      58547,
      3723,
      163,
      2177,
      32288,
      85454,
      34033,
      8497,
      14282,
      25742,
      10535,
      10741,
      79559,
      117493,
      243787,
      49337,
      100718,
      79495,
      40139,
      42956,
      7551,
      55433,
      15421,
      31509,
      23034,
      45081,
      547,
      61176,
      53434,
      328001,
      8470,
      36263,
      30145,
      4519,
      74173,
      53935,
      11845,
      73774,
      60211,
      78025,
      3,
      4102,
      73782,
      109293,
      315332,
      48412,
      26683,
      13714,
      6865,
      20128,
      18490,
      104141,
      325,
      39470,
      171970,
      115860,
      15707,
      7268,
      73301,
      74336,
      31370,
      2368,
      111827,
      107757,
      136231,
      142844,
      97138,
      96638,
      84053,
      38691,
      23801,
      1588,
      10573,
      122098,
      77039,
      240,
      186135,
      146101,
      11996,
      18143,
      112963,
      46171,
      155836,
      348769,
      47795,
      121213,
      116266,
      132515,
      3344,
      144804,
      31286,
      99187,
      255838,
      129694,
      35894,
      48779,
      55235,
      148582,
      71967,
      65282,
      15174,
      13920,
      47080,
      6147,
      108242,
      157593,
      125025,
      7136,
      1286,
      28957,
      127956,
      28402,
      98813,
      20805,
      7532,
      109417,
      40610,
      5041,
      32958,
      15142,
      18408,
      108596,
      33543,
      50517,
      27748,
      80114,
      233434,
      91447,
      487,
      37094,
      100048,
      30541,
      43477,
      10639,
      89862,
      155868,
      37667,
      8726,
      60684,
      237903,
      73408,
      99589,
      12190,
      38739,
      97348,
      3914,
      13594,
      2680,
      149016,
      13907,
      30171,
      28343,
      23530,
      115225,
      61104,
      35821,
      147679,
      14337,
      4297,
      244282,
      24085,
      326976,
      56428,
      7851,
      21303,
      131620,
      71446,
      83253,
      68692,
      111870,
      5224,
      15813,
      38197,
      49026,
      45057,
      13660,
      3306,
      76345,
      40671,
      27905,
      91072,
      996,
      68527,
      62085,
      91351,
      122634,
      55109,
      168209,
      2024,
      27560,
      112707,
      17352,
      8306,
      167115,
      169921,
      166958,
      5031,
      46020,
      11844,
      67284,
      19130,
      76185,
      6920,
      32849,
      5450,
      14610,
      22451,
      21002,
      17392,
      31872,
      66682,
      84796,
      13709,
      40210,
      59898,
      12029,
      8719,
      53564,
      21462,
      91884,
      21647,
      88379,
      194428,
      12754,
      37797,
      132826,
      160016,
      22567,
      54383,
      53186,
      77611,
      31107,
      8339,
      4694,
      19185,
      90355,
      23597,
      17222,
      140675,
      28442,
      23668,
      55977,
      9128,
      61555,
      28774,
      155229,
      17658,
      9390,
      24379,
      69357,
      15752,
      127381,
      239631,
      62460,
      93181,
      55913,
      45133,
      140155,
      18676,
      25249,
      33164,
      29581,
      82837,
      67223,
      22362,
      29975,
      7317,
      52813,
      1943,
      29613,
      20012,
      207130,
      49617,
      49651,
      5636,
      15334,
      36313,
      29226,
      28084,
      95247,
      72072,
      19e3,
      224932,
      15811,
      114,
      32127,
      38097,
      37508,
      88507,
      37225,
      27359,
      91626,
      12193,
      69279,
      20608,
      11055,
      88156,
      92808,
      2152,
      57259,
      55275,
      72789,
      24475,
      104414,
      1708,
      9882,
      3818,
      48661,
      66897,
      1631,
      34806,
      227930,
      85815,
      87753,
      18321,
      250664,
      72733,
      25107,
      206797,
      50891,
      8082,
      196411,
      92596,
      96764,
      152823,
      65514,
      22819,
      387277,
      62176,
      51225,
      40329,
      15563,
      189,
      3659,
      73670,
      64357,
      51793,
      275136,
      33482,
      86653,
      74615,
      67058,
      11318,
      125720,
      15388,
      22388,
      8267,
      1730,
      102663,
      170910,
      40784,
      7144,
      85373,
      13040,
      7088,
      94309,
      583,
      44224,
      140424,
      77439,
      18496,
      164026,
      36578,
      4722,
      9151,
      5824,
      63365,
      26510,
      35199,
      40500,
      79277,
      32495,
      44614,
      35233,
      9566,
      203293,
      152144,
      7097,
      2330,
      183480,
      98629,
      13423,
      330887,
      44130,
      68600,
      30939,
      97829,
      31012,
      345465,
      56747,
      94879,
      4939,
      160027,
      149761,
      99423,
      46099,
      32251,
      15332,
      8761,
      96094,
      128555,
      5763,
      235318,
      222223,
      55729,
      30241,
      55420,
      201746,
      3987,
      81382,
      8259,
      49325,
      23287,
      7719,
      24633,
      251100,
      92311,
      18591,
      110533,
      64759,
      170260,
      393860,
      7175,
      21144,
      132887,
      3593,
      75346,
      101277,
      91109,
      16387,
      259187,
      11627,
      57459,
      173829,
      44694,
      55780,
      49797,
      89192,
      120443,
      62622,
      3904,
      14814,
      23887,
      1027,
      112258,
      64955,
      99800,
      11132,
      66353,
      36202,
      48624,
      18158,
      88481,
      96882,
      43059,
      11040,
      2455,
      7077,
      21651,
      181159,
      99126,
      100434,
      61388,
      68186,
      19161,
      110468,
      120052,
      8819,
      55324,
      41494,
      7014,
      37689,
      3618,
      87729,
      92615,
      207943,
      9823,
      128657,
      12587,
      15857,
      6379,
      67628,
      51216,
      71775,
      157617,
      63244,
      1503,
      3864,
      218754,
      110864,
      5769,
      21492,
      7243,
      1192,
      87921,
      85529,
      31512,
      18537,
      42698,
      35350,
      73510,
      84474,
      34301,
      8991,
      21013,
      35034,
      566,
      38832,
      19838,
      35586,
      37216,
      39413,
      55006,
      12178,
      59742,
      856,
      84563,
      6900,
      25632,
      17437,
      49786,
      30723,
      13847,
      70845,
      4044,
      7843,
      23944,
      235976,
      55530,
      48942,
      6518,
      20939,
      73769,
      192653,
      52936,
      95207,
      23895,
      132542,
      142982,
      22632,
      87452,
      48042,
      54018,
      178468,
      10728,
      26230,
      23559,
      363,
      81269,
      142012,
      5718,
      346258,
      31456,
      84333,
      246476,
      51018,
      66692,
      101804,
      120570,
      39962,
      30373,
      70593,
      2864,
      60541,
      19425,
      54209,
      104092,
      7201,
      31545,
      48018,
      25865,
      15442,
      46257,
      40443,
      8328,
      6451,
      111782,
      47527,
      97754,
      33046,
      470,
      245116,
      31095,
      39,
      91934,
      87208,
      73470,
      36708,
      36521,
      12801,
      70624,
      36272,
      8892,
      79768,
      12427,
      55454,
      103756,
      5908,
      52390,
      62962,
      22720,
      141138,
      94634,
      41689,
      128402,
      126390,
      6628,
      106394,
      35527,
      134394,
      82727,
      254651,
      194502,
      148064,
      89549,
      3202,
      28359,
      957,
      21954,
      27906,
      49840,
      142747,
      8307,
      24206,
      48978,
      1186,
      71728,
      133038,
      71474,
      91306,
      6333,
      110959,
      74600,
      70387,
      18983,
      62609,
      56057,
      22970,
      1147,
      135850,
      1321,
      28834,
      3578,
      59715,
      102227,
      32827,
      81415,
      99952,
      55636,
      257598,
      390,
      22702,
      35701,
      85872,
      402916,
      39216,
      189795,
      14929,
      19467,
      10112,
      144422,
      61514,
      5279,
      63421,
      134686,
      41436,
      8424,
      51925,
      10598,
      132295,
      124416,
      4604,
      194739,
      210929,
      57866,
      31829,
      51626,
      50007,
      9976,
      91878,
      61906,
      56168,
      81906,
      60918,
      61859,
      40017,
      23059,
      16887,
      40927,
      62064,
      12785,
      32893,
      32913,
      21782,
      93965,
      20169,
      44387,
      79084,
      38463,
      11457,
      93950,
      27127,
      157050,
      2697,
      337088,
      5116,
      54128,
      48255,
      33279,
      8821,
      27352,
      25515,
      124022,
      65710,
      28906,
      38557,
      33390,
      1722,
      104435,
      72215,
      38551,
      12094,
      30978,
      25113,
      6671,
      37355,
      175109,
      42862,
      98024,
      65406,
      221276,
      59624,
      118012,
      64637,
      78760,
      86697,
      21426,
      1639,
      40350,
      12584,
      67193,
      84144,
      31396,
      7863,
      143011,
      69629,
      63112,
      9454,
      28666,
      65798,
      46372,
      134721,
      6314,
      51402,
      30837,
      151922,
      2847,
      38676,
      38008,
      92823,
      136245,
      17540,
      5504,
      109295,
      205242,
      37606,
      5211,
      214892,
      1586,
      20670,
      208711,
      137743,
      19328,
      40652,
      16995,
      20023,
      14657,
      154919,
      34422,
      12996,
      13918,
      38221,
      47690,
      16398,
      2959,
      37680,
      89122,
      6721,
      198469,
      91876,
      172043,
      83898,
      101992,
      26084,
      94570,
      3635,
      76958,
      22853,
      76497,
      38266,
      176590,
      168403,
      44464,
      142840,
      79180,
      184594,
      1984,
      41806,
      83147,
      11985,
      6546,
      366068,
      59732,
      24533,
      271505,
      8736,
      39084,
      222992,
      93429,
      28962,
      58985,
      86665,
      8432,
      30028,
      14548,
      32439,
      54424,
      165029,
      55175,
      27458,
      69046,
      121277,
      46168,
      33732,
      20661,
      24581,
      135574,
      123110,
      37556,
      79260,
      72611,
      16957,
      12939,
      46162,
      58238,
      44907,
      72936,
      253758,
      41324,
      32518,
      96480,
      11949,
      124438,
      65280,
      43256,
      34107,
      53533,
      43531,
      37037,
      28366,
      45970,
      32741,
      173438,
      6121,
      194202,
      62969,
      26355,
      30314,
      58370,
      28455,
      1848,
      50519,
      82830,
      90393,
      21761,
      295490,
      10936,
      256940,
      133568,
      44050,
      20269,
      4089,
      27457,
      21610,
      219460,
      36743,
      14821,
      101388,
      52005,
      13124,
      30979,
      140816,
      167362,
      26054,
      18458,
      60789,
      34917,
      40447,
      26606,
      33422,
      9066,
      3452,
      83614,
      5761,
      20263,
      137238,
      25038,
      91310,
      101,
      52322,
      74548,
      42572,
      38084,
      214054,
      186568,
      31802,
      17665,
      30620,
      141936,
      37730,
      14420,
      4265,
      187218,
      49640,
      188208,
      51441,
      55388,
      96452,
      66659,
      40869,
      42039,
      60967,
      221027,
      19234,
      178581,
      29105,
      96050,
      9165,
      196118,
      157335,
      3738,
      40354,
      117436,
      2965,
      34136,
      59659,
      15570,
      50843,
      230035,
      31444,
      71260,
      43886,
      18316,
      5387,
      38500,
      168508,
      17406,
      32174,
      8828,
      103373,
      143806,
      90367,
      3560,
      18719,
      122310,
      16508,
      26719,
      2541,
      105429,
      6645,
      37998,
      73190,
      10591,
      235916,
      49737,
      87112,
      233941,
      53188,
      32193,
      79154,
      4544,
      52905,
      126477,
      7580,
      63501,
      57314,
      3216,
      31337,
      6541,
      103083,
      60846,
      49,
      9756,
      15481,
      1355,
      43840,
      14319,
      13743,
      27486,
      10222,
      73114,
      230718,
      418644,
      16706,
      6674,
      279748,
      23058,
      45273,
      295831,
      86306,
      2743,
      5535,
      88773,
      21829,
      35253,
      120938,
      31153,
      3169,
      16839,
      42847,
      8751,
      80974,
      33942,
      36867,
      35514,
      16485,
      26474,
      77775,
      56877,
      5391,
      48346,
      3882,
      108713,
      31403,
      27804,
      55248,
      26235,
      43821,
      136104,
      40118,
      175507,
      28034,
      203908,
      18732,
      1788,
      34030,
      106427,
      36958,
      54359,
      7251,
      44936,
      15356,
      69139,
      455,
      157915,
      22173,
      140291,
      50348,
      43275,
      82066,
      49621,
      54952,
      15216,
      36226,
      96695,
      66855,
      6936,
      1987,
      8227,
      196087,
      4631,
      68827,
      99004,
      47541,
      110265,
      17953,
      147605,
      110242,
      58520,
      31312,
      38724,
      329975,
      642,
      3155,
      34497,
      75937,
      6207,
      73843,
      6120,
      17249,
      51429,
      117746,
      3218,
      910,
      68961,
      319671,
      14938,
      29555,
      34700,
      1649,
      66673,
      72268,
      9655,
      76800,
      153087,
      6941,
      210168,
      27130,
      35398,
      1780,
      73242,
      3135,
      56689,
      19556,
      165307,
      8765,
      35967,
      121458,
      13333,
      70453,
      17350,
      117253,
      22265,
      13340,
      44265,
      39869,
      441,
      3742,
      135025,
      23581,
      33309,
      16543,
      17731,
      13291,
      157637,
      283005,
      21408,
      101360,
      63887,
      52312,
      83873,
      5338,
      233779,
      23759,
      186949,
      34531,
      177320,
      38069,
      156465,
      91004,
      19353,
      59852,
      68160,
      14891,
      1338,
      1072,
      29823,
      1950,
      28901,
      81407,
      313445,
      73038,
      84807,
      162348,
      240257,
      37162,
      138934,
      16111,
      58013,
      41253,
      102951,
      16457,
      96056,
      19541,
      56402,
      67217,
      41638,
      94381,
      89674,
      29481,
      37456,
      80815,
      151579,
      13937,
      13683,
      132537,
      19699,
      134545,
      67020,
      29816,
      222341,
      141235,
      427578,
      48868,
      129557,
      233342,
      23077,
      87871,
      16213,
      18728,
      16184,
      9469,
      37913,
      19680,
      2798,
      171356,
      178328,
      13216,
      50049,
      72690,
      71904,
      124644,
      55455,
      7504,
      29052,
      41036,
      266546,
      19899,
      30391,
      188755,
      8659,
      59469,
      16,
      104298,
      112943,
      53865,
      76203,
      138226,
      68857,
      139953,
      14125,
      107625,
      119795,
      173133,
      4398,
      50273,
      48808,
      54390,
      16466,
      122086,
      31835,
      67035,
      50971,
      48859,
      7508,
      46427,
      66477,
      73021,
      84615,
      39985,
      83076,
      46779,
      201569,
      53336,
      36443,
      60865,
      168164,
      143810,
      51393,
      25548,
      169307,
      32896,
      24485,
      38424,
      21837,
      29087,
      275813,
      51674,
      6714,
      64883,
      46169,
      187369,
      55186,
      76192,
      12852,
      12018,
      62134,
      31067,
      118303,
      16542,
      12125,
      10579,
      4928,
      26291,
      43854,
      7091,
      10946,
      253716,
      109062,
      39283,
      17261,
      113012,
      258512,
      47764,
      125126,
      32646,
      55892,
      80279,
      201623,
      149872,
      3192,
      385,
      1208,
      48750,
      5376,
      58738,
      22335,
      5427,
      82416,
      47811,
      32435,
      143086,
      38930,
      94128,
      59975,
      156037,
      37977,
      38224,
      62485,
      7698,
      50405,
      71027,
      16462,
      21559,
      136153,
      34131,
      107506,
      162069,
      63703,
      3101,
      215029,
      40407,
      4178,
      3774,
      9187,
      80019,
      17880,
      97926,
      67579,
      2600,
      18405,
      8351,
      47924,
      86638,
      70820,
      92206,
      86453,
      29610,
      42241,
      119200,
      3198,
      15466,
      67813,
      57863,
      35454,
      4779,
      99518,
      4649,
      104641,
      144269,
      33730,
      38073,
      65864,
      6838,
      109456,
      193298,
      154007,
      5623,
      45741,
      30846,
      182578,
      25573,
      157224,
      1543,
      58575,
      138703,
      146140,
      44971,
      49356,
      18275,
      59064,
      20300,
      13122,
      11848,
      24453,
      11973,
      9797,
      86843,
      2919,
      25530,
      49210,
      1130,
      161220,
      76788,
      75373,
      85604,
      34926,
      36014,
      17777,
      17255,
      51533,
      11676,
      92226,
      51845,
      119859,
      21525,
      5936,
      18507,
      28050,
      1140,
      31418,
      14857,
      34207,
      47859,
      10750,
      36382,
      32079,
      106909,
      59426,
      87757,
      38393,
      110042,
      15965,
      97104,
      33757,
      35344,
      97993,
      53979,
      33651,
      45407,
      41884,
      82515,
      173089,
      7177,
      58371,
      35365,
      47543,
      51927,
      35587,
      10670,
      23544,
      29306,
      84233,
      39976,
      76076,
      62097,
      9007,
      8668,
      28119,
      78281,
      120790,
      19835,
      143020,
      54968,
      18670,
      64959,
      20649,
      34469,
      42570,
      33001,
      136570,
      87796,
      120044,
      1106,
      58700,
      63951,
      127623,
      12805,
      83057,
      40212,
      31773,
      49850,
      7361,
      54336,
      347524,
      101314,
      23751,
      19569,
      48791,
      29174,
      49369,
      20467,
      7465,
      75842,
      38281,
      623,
      112457,
      60210,
      28849,
      51003,
      94720,
      6426,
      90047,
      85560,
      43761,
      3579,
      85105,
      34607,
      90410,
      118528,
      7224,
      42907,
      111163,
      18168,
      6960,
      161135,
      191298,
      5247,
      100584,
      127552,
      171568,
      20121,
      91173,
      12636,
      54615,
      20199,
      63730,
      98105,
      2396,
      40387,
      14438,
      125012,
      4765,
      33235,
      12865,
      45299,
      37728,
      82098,
      77872,
      114037,
      59253,
      19675,
      24838,
      398016,
      102561,
      11446,
      17069,
      57508,
      178277,
      65836,
      99941,
      26114,
      2585,
      271882,
      136866,
      50126,
      11027,
      155648,
      118367,
      14585,
      8910,
      123015,
      335383,
      40434,
      41016,
      53021,
      14439,
      87098,
      176860,
      201543,
      121888,
      2358,
      9286,
      5739,
      22666,
      54270,
      37884,
      169381,
      33984,
      93859,
      16124,
      89364,
      72207,
      51639,
      76366,
      99029,
      65812,
      2198,
      12147,
      174891,
      194289,
      6986,
      30252,
      88822,
      21284,
      11445,
      288337,
      160821,
      33034,
      100869,
      43852,
      25761,
      52882,
      1144,
      103809,
      1924,
      84458,
      86079,
      43411,
      13542,
      139276,
      18141,
      34978,
      41298,
      7276,
      26481,
      173800,
      33210,
      17951,
      142652,
      33616,
      33677,
      2210,
      19941,
      98568,
      2486,
      192414,
      80136,
      12058,
      235883,
      50963,
      249638,
      29572,
      27221,
      47034,
      6124,
      72107,
      63346,
      97620,
      158513,
      299699,
      40388,
      23235,
      37176,
      224244,
      198386,
      121323,
      67992,
      23827,
      63170,
      17838,
      106622,
      158590,
      26807,
      5345,
      23489,
      91891,
      55474,
      74834,
      37981,
      13058,
      5977,
      72552,
      34706,
      26828,
      145172,
      19904,
      21367,
      34043,
      960,
      77092,
      91381,
      4733,
      47446,
      7680,
      41697,
      5170,
      16960,
      14741,
      46101,
      13656,
      473,
      51842,
      37433,
      11103,
      11551,
      121951,
      13191,
      97536,
      165932,
      50397,
      51628,
      129028,
      9069,
      44885,
      6590,
      59195,
      47045,
      32940,
      225472,
      90345,
      21833,
      13303,
      29407,
      96615,
      141951,
      5198,
      6028,
      18395,
      7181,
      3861,
      14966,
      156358,
      167182,
      36529,
      55253,
      25942,
      173153,
      30959,
      27261,
      50691,
      150176,
      162201,
      38467,
      48462,
      80602,
      42163,
      118482,
      168,
      108756,
      26011,
      17166,
      54149,
      456538,
      22512,
      91374,
      13816,
      90358,
      131615,
      18132,
      226707,
      1824,
      28139,
      26860,
      42253,
      93877,
      77351,
      65575,
      8980,
      80574,
      22020,
      27948,
      40422,
      91324,
      76376,
      13528,
      39281,
      91685,
      82215,
      122541,
      144066,
      1983,
      193851,
      17283,
      26320,
      2739,
      194978,
      4790,
      26845,
      42627,
      61300,
      65815,
      174612,
      55133,
      4200,
      191130,
      79771,
      158321,
      52280,
      166796,
      221620,
      62461,
      11278,
      4067,
      88152,
      83409,
      31717,
      121367,
      13522,
      47325,
      37945,
      10406,
      174348,
      249321,
      154101,
      64912,
      29938,
      51775,
      17220,
      15776,
      166138,
      78890,
      84425,
      54121,
      42861,
      16368,
      24572,
      291647,
      10197,
      32073,
      22651,
      11677,
      97509,
      26952,
      35787,
      18424,
      41910,
      71614,
      94977,
      72318,
      41594,
      70024,
      275419,
      37702,
      60199,
      7335,
      39107,
      61315,
      18271,
      18394,
      33768,
      87884,
      104277,
      123724,
      7277,
      56288,
      71981,
      189803,
      49320,
      3352,
      6798,
      14240,
      8954,
      69220,
      94433,
      57372,
      28620,
      68863,
      193727,
      85575,
      42309,
      41667,
      67689,
      42081,
      22543,
      44824,
      12719,
      28540,
      114236,
      101553,
      27638,
      27296,
      4300,
      5353,
      4663,
      19379,
      94098,
      3758,
      95888,
      95144,
      80344,
      87320,
      28447,
      259518,
      12718,
      71391,
      152731,
      37063,
      24132,
      31911,
      104896,
      15672,
      103782,
      1521,
      4945,
      72541,
      23717,
      122632,
      15619,
      87175,
      206120,
      29428,
      189780,
      61416,
      28350,
      44457,
      972,
      1175,
      47233,
      198738,
      95789,
      41907,
      21953,
      97034,
      59341,
      22864,
      53713,
      16873,
      32971,
      20693,
      20954,
      31336,
      21477,
      16169,
      38370,
      16412,
      9019,
      3841,
      24599,
      21938,
      17085,
      6484,
      81198,
      76413,
      5849,
      72514,
      12320,
      65247,
      276175,
      37234,
      59796,
      52642,
      16312,
      57349,
      198507,
      94148,
      46134,
      18958,
      125552,
      1747,
      18725,
      151873,
      14901,
      5490,
      68287,
      29470,
      3689,
      64794,
      40814,
      26018,
      25692,
      54450,
      2703,
      88278,
      124886,
      173087,
      174e3,
      24159,
      179477,
      24276,
      46004,
      201876,
      209202,
      445,
      52876,
      31948,
      30206,
      157610,
      39180,
      18439,
      44124,
      50469,
      5774,
      96278,
      222758,
      200216,
      50290,
      45486,
      20435,
      46986,
      46276,
      140133,
      142326,
      15569,
      13363,
      47522,
      92583,
      2182,
      7135,
      16853,
      22998,
      30272,
      4952,
      63263,
      35623,
      39096,
      53789,
      44864,
      20053,
      110392,
      124213,
      4630,
      16087,
      28221,
      127787,
      25839,
      77481,
      44693,
      13464,
      113146,
      6983,
      27069,
      55717,
      50102,
      4760,
      7107,
      26186,
      66507,
      59145,
      36032,
      104182,
      71328,
      29425,
      64317,
      50781,
      47465,
      94298,
      69706,
      74899,
      22754,
      120756,
      25108,
      93077,
      56834,
      73286,
      39928,
      16218,
      41699,
      176763,
      7555,
      70819,
      50083,
      26895,
      23315,
      26014,
      16773,
      123079,
      41712,
      5719,
      31516,
      90427,
      158540,
      85051,
      183128,
      40864,
      27505,
      55392,
      9058,
      45224,
      96857,
      30901,
      136622,
      96557,
      56304,
      120061,
      11501,
      151448,
      5773,
      89743,
      7769,
      86069,
      2935,
      18471,
      41628,
      10114,
      33660,
      110170,
      49479,
      26745,
      92846,
      33221,
      26731,
      18795,
      87076,
      8550,
      2100,
      29972,
      120289,
      3077,
      72490,
      33784,
      2630,
      208722,
      50861,
      63483,
      79029,
      6419,
      39467,
      14302,
      45286,
      64207,
      9686,
      67513,
      44170,
      1050,
      77246,
      59266,
      17055,
      53801,
      7150,
      11111,
      42432,
      4278,
      94579,
      362117,
      36175,
      42902,
      41933,
      39002,
      98489,
      22913,
      74161,
      84773,
      57036,
      17556,
      162288,
      74485,
      178760,
      93867,
      73635,
      128860,
      50362,
      261,
      67455,
      80001,
      46080,
      35662,
      4368,
      25247,
      19230,
      74393,
      22588,
      1822,
      27682,
      235324,
      13798,
      85998,
      13194,
      235067,
      23514,
      71669,
      147632,
      23191,
      134748,
      214683,
      105101,
      1518,
      25489,
      247114,
      7380,
      54842,
      26922,
      3971,
      26361,
      20844,
      68642,
      170517,
      77339,
      123255,
      8963,
      77818,
      150998,
      48466,
      36806,
      2732,
      23261,
      11741,
      236162,
      18243,
      126216,
      28690,
      50546,
      16385,
      92760,
      197383,
      246558,
      201295,
      88255,
      67588,
      71687,
      176076,
      172653,
      169058,
      33906,
      63747,
      24835,
      157621,
      43338,
      30050,
      46152,
      132741,
      2770,
      51371,
      94835,
      6614,
      15112,
      11749,
      56936,
      1250,
      19027,
      399017,
      58036,
      100215,
      23388,
      55815,
      308768,
      124152,
      94803,
      9521,
      64186,
      8971,
      28,
      30427,
      62163,
      7616,
      103838,
      35079,
      29203,
      131235,
      7743,
      17389,
      10882,
      37420,
      61460,
      228512,
      85363,
      41581,
      131077,
      62822,
      119647,
      10130,
      54445,
      26925,
      19968,
      29016,
      24446,
      74028,
      24176,
      61448,
      67185,
      9254,
      8563,
      119129,
      9771,
      99184,
      37716,
      39514,
      10532,
      221512,
      258753,
      218630,
      55980,
      23394,
      32141,
      61924,
      66749,
      32411,
      3741,
      36475,
      26678,
      77010,
      44946,
      91203,
      128749,
      116953,
      20476,
      49625,
      53116,
      13735,
      102335,
      29376,
      51946,
      83407,
      67892,
      59212,
      34685,
      21083,
      1546,
      112982,
      32972,
      74397,
      1078,
      190545,
      16082,
      86140,
      58591,
      89611,
      101531,
      10061,
      105104,
      76319,
      20035,
      17551,
      52611,
      169061,
      190842,
      100780,
      23907,
      90413,
      115619,
      9675,
      34710,
      193435,
      49443,
      129734,
      11183,
      258877,
      16318,
      136182,
      126808,
      44635,
      27304,
      192375,
      2599,
      125648,
      47051,
      12091,
      23814,
      721,
      58800,
      40137,
      66726,
      97930,
      60877,
      74487,
      7942,
      54326,
      9841,
      41428,
      13762,
      8211,
      85383,
      6950,
      99177,
      79806,
      201786,
      296464,
      124087,
      13144,
      29741,
      41721,
      47634,
      55088,
      254286,
      106408,
      17041,
      99064,
      12942,
      64086,
      45233,
      14005,
      2612,
      55827,
      255,
      7984,
      13980,
      38574,
      12776,
      46654,
      73499,
      249951,
      2101,
      26676,
      25996,
      132326,
      116415,
      119062,
      50449,
      31033,
      23038,
      11589,
      179252,
      20007,
      14860,
      129270,
      21143,
      17796,
      144715,
      60106,
      70758,
      69842,
      34674,
      282133,
      44014,
      16774,
      57268,
      38528,
      24053,
      46373,
      201667,
      28327,
      471023,
      51889,
      102667,
      21193,
      114909,
      84132,
      69317,
      96723,
      67969,
      16134,
      68145,
      15058,
      28765,
      32035,
      2524,
      101089,
      98664,
      25045,
      76571,
      14957,
      86040,
      118506,
      262428,
      154764,
      81573,
      39681,
      283900,
      73287,
      127825,
      544,
      80448,
      52347,
      38512,
      175971,
      15180,
      45467,
      33086,
      46552,
      48894,
      81107,
      43213,
      36672,
      54025,
      76703,
      8053,
      7608,
      13299,
      56619,
      20752,
      238099,
      54164,
      105133,
      1444,
      32942,
      953,
      37564,
      8e3,
      66316,
      119463,
      106817,
      404,
      13667,
      149108,
      128597,
      31267,
      10269,
      49836,
      106150,
      1484,
      52330,
      76965,
      160486,
      171648,
      38456,
      31263,
      22424,
      37738,
      66245,
      67467,
      143369,
      60471,
      75610,
      20895,
      115528,
      86070,
      60854,
      40796,
      49347,
      18989,
      15030,
      11371,
      37578,
      15779,
      79867,
      10187,
      86462,
      46402,
      155626,
      93200,
      40229,
      7090,
      57547,
      108053,
      99598,
      11088,
      47505,
      41218,
      206017,
      2173,
      20988,
      30219,
      22919,
      80563,
      57566,
      42369,
      93141,
      41675,
      2407,
      182519,
      120495,
      27154,
      16702,
      29456,
      14349,
      7958,
      16688,
      117177,
      140375,
      42467,
      261919,
      74916,
      153569,
      10836,
      34742,
      49526,
      7621,
      105997,
      12212,
      2270,
      392377,
      7755,
      17959,
      25086,
      232152,
      138791,
      33847,
      13860,
      35316,
      5811,
      1344,
      71259,
      50452,
      207539,
      92635,
      50359,
      5821,
      33674,
      30255,
      2086,
      2587,
      96264,
      17543,
      42,
      6029,
      9580,
      43007,
      139248,
      82831,
      12917,
      29607,
      25786,
      51467,
      42137,
      85161,
      100698,
      31561,
      88989,
      121990,
      278500,
      3602,
      109344,
      37982,
      15279,
      116442,
      28936,
      30880,
      87894,
      58079,
      128661,
      126731,
      67392,
      28051,
      146885,
      4861,
      16216,
      97344,
      42827,
      147561,
      153948,
      22684,
      21335,
      47685,
      1853,
      43349,
      15185,
      59642,
      10229,
      25520,
      187921,
      108972,
      5579,
      98037,
      24945,
      6697,
      19193,
      63734,
      137934,
      75056,
      89740,
      19767,
      224268,
      56138,
      63643,
      151661,
      39313,
      70618,
      84031,
      89723,
      84074,
      13703,
      85626,
      35460,
      8867,
      64845,
      3439,
      57906,
      99776,
      63968,
      49270,
      81130,
      34356,
      16210,
      23547,
      36446,
      34090,
      140028,
      72439,
      2221,
      22163,
      57058,
      363492,
      113754,
      18913,
      95451,
      48663,
      54464,
      54037,
      176097,
      68425,
      3023,
      34906,
      29482,
      117389,
      341780,
      80431,
      58330,
      16753,
      92616,
      60907,
      94846,
      147486,
      4498,
      48646,
      7773,
      46801,
      7778,
      18946,
      464978,
      47558,
      33223,
      177444,
      7328,
      15626,
      63337,
      94700,
      11743,
      9351,
      255024,
      39098,
      16447,
      42647,
      96230,
      39769,
      58840,
      10068,
      63439,
      35800,
      65843,
      58823,
      413844,
      9156,
      51258,
      7434,
      61791,
      85018,
      6872,
      3692,
      28096,
      7121,
      33024,
      6009,
      75532,
      31997,
      192535,
      9661,
      3304,
      9547,
      14753,
      31987,
      25314,
      55689,
      15896,
      20430,
      39472,
      31340,
      99744,
      25398,
      115569,
      54883,
      28719,
      205423,
      23071,
      57855,
      64638,
      149867,
      25671,
      82403,
      37616,
      20668,
      39989,
      77996,
      74948,
      140555,
      175248,
      64810,
      36515,
      46595,
      4958,
      248773,
      24045,
      28728,
      136673,
      168704,
      20804,
      114833,
      100325,
      27135,
      21205,
      96151,
      153134,
      45992,
      7093,
      13992,
      76047,
      1980,
      19432,
      145001,
      75159,
      87462,
      17710,
      1013,
      45556,
      34297,
      144882,
      20648,
      26061,
      11319,
      129567,
      108555,
      18872,
      464580,
      33386,
      22717,
      65948,
      167189,
      5603,
      135042,
      79542,
      8801,
      202632,
      18114,
      91882,
      5973,
      5239,
      67315,
      4431,
      60916,
      47819,
      71693,
      32597,
      32606,
      18183,
      45072,
      80329,
      76385,
      24749,
      51305,
      40314,
      156514,
      14693,
      130345,
      13168,
      66214,
      18029,
      12858,
      34801,
      27628,
      14544,
      10823,
      40522,
      40185,
      33739,
      148694,
      23548,
      9923,
      61012,
      28859,
      17933,
      19442,
      34364,
      99849,
      164107,
      141167,
      30629,
      21054,
      6744,
      36491,
      8096,
      42474,
      41706,
      155060,
      30650,
      10600,
      163442,
      1143,
      96655,
      61390,
      52359,
      7559,
      51568,
      64256,
      203854,
      4467,
      22453,
      14504,
      436398,
      7878,
      6980,
      8293,
      63610,
      293747,
      16167,
      35763,
      19627,
      147603,
      15419,
      18032,
      110744,
      51346,
      33681,
      54571,
      40472,
      48615,
      39073,
      21604,
      13754,
      173027,
      92560,
      11083,
      47299,
      63062,
      11813,
      52007,
      29883,
      9734,
      139722,
      15953,
      1550,
      20651,
      13616,
      49306,
      16113,
      90089,
      92326,
      7584,
      30712,
      72424,
      164858,
      6831,
      152871,
      55746,
      197721,
      34167,
      196442,
      6022,
      112107,
      55215,
      7538,
      123381,
      4920,
      43539,
      77165,
      8939,
      50392,
      34192,
      20225,
      79762,
      22505,
      58667,
      40770,
      29788,
      97180,
      82835,
      4568,
      8579,
      13273,
      363569,
      35898,
      49983,
      436,
      36598,
      3237,
      131691,
      62418,
      35591,
      8101,
      4073,
      379438,
      65218,
      76072,
      33887,
      2968,
      27573,
      212619,
      288680,
      68278,
      72851,
      150504,
      217896,
      6913,
      121339,
      22017,
      35340,
      51072,
      43616,
      75043,
      31437,
      10833,
      81487,
      4364,
      22968,
      41454,
      106687,
      85446,
      19863,
      109625,
      149241,
      524,
      141850,
      214404,
      54376,
      657,
      237023,
      9401,
      108137,
      53800,
      32474,
      49712,
      53334,
      126876,
      27337,
      45552,
      177696,
      8269,
      15036,
      12097,
      42240,
      2328,
      125374,
      119295,
      99715,
      2500,
      19624,
      39441,
      27220,
      102691,
      60957,
      94543,
      39101,
      18566,
      67362,
      13975,
      78230,
      25017,
      34017,
      239007,
      90027,
      39351,
      41681,
      35354,
      43822,
      1043,
      916,
      58587,
      141983,
      94818,
      38799,
      75459,
      41114,
      67432,
      16195,
      36606,
      59568,
      22272,
      126769,
      31424,
      68659,
      12287,
      134302,
      257977,
      5756,
      207285,
      95637,
      47248,
      117689,
      19583,
      77451,
      22373,
      12200,
      54993,
      117118,
      34244,
      29386,
      34562,
      53819,
      71267,
      64172,
      77665,
      49368,
      7716,
      59301,
      25749,
      45426,
      194789,
      17297,
      2650,
      1766,
      32501,
      45198,
      20403,
      20984,
      6600,
      14171,
      94604,
      19037,
      5402,
      29896,
      9938,
      59935,
      109708,
      88081,
      145182,
      44844,
      39167,
      352626,
      164173,
      35374,
      45982,
      6122,
      154,
      73419,
      220487,
      53834,
      53601,
      17992,
      8609,
      229321,
      5610,
      68098,
      66815,
      71012,
      95069,
      140968,
      27396,
      8957,
      134489,
      24656,
      86659,
      56598,
      134852,
      17316,
      123838,
      255436,
      6613,
      41610,
      138033,
      81452,
      32023,
      32396,
      123687,
      63398,
      8693,
      29712,
      30407,
      19296,
      121188,
      3551,
      36099,
      20032,
      111948,
      56624,
      16547,
      27453,
      35916,
      15378,
      52039,
      56849,
      13489,
      22214,
      73177,
      53097,
      277349,
      2157,
      14029,
      187886,
      10260,
      141743,
      246460,
      91880,
      50869,
      3788,
      49486,
      133566,
      54950,
      33120,
      129337,
      53768,
      18333,
      9525,
      26902,
      312251,
      10297,
      9020,
      70759,
      16647,
      112432,
      59260,
      84609,
      9818,
      82766,
      73569,
      468,
      46001,
      75780,
      55028,
      52106,
      11498,
      43645,
      108069,
      17150,
      17753,
      29417,
      16705,
      31799,
      9606,
      289,
      122254,
      115975,
      8620,
      6133,
      255357,
      56908,
      14456,
      133464,
      43554,
      79224,
      11247,
      29630,
      160,
      12756,
      25464,
      65960,
      350428,
      62521,
      321796,
      100359,
      67358,
      35169,
      46172,
      113128,
      48988,
      88868,
      31094,
      33266,
      6847,
      60887,
      98188,
      49659,
      69117,
      92977,
      220228,
      13947,
      80181,
      35103,
      62170,
      97351,
      13475,
      2440,
      199768,
      19498,
      36597,
      46971,
      25234,
      67806,
      62881,
      84717,
      73648,
      181966,
      10488,
      94149,
      21550,
      26655,
      63436,
      48375,
      14405,
      165650,
      9621,
      24439,
      28043,
      42735,
      4490,
      29963,
      56674,
      45373,
      1934,
      262446,
      50855,
      67098,
      26898,
      5261,
      52696,
      40644,
      33900,
      9440,
      180286,
      87162,
      22940,
      19704,
      26936,
      69769,
      10254,
      101759,
      27406,
      12243,
      48e3,
      73926,
      113215,
      54935,
      5726,
      192787,
      4312,
      106216,
      9366,
      11550,
      52949,
      23457,
      212271,
      277152,
      133895,
      108374,
      6191,
      96477,
      29980,
      218916,
      58024,
      54696,
      40853,
      91124,
      65894,
      91170,
      65908,
      252552,
      6793,
      29212,
      15389,
      44516,
      122515,
      52617,
      35058,
      9017,
      103536,
      39510,
      49136,
      19242,
      130652,
      662077,
      74699,
      47024,
      31422,
      8517,
      73351,
      24399,
      13867,
      128360,
      4810,
      4434,
      61779,
      111983,
      61036,
      17798,
      110240,
      59722,
      102960,
      39688,
      10001,
      23803,
      23039,
      176498,
      56659,
      44814,
      134295,
      17188,
      77577,
      74466,
      226175,
      102472,
      154333,
      63900,
      111747,
      18062,
      41171,
      79669,
      32773,
      408933,
      42562,
      28931,
      30907,
      107388,
      43487,
      2946,
      240310,
      23938,
      24354,
      319,
      184983,
      7927,
      6488,
      1422,
      10790,
      68809,
      68209,
      64775,
      4361,
      202,
      17123,
      59634,
      51200,
      44391,
      18188,
      17843,
      2619,
      74278,
      3230,
      9540,
      47187,
      21702,
      36274,
      56894,
      43907,
      16310,
      34790,
      16866,
      6150,
      5561,
      13587,
      107545,
      108873,
      126867,
      86986,
      28640,
      33427,
      19017,
      5762,
      80637,
      17430,
      46903,
      2047,
      131055,
      25958,
      13558,
      5444,
      47152,
      13900,
      44563,
      122857,
      45348,
      70863,
      39593,
      54332,
      38068,
      33637,
      318,
      40310,
      143467,
      18502,
      24520,
      11377,
      62013,
      28942,
      27246,
      28269,
      83545,
      17999,
      59015,
      90707,
      30065,
      15161,
      34720,
      1263,
      37008,
      2012,
      6060,
      98575,
      92933,
      5721,
      299,
      199555,
      24578,
      29223,
      2985,
      743,
      115825,
      109523,
      136657,
      47454,
      26378,
      53586,
      3733,
      174945,
      93340,
      244456,
      5693,
      37386,
      28782,
      89767,
      27545,
      23573,
      18798,
      136425,
      34320,
      84778,
      20041,
      48453,
      38215,
      7477,
      71958,
      40621,
      8773,
      5874,
      187927,
      105965,
      51100,
      43533,
      18083,
      8443,
      10180,
      43597,
      2003,
      183999,
      69689,
      12216,
      129696,
      146188,
      62389,
      34044,
      68410,
      12765,
      43273,
      26949,
      266807,
      3345,
      34477,
      79197,
      5688,
      47539,
      213110,
      21634,
      22257,
      50092,
      32222,
      42346,
      39530,
      63668,
      98,
      134978,
      74022,
      5152,
      59088,
      174145,
      37220,
      9934,
      9545,
      118937,
      5724,
      87240,
      19875,
      15784,
      40143,
      23263,
      87513,
      181654,
      285152,
      37881,
      263241,
      4966,
      43934,
      10433,
      186657,
      6470,
      74416,
      225854,
      25908,
      142677,
      246262,
      32280,
      6192,
      75890,
      45546,
      143264,
      135305,
      29742,
      47013,
      77787,
      11732,
      126658,
      8763,
      37950,
      21806,
      57557,
      113464,
      89465,
      108995,
      164574,
      23894,
      22996,
      23169,
      15369,
      23117,
      17642,
      130607,
      40503,
      36239,
      280990,
      44666,
      9981,
      40427,
      147487,
      26869,
      168452,
      32886,
      32991,
      46798,
      240839,
      15111,
      70502,
      65697,
      88548,
      44145,
      28701,
      48767,
      31139,
      206777,
      35659,
      181164,
      166262,
      14554,
      171445,
      31786,
      66523,
      76607,
      17956,
      6507,
      31279,
      90476,
      116611,
      167918,
      6560,
      1243,
      115324,
      80128,
      41867,
      55897,
      187323,
      37069,
      32596,
      189444,
      145931,
      13390,
      105530,
      65709,
      26805,
      6999,
      55714,
      41300,
      22915,
      68951,
      22138,
      21120,
      22264,
      10058,
      19945,
      33635,
      56123,
      99085,
      10032,
      5818,
      6016,
      46649,
      57476,
      35264,
      94413,
      112522,
      262288,
      93686,
      83038,
      14341,
      23204,
      28807,
      66084,
      77987,
      6101,
      126673,
      7133,
      38126,
      5923,
      122091,
      170240,
      97772,
      46874,
      215746,
      43948,
      41622,
      3272,
      55596,
      8332,
      146411,
      251315,
      13533,
      8561,
      81521,
      115449,
      48616,
      175175,
      2063,
      186556,
      3036,
      134537,
      75772,
      29728,
      82360,
      22973,
      186559,
      86348,
      89100,
      38388,
      82297,
      45610,
      2613,
      87082,
      9986,
      177812,
      57884,
      23591,
      47485,
      42543,
      33582,
      44713,
      74439,
      257444,
      252451,
      31825,
      35631,
      38540,
      33066,
      5147,
      13973,
      4343,
      51830,
      70378,
      22827,
      26448,
      95560,
      36896,
      241741,
      48067,
      203953,
      298860,
      61620,
      20450,
      3220,
      67272,
      6586,
      107662,
      100160,
      108684,
      6929,
      57226,
      4762,
      7457,
      1320,
      40404,
      77204,
      99309,
      62750,
      208653,
      59977,
      44e3,
      74315,
      34332,
      5819,
      172217,
      64904,
      114077,
      18147,
      84012,
      1791,
      98456,
      90930,
      21446,
      116669,
      103938,
      7422,
      85140,
      59713,
      5768,
      326211,
      16239,
      75411,
      13229,
      29398,
      10758,
      236107,
      1539,
      112472,
      95979,
      152154,
      151294,
      306,
      21196,
      38146,
      10700,
      6891,
      84282,
      109646,
      56492,
      40539,
      6589,
      119491,
      51354,
      30685,
      140209,
      136906,
      29622,
      73617,
      49553,
      70525,
      51671,
      166869,
      139616,
      74395,
      37439,
      49595,
      45678,
      11959,
      33211,
      86560,
      52434,
      9282,
      62690,
      112155,
      130810,
      5243,
      108261,
      99970,
      265613,
      72551,
      80049,
      6391,
      33365,
      90721,
      66737,
      69872,
      87011,
      1860,
      9032,
      112544,
      60905,
      37371,
      89015,
      140351,
      19076,
      850,
      373531,
      2802,
      36725,
      218795,
      72062,
      28990,
      16550,
      24614,
      7815,
      6187,
      26336,
      33373,
      32162,
      42791,
      73555,
      32062,
      23386,
      10244,
      56392,
      49442,
      27076,
      136262,
      12412,
      14883,
      1134,
      33675,
      97153,
      199281,
      15608,
      100152,
      74072,
      47942,
      254301,
      36451,
      16026,
      10687,
      65067,
      56708,
      254030,
      30290,
      50490,
      13864,
      57941,
      259331,
      35588,
      23485,
      43486,
      24869,
      21620,
      92971,
      22072,
      88645,
      1048,
      182050,
      13343,
      32452,
      14825,
      19509,
      3325,
      216938,
      45740,
      99716,
      189082,
      53740,
      78245,
      25609,
      24311,
      176777,
      47340,
      308354,
      40669,
      66085,
      14102,
      125339,
      9225,
      128709,
      97207,
      1271,
      200933,
      78439,
      113451,
      88975,
      18324,
      46521,
      11819,
      18570,
      141756,
      72512,
      170020,
      52754,
      63550,
      118515,
      103073,
      93330,
      32736,
      50499,
      14722,
      31600,
      68452,
      398867,
      29316,
      172786,
      18417,
      104924,
      2606,
      5670,
      84818,
      16288,
      67106,
      59580,
      82929,
      607401,
      291,
      85829,
      359,
      15897,
      35830,
      50696,
      65630,
      52672,
      22115,
      356968,
      29895,
      40837,
      231192,
      34024,
      38957,
      26722,
      406,
      23335,
      124952,
      72068,
      68804,
      13268,
      147101,
      164740,
      276569,
      162596,
      66943,
      11569,
      26654,
      66358,
      4777,
      23229,
      102127,
      5848,
      978,
      2921,
      59666,
      5371,
      28212,
      90108,
      42938,
      39320,
      2499,
      4271,
      108792,
      33510,
      125072,
      71653,
      65239,
      38250,
      66357,
      38577,
      13964,
      86251,
      35708,
      50755,
      36010,
      29448,
      12209,
      3844,
      38222,
      206337,
      100876,
      67827,
      137088,
      14167,
      252225,
      84163,
      195270,
      1306,
      5703,
      54198,
      779,
      46802,
      22028,
      51124,
      86759,
      70560,
      113164,
      35685,
      162145,
      45471,
      34561,
      422,
      2611,
      6464,
      47486,
      19223,
      38246,
      9191,
      18331,
      89942,
      243642,
      212364,
      15893,
      17518,
      22617,
      6409,
      30046,
      126182,
      59716,
      36560,
      104428,
      18846,
      26592,
      19458,
      50793,
      147333,
      30826,
      1388,
      27647,
      10922,
      14495,
      33545,
      19269,
      135828,
      39727,
      41601,
      46931,
      233379,
      49169,
      131130,
      182112,
      16276,
      82381,
      118209,
      142445,
      128310,
      19672,
      28740,
      82907,
      33436,
      3118,
      102206,
      28723,
      24819,
      41937,
      38854,
      5157,
      3881,
      111491,
      1142,
      9776,
      421673,
      152241,
      29309,
      14961,
      87854,
      6054,
      15424,
      3796,
      82656,
      54996,
      2108,
      55367,
      239450,
      154525,
      9643,
      118103,
      106041,
      64601,
      68549,
      48707,
      30266,
      25772,
      18740,
      9462,
      229669,
      91798,
      112152,
      191327,
      14493,
      72828,
      8175,
      66636,
      236474,
      25817,
      87351,
      129027,
      76653,
      20422,
      22983,
      71240,
      27846,
      44661,
      12399,
      46158,
      77704,
      53101,
      35032,
      11072,
      17300,
      109294,
      33638,
      24408,
      1895,
      11241,
      760,
      17584,
      82479,
      125877,
      63150,
      141075,
      34259,
      23274,
      81698,
      15732,
      43577,
      48340,
      91584,
      14688,
      16379,
      24481,
      150280,
      96420,
      262050,
      48635,
      43727,
      61819,
      56268,
      72003,
      88178,
      17281,
      79912,
      13218,
      122519,
      125295,
      166396,
      11811,
      2171,
      118930,
      67746,
      17636,
      178278,
      174656,
      95661,
      173039,
      83845,
      79689,
      17473,
      98555,
      127696,
      203415,
      54730,
      22925,
      232239,
      9309,
      12136,
      175026,
      20740,
      180188,
      10747,
      39816,
      314017,
      266131,
      10040,
      175732,
      112550,
      220651,
      31974,
      37393,
      888,
      23008,
      86799,
      4303,
      64905,
      148467,
      75337,
      251,
      3284,
      370102,
      50264,
      9835,
      5438,
      23655,
      4481,
      29851,
      329,
      12855,
      7162,
      64931,
      78141,
      12804,
      42372,
      296771,
      83547,
      18624,
      34874,
      86271,
      3360,
      48665,
      77735,
      88767,
      11463,
      63527,
      28889,
      22258,
      29140,
      194315,
      113924,
      25499,
      6406,
      31334,
      1845,
      4802,
      49184,
      43455,
      35469,
      127594,
      92970,
      61038,
      115005,
      38840,
      87761,
      106838,
      8811,
      20572,
      55637,
      11162,
      96721,
      132425,
      108925,
      2948,
      125457,
      36356,
      3502,
      75270,
      27622,
      127192,
      2561,
      123095,
      49394,
      61155,
      16897,
      110064,
      9699,
      89448,
      53356,
      19628,
      220310,
      21622,
      83036,
      9885,
      112214,
      6087,
      26713,
      17901,
      161912,
      91492,
      3440,
      68594,
      9266,
      92238,
      8087,
      6866,
      150194,
      72175,
      80701,
      13459,
      31836,
      43243,
      239700,
      95846,
      44749,
      50647,
      21945,
      230538,
      120612,
      132371,
      244604,
      5193,
      105637,
      34661,
      41341,
      68775,
      85393,
      1874,
      8771,
      33718,
      49672,
      77403,
      595452,
      99507,
      6490,
      58895,
      128742,
      7704,
      39239,
      73217,
      43816,
      62824,
      37804,
      199976,
      22361,
      80005,
      87514,
      94832,
      14089,
      4574,
      139975,
      59142,
      75523,
      100268,
      43906,
      53442,
      15152,
      2547,
      186002,
      17011,
      19513,
      204282,
      3343,
      60568,
      128318,
      119250,
      4298,
      51871,
      41336,
      71759,
      21921,
      45074,
      98169,
      145889,
      99427,
      11350,
      1237,
      5520,
      28799,
      7803,
      53702,
      21026,
      136352,
      38293,
      128690,
      12158,
      90132,
      44600,
      10184,
      26957,
      39459,
      126025,
      78904,
      82999,
      59373,
      39301,
      150198,
      120529,
      153042,
      20177,
      50089,
      14764,
      271571,
      30530,
      123161,
      38975,
      101562,
      22941,
      5648,
      124654,
      109243,
      69817,
      71675,
      49162,
      106884,
      21241,
      107795,
      30258,
      16572,
      188262,
      141456,
      7688,
      60718,
      8271,
      11044,
      32440,
      104608,
      103419,
      236109,
      93156,
      43293,
      128929,
      42107,
      67180,
      25201,
      115254,
      185488,
      130954,
      72813,
      167547,
      20537,
      39969,
      38432,
      22582,
      184022,
      1139,
      27199,
      5655,
      17767,
      97412,
      122606,
      209377,
      27070,
      35871,
      326617,
      188954,
      42680,
      73512,
      80911,
      22629,
      3011,
      95021,
      315242,
      157737,
      383,
      41821,
      41808,
      19335,
      27950,
      15674,
      25677,
      110950,
      35375,
      76835,
      59108,
      57370,
      35262,
      16569,
      160415,
      37706,
      78086,
      32041,
      49691,
      137143,
      9782,
      172080,
      50148,
      77917,
      6323,
      10110,
      69172,
      17711,
      21795,
      59511,
      76184,
      135114,
      31046,
      132319,
      59105,
      157578,
      20549,
      80778,
      57649,
      158421,
      65143,
      4575,
      72235,
      21899,
      10797,
      92745,
      34035,
      106079,
      80159,
      4508,
      78304,
      25350,
      75457,
      46458,
      32937,
      25623,
      47,
      8531,
      104751,
      84953,
      8138,
      36508,
      187199,
      66310,
      115274,
      13253,
      32461,
      38536,
      1916,
      42007,
      187160,
      35055,
      26325,
      84394,
      35963,
      94216,
      45590,
      97782
    ];
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/routing-table/refresh.js
var require_refresh = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/routing-table/refresh.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { xor: uint8ArrayXor } = (init_xor(), __toCommonJS(xor_exports));
    var GENERATED_PREFIXES = require_generated_prefix_list_browser();
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    var crypto6 = require_src6();
    var PeerId14 = require_src5();
    var utils = require_utils7();
    var length5 = require_it_length();
    var { TimeoutController: TimeoutController3 } = require_timeout_abort_controller();
    var { TABLE_REFRESH_INTERVAL, TABLE_REFRESH_QUERY_TIMEOUT } = require_constants10();
    var MAX_COMMON_PREFIX_LENGTH = 15;
    var RoutingTableRefresh = class {
      constructor({ peerRouting, routingTable, refreshInterval, refreshQueryTimeout, lan }) {
        this._log = utils.logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:routing-table:refresh`);
        this._peerRouting = peerRouting;
        this._routingTable = routingTable;
        this._refreshInterval = refreshInterval || TABLE_REFRESH_INTERVAL;
        this._refreshQueryTimeout = refreshQueryTimeout || TABLE_REFRESH_QUERY_TIMEOUT;
        this.commonPrefixLengthRefreshedAt = [];
        this.refreshTable = this.refreshTable.bind(this);
      }
      async start() {
        this._log(`refreshing routing table every ${this._refreshInterval}ms`);
        await this.refreshTable(true);
      }
      async stop() {
        if (this._refreshTimeoutId) {
          clearTimeout(this._refreshTimeoutId);
        }
      }
      async refreshTable(force) {
        this._log("refreshing routing table");
        const prefixLength = this._maxCommonPrefix();
        const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
        this._log(`max common prefix length ${prefixLength}`);
        this._log(`tracked CPLs [ ${refreshCpls.map((date) => date.toISOString()).join(", ")} ]`);
        await Promise.all(refreshCpls.map(async (lastRefresh, index) => {
          try {
            await this._refreshCommonPrefixLength(index, lastRefresh, force === true);
            if (this._numPeersForCpl(prefixLength) === 0) {
              const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);
              for (let n = index + 1; n < lastCpl + 1; n++) {
                try {
                  await this._refreshCommonPrefixLength(n, lastRefresh, force === true);
                } catch (err) {
                  this._log.error(err);
                }
              }
            }
          } catch (err) {
            this._log.error(err);
          }
        }));
        this._refreshTimeoutId = setTimeout(this.refreshTable, this._refreshInterval);
        if (this._refreshTimeoutId.unref) {
          this._refreshTimeoutId.unref();
        }
      }
      async _refreshCommonPrefixLength(cpl, lastRefresh, force) {
        if (!force && lastRefresh.getTime() > Date.now() - this._refreshInterval) {
          this._log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
          return;
        }
        const peerId = await this._generateRandomPeerId(cpl);
        this._log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId, this._routingTable.kb.count());
        const controller = new TimeoutController3(this._refreshQueryTimeout);
        try {
          const peers = await length5(this._peerRouting.getClosestPeers(peerId.toBytes(), { signal: controller.signal }));
          this._log(`found ${peers} peers that were close to imaginary peer %p`, peerId);
          this._log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId, this._routingTable.kb.count());
        } finally {
          controller.clear();
        }
      }
      _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
        if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
          maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
        }
        const dates = [];
        for (let i = 0; i <= maxCommonPrefix; i++) {
          dates[i] = this.commonPrefixLengthRefreshedAt[i] || new Date();
        }
        return dates;
      }
      async _generateRandomPeerId(targetCommonPrefixLength) {
        const randomBytes = crypto6.randomBytes(2);
        const randomUint16 = (randomBytes[1] << 8) + randomBytes[0];
        const key = await this._makePeerId(this._routingTable.kb.localNodeId, randomUint16, targetCommonPrefixLength);
        return PeerId14.createFromBytes(key);
      }
      async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
        if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
          throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
        }
        const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
        const localPrefix = view.getUint16(0, false);
        const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
        const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
        const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
        const keyPrefix = GENERATED_PREFIXES[targetPrefix];
        const keyBuffer = new ArrayBuffer(34);
        const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
        keyView.setUint8(0, sha2563.code);
        keyView.setUint8(1, 32);
        keyView.setUint32(2, keyPrefix, false);
        return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
      }
      _maxCommonPrefix() {
        let prefixLength = 0;
        for (const length6 of this._prefixLengths()) {
          if (length6 > prefixLength) {
            prefixLength = length6;
          }
        }
        return prefixLength;
      }
      _numPeersForCpl(prefixLength) {
        let count = 0;
        for (const length6 of this._prefixLengths()) {
          if (length6 === prefixLength) {
            count++;
          }
        }
        return count;
      }
      *_prefixLengths() {
        if (!this._routingTable.kb) {
          return;
        }
        for (const { id } of this._routingTable.kb.toIterable()) {
          const distance = uint8ArrayXor(this._routingTable.kb.localNodeId, id);
          let leadingZeros = 0;
          for (const byte of distance) {
            if (byte === 0) {
              leadingZeros++;
            } else {
              break;
            }
          }
          yield leadingZeros;
        }
      }
    };
    module2.exports.RoutingTableRefresh = RoutingTableRefresh;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/message/dht.js
var require_dht = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/message/dht.js"(exports2, module2) {
    "use strict";
    init_globals();
    var $protobuf12 = require_minimal2();
    var $Reader11 = $protobuf12.Reader;
    var $Writer11 = $protobuf12.Writer;
    var $util11 = $protobuf12.util;
    var $root11 = $protobuf12.roots["libp2p-dht-message"] || ($protobuf12.roots["libp2p-dht-message"] = {});
    $root11.Record = function() {
      function Record2(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Record2.prototype.key = null;
      Record2.prototype.value = null;
      Record2.prototype.author = null;
      Record2.prototype.signature = null;
      Record2.prototype.timeReceived = null;
      var $oneOfFields;
      Object.defineProperty(Record2.prototype, "_key", {
        get: $util11.oneOfGetter($oneOfFields = ["key"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Record2.prototype, "_value", {
        get: $util11.oneOfGetter($oneOfFields = ["value"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Record2.prototype, "_author", {
        get: $util11.oneOfGetter($oneOfFields = ["author"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Record2.prototype, "_signature", {
        get: $util11.oneOfGetter($oneOfFields = ["signature"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Record2.prototype, "_timeReceived", {
        get: $util11.oneOfGetter($oneOfFields = ["timeReceived"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Record2.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.key != null && Object.hasOwnProperty.call(m, "key"))
          w.uint32(10).bytes(m.key);
        if (m.value != null && Object.hasOwnProperty.call(m, "value"))
          w.uint32(18).bytes(m.value);
        if (m.author != null && Object.hasOwnProperty.call(m, "author"))
          w.uint32(26).bytes(m.author);
        if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
          w.uint32(34).bytes(m.signature);
        if (m.timeReceived != null && Object.hasOwnProperty.call(m, "timeReceived"))
          w.uint32(42).string(m.timeReceived);
        return w;
      };
      Record2.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.Record();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.key = r.bytes();
              break;
            case 2:
              m.value = r.bytes();
              break;
            case 3:
              m.author = r.bytes();
              break;
            case 4:
              m.signature = r.bytes();
              break;
            case 5:
              m.timeReceived = r.string();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Record2.fromObject = function fromObject(d) {
        if (d instanceof $root11.Record)
          return d;
        var m = new $root11.Record();
        if (d.key != null) {
          if (typeof d.key === "string")
            $util11.base64.decode(d.key, m.key = $util11.newBuffer($util11.base64.length(d.key)), 0);
          else if (d.key.length)
            m.key = d.key;
        }
        if (d.value != null) {
          if (typeof d.value === "string")
            $util11.base64.decode(d.value, m.value = $util11.newBuffer($util11.base64.length(d.value)), 0);
          else if (d.value.length)
            m.value = d.value;
        }
        if (d.author != null) {
          if (typeof d.author === "string")
            $util11.base64.decode(d.author, m.author = $util11.newBuffer($util11.base64.length(d.author)), 0);
          else if (d.author.length)
            m.author = d.author;
        }
        if (d.signature != null) {
          if (typeof d.signature === "string")
            $util11.base64.decode(d.signature, m.signature = $util11.newBuffer($util11.base64.length(d.signature)), 0);
          else if (d.signature.length)
            m.signature = d.signature;
        }
        if (d.timeReceived != null) {
          m.timeReceived = String(d.timeReceived);
        }
        return m;
      };
      Record2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (m.key != null && m.hasOwnProperty("key")) {
          d.key = o.bytes === String ? $util11.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
          if (o.oneofs)
            d._key = "key";
        }
        if (m.value != null && m.hasOwnProperty("value")) {
          d.value = o.bytes === String ? $util11.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
          if (o.oneofs)
            d._value = "value";
        }
        if (m.author != null && m.hasOwnProperty("author")) {
          d.author = o.bytes === String ? $util11.base64.encode(m.author, 0, m.author.length) : o.bytes === Array ? Array.prototype.slice.call(m.author) : m.author;
          if (o.oneofs)
            d._author = "author";
        }
        if (m.signature != null && m.hasOwnProperty("signature")) {
          d.signature = o.bytes === String ? $util11.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
          if (o.oneofs)
            d._signature = "signature";
        }
        if (m.timeReceived != null && m.hasOwnProperty("timeReceived")) {
          d.timeReceived = m.timeReceived;
          if (o.oneofs)
            d._timeReceived = "timeReceived";
        }
        return d;
      };
      Record2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      return Record2;
    }();
    $root11.Message = function() {
      function Message2(p) {
        this.closerPeers = [];
        this.providerPeers = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Message2.prototype.type = null;
      Message2.prototype.clusterLevelRaw = null;
      Message2.prototype.key = null;
      Message2.prototype.record = null;
      Message2.prototype.closerPeers = $util11.emptyArray;
      Message2.prototype.providerPeers = $util11.emptyArray;
      var $oneOfFields;
      Object.defineProperty(Message2.prototype, "_type", {
        get: $util11.oneOfGetter($oneOfFields = ["type"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Message2.prototype, "_clusterLevelRaw", {
        get: $util11.oneOfGetter($oneOfFields = ["clusterLevelRaw"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Message2.prototype, "_key", {
        get: $util11.oneOfGetter($oneOfFields = ["key"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Message2.prototype, "_record", {
        get: $util11.oneOfGetter($oneOfFields = ["record"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Message2.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.type != null && Object.hasOwnProperty.call(m, "type"))
          w.uint32(8).int32(m.type);
        if (m.key != null && Object.hasOwnProperty.call(m, "key"))
          w.uint32(18).bytes(m.key);
        if (m.record != null && Object.hasOwnProperty.call(m, "record"))
          w.uint32(26).bytes(m.record);
        if (m.closerPeers != null && m.closerPeers.length) {
          for (var i = 0; i < m.closerPeers.length; ++i)
            $root11.Message.Peer.encode(m.closerPeers[i], w.uint32(66).fork()).ldelim();
        }
        if (m.providerPeers != null && m.providerPeers.length) {
          for (var i = 0; i < m.providerPeers.length; ++i)
            $root11.Message.Peer.encode(m.providerPeers[i], w.uint32(74).fork()).ldelim();
        }
        if (m.clusterLevelRaw != null && Object.hasOwnProperty.call(m, "clusterLevelRaw"))
          w.uint32(80).int32(m.clusterLevelRaw);
        return w;
      };
      Message2.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.Message();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.type = r.int32();
              break;
            case 10:
              m.clusterLevelRaw = r.int32();
              break;
            case 2:
              m.key = r.bytes();
              break;
            case 3:
              m.record = r.bytes();
              break;
            case 8:
              if (!(m.closerPeers && m.closerPeers.length))
                m.closerPeers = [];
              m.closerPeers.push($root11.Message.Peer.decode(r, r.uint32()));
              break;
            case 9:
              if (!(m.providerPeers && m.providerPeers.length))
                m.providerPeers = [];
              m.providerPeers.push($root11.Message.Peer.decode(r, r.uint32()));
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Message2.fromObject = function fromObject(d) {
        if (d instanceof $root11.Message)
          return d;
        var m = new $root11.Message();
        switch (d.type) {
          case "PUT_VALUE":
          case 0:
            m.type = 0;
            break;
          case "GET_VALUE":
          case 1:
            m.type = 1;
            break;
          case "ADD_PROVIDER":
          case 2:
            m.type = 2;
            break;
          case "GET_PROVIDERS":
          case 3:
            m.type = 3;
            break;
          case "FIND_NODE":
          case 4:
            m.type = 4;
            break;
          case "PING":
          case 5:
            m.type = 5;
            break;
        }
        if (d.clusterLevelRaw != null) {
          m.clusterLevelRaw = d.clusterLevelRaw | 0;
        }
        if (d.key != null) {
          if (typeof d.key === "string")
            $util11.base64.decode(d.key, m.key = $util11.newBuffer($util11.base64.length(d.key)), 0);
          else if (d.key.length)
            m.key = d.key;
        }
        if (d.record != null) {
          if (typeof d.record === "string")
            $util11.base64.decode(d.record, m.record = $util11.newBuffer($util11.base64.length(d.record)), 0);
          else if (d.record.length)
            m.record = d.record;
        }
        if (d.closerPeers) {
          if (!Array.isArray(d.closerPeers))
            throw TypeError(".Message.closerPeers: array expected");
          m.closerPeers = [];
          for (var i = 0; i < d.closerPeers.length; ++i) {
            if (typeof d.closerPeers[i] !== "object")
              throw TypeError(".Message.closerPeers: object expected");
            m.closerPeers[i] = $root11.Message.Peer.fromObject(d.closerPeers[i]);
          }
        }
        if (d.providerPeers) {
          if (!Array.isArray(d.providerPeers))
            throw TypeError(".Message.providerPeers: array expected");
          m.providerPeers = [];
          for (var i = 0; i < d.providerPeers.length; ++i) {
            if (typeof d.providerPeers[i] !== "object")
              throw TypeError(".Message.providerPeers: object expected");
            m.providerPeers[i] = $root11.Message.Peer.fromObject(d.providerPeers[i]);
          }
        }
        return m;
      };
      Message2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.closerPeers = [];
          d.providerPeers = [];
        }
        if (m.type != null && m.hasOwnProperty("type")) {
          d.type = o.enums === String ? $root11.Message.MessageType[m.type] : m.type;
          if (o.oneofs)
            d._type = "type";
        }
        if (m.key != null && m.hasOwnProperty("key")) {
          d.key = o.bytes === String ? $util11.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
          if (o.oneofs)
            d._key = "key";
        }
        if (m.record != null && m.hasOwnProperty("record")) {
          d.record = o.bytes === String ? $util11.base64.encode(m.record, 0, m.record.length) : o.bytes === Array ? Array.prototype.slice.call(m.record) : m.record;
          if (o.oneofs)
            d._record = "record";
        }
        if (m.closerPeers && m.closerPeers.length) {
          d.closerPeers = [];
          for (var j = 0; j < m.closerPeers.length; ++j) {
            d.closerPeers[j] = $root11.Message.Peer.toObject(m.closerPeers[j], o);
          }
        }
        if (m.providerPeers && m.providerPeers.length) {
          d.providerPeers = [];
          for (var j = 0; j < m.providerPeers.length; ++j) {
            d.providerPeers[j] = $root11.Message.Peer.toObject(m.providerPeers[j], o);
          }
        }
        if (m.clusterLevelRaw != null && m.hasOwnProperty("clusterLevelRaw")) {
          d.clusterLevelRaw = m.clusterLevelRaw;
          if (o.oneofs)
            d._clusterLevelRaw = "clusterLevelRaw";
        }
        return d;
      };
      Message2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      Message2.MessageType = function() {
        var valuesById = {}, values2 = Object.create(valuesById);
        values2[valuesById[0] = "PUT_VALUE"] = 0;
        values2[valuesById[1] = "GET_VALUE"] = 1;
        values2[valuesById[2] = "ADD_PROVIDER"] = 2;
        values2[valuesById[3] = "GET_PROVIDERS"] = 3;
        values2[valuesById[4] = "FIND_NODE"] = 4;
        values2[valuesById[5] = "PING"] = 5;
        return values2;
      }();
      Message2.ConnectionType = function() {
        var valuesById = {}, values2 = Object.create(valuesById);
        values2[valuesById[0] = "NOT_CONNECTED"] = 0;
        values2[valuesById[1] = "CONNECTED"] = 1;
        values2[valuesById[2] = "CAN_CONNECT"] = 2;
        values2[valuesById[3] = "CANNOT_CONNECT"] = 3;
        return values2;
      }();
      Message2.Peer = function() {
        function Peer3(p) {
          this.addrs = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Peer3.prototype.id = null;
        Peer3.prototype.addrs = $util11.emptyArray;
        Peer3.prototype.connection = null;
        var $oneOfFields2;
        Object.defineProperty(Peer3.prototype, "_id", {
          get: $util11.oneOfGetter($oneOfFields2 = ["id"]),
          set: $util11.oneOfSetter($oneOfFields2)
        });
        Object.defineProperty(Peer3.prototype, "_connection", {
          get: $util11.oneOfGetter($oneOfFields2 = ["connection"]),
          set: $util11.oneOfSetter($oneOfFields2)
        });
        Peer3.encode = function encode19(m, w) {
          if (!w)
            w = $Writer11.create();
          if (m.id != null && Object.hasOwnProperty.call(m, "id"))
            w.uint32(10).bytes(m.id);
          if (m.addrs != null && m.addrs.length) {
            for (var i = 0; i < m.addrs.length; ++i)
              w.uint32(18).bytes(m.addrs[i]);
          }
          if (m.connection != null && Object.hasOwnProperty.call(m, "connection"))
            w.uint32(24).int32(m.connection);
          return w;
        };
        Peer3.decode = function decode22(r, l) {
          if (!(r instanceof $Reader11))
            r = $Reader11.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root11.Message.Peer();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.id = r.bytes();
                break;
              case 2:
                if (!(m.addrs && m.addrs.length))
                  m.addrs = [];
                m.addrs.push(r.bytes());
                break;
              case 3:
                m.connection = r.int32();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        Peer3.fromObject = function fromObject(d) {
          if (d instanceof $root11.Message.Peer)
            return d;
          var m = new $root11.Message.Peer();
          if (d.id != null) {
            if (typeof d.id === "string")
              $util11.base64.decode(d.id, m.id = $util11.newBuffer($util11.base64.length(d.id)), 0);
            else if (d.id.length)
              m.id = d.id;
          }
          if (d.addrs) {
            if (!Array.isArray(d.addrs))
              throw TypeError(".Message.Peer.addrs: array expected");
            m.addrs = [];
            for (var i = 0; i < d.addrs.length; ++i) {
              if (typeof d.addrs[i] === "string")
                $util11.base64.decode(d.addrs[i], m.addrs[i] = $util11.newBuffer($util11.base64.length(d.addrs[i])), 0);
              else if (d.addrs[i].length)
                m.addrs[i] = d.addrs[i];
            }
          }
          switch (d.connection) {
            case "NOT_CONNECTED":
            case 0:
              m.connection = 0;
              break;
            case "CONNECTED":
            case 1:
              m.connection = 1;
              break;
            case "CAN_CONNECT":
            case 2:
              m.connection = 2;
              break;
            case "CANNOT_CONNECT":
            case 3:
              m.connection = 3;
              break;
          }
          return m;
        };
        Peer3.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.addrs = [];
          }
          if (m.id != null && m.hasOwnProperty("id")) {
            d.id = o.bytes === String ? $util11.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;
            if (o.oneofs)
              d._id = "id";
          }
          if (m.addrs && m.addrs.length) {
            d.addrs = [];
            for (var j = 0; j < m.addrs.length; ++j) {
              d.addrs[j] = o.bytes === String ? $util11.base64.encode(m.addrs[j], 0, m.addrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.addrs[j]) : m.addrs[j];
            }
          }
          if (m.connection != null && m.hasOwnProperty("connection")) {
            d.connection = o.enums === String ? $root11.Message.ConnectionType[m.connection] : m.connection;
            if (o.oneofs)
              d._connection = "connection";
          }
          return d;
        };
        Peer3.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
        };
        return Peer3;
      }();
      return Message2;
    }();
    module2.exports = $root11;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/message/index.js
var require_message = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/message/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var PeerId14 = require_src5();
    var { Multiaddr: Multiaddr22 } = require_src();
    var { Record: Record2 } = require_src7();
    var Proto = require_dht();
    var MESSAGE_TYPE = Proto.Message.MessageType;
    var CONNECTION_TYPE = Proto.Message.ConnectionType;
    var MESSAGE_TYPE_LOOKUP = Object.keys(MESSAGE_TYPE);
    var Message2 = class {
      constructor(type, key, level) {
        if (key && !(key instanceof Uint8Array)) {
          throw new Error("Key must be a Uint8Array");
        }
        this.type = type;
        this.key = key;
        this._clusterLevelRaw = level;
        this.closerPeers = [];
        this.providerPeers = [];
        this.record = void 0;
      }
      get clusterLevel() {
        const level = this._clusterLevelRaw - 1;
        if (level < 0) {
          return 0;
        }
        return level;
      }
      set clusterLevel(level) {
        this._clusterLevelRaw = level;
      }
      serialize() {
        const obj = {
          key: this.key,
          type: this.type,
          clusterLevelRaw: this._clusterLevelRaw,
          closerPeers: this.closerPeers.map(toPbPeer),
          providerPeers: this.providerPeers.map(toPbPeer),
          record: void 0
        };
        if (this.record) {
          if (this.record instanceof Uint8Array) {
            obj.record = this.record;
          } else {
            obj.record = this.record.serialize();
          }
        }
        return Proto.Message.encode(obj).finish();
      }
      static deserialize(raw) {
        const dec = Proto.Message.decode(raw);
        const msg = new Message2(dec.type || 0, dec.key || Uint8Array.from([]), dec.clusterLevelRaw || 0);
        msg.closerPeers = dec.closerPeers.map(fromPbPeer);
        msg.providerPeers = dec.providerPeers.map(fromPbPeer);
        if (dec.record && dec.record.length) {
          msg.record = Record2.deserialize(dec.record);
        }
        return msg;
      }
    };
    Message2.TYPES = MESSAGE_TYPE;
    Message2.CONNECTION_TYPES = CONNECTION_TYPE;
    function toPbPeer(peer) {
      const output = {
        id: peer.id.id,
        addrs: (peer.multiaddrs || []).map((m) => m.bytes),
        connection: CONNECTION_TYPE.CONNECTED
      };
      return output;
    }
    function fromPbPeer(peer) {
      return {
        id: new PeerId14(peer.id),
        multiaddrs: (peer.addrs || []).map((a) => new Multiaddr22(a))
      };
    }
    module2.exports.Message = Message2;
    module2.exports.MESSAGE_TYPE = MESSAGE_TYPE;
    module2.exports.MESSAGE_TYPE_LOOKUP = MESSAGE_TYPE_LOOKUP;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/query/events.js
var require_events2 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/query/events.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { MESSAGE_TYPE_LOOKUP } = require_message();
    var MESSAGE_NAMES = [
      "PUT_VALUE",
      "GET_VALUE",
      "ADD_PROVIDER",
      "GET_PROVIDERS",
      "FIND_NODE",
      "PING"
    ];
    function sendingQueryEvent(fields) {
      return {
        ...fields,
        name: "SENDING_QUERY",
        type: 0,
        messageName: MESSAGE_TYPE_LOOKUP[fields.type],
        messageType: fields.type
      };
    }
    function peerResponseEvent(fields) {
      return {
        ...fields,
        name: "PEER_RESPONSE",
        type: 1,
        messageName: MESSAGE_NAMES[fields.messageType],
        closer: fields.closer ? fields.closer : [],
        providers: fields.providers ? fields.providers : []
      };
    }
    function finalPeerEvent(fields) {
      return {
        ...fields,
        name: "FINAL_PEER",
        type: 2
      };
    }
    function queryErrorEvent(fields) {
      return {
        ...fields,
        name: "QUERY_ERROR",
        type: 3
      };
    }
    function providerEvent(fields) {
      return {
        ...fields,
        name: "PROVIDER",
        type: 4
      };
    }
    function valueEvent(fields) {
      return {
        ...fields,
        name: "VALUE",
        type: 5
      };
    }
    function addingPeerEvent(fields) {
      return {
        ...fields,
        name: "ADDING_PEER",
        type: 6
      };
    }
    function dialingPeerEvent(fields) {
      return {
        ...fields,
        name: "DIALING_PEER",
        type: 7
      };
    }
    module2.exports = {
      sendingQueryEvent,
      peerResponseEvent,
      finalPeerEvent,
      queryErrorEvent,
      providerEvent,
      valueEvent,
      addingPeerEvent,
      dialingPeerEvent
    };
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/network.js
var require_network = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/network.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errcode17 = require_err_code();
    var { pipe: pipe8 } = require_it_pipe();
    var lp2 = require_src11();
    var drain9 = require_it_drain();
    var first4 = require_it_first();
    var { Message: Message2, MESSAGE_TYPE_LOOKUP } = require_message();
    var utils = require_utils7();
    var { EventEmitter: EventEmitter4 } = require_events();
    var {
      dialingPeerEvent,
      sendingQueryEvent,
      peerResponseEvent,
      queryErrorEvent
    } = require_events2();
    var Network3 = class extends EventEmitter4 {
      constructor({ dialer, protocol, lan }) {
        super();
        this._log = utils.logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:network`);
        this._running = false;
        this._dialer = dialer;
        this._protocol = protocol;
      }
      start() {
        if (this._running) {
          return;
        }
        this._running = true;
      }
      stop() {
        this._running = false;
      }
      get isStarted() {
        return this._running;
      }
      async *sendRequest(to, msg, options = {}) {
        if (!this._running) {
          return;
        }
        this._log("sending %s to %p", MESSAGE_TYPE_LOOKUP[msg.type], to);
        try {
          yield dialingPeerEvent({ peer: to });
          const { stream } = await this._dialer.dialProtocol(to, this._protocol, options);
          yield sendingQueryEvent({ to, type: msg.type });
          const response = await this._writeReadMessage(stream, msg.serialize(), options);
          yield peerResponseEvent({
            from: to,
            messageType: response.type,
            closer: response.closerPeers,
            providers: response.providerPeers,
            record: response.record
          });
        } catch (err) {
          yield queryErrorEvent({ from: to, error: err });
        }
      }
      async *sendMessage(to, msg, options = {}) {
        if (!this._running) {
          return;
        }
        this._log("sending %s to %p", MESSAGE_TYPE_LOOKUP[msg.type], to);
        yield dialingPeerEvent({ peer: to });
        const { stream } = await this._dialer.dialProtocol(to, this._protocol, options);
        yield sendingQueryEvent({ to, type: msg.type });
        try {
          await this._writeMessage(stream, msg.serialize(), options);
          yield peerResponseEvent({ from: to, messageType: msg.type });
        } catch (err) {
          yield queryErrorEvent({ from: to, error: err });
        }
      }
      async _writeMessage(stream, msg, options = {}) {
        await pipe8([msg], lp2.encode(), stream, drain9);
      }
      async _writeReadMessage(stream, msg, options = {}) {
        const res = await pipe8([msg], lp2.encode(), stream, lp2.decode(), async (source) => {
          const buf3 = await first4(source);
          if (buf3) {
            return buf3.slice();
          }
        });
        if (res.length === 0) {
          throw errcode17(new Error("No message received"), "ERR_NO_MESSAGE_RECEIVED");
        }
        const message = Message2.deserialize(res);
        message.closerPeers.forEach((peerData) => {
          this.emit("peer", peerData);
        });
        message.providerPeers.forEach((peerData) => {
          this.emit("peer", peerData);
        });
        return message;
      }
    };
    module2.exports.Network = Network3;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/content-fetching/index.js
var require_content_fetching = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/content-fetching/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errcode17 = require_err_code();
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var Libp2pRecord = require_src7();
    var {
      ALPHA
    } = require_constants10();
    var utils = require_utils7();
    var Record2 = Libp2pRecord.Record;
    var parallel2 = require_it_parallel();
    var map12 = require_it_map();
    var {
      valueEvent,
      queryErrorEvent
    } = require_events2();
    var { Message: Message2 } = require_message();
    var { pipe: pipe8 } = require_it_pipe();
    var ContentFetching = class {
      constructor({ peerId, records, validators, selectors, peerRouting, queryManager, routingTable, network, lan }) {
        this._log = utils.logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-fetching`);
        this._peerId = peerId;
        this._records = records;
        this._validators = validators;
        this._selectors = selectors;
        this._peerRouting = peerRouting;
        this._queryManager = queryManager;
        this._routingTable = routingTable;
        this._network = network;
      }
      async putLocal(key, rec) {
        return this._records.put(utils.bufferToKey(key), rec);
      }
      async getLocal(key) {
        this._log(`getLocal ${uint8ArrayToString(key, "base32")}`);
        const dsKey = utils.bufferToKey(key);
        this._log(`fetching record for key ${dsKey}`);
        const raw = await this._records.get(dsKey);
        this._log(`found ${dsKey} in local datastore`);
        const rec = Record2.deserialize(raw);
        await Libp2pRecord.validator.verifyRecord(this._validators, rec);
        return rec;
      }
      async *sendCorrectionRecord(key, vals, best, options = {}) {
        this._log("sendCorrection for %b", key);
        const fixupRec = await utils.createPutRecord(key, best);
        for (const { value, from: from5 } of vals) {
          if (uint8ArrayEquals(value, best)) {
            this._log("record was ok");
            continue;
          }
          if (this._peerId.equals(from5)) {
            try {
              const dsKey = utils.bufferToKey(key);
              this._log(`Storing corrected record for key ${dsKey}`);
              await this._records.put(dsKey, fixupRec);
            } catch (err) {
              this._log.error("Failed error correcting self", err);
            }
            continue;
          }
          let sentCorrection = false;
          const request = new Message2(Message2.TYPES.PUT_VALUE, key, 0);
          request.record = Record2.deserialize(fixupRec);
          for await (const event of this._network.sendRequest(from5, request, options)) {
            if (event.name === "PEER_RESPONSE" && event.record && uint8ArrayEquals(event.record.value, Record2.deserialize(fixupRec).value)) {
              sentCorrection = true;
            }
            yield event;
          }
          if (!sentCorrection) {
            yield queryErrorEvent({ from: from5, error: errcode17(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") });
          }
          this._log.error("Failed error correcting entry");
        }
      }
      async *put(key, value, options = {}) {
        this._log("put key %b value %b", key, value);
        const record = await utils.createPutRecord(key, value);
        const dsKey = utils.bufferToKey(key);
        this._log(`storing record for key ${dsKey}`);
        await this._records.put(dsKey, record);
        yield* pipe8(this._peerRouting.getClosestPeers(key, { signal: options.signal }), (source) => map12(source, (event) => {
          return async () => {
            if (event.name !== "FINAL_PEER") {
              return [event];
            }
            const events2 = [];
            const msg = new Message2(Message2.TYPES.PUT_VALUE, key, 0);
            msg.record = Record2.deserialize(record);
            for await (const putEvent of this._network.sendRequest(event.peer.id, msg, options)) {
              events2.push(putEvent);
              if (putEvent.name !== "PEER_RESPONSE") {
                continue;
              }
              if (putEvent.record && uint8ArrayEquals(putEvent.record.value, Record2.deserialize(record).value)) {
              } else {
                events2.push(queryErrorEvent({ from: event.peer.id, error: errcode17(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") }));
              }
            }
            return events2;
          };
        }), (source) => parallel2(source, {
          ordered: false,
          concurrency: ALPHA
        }), async function* (source) {
          for await (const events2 of source) {
            yield* events2;
          }
        });
      }
      async *get(key, options = {}) {
        this._log("get %b", key);
        const vals = [];
        for await (const event of this.getMany(key, options)) {
          if (event.name === "VALUE") {
            vals.push(event);
          }
          yield event;
        }
        if (!vals.length) {
          return;
        }
        const records = vals.map((v) => v.value);
        let i = 0;
        try {
          i = Libp2pRecord.selection.bestRecord(this._selectors, key, records);
        } catch (err) {
          if (err.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY") {
            throw err;
          }
        }
        const best = records[i];
        this._log("GetValue %b %b", key, best);
        if (!best) {
          throw errcode17(new Error("best value was not found"), "ERR_NOT_FOUND");
        }
        yield* this.sendCorrectionRecord(key, vals, best, options);
        yield vals[i];
      }
      async *getMany(key, options = {}) {
        this._log("getMany values for %t", key);
        try {
          const localRec = await this.getLocal(key);
          yield valueEvent({
            value: localRec.value,
            from: this._peerId
          });
        } catch (err) {
          this._log("error getting local value for %b", key, err);
        }
        const id = await utils.convertBuffer(key);
        const rtp = this._routingTable.closestPeers(id);
        this._log("found %d peers in routing table", rtp.length);
        const self2 = this;
        const getValueQuery = async function* ({ peer, signal }) {
          for await (const event of self2._peerRouting.getValueOrPeers(peer, key, { signal })) {
            yield event;
            if (event.name === "PEER_RESPONSE" && event.record) {
              yield valueEvent({ from: peer, value: event.record.value });
            }
          }
        };
        yield* this._queryManager.run(key, rtp, getValueQuery, options);
      }
    };
    module2.exports.ContentFetching = ContentFetching;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/content-routing/index.js
var require_content_routing = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/content-routing/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Message: Message2 } = require_message();
    var parallel2 = require_it_parallel();
    var map12 = require_it_map();
    var { convertBuffer, logger: logger2 } = require_utils7();
    var { ALPHA } = require_constants10();
    var { pipe: pipe8 } = require_it_pipe();
    var {
      queryErrorEvent,
      peerResponseEvent,
      providerEvent
    } = require_events2();
    var { Message: { MessageType } } = require_dht();
    var ContentRouting = class {
      constructor({ peerId, network, peerRouting, queryManager, routingTable, providers, peerStore, lan }) {
        this._log = logger2(`libp2p:kad-dht:${lan ? "lan" : "wan"}:content-routing`);
        this._peerId = peerId;
        this._network = network;
        this._peerRouting = peerRouting;
        this._queryManager = queryManager;
        this._routingTable = routingTable;
        this._providers = providers;
        this._peerStore = peerStore;
      }
      async *provide(key, multiaddrs, options = {}) {
        this._log("provide %s", key);
        await this._providers.addProvider(key, this._peerId);
        const msg = new Message2(Message2.TYPES.ADD_PROVIDER, key.bytes, 0);
        msg.providerPeers = [{
          id: this._peerId,
          multiaddrs
        }];
        let sent = 0;
        const maybeNotifyPeer = (event) => {
          return async () => {
            if (event.name !== "FINAL_PEER") {
              return [event];
            }
            const events2 = [];
            this._log("putProvider %s to %p", key, event.peer.id);
            try {
              this._log("sending provider record for %s to %p", key, event.peer.id);
              for await (const sendEvent of this._network.sendMessage(event.peer.id, msg, options)) {
                if (sendEvent.name === "PEER_RESPONSE") {
                  this._log("sent provider record for %s to %p", key, event.peer.id);
                  sent++;
                }
                events2.push(sendEvent);
              }
            } catch (err) {
              this._log.error("error sending provide record to peer %p", event.peer.id, err);
              events2.push(queryErrorEvent({ from: event.peer.id, error: err }));
            }
            return events2;
          };
        };
        yield* pipe8(this._peerRouting.getClosestPeers(key.multihash.bytes, options), (source) => map12(source, (event) => maybeNotifyPeer(event)), (source) => parallel2(source, {
          ordered: false,
          concurrency: ALPHA
        }), async function* (source) {
          for await (const events2 of source) {
            yield* events2;
          }
        });
        this._log("sent provider records to %d peers", sent);
      }
      async *findProviders(key, options = { maxNumProviders: 5 }) {
        const toFind = options.maxNumProviders || this._routingTable._kBucketSize;
        const target = key.multihash.bytes;
        const id = await convertBuffer(target);
        const self2 = this;
        this._log(`findProviders ${key}`);
        const provs = await this._providers.getProviders(key);
        if (provs.length) {
          const providers2 = [];
          for (const peerId of provs.slice(0, toFind)) {
            providers2.push({
              id: peerId,
              multiaddrs: (await this._peerStore.addressBook.get(peerId) || []).map((address) => address.multiaddr)
            });
          }
          yield peerResponseEvent({ from: this._peerId, messageType: MessageType.GET_PROVIDERS, providers: providers2 });
          yield providerEvent({ from: this._peerId, providers: providers2 });
        }
        if (provs.length >= toFind) {
          return;
        }
        const findProvidersQuery = async function* ({ peer, signal }) {
          const request = new Message2(Message2.TYPES.GET_PROVIDERS, target, 0);
          yield* self2._network.sendRequest(peer, request, { signal });
        };
        const providers = new Set(provs.map((p) => p.toB58String()));
        for await (const event of this._queryManager.run(target, this._routingTable.closestPeers(id), findProvidersQuery, options)) {
          yield event;
          if (event.name === "PEER_RESPONSE") {
            this._log(`Found ${event.providers.length} provider entries for ${key} and ${event.closer.length} closer peers`);
            const newProviders = [];
            for (const peer of event.providers) {
              if (providers.has(peer.id.toB58String())) {
                continue;
              }
              providers.add(peer.id.toB58String());
              newProviders.push(peer);
            }
            if (newProviders.length) {
              yield providerEvent({ from: event.from, providers: newProviders });
            }
            if (providers.size === toFind) {
              return;
            }
          }
        }
      }
    };
    module2.exports.ContentRouting = ContentRouting;
  }
});

// node_modules/indent-string/index.js
var require_indent_string = __commonJS({
  "node_modules/indent-string/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = (string3, count = 1, options) => {
      options = {
        indent: " ",
        includeEmptyLines: false,
        ...options
      };
      if (typeof string3 !== "string") {
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string3}\``);
      }
      if (typeof count !== "number") {
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
      }
      if (typeof options.indent !== "string") {
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
      }
      if (count === 0) {
        return string3;
      }
      const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string3.replace(regex, options.indent.repeat(count));
    };
  }
});

// (disabled):os
var require_os = __commonJS({
  "(disabled):os"() {
    init_globals();
  }
});

// node_modules/clean-stack/index.js
var require_clean_stack = __commonJS({
  "node_modules/clean-stack/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var os = require_os();
    var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
    var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
    var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
    module2.exports = (stack, options) => {
      options = Object.assign({ pretty: false }, options);
      return stack.replace(/\\/g, "/").split("\n").filter((line) => {
        const pathMatches = line.match(extractPathRegex);
        if (pathMatches === null || !pathMatches[1]) {
          return true;
        }
        const match = pathMatches[1];
        if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
          return false;
        }
        return !pathRegex.test(match);
      }).filter((line) => line.trim() !== "").map((line) => {
        if (options.pretty) {
          return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
        }
        return line;
      }).join("\n");
    };
  }
});

// node_modules/aggregate-error/index.js
var require_aggregate_error = __commonJS({
  "node_modules/aggregate-error/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var indentString = require_indent_string();
    var cleanStack = require_clean_stack();
    var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
    var AggregateError2 = class extends Error {
      constructor(errors2) {
        if (!Array.isArray(errors2)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors2}`);
        }
        errors2 = [...errors2].map((error) => {
          if (error instanceof Error) {
            return error;
          }
          if (error !== null && typeof error === "object") {
            return Object.assign(new Error(error.message), error);
          }
          return new Error(error);
        });
        let message = errors2.map((error) => {
          return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
        }).join("\n");
        message = "\n" + indentString(message, 4);
        super(message);
        this.name = "AggregateError";
        Object.defineProperty(this, "_errors", { value: errors2 });
      }
      *[Symbol.iterator]() {
        for (const error of this._errors) {
          yield error;
        }
      }
    };
    module2.exports = AggregateError2;
  }
});

// node_modules/p-map/index.js
var require_p_map = __commonJS({
  "node_modules/p-map/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var AggregateError2 = require_aggregate_error();
    module2.exports = async (iterable, mapper, {
      concurrency = Infinity,
      stopOnError = true
    } = {}) => {
      return new Promise((resolve11, reject) => {
        if (typeof mapper !== "function") {
          throw new TypeError("Mapper function is required");
        }
        if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
        }
        const result = [];
        const errors2 = [];
        const iterator = iterable[Symbol.iterator]();
        let isRejected = false;
        let isIterableDone = false;
        let resolvingCount = 0;
        let currentIndex = 0;
        const next = () => {
          if (isRejected) {
            return;
          }
          const nextItem = iterator.next();
          const index = currentIndex;
          currentIndex++;
          if (nextItem.done) {
            isIterableDone = true;
            if (resolvingCount === 0) {
              if (!stopOnError && errors2.length !== 0) {
                reject(new AggregateError2(errors2));
              } else {
                resolve11(result);
              }
            }
            return;
          }
          resolvingCount++;
          (async () => {
            try {
              const element = await nextItem.value;
              result[index] = await mapper(element, index);
              resolvingCount--;
              next();
            } catch (error) {
              if (stopOnError) {
                isRejected = true;
                reject(error);
              } else {
                errors2.push(error);
                resolvingCount--;
                next();
              }
            }
          })();
        };
        for (let i = 0; i < concurrency; i++) {
          next();
          if (isIterableDone) {
            break;
          }
        }
      });
    };
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/peer-list/peer-distance-list.js
var require_peer_distance_list = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/peer-list/peer-distance-list.js"(exports2, module2) {
    "use strict";
    init_globals();
    var utils = require_utils7();
    var pMap = require_p_map();
    var { compare: uint8ArrayCompare } = (init_compare(), __toCommonJS(compare_exports));
    var { xor: uint8ArrayXor } = (init_xor(), __toCommonJS(xor_exports));
    var PeerDistanceList = class {
      constructor(originDhtKey, capacity) {
        this.originDhtKey = originDhtKey;
        this.capacity = capacity;
        this.peerDistances = [];
      }
      get length() {
        return this.peerDistances.length;
      }
      get peers() {
        return this.peerDistances.map((pd) => pd.peerId);
      }
      async add(peerId) {
        if (this.peerDistances.find((pd) => pd.peerId.equals(peerId))) {
          return;
        }
        const dhtKey = await utils.convertPeerId(peerId);
        const el = {
          peerId,
          distance: uint8ArrayXor(this.originDhtKey, dhtKey)
        };
        this.peerDistances.push(el);
        this.peerDistances.sort((a, b) => uint8ArrayCompare(a.distance, b.distance));
        this.peerDistances = this.peerDistances.slice(0, this.capacity);
      }
      async anyCloser(peerIds) {
        if (!peerIds.length) {
          return false;
        }
        if (!this.length) {
          return true;
        }
        const dhtKeys = await pMap(peerIds, (peerId) => utils.convertPeerId(peerId));
        const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
        for (const dhtKey of dhtKeys) {
          const keyDistance = uint8ArrayXor(this.originDhtKey, dhtKey);
          if (uint8ArrayCompare(keyDistance, furthestDistance) < 0) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = PeerDistanceList;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/peer-routing/index.js
var require_peer_routing = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/peer-routing/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errcode17 = require_err_code();
    var { validator: validator3 } = require_src7();
    var PeerId14 = require_src5();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { Message: Message2 } = require_message();
    var utils = require_utils7();
    var {
      queryErrorEvent,
      finalPeerEvent,
      valueEvent
    } = require_events2();
    var PeerDistanceList = require_peer_distance_list();
    var { Record: Record2 } = require_src7();
    var PeerRouting = class {
      constructor({ peerId, routingTable, peerStore, network, validators, queryManager, lan }) {
        this._peerId = peerId;
        this._routingTable = routingTable;
        this._peerStore = peerStore;
        this._network = network;
        this._validators = validators;
        this._queryManager = queryManager;
        this._log = utils.logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:peer-routing`);
      }
      async findPeerLocal(peer) {
        let peerData;
        const p = await this._routingTable.find(peer);
        if (p) {
          this._log("findPeerLocal found %p in routing table", peer);
          try {
            peerData = await this._peerStore.get(p);
          } catch (err) {
            if (err.code !== "ERR_NOT_FOUND") {
              throw err;
            }
          }
        }
        if (!peerData) {
          try {
            peerData = await this._peerStore.get(peer);
          } catch (err) {
            if (err.code !== "ERR_NOT_FOUND") {
              throw err;
            }
          }
        }
        if (peerData) {
          this._log("findPeerLocal found %p in peer store", peer);
          return {
            id: peerData.id,
            multiaddrs: peerData.addresses.map((address) => address.multiaddr)
          };
        }
      }
      async *_getValueSingle(peer, key, options = {}) {
        const msg = new Message2(Message2.TYPES.GET_VALUE, key, 0);
        yield* this._network.sendRequest(peer, msg, options);
      }
      async *getPublicKeyFromNode(peer, options) {
        const pkKey = utils.keyForPublicKey(peer);
        for await (const event of this._getValueSingle(peer, pkKey, options)) {
          yield event;
          if (event.name === "PEER_RESPONSE" && event.record) {
            const recPeer = await PeerId14.createFromPubKey(event.record.value);
            if (!recPeer.equals(peer)) {
              throw errcode17(new Error("public key does not match id"), "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");
            }
            yield valueEvent({ from: peer, value: recPeer.pubKey.bytes });
          }
        }
        throw errcode17(new Error(`Node not responding with its public key: ${peer.toB58String()}`), "ERR_INVALID_RECORD");
      }
      async *findPeer(id, options = {}) {
        this._log("findPeer %p", id);
        const pi = await this.findPeerLocal(id);
        if (pi != null) {
          this._log("found local");
          yield finalPeerEvent({
            from: this._peerId,
            peer: pi
          });
          return;
        }
        const key = await utils.convertPeerId(id);
        const peers = this._routingTable.closestPeers(key);
        const match = peers.find((p) => p.equals(id));
        if (match) {
          try {
            const peer = await this._peerStore.get(id);
            this._log("found in peerStore");
            yield finalPeerEvent({
              from: this._peerId,
              peer: {
                id: peer.id,
                multiaddrs: peer.addresses.map((address) => address.multiaddr)
              }
            });
            return;
          } catch (err) {
            if (err.code !== "ERR_NOT_FOUND") {
              throw err;
            }
          }
        }
        const self2 = this;
        const findPeerQuery = async function* ({ peer, signal }) {
          const request = new Message2(Message2.TYPES.FIND_NODE, id.toBytes(), 0);
          for await (const event of self2._network.sendRequest(peer, request, { signal })) {
            yield event;
            if (event.name === "PEER_RESPONSE") {
              const match2 = event.closer.find((p) => p.id.equals(id));
              if (match2) {
                yield finalPeerEvent({ from: event.from, peer: match2 });
              }
            }
          }
        };
        let foundPeer = false;
        for await (const event of this._queryManager.run(id.id, peers, findPeerQuery, options)) {
          if (event.name === "FINAL_PEER") {
            foundPeer = true;
          }
          yield event;
        }
        if (!foundPeer) {
          yield queryErrorEvent({ from: this._peerId, error: errcode17(new Error("Not found"), "ERR_NOT_FOUND") });
        }
      }
      async *getClosestPeers(key, options = {}) {
        this._log("getClosestPeers to %b", key);
        const id = await utils.convertBuffer(key);
        const tablePeers = this._routingTable.closestPeers(id);
        const self2 = this;
        const peers = new PeerDistanceList(id, this._routingTable._kBucketSize);
        tablePeers.forEach((peer) => peers.add(peer));
        const getCloserPeersQuery = async function* ({ peer, signal }) {
          self2._log("closerPeersSingle %s from %p", uint8ArrayToString(key, "base32"), peer);
          const request = new Message2(Message2.TYPES.FIND_NODE, key, 0);
          yield* self2._network.sendRequest(peer, request, { signal });
        };
        for await (const event of this._queryManager.run(key, tablePeers, getCloserPeersQuery, options)) {
          yield event;
          if (event.name === "PEER_RESPONSE") {
            event.closer.forEach((peerData) => {
              peers.add(peerData.id);
            });
          }
        }
        this._log("found %d peers close to %b", peers.length, key);
        for (const peer of peers.peers) {
          yield finalPeerEvent({
            from: this._peerId,
            peer: {
              id: peer,
              multiaddrs: (await this._peerStore.addressBook.get(peer) || []).map((addr) => addr.multiaddr)
            }
          });
        }
      }
      async *getValueOrPeers(peer, key, options = {}) {
        for await (const event of this._getValueSingle(peer, key, options)) {
          if (event.name === "PEER_RESPONSE") {
            if (event.record) {
              try {
                await this._verifyRecordOnline(event.record);
              } catch (err) {
                const errMsg = "invalid record received, discarded";
                this._log(errMsg);
                yield queryErrorEvent({ from: event.from, error: errcode17(new Error(errMsg), "ERR_INVALID_RECORD") });
                continue;
              }
            }
          }
          yield event;
        }
      }
      async _verifyRecordOnline({ key, value, timeReceived }) {
        await validator3.verifyRecord(this._validators, new Record2(key, value, timeReceived));
      }
      async getCloserPeersOffline(key, closerThan) {
        const id = await utils.convertBuffer(key);
        const ids = this._routingTable.closestPeers(id);
        const output = [];
        for (const peerId of ids) {
          if (peerId.equals(closerThan)) {
            continue;
          }
          try {
            const addresses = await this._peerStore.addressBook.get(peerId);
            output.push({
              id: peerId,
              multiaddrs: addresses.map((address) => address.multiaddr)
            });
          } catch (err) {
            if (err.code !== "ERR_NOT_FOUND") {
              throw err;
            }
          }
        }
        if (output.length) {
          this._log("getCloserPeersOffline found %d peer(s) closer to %b than %p", output.length, key, closerThan);
        } else {
          this._log("getCloserPeersOffline could not find peer closer to %b than %p", key, closerThan);
        }
        return output;
      }
    };
    module2.exports.PeerRouting = PeerRouting;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/providers.js
var require_providers = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/providers.js"(exports2, module2) {
    "use strict";
    init_globals();
    var cache2 = require_hashlru();
    var varint7 = require_varint();
    var PeerId14 = require_src5();
    var { Key: Key2 } = (init_key(), __toCommonJS(key_exports));
    var { default: Queue4 } = require_dist();
    var {
      PROVIDERS_CLEANUP_INTERVAL,
      PROVIDERS_VALIDITY,
      PROVIDERS_LRU_CACHE_SIZE,
      PROVIDER_KEY_PREFIX
    } = require_constants10();
    var utils = require_utils7();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var log48 = utils.logger("libp2p:kad-dht:providers");
    var Providers = class {
      constructor({ providers, cacheSize, cleanupInterval, provideValidity }) {
        this.datastore = providers;
        this.cleanupInterval = cleanupInterval || PROVIDERS_CLEANUP_INTERVAL;
        this.provideValidity = provideValidity || PROVIDERS_VALIDITY;
        this.cache = cache2(cacheSize || PROVIDERS_LRU_CACHE_SIZE);
        this.syncQueue = new Queue4({ concurrency: 1 });
      }
      start() {
        if (this._started) {
          return;
        }
        this._started = true;
        this._cleaner = setInterval(() => this._cleanup(), this.cleanupInterval);
      }
      stop() {
        this._started = false;
        if (this._cleaner) {
          clearInterval(this._cleaner);
          this._cleaner = null;
        }
      }
      _cleanup() {
        return this.syncQueue.add(async () => {
          const start = Date.now();
          let count = 0;
          let deleteCount = 0;
          const deleted = /* @__PURE__ */ new Map();
          const batch3 = this.datastore.batch();
          const query = this.datastore.query({ prefix: PROVIDER_KEY_PREFIX });
          for await (const entry of query) {
            try {
              const { cid, peerId } = parseProviderKey(entry.key);
              const time = readTime(entry.value);
              const now = Date.now();
              const delta = now - time;
              const expired = delta > this.provideValidity;
              log48("comparing: %d - %d = %d > %d %s", now, time, delta, this.provideValidity, expired ? "(expired)" : "");
              if (expired) {
                deleteCount++;
                batch3.delete(entry.key);
                const peers = deleted.get(cid) || /* @__PURE__ */ new Set();
                peers.add(peerId);
                deleted.set(cid, peers);
              }
              count++;
            } catch (err) {
              log48.error(err.message);
            }
          }
          if (deleted.size) {
            log48("deleting %d / %d entries", deleteCount, count);
            await batch3.commit();
          } else {
            log48("nothing to delete");
          }
          for (const [cid, peers] of deleted) {
            const key = makeProviderKey(cid);
            const provs = this.cache.get(key);
            if (provs) {
              for (const peerId of peers) {
                provs.delete(peerId);
              }
              if (provs.size === 0) {
                this.cache.remove(key);
              } else {
                this.cache.set(key, provs);
              }
            }
          }
          log48("Cleanup successful (%dms)", Date.now() - start);
        });
      }
      async _getProvidersMap(cid) {
        const cacheKey = makeProviderKey(cid);
        let provs = this.cache.get(cacheKey);
        if (!provs) {
          provs = await loadProviders(this.datastore, cid);
          this.cache.set(cacheKey, provs);
        }
        return provs;
      }
      async addProvider(cid, provider) {
        return this.syncQueue.add(async () => {
          log48("%p provides %s", provider, cid);
          const provs = await this._getProvidersMap(cid);
          log48("loaded %s provs", provs.size);
          const now = new Date();
          provs.set(provider.toString(), now);
          const dsKey = makeProviderKey(cid);
          this.cache.set(dsKey, provs);
          return writeProviderEntry(this.datastore, cid, provider, now);
        });
      }
      async getProviders(cid) {
        return this.syncQueue.add(async () => {
          log48("get providers for %s", cid);
          const provs = await this._getProvidersMap(cid);
          return [...provs.keys()].map((peerIdStr) => {
            return PeerId14.parse(peerIdStr);
          });
        });
      }
    };
    function makeProviderKey(cid) {
      cid = typeof cid === "string" ? cid : uint8ArrayToString(cid.multihash.bytes, "base32");
      return `${PROVIDER_KEY_PREFIX}/${cid}`;
    }
    async function writeProviderEntry(store, cid, peer, time) {
      const dsKey = [
        makeProviderKey(cid),
        "/",
        peer.toString()
      ].join("");
      const key = new Key2(dsKey);
      const buffer3 = Uint8Array.from(varint7.encode(time.getTime()));
      return store.put(key, buffer3);
    }
    function parseProviderKey(key) {
      const parts = key.toString().split("/");
      if (parts.length !== 5) {
        throw new Error("incorrectly formatted provider entry key in datastore: " + key);
      }
      return {
        cid: parts[3],
        peerId: parts[4]
      };
    }
    async function loadProviders(store, cid) {
      const providers = /* @__PURE__ */ new Map();
      const query = store.query({ prefix: makeProviderKey(cid) });
      for await (const entry of query) {
        const { peerId } = parseProviderKey(entry.key);
        providers.set(peerId, readTime(entry.value));
      }
      return providers;
    }
    function readTime(buf3) {
      return varint7.decode(buf3);
    }
    module2.exports.Providers = Providers;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/query/query-path.js
var require_query_path = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/query/query-path.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { default: Queue4 } = require_dist();
    var { xor: xor2 } = (init_xor(), __toCommonJS(xor_exports));
    var { toString: toString6 } = (init_to_string(), __toCommonJS(to_string_exports));
    var defer = require_p_defer();
    var errCode69 = require_err_code();
    var { convertPeerId, convertBuffer } = require_utils7();
    var { TimeoutController: TimeoutController3 } = require_timeout_abort_controller();
    var { anySignal: anySignal5 } = require_any_signal();
    var { queryErrorEvent } = require_events2();
    var MAX_XOR = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
    module2.exports.queryPath = async function* queryPath({ key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, cleanUp, queryFuncTimeout, log: log48 }) {
      const queue = new Queue4({
        concurrency: alpha
      });
      const kadId = await convertBuffer(key);
      const peersSeen = /* @__PURE__ */ new Set();
      function queryPeer(peer, peerKadId) {
        if (!peer) {
          return;
        }
        peersSeen.add(peer.toB58String());
        const peerXor = BigInt("0x" + toString6(xor2(peerKadId, kadId), "base16"));
        queue.add(async () => {
          let timeout;
          const signals = [signal];
          if (queryFuncTimeout != null) {
            timeout = new TimeoutController3(queryFuncTimeout);
            signals.push(timeout.signal);
          }
          const compoundSignal = anySignal5(signals);
          try {
            for await (const event of query({
              key,
              peer,
              signal: compoundSignal,
              pathIndex,
              numPaths
            })) {
              if (compoundSignal.aborted) {
                return;
              }
              if (event.name === "PEER_RESPONSE") {
                for (const closerPeer of event.closer) {
                  if (peersSeen.has(closerPeer.id.toB58String())) {
                    log48("already seen %p in query", closerPeer.id);
                    continue;
                  }
                  if (ourPeerId.equals(closerPeer.id)) {
                    log48("not querying ourselves");
                    continue;
                  }
                  const closerPeerKadId = await convertPeerId(closerPeer.id);
                  const closerPeerXor = BigInt("0x" + toString6(xor2(closerPeerKadId, kadId), "base16"));
                  if (closerPeerXor > peerXor) {
                    log48("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer);
                    continue;
                  }
                  log48("querying closer peer %p", closerPeer.id);
                  queryPeer(closerPeer.id, closerPeerKadId);
                }
              }
              queue.emit("completed", event);
            }
            timeout && timeout.clear();
          } catch (err) {
            if (signal.aborted) {
              queue.emit("error", err);
            } else {
              queue.emit("completed", queryErrorEvent({
                from: peer,
                error: err
              }));
            }
          } finally {
            timeout && timeout.clear();
          }
        }, {
          priority: MAX_XOR - peerXor
        });
      }
      queryPeer(startingPeer, await convertPeerId(startingPeer));
      yield* toGenerator(queue, signal, cleanUp, log48);
    };
    async function* toGenerator(queue, signal, cleanUp, log48) {
      let deferred = defer();
      let running = true;
      const results = [];
      const cleanup = () => {
        if (!running) {
          return;
        }
        log48("clean up queue, results %d, queue size %d, pending tasks %d", results.length, queue.size, queue.pending);
        running = false;
        queue.clear();
        results.splice(0, results.length);
      };
      queue.on("completed", (result) => {
        results.push(result);
        deferred.resolve();
      });
      queue.on("error", (err) => {
        log48("queue error", err);
        cleanup();
        deferred.reject(err);
      });
      queue.on("idle", () => {
        log48("queue idle");
        running = false;
        deferred.resolve();
      });
      signal.addEventListener("abort", () => {
        log48("abort queue");
        const wasRunning = running;
        cleanup();
        if (wasRunning) {
          deferred.reject(errCode69(new Error("Query aborted"), "ERR_QUERY_ABORTED"));
        }
      });
      cleanUp.on("cleanup", () => {
        cleanup();
        deferred.resolve();
      });
      while (running) {
        await deferred.promise;
        deferred = defer();
        while (results.length) {
          const result = results.shift();
          if (result) {
            yield result;
          }
        }
      }
      yield* results;
    }
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/query/manager.js
var require_manager2 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/query/manager.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { TimeoutController: TimeoutController3 } = require_timeout_abort_controller();
    var { anySignal: anySignal5 } = require_any_signal();
    var {
      ALPHA,
      K,
      DEFAULT_QUERY_TIMEOUT
    } = require_constants10();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { logger: logger2 } = require_utils7();
    var { queryPath } = require_query_path();
    var merge5 = require_it_merge();
    var {
      EventEmitter: EventEmitter4,
      setMaxListeners
    } = require_events();
    var METRIC_RUNNING_QUERIES = "running-queries";
    var QueryManager = class {
      constructor({ peerId, lan, metrics, disjointPaths = K, alpha = ALPHA }) {
        this._peerId = peerId;
        this._disjointPaths = disjointPaths || K;
        this._controllers = /* @__PURE__ */ new Set();
        this._running = false;
        this._alpha = alpha || ALPHA;
        this._lan = lan;
        this._metrics = metrics;
        this._queries = 0;
      }
      start() {
        this._running = true;
      }
      stop() {
        this._running = false;
        for (const controller of this._controllers) {
          controller.abort();
        }
        this._controllers.clear();
      }
      async *run(key, peers, queryFunc, options = {}) {
        if (!this._running) {
          throw new Error("QueryManager not started");
        }
        let timeoutController;
        if (!options.signal) {
          timeoutController = new TimeoutController3(DEFAULT_QUERY_TIMEOUT);
          options.signal = timeoutController.signal;
        }
        const abortController = new AbortController();
        this._controllers.add(abortController);
        const signals = [abortController.signal];
        options.signal && signals.push(options.signal);
        const signal = anySignal5(signals);
        try {
          setMaxListeners && setMaxListeners(0, signal);
        } catch {
        }
        const log48 = logger2(`libp2p:kad-dht:${this._lan ? "lan" : "wan"}:query:` + uint8ArrayToString(key, "base58btc"));
        const peersToQuery = peers.slice(0, Math.min(this._disjointPaths, peers.length));
        const startTime = Date.now();
        const cleanUp = new EventEmitter4();
        try {
          log48("query:start");
          this._queries++;
          this._metrics && this._metrics.updateComponentMetric({ component: `kad-dht-${this._lan ? "lan" : "wan"}`, metric: METRIC_RUNNING_QUERIES, value: this._queries });
          if (peers.length === 0) {
            log48.error("Running query with no peers");
            return;
          }
          const paths = peersToQuery.map((peer, index) => {
            return queryPath({
              key,
              startingPeer: peer,
              ourPeerId: this._peerId,
              signal,
              query: queryFunc,
              pathIndex: index,
              numPaths: peersToQuery.length,
              alpha: this._alpha,
              cleanUp,
              queryFuncTimeout: options.queryFuncTimeout,
              log: log48
            });
          });
          for await (const event of merge5(...paths)) {
            yield event;
            if (event.name === "QUERY_ERROR" && event.error) {
              log48("error", event.error);
            }
          }
        } catch (err) {
          if (!this._running && err.code === "ERR_QUERY_ABORTED") {
          } else {
            throw err;
          }
        } finally {
          this._controllers.delete(abortController);
          if (timeoutController) {
            timeoutController.clear();
          }
          this._queries--;
          this._metrics && this._metrics.updateComponentMetric({ component: `kad-dht-${this._lan ? "lan" : "wan"}`, metric: METRIC_RUNNING_QUERIES, value: this._queries });
          cleanUp.emit("cleanup");
          log48(`query:done in ${Date.now() - (startTime || 0)}ms`);
        }
      }
    };
    module2.exports.QueryManager = QueryManager;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js
var require_add_provider = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { CID: CID3 } = (init_cid(), __toCommonJS(cid_exports));
    var errcode17 = require_err_code();
    var utils = require_utils7();
    var log48 = utils.logger("libp2p:kad-dht:rpc:handlers:add-provider");
    var AddProviderHandler = class {
      constructor({ peerId, providers, peerStore }) {
        this._peerId = peerId;
        this._providers = providers;
        this._peerStore = peerStore;
      }
      async handle(peerId, msg) {
        log48("start");
        if (!msg.key || msg.key.length === 0) {
          throw errcode17(new Error("Missing key"), "ERR_MISSING_KEY");
        }
        let cid;
        try {
          cid = CID3.decode(msg.key);
        } catch (err) {
          const errMsg = `Invalid CID: ${err.message}`;
          throw errcode17(new Error(errMsg), "ERR_INVALID_CID");
        }
        if (!msg.providerPeers || !msg.providerPeers.length) {
          log48.error("no providers found in message");
        }
        await Promise.all(msg.providerPeers.map(async (pi) => {
          if (!pi.id.equals(peerId)) {
            log48("invalid provider peer %p from %p", pi.id, peerId);
            return;
          }
          if (pi.multiaddrs.length < 1) {
            log48("no valid addresses for provider %p. Ignore", peerId);
            return;
          }
          log48("received provider %p for %s (addrs %s)", peerId, cid, pi.multiaddrs.map((m) => m.toString()));
          if (!this._peerId.equals(pi.id)) {
            await this._peerStore.addressBook.add(pi.id, pi.multiaddrs);
            await this._providers.addProvider(cid, pi.id);
          }
        }));
        return void 0;
      }
    };
    module2.exports.AddProviderHandler = AddProviderHandler;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/find-node.js
var require_find_node = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/find-node.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Message: Message2 } = require_message();
    var utils = require_utils7();
    var log48 = utils.logger("libp2p:kad-dht:rpc:handlers:find-node");
    var {
      removePrivateAddresses,
      removePublicAddresses
    } = require_utils7();
    var FindNodeHandler = class {
      constructor({ peerId, addressable, peerRouting, lan }) {
        this._peerId = peerId;
        this._addressable = addressable;
        this._peerRouting = peerRouting;
        this._lan = Boolean(lan);
      }
      async handle(peerId, msg) {
        log48("incoming request from %p for peers closer to %b", peerId, msg.key);
        let closer;
        if (this._peerId.equals(msg.key)) {
          closer = [{
            id: this._peerId,
            multiaddrs: this._addressable.multiaddrs
          }];
        } else {
          closer = await this._peerRouting.getCloserPeersOffline(msg.key, peerId);
        }
        closer = closer.map(this._lan ? removePublicAddresses : removePrivateAddresses).filter(({ multiaddrs }) => multiaddrs.length);
        const response = new Message2(msg.type, new Uint8Array(0), msg.clusterLevel);
        if (closer.length > 0) {
          response.closerPeers = closer;
        } else {
          log48("could not find any peers closer to %p", peerId);
        }
        return response;
      }
    };
    module2.exports.FindNodeHandler = FindNodeHandler;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js
var require_get_providers = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { CID: CID3 } = (init_cid(), __toCommonJS(cid_exports));
    var errcode17 = require_err_code();
    var { Message: Message2 } = require_message();
    var utils = require_utils7();
    var log48 = utils.logger("libp2p:kad-dht:rpc:handlers:get-providers");
    var {
      removePrivateAddresses,
      removePublicAddresses
    } = require_utils7();
    var GetProvidersHandler = class {
      constructor({ peerId, peerRouting, providers, peerStore, addressable, lan }) {
        this._peerId = peerId;
        this._peerRouting = peerRouting;
        this._providers = providers;
        this._peerStore = peerStore;
        this._addressable = addressable;
        this._lan = Boolean(lan);
      }
      async handle(peerId, msg) {
        let cid;
        try {
          cid = CID3.decode(msg.key);
        } catch (err) {
          throw errcode17(new Error(`Invalid CID: ${err.message}`), "ERR_INVALID_CID");
        }
        log48("%p asking for providers for %s", peerId, cid);
        const [peers, closer] = await Promise.all([
          this._providers.getProviders(cid),
          this._peerRouting.getCloserPeersOffline(msg.key, peerId)
        ]);
        const providerPeers = await this._getPeers(peers);
        const closerPeers = await this._getPeers(closer.map(({ id }) => id));
        const response = new Message2(msg.type, msg.key, msg.clusterLevel);
        if (providerPeers.length > 0) {
          response.providerPeers = providerPeers;
        }
        if (closerPeers.length > 0) {
          response.closerPeers = closerPeers;
        }
        log48("got %s providers %s closerPeers", providerPeers.length, closerPeers.length);
        return response;
      }
      async _getAddresses(peerId) {
        return this._peerId.equals(peerId) ? this._addressable.multiaddrs : (await this._peerStore.addressBook.get(peerId) || []).map((address) => address.multiaddr);
      }
      async _getPeers(peerIds) {
        const output = [];
        const addrFilter = this._lan ? removePublicAddresses : removePrivateAddresses;
        for (const peerId of peerIds) {
          const peer = addrFilter({
            id: peerId,
            multiaddrs: await this._getAddresses(peerId)
          });
          if (peer.multiaddrs.length) {
            output.push(peer);
          }
        }
        return output;
      }
    };
    module2.exports.GetProvidersHandler = GetProvidersHandler;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/get-value.js
var require_get_value = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/get-value.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Record: Record2 } = require_src7();
    var errcode17 = require_err_code();
    var { Message: Message2 } = require_message();
    var {
      MAX_RECORD_AGE
    } = require_constants10();
    var utils = require_utils7();
    var log48 = utils.logger("libp2p:kad-dht:rpc:handlers:get-value");
    var GetValueHandler = class {
      constructor({ peerId, peerStore, peerRouting, records }) {
        this._peerId = peerId;
        this._peerStore = peerStore;
        this._peerRouting = peerRouting;
        this._records = records;
      }
      async handle(peerId, msg) {
        const key = msg.key;
        log48("%p asked for key %b", peerId, key);
        if (!key || key.length === 0) {
          throw errcode17(new Error("Invalid key"), "ERR_INVALID_KEY");
        }
        const response = new Message2(Message2.TYPES.GET_VALUE, key, msg.clusterLevel);
        if (utils.isPublicKeyKey(key)) {
          log48("is public key");
          const idFromKey = utils.fromPublicKeyKey(key);
          let pubKey;
          if (this._peerId.equals(idFromKey)) {
            pubKey = this._peerId.pubKey;
          } else {
            try {
              pubKey = await this._peerStore.keyBook.get(idFromKey);
            } catch (err) {
              if (err.code !== "ERR_NOT_FOUND") {
                throw err;
              }
            }
          }
          if (pubKey != null) {
            log48("returning found public key");
            response.record = new Record2(key, pubKey.bytes);
            return response;
          }
        }
        const [record, closer] = await Promise.all([
          this._checkLocalDatastore(key),
          this._peerRouting.getCloserPeersOffline(msg.key, peerId)
        ]);
        if (record) {
          log48("had record for %b in local datastore", key);
          response.record = record;
        }
        if (closer.length > 0) {
          log48("had %s closer peers in routing table", closer.length);
          response.closerPeers = closer;
        }
        return response;
      }
      async _checkLocalDatastore(key) {
        log48("checkLocalDatastore looking for %b", key);
        const dsKey = utils.bufferToKey(key);
        let rawRecord;
        try {
          rawRecord = await this._records.get(dsKey);
        } catch (err) {
          if (err.code === "ERR_NOT_FOUND") {
            return void 0;
          }
          throw err;
        }
        const record = Record2.deserialize(rawRecord);
        if (!record) {
          throw errcode17(new Error("Invalid record"), "ERR_INVALID_RECORD");
        }
        if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {
          await this._records.delete(dsKey);
          return void 0;
        }
        return record;
      }
    };
    module2.exports.GetValueHandler = GetValueHandler;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/ping.js
var require_ping = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/ping.js"(exports2, module2) {
    "use strict";
    init_globals();
    var utils = require_utils7();
    var log48 = utils.logger("libp2p:kad-dht:rpc:handlers:ping");
    var PingHandler = class {
      async handle(peerId, msg) {
        log48(`ping from ${peerId}`);
        return msg;
      }
    };
    module2.exports.PingHandler = PingHandler;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/put-value.js
var require_put_value = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/put-value.js"(exports2, module2) {
    "use strict";
    init_globals();
    var utils = require_utils7();
    var errcode17 = require_err_code();
    var Libp2pRecord = require_src7();
    var log48 = utils.logger("libp2p:kad-dht:rpc:handlers:put-value");
    var PutValueHandler = class {
      constructor({ validators, records }) {
        this._validators = validators;
        this._records = records;
      }
      async handle(peerId, msg) {
        const key = msg.key;
        log48("%p asked to store value for key %b", peerId, key);
        const record = msg.record;
        if (!record) {
          const errMsg = `Empty record from: ${peerId.toB58String()}`;
          log48.error(errMsg);
          throw errcode17(new Error(errMsg), "ERR_EMPTY_RECORD");
        }
        await Libp2pRecord.validator.verifyRecord(this._validators, record);
        record.timeReceived = new Date();
        const recordKey = utils.bufferToKey(record.key);
        await this._records.put(recordKey, record.serialize());
        return msg;
      }
    };
    module2.exports.PutValueHandler = PutValueHandler;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/index.js
var require_handlers = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/handlers/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Message: Message2 } = require_message();
    var { AddProviderHandler } = require_add_provider();
    var { FindNodeHandler } = require_find_node();
    var { GetProvidersHandler } = require_get_providers();
    var { GetValueHandler } = require_get_value();
    var { PingHandler } = require_ping();
    var { PutValueHandler } = require_put_value();
    module2.exports = ({ peerId, providers, peerStore, addressable, peerRouting, records, validators, lan }) => {
      const handlers = {
        [Message2.TYPES.GET_VALUE]: new GetValueHandler({ peerId, peerStore, peerRouting, records }),
        [Message2.TYPES.PUT_VALUE]: new PutValueHandler({ validators, records }),
        [Message2.TYPES.FIND_NODE]: new FindNodeHandler({ peerId, addressable, peerRouting, lan }),
        [Message2.TYPES.ADD_PROVIDER]: new AddProviderHandler({ peerId, providers, peerStore }),
        [Message2.TYPES.GET_PROVIDERS]: new GetProvidersHandler({ peerId, peerRouting, providers, peerStore, addressable, lan }),
        [Message2.TYPES.PING]: new PingHandler()
      };
      function getMessageHandler(type) {
        return handlers[type];
      }
      return getMessageHandler;
    };
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/index.js
var require_rpc4 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/rpc/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { pipe: pipe8 } = require_it_pipe();
    var lp2 = require_src11();
    var { Message: Message2, MESSAGE_TYPE_LOOKUP } = require_message();
    var handlers = require_handlers();
    var utils = require_utils7();
    var log48 = utils.logger("libp2p:kad-dht:rpc");
    var RPC = class {
      constructor(params) {
        this._messageHandler = handlers(params);
        this._routingTable = params.routingTable;
      }
      async handleMessage(peerId, msg) {
        const handler = this._messageHandler(msg.type);
        try {
          await this._routingTable.add(peerId);
        } catch (err) {
          log48.error("Failed to update the kbucket store", err);
        }
        if (!handler) {
          log48.error(`no handler found for message type: ${msg.type}`);
          return;
        }
        return handler.handle(peerId, msg);
      }
      async onIncomingStream({ stream, connection }) {
        const peerId = connection.remotePeer;
        try {
          await this._routingTable.add(peerId);
        } catch (err) {
          log48.error(err);
        }
        const self2 = this;
        await pipe8(stream.source, lp2.decode(), (source) => async function* () {
          for await (const msg of source) {
            const desMessage = Message2.deserialize(msg.slice());
            log48("incoming %s from %p", MESSAGE_TYPE_LOOKUP[desMessage.type], peerId);
            const res = await self2.handleMessage(peerId, desMessage);
            if (res) {
              yield res.serialize();
            }
          }
        }(), lp2.encode(), stream.sink);
      }
    };
    module2.exports.RPC = RPC;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/topology-listener.js
var require_topology_listener = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/topology-listener.js"(exports2, module2) {
    "use strict";
    init_globals();
    var MulticodecTopology2 = require_multicodec_topology();
    var { EventEmitter: EventEmitter4 } = require_events();
    var utils = require_utils7();
    var TopologyListener = class extends EventEmitter4 {
      constructor({ registrar, protocol, lan }) {
        super();
        this._log = utils.logger(`libp2p:kad-dht:topology-listener:${lan ? "lan" : "wan"}:network`);
        this._running = false;
        this._registrar = registrar;
        this._protocol = protocol;
      }
      async start() {
        if (this._running) {
          return;
        }
        this._running = true;
        const topology = new MulticodecTopology2({
          multicodecs: [this._protocol],
          handlers: {
            onConnect: (peerId) => {
              this._log("observed peer that with protocol %s %p", this._protocol, peerId);
              this.emit("peer", peerId);
            },
            onDisconnect: () => {
            }
          }
        });
        this._registrarId = await this._registrar.register(topology);
      }
      stop() {
        this._running = false;
        if (this._registrarId) {
          this._registrar.unregister(this._registrarId);
        }
      }
    };
    module2.exports.TopologyListener = TopologyListener;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/query-self.js
var require_query_self = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/query-self.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { EventEmitter: EventEmitter4 } = require_events();
    var take5 = require_it_take();
    var length5 = require_it_length();
    var { QUERY_SELF_INTERVAL, QUERY_SELF_TIMEOUT, K } = require_constants10();
    var utils = require_utils7();
    var { TimeoutController: TimeoutController3 } = require_timeout_abort_controller();
    var { anySignal: anySignal5 } = require_any_signal();
    var { setMaxListeners } = require_events();
    var QuerySelf = class extends EventEmitter4 {
      constructor({ peerId, peerRouting, lan, count = K, interval = QUERY_SELF_INTERVAL, queryTimeout = QUERY_SELF_TIMEOUT }) {
        super();
        this._log = utils.logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}:query-self`);
        this._running = false;
        this._peerId = peerId;
        this._peerRouting = peerRouting;
        this._count = count || K;
        this._interval = interval || QUERY_SELF_INTERVAL;
        this._queryTimeout = queryTimeout || QUERY_SELF_TIMEOUT;
      }
      start() {
        if (this._running) {
          return;
        }
        this._running = true;
        this._querySelf();
      }
      stop() {
        this._running = false;
        if (this._timeoutId) {
          clearTimeout(this._timeoutId);
        }
        if (this._controller) {
          this._controller.abort();
        }
      }
      async _querySelf() {
        const timeoutController = new TimeoutController3(this._queryTimeout);
        try {
          this._controller = new AbortController();
          const signal = anySignal5([this._controller.signal, timeoutController.signal]);
          try {
            setMaxListeners && setMaxListeners(Infinity, signal);
          } catch {
          }
          const found = await length5(await take5(this._peerRouting.getClosestPeers(this._peerId.toBytes(), {
            signal
          }), this._count));
          this._log("query ran successfully - found %d peers", found);
        } catch (err) {
          this._log("query error", err);
        } finally {
          this._timeoutId = setTimeout(this._querySelf.bind(this), this._interval);
          timeoutController.clear();
        }
      }
    };
    module2.exports.QuerySelf = QuerySelf;
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/kad-dht.js
var require_kad_dht = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/kad-dht.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { EventEmitter: EventEmitter4 } = require_events();
    var crypto6 = require_src6();
    var libp2pRecord = require_src7();
    var { MemoryDatastore: MemoryDatastore2 } = (init_memory(), __toCommonJS(memory_exports));
    var { RoutingTable } = require_routing_table();
    var { RoutingTableRefresh } = require_refresh();
    var utils = require_utils7();
    var {
      K,
      QUERY_SELF_INTERVAL,
      RECORD_KEY_PREFIX
    } = require_constants10();
    var { Network: Network3 } = require_network();
    var { ContentFetching } = require_content_fetching();
    var { ContentRouting } = require_content_routing();
    var { PeerRouting } = require_peer_routing();
    var { Providers } = require_providers();
    var { QueryManager } = require_manager2();
    var { RPC } = require_rpc4();
    var { TopologyListener } = require_topology_listener();
    var { QuerySelf } = require_query_self();
    var {
      removePrivateAddresses,
      removePublicAddresses
    } = require_utils7();
    var { KeyTransformDatastore: KeyTransformDatastore2 } = (init_src3(), __toCommonJS(src_exports4));
    var { Key: Key2 } = (init_key(), __toCommonJS(key_exports));
    var PrefixTransform = class {
      constructor(prefix) {
        this._prefix = prefix;
        if (this._prefix.startsWith("/")) {
          this._prefix = this._prefix.substring(1);
        }
      }
      convert(key) {
        return new Key2(`/${this._prefix}${key}`);
      }
      invert(key) {
        const namespaces = key.namespaces();
        if (namespaces[0] === this._prefix) {
          namespaces.shift();
        }
        return Key2.withNamespaces(namespaces);
      }
    };
    var KadDHT2 = class extends EventEmitter4 {
      constructor({
        libp2p,
        kBucketSize = K,
        clientMode = true,
        validators = {},
        selectors = {},
        querySelfInterval = QUERY_SELF_INTERVAL,
        lan = true,
        protocol = "/ipfs/lan/kad/1.0.0",
        bootstrapPeers = []
      }) {
        super();
        this._running = false;
        this._log = utils.logger(`libp2p:kad-dht:${lan ? "lan" : "wan"}`);
        this._libp2p = libp2p;
        this._protocol = protocol;
        this._kBucketSize = kBucketSize;
        this._clientMode = clientMode;
        this._bootstrapPeers = bootstrapPeers;
        this._routingTable = new RoutingTable({
          peerId: libp2p.peerId,
          dialer: libp2p,
          kBucketSize,
          metrics: libp2p.metrics,
          lan
        });
        const datastore = libp2p.datastore || new MemoryDatastore2();
        const records = new KeyTransformDatastore2(datastore, new PrefixTransform(RECORD_KEY_PREFIX));
        this._providers = new Providers({
          providers: datastore
        });
        this._lan = lan;
        this._validators = {
          pk: libp2pRecord.validator.validators.pk,
          ...validators
        };
        this._selectors = {
          pk: libp2pRecord.selection.selectors.pk,
          ...selectors
        };
        this._network = new Network3({
          dialer: libp2p,
          protocol: this._protocol,
          lan
        });
        this._queryManager = new QueryManager({
          peerId: libp2p.peerId,
          disjointPaths: Math.ceil(kBucketSize / 2),
          metrics: libp2p.metrics,
          lan
        });
        this._peerRouting = new PeerRouting({
          peerId: libp2p.peerId,
          routingTable: this._routingTable,
          peerStore: libp2p.peerStore,
          network: this._network,
          validators: this._validators,
          queryManager: this._queryManager,
          lan
        });
        this._contentFetching = new ContentFetching({
          peerId: libp2p.peerId,
          records,
          validators: this._validators,
          selectors: this._selectors,
          peerRouting: this._peerRouting,
          queryManager: this._queryManager,
          routingTable: this._routingTable,
          network: this._network,
          lan
        });
        this._contentRouting = new ContentRouting({
          peerId: libp2p.peerId,
          network: this._network,
          peerRouting: this._peerRouting,
          queryManager: this._queryManager,
          routingTable: this._routingTable,
          providers: this._providers,
          peerStore: libp2p.peerStore,
          lan
        });
        this._routingTableRefresh = new RoutingTableRefresh({
          peerRouting: this._peerRouting,
          routingTable: this._routingTable,
          lan
        });
        this._rpc = new RPC({
          routingTable: this._routingTable,
          peerId: libp2p.peerId,
          providers: this._providers,
          peerStore: libp2p.peerStore,
          addressable: libp2p,
          peerRouting: this._peerRouting,
          records,
          validators: this._validators,
          lan
        });
        this._topologyListener = new TopologyListener({
          registrar: libp2p.registrar,
          protocol: this._protocol,
          lan
        });
        this._querySelf = new QuerySelf({
          peerId: libp2p.peerId,
          peerRouting: this._peerRouting,
          interval: querySelfInterval,
          lan
        });
        this._network.on("peer", (peerData) => {
          this.onPeerConnect(peerData).catch((err) => {
            this._log.error(`could not add ${peerData.id} to routing table`, err);
          });
          this.emit("peer", peerData);
        });
        this._topologyListener.on("peer", async (peerId) => {
          const multiaddrs = await this._libp2p.peerStore.addressBook.get(peerId);
          const peerData = {
            id: peerId,
            multiaddrs: multiaddrs.map((addr) => addr.multiaddr)
          };
          this.onPeerConnect(peerData).catch((err) => {
            this._log.error(`could not add ${peerData.id} to routing table`, err);
          });
        });
      }
      async onPeerConnect(peerData) {
        this._log("peer %p connected", peerData.id);
        if (this._lan) {
          peerData = removePublicAddresses(peerData);
        } else {
          peerData = removePrivateAddresses(peerData);
        }
        if (!peerData.multiaddrs.length) {
          this._log("ignoring %p as they do not have any %s addresses in %s", peerData.id, this._lan ? "private" : "public", peerData.multiaddrs.map((addr) => addr.toString()));
          return;
        }
        try {
          await this._routingTable.add(peerData.id);
        } catch (err) {
          this._log.error("could not add %p to routing table", peerData.id, err);
        }
      }
      isStarted() {
        return this._running;
      }
      isServer() {
        return !this._clientMode;
      }
      async enableServerMode() {
        this._log("enabling server mode");
        this._clientMode = false;
        await this._libp2p.handle(this._protocol, this._rpc.onIncomingStream.bind(this._rpc));
      }
      async enableClientMode() {
        this._log("enabling client mode");
        this._clientMode = true;
        await this._libp2p.unhandle(this._protocol);
      }
      async start() {
        this._running = true;
        if (this._clientMode) {
          await this.enableClientMode();
        } else {
          await this.enableServerMode();
        }
        await Promise.all([
          this._providers.start(),
          this._queryManager.start(),
          this._network.start(),
          this._routingTable.start(),
          this._topologyListener.start(),
          this._querySelf.start()
        ]);
        await Promise.all(this._bootstrapPeers.map((peerData) => this._routingTable.add(peerData.id)));
        await this._routingTableRefresh.start();
        await this.refreshRoutingTable();
      }
      async stop() {
        this._running = false;
        await Promise.all([
          this._providers.stop(),
          this._queryManager.stop(),
          this._network.stop(),
          this._routingTable.stop(),
          this._routingTableRefresh.stop(),
          this._topologyListener.stop(),
          this._querySelf.stop()
        ]);
      }
      async *put(key, value, options = {}) {
        yield* this._contentFetching.put(key, value, options);
      }
      async *get(key, options = {}) {
        yield* this._contentFetching.get(key, options);
      }
      async *provide(key, options = {}) {
        yield* this._contentRouting.provide(key, this._libp2p.multiaddrs, options);
      }
      async *findProviders(key, options = { maxNumProviders: 5 }) {
        yield* this._contentRouting.findProviders(key, options);
      }
      async *findPeer(id, options = {}) {
        yield* this._peerRouting.findPeer(id, options);
      }
      async *getClosestPeers(key, options = {}) {
        yield* this._peerRouting.getClosestPeers(key, options);
      }
      async getPublicKey(peer, options = {}) {
        this._log("getPublicKey %p", peer);
        for await (const event of this._peerRouting.getPublicKeyFromNode(peer, options)) {
          if (event.name === "VALUE") {
            return crypto6.keys.unmarshalPublicKey(event.value);
          }
        }
        const pkKey = utils.keyForPublicKey(peer);
        for await (const event of this.get(pkKey, options)) {
          if (event.name === "VALUE") {
            return crypto6.keys.unmarshalPublicKey(event.value);
          }
        }
      }
      async refreshRoutingTable() {
        await this._routingTableRefresh.refreshTable(true);
      }
    };
    module2.exports = {
      KadDHT: KadDHT2
    };
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/dual-kad-dht.js
var require_dual_kad_dht = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/dual-kad-dht.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { EventEmitter: EventEmitter4 } = require_events();
    var PeerId14 = require_src5();
    var utils = require_utils7();
    var errCode69 = require_err_code();
    var merge5 = require_it_merge();
    var { queryErrorEvent } = require_events2();
    var log48 = utils.logger("libp2p:kad-dht");
    var DualKadDHT = class extends EventEmitter4 {
      constructor(wan, lan, libp2p) {
        super();
        this._wan = wan;
        this._lan = lan;
        this._libp2p = libp2p;
        this._wan.on("peer", (peerData) => {
          this.emit("peer", peerData);
        });
        this._lan.on("peer", (peerData) => {
          this.emit("peer", peerData);
        });
      }
      isStarted() {
        return this._wan.isStarted() && this._lan.isStarted();
      }
      async enableServerMode() {
        await this._wan.enableServerMode();
      }
      async enableClientMode() {
        await this._wan.enableClientMode();
      }
      async start() {
        await Promise.all([
          this._lan.start(),
          this._wan.start()
        ]);
      }
      async stop() {
        await Promise.all([
          this._lan.stop(),
          this._wan.stop()
        ]);
      }
      async *put(key, value, options = {}) {
        let counterAll = 0;
        let counterSuccess = 0;
        for await (const event of merge5(this._lan.put(key, value, options), this._wan.put(key, value, options))) {
          yield event;
          if (event.name === "SENDING_QUERY" && event.messageName === "PUT_VALUE") {
            counterAll++;
          }
          if (event.name === "PEER_RESPONSE" && event.messageName === "PUT_VALUE") {
            counterSuccess++;
          }
        }
        const minPeers = options.minPeers == null ? counterAll || 1 : options.minPeers;
        if (counterSuccess < minPeers) {
          const error = errCode69(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), "ERR_NOT_ENOUGH_PUT_PEERS");
          log48.error(error);
          throw error;
        }
      }
      async *get(key, options = {}) {
        let queriedPeers = false;
        let foundValue = false;
        for await (const event of merge5(this._lan.get(key, options), this._wan.get(key, options))) {
          yield event;
          if (event.name === "DIALING_PEER") {
            queriedPeers = true;
          }
          if (event.name === "VALUE") {
            queriedPeers = true;
            if (event.value != null) {
              foundValue = true;
            }
          }
          if (event.name === "SENDING_QUERY") {
            queriedPeers = true;
          }
        }
        if (!queriedPeers) {
          throw errCode69(new Error("No peers found in routing table!"), "ERR_NO_PEERS_IN_ROUTING_TABLE");
        }
        if (!foundValue) {
          yield queryErrorEvent({
            from: this._libp2p.peerId,
            error: errCode69(new Error("Not found"), "ERR_NOT_FOUND")
          });
        }
      }
      async *provide(key, options = {}) {
        let sent = 0;
        let success = 0;
        const errors2 = [];
        const dhts = [this._lan];
        if (this._wan.isServer()) {
          dhts.push(this._wan);
        }
        for await (const event of merge5(...dhts.map((dht) => dht.provide(key, options)))) {
          yield event;
          if (event.name === "SENDING_QUERY") {
            sent++;
          }
          if (event.name === "QUERY_ERROR") {
            errors2.push(event.error);
          }
          if (event.name === "PEER_RESPONSE" && event.messageName === "ADD_PROVIDER") {
            log48("sent provider record for %s to %p", key, event.from.id);
            success++;
          }
        }
        if (success === 0) {
          if (errors2.length) {
            throw errCode69(new Error(`Failed to provide to ${errors2.length} of ${sent} peers`), "ERR_PROVIDES_FAILED", { errors: errors2 });
          }
          throw errCode69(new Error("Failed to provide - no peers found"), "ERR_PROVIDES_FAILED");
        }
      }
      async *findProviders(key, options = { maxNumProviders: 5 }) {
        yield* merge5(this._lan.findProviders(key, options), this._wan.findProviders(key, options));
      }
      async *findPeer(id, options = {}) {
        let queriedPeers = false;
        for await (const event of merge5(this._lan.findPeer(id, options), this._wan.findPeer(id, options))) {
          yield event;
          if (event.name === "SENDING_QUERY" || event.name === "FINAL_PEER") {
            queriedPeers = true;
          }
        }
        if (!queriedPeers) {
          throw errCode69(new Error("Peer lookup failed"), "ERR_LOOKUP_FAILED");
        }
      }
      async *getClosestPeers(key, options = {}) {
        yield* merge5(this._lan.getClosestPeers(key, options), this._wan.getClosestPeers(key, options));
      }
      async getPublicKey(peer, options = {}) {
        log48("getPublicKey %p", peer);
        let peerData;
        try {
          peerData = await this._libp2p.peerStore.get(peer);
          if (peerData.pubKey) {
            log48("getPublicKey: found local copy");
            return peerData.pubKey;
          }
          if (peerData.id.pubKey) {
            log48("getPublicKey: found local copy");
            return peerData.id.pubKey;
          }
        } catch (err) {
          if (err.code !== "ERR_NOT_FOUND") {
            throw err;
          }
        }
        const pks = await Promise.all([
          this._lan.getPublicKey(peer, options),
          this._wan.getPublicKey(peer, options)
        ]);
        if (pks[0] && pks[1] && !pks[0].equals(pks[1])) {
          throw errCode69(new Error("Inconsistent public key loaded from wan and lan DHTs"), "ERR_FAILED_TO_LOAD_KEY");
        }
        const pk = pks[0] || pks[1];
        if (!pk) {
          throw errCode69(new Error("Failed to load public key"), "ERR_FAILED_TO_LOAD_KEY");
        }
        const peerId = new PeerId14(peer.id, void 0, pk);
        const addrs = (peerData && peerData.addresses || []).map((address) => address.multiaddr);
        await this._libp2p.peerStore.addressBook.add(peerId, addrs);
        await this._libp2p.peerStore.keyBook.set(peerId, pk);
        return pk;
      }
      async refreshRoutingTable() {
        await Promise.all([
          this._lan.refreshRoutingTable(),
          this._wan.refreshRoutingTable()
        ]);
      }
    };
    module2.exports = {
      DualKadDHT
    };
  }
});

// node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/index.js
var require_src21 = __commonJS({
  "node_modules/ipfs-core-config/node_modules/libp2p-kad-dht/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { KadDHT: KadDHT2 } = require_kad_dht();
    var { DualKadDHT } = require_dual_kad_dht();
    module2.exports = {
      create: (opts) => {
        return new DualKadDHT(new KadDHT2({
          ...opts,
          protocol: "/ipfs/kad/1.0.0",
          lan: false
        }), new KadDHT2({
          ...opts,
          protocol: "/ipfs/lan/kad/1.0.0",
          clientMode: false,
          lan: true
        }), opts.libp2p);
      }
    };
  }
});

// node_modules/libp2p-bootstrap/src/index.js
var require_src22 = __commonJS({
  "node_modules/libp2p-bootstrap/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var PeerId14 = require_src5();
    var { Multiaddr: Multiaddr22 } = require_src();
    var mafmt2 = require_src2();
    var { EventEmitter: EventEmitter4 } = require_events();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:bootstrap"), {
      error: debug50("libp2p:bootstrap:error")
    });
    var Bootstrap = class extends EventEmitter4 {
      constructor(options = { list: [] }) {
        if (!options.list || !options.list.length) {
          throw new Error("Bootstrap requires a list of peer addresses");
        }
        super();
        this._list = options.list;
        this._interval = options.interval || 1e4;
        this._timer = null;
      }
      start() {
        if (this._timer) {
          return;
        }
        this._timer = setInterval(() => this._discoverBootstrapPeers(), this._interval);
        log48("Starting bootstrap node discovery");
        this._discoverBootstrapPeers();
      }
      _discoverBootstrapPeers() {
        if (!this._timer) {
          return;
        }
        this._list.forEach((candidate) => {
          if (!mafmt2.P2P.matches(candidate)) {
            return log48.error("Invalid multiaddr");
          }
          const ma = new Multiaddr22(candidate);
          const peerIdStr = ma.getPeerId();
          if (!peerIdStr) {
            log48.error("Invalid bootstrap multiaddr without peer id");
            return;
          }
          const peerId = PeerId14.createFromB58String(peerIdStr);
          try {
            this.emit("peer", {
              id: peerId,
              multiaddrs: [ma]
            });
          } catch (err) {
            log48.error("Invalid bootstrap peer id", err);
          }
        });
      }
      stop() {
        if (this._timer)
          clearInterval(this._timer);
        this._timer = null;
      }
    };
    exports2 = module2.exports = Bootstrap;
    exports2.tag = "bootstrap";
  }
});

// node_modules/libp2p/src/content-routing/utils.js
var require_utils8 = __commonJS({
  "node_modules/libp2p/src/content-routing/utils.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errCode69 = require_err_code();
    var filter10 = require_it_filter();
    var map12 = require_it_map();
    var take5 = require_it_take();
    async function* storeAddresses(source, peerStore) {
      yield* map12(source, async (peer) => {
        await peerStore.addressBook.add(peer.id, peer.multiaddrs);
        return peer;
      });
    }
    function uniquePeers(source) {
      const seen = /* @__PURE__ */ new Set();
      return filter10(source, (peer) => {
        if (seen.has(peer.id.toString())) {
          return false;
        }
        seen.add(peer.id.toString());
        return true;
      });
    }
    async function* requirePeers(source, min = 1) {
      let seen = 0;
      for await (const peer of source) {
        seen++;
        yield peer;
      }
      if (seen < min) {
        throw errCode69(new Error("not found"), "NOT_FOUND");
      }
    }
    function maybeLimitSource(source, max) {
      if (max) {
        return take5(source, max);
      }
      return source;
    }
    module2.exports = {
      storeAddresses,
      uniquePeers,
      requirePeers,
      maybeLimitSource
    };
  }
});

// node_modules/set-delayed-interval/src/index.js
var require_src23 = __commonJS({
  "node_modules/set-delayed-interval/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var intervals = /* @__PURE__ */ new Map();
    var _generateId = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`;
    async function _runPeriodically(task, interval, id) {
      while (intervals.get(id)) {
        try {
          await task();
        } catch (err) {
          setTimeout(() => {
            throw err;
          }, 1);
          break;
        }
        if (!intervals.get(id)) {
          break;
        }
        await new Promise((resolve11) => {
          const _timeout = setTimeout(resolve11, interval);
          intervals.set(id, _timeout);
        });
      }
    }
    function setDelayedInterval(task, interval, delay) {
      delay = delay || interval;
      const id = _generateId();
      const _timeout = setTimeout(() => {
        _runPeriodically(task, interval, id);
      }, delay);
      intervals.set(id, _timeout);
      return id;
    }
    function clearDelayedInterval(id) {
      const _timeout = intervals.get(id);
      if (_timeout) {
        clearTimeout(_timeout);
        intervals.delete(id);
      }
    }
    module2.exports = {
      setDelayedInterval,
      clearDelayedInterval
    };
  }
});

// node_modules/libp2p/src/dht/dht-peer-routing.js
var require_dht_peer_routing = __commonJS({
  "node_modules/libp2p/src/dht/dht-peer-routing.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errCode69 = require_err_code();
    var { messages, codes } = require_errors3();
    var DHTPeerRouting = class {
      constructor(dht) {
        this._dht = dht;
      }
      async findPeer(peerId, options = {}) {
        for await (const event of this._dht.findPeer(peerId, options)) {
          if (event.name === "FINAL_PEER") {
            return event.peer;
          }
        }
        throw errCode69(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
      }
      async *getClosestPeers(key, options = {}) {
        for await (const event of this._dht.getClosestPeers(key, options)) {
          if (event.name === "PEER_RESPONSE") {
            yield* event.closer;
          }
        }
      }
    };
    module2.exports = { DHTPeerRouting };
  }
});

// node_modules/libp2p/src/peer-routing.js
var require_peer_routing2 = __commonJS({
  "node_modules/libp2p/src/peer-routing.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:peer-routing"), {
      error: debug50("libp2p:peer-routing:err")
    });
    var errCode69 = require_err_code();
    var errors2 = require_errors3();
    var {
      storeAddresses,
      uniquePeers,
      requirePeers
    } = require_utils8();
    var { TimeoutController: TimeoutController3 } = require_timeout_abort_controller();
    var merge5 = require_it_merge();
    var { pipe: pipe8 } = require_it_pipe();
    var first4 = require_it_first();
    var drain9 = require_it_drain();
    var filter10 = require_it_filter();
    var {
      setDelayedInterval,
      clearDelayedInterval
    } = require_src23();
    var { DHTPeerRouting } = require_dht_peer_routing();
    var { setMaxListeners } = require_events();
    var PeerRouting = class {
      constructor(libp2p) {
        this._peerId = libp2p.peerId;
        this._peerStore = libp2p.peerStore;
        this._routers = libp2p._modules.peerRouting || [];
        if (libp2p._dht && libp2p._config.dht.enabled) {
          this._routers.push(new DHTPeerRouting(libp2p._dht));
        }
        this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager;
        this._findClosestPeersTask = this._findClosestPeersTask.bind(this);
      }
      start() {
        if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {
          return;
        }
        this._timeoutId = setDelayedInterval(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay);
      }
      async _findClosestPeersTask() {
        try {
          await drain9(this.getClosestPeers(this._peerId.id, { timeout: this._refreshManagerOptions.timeout || 1e4 }));
        } catch (err) {
          log48.error(err);
        }
      }
      stop() {
        clearDelayedInterval(this._timeoutId);
      }
      async findPeer(id, options) {
        if (!this._routers.length) {
          throw errCode69(new Error("No peer routers available"), errors2.codes.ERR_NO_ROUTERS_AVAILABLE);
        }
        if (id.toB58String() === this._peerId.toB58String()) {
          throw errCode69(new Error("Should not try to find self"), errors2.codes.ERR_FIND_SELF);
        }
        const output = await pipe8(merge5(...this._routers.map((router) => async function* () {
          try {
            yield await router.findPeer(id, options);
          } catch (err) {
            log48.error(err);
          }
        }())), (source) => filter10(source, Boolean), (source) => storeAddresses(source, this._peerStore), (source) => first4(source));
        if (output) {
          return output;
        }
        throw errCode69(new Error(errors2.messages.NOT_FOUND), errors2.codes.ERR_NOT_FOUND);
      }
      async *getClosestPeers(key, options = { timeout: 3e4 }) {
        if (!this._routers.length) {
          throw errCode69(new Error("No peer routers available"), errors2.codes.ERR_NO_ROUTERS_AVAILABLE);
        }
        if (options.timeout) {
          const controller = new TimeoutController3(options.timeout);
          try {
            setMaxListeners && setMaxListeners(Infinity, controller.signal);
          } catch {
          }
          options.signal = controller.signal;
        }
        yield* pipe8(merge5(...this._routers.map((router) => router.getClosestPeers(key, options))), (source) => storeAddresses(source, this._peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
      }
    };
    module2.exports = PeerRouting;
  }
});

// node_modules/libp2p/src/dht/dht-content-routing.js
var require_dht_content_routing = __commonJS({
  "node_modules/libp2p/src/dht/dht-content-routing.js"(exports2, module2) {
    "use strict";
    init_globals();
    var drain9 = require_it_drain();
    var DHTContentRouting = class {
      constructor(dht) {
        this._dht = dht;
      }
      async provide(cid) {
        await drain9(this._dht.provide(cid));
      }
      async *findProviders(cid, options) {
        for await (const event of this._dht.findProviders(cid, options)) {
          if (event.name === "PROVIDER") {
            yield* event.providers;
          }
        }
      }
    };
    module2.exports = { DHTContentRouting };
  }
});

// node_modules/libp2p/src/content-routing/index.js
var require_content_routing2 = __commonJS({
  "node_modules/libp2p/src/content-routing/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errCode69 = require_err_code();
    var { messages, codes } = require_errors3();
    var {
      storeAddresses,
      uniquePeers,
      requirePeers,
      maybeLimitSource
    } = require_utils8();
    var drain9 = require_it_drain();
    var merge5 = require_it_merge();
    var { pipe: pipe8 } = require_it_pipe();
    var { DHTContentRouting } = require_dht_content_routing();
    var ContentRouting = class {
      constructor(libp2p) {
        this.libp2p = libp2p;
        this.routers = libp2p._modules.contentRouting || [];
        this.dht = libp2p._dht;
        if (this.dht && libp2p._config.dht.enabled) {
          this.routers.push(new DHTContentRouting(this.dht));
        }
      }
      async *findProviders(key, options = {}) {
        if (!this.routers.length) {
          throw errCode69(new Error("No content this.routers available"), codes.ERR_NO_ROUTERS_AVAILABLE);
        }
        yield* pipe8(merge5(...this.routers.map((router) => router.findProviders(key, options))), (source) => storeAddresses(source, this.libp2p.peerStore), (source) => uniquePeers(source), (source) => maybeLimitSource(source, options.maxNumProviders), (source) => requirePeers(source));
      }
      async provide(key) {
        if (!this.routers.length) {
          throw errCode69(new Error("No content routers available"), codes.ERR_NO_ROUTERS_AVAILABLE);
        }
        await Promise.all(this.routers.map((router) => router.provide(key)));
      }
      async put(key, value, options) {
        if (!this.libp2p.isStarted() || !this.dht.isStarted) {
          throw errCode69(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
        }
        await drain9(this.dht.put(key, value, options));
      }
      async get(key, options) {
        if (!this.libp2p.isStarted() || !this.dht.isStarted) {
          throw errCode69(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
        }
        for await (const event of this.dht.get(key, options)) {
          if (event.name === "VALUE") {
            return { from: event.peerId, val: event.value };
          }
        }
        throw errCode69(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
      }
      async *getMany(key, nVals, options) {
        if (!this.libp2p.isStarted() || !this.dht.isStarted) {
          throw errCode69(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
        }
        if (!nVals) {
          return;
        }
        let gotValues = 0;
        for await (const event of this.dht.get(key, options)) {
          if (event.name === "VALUE") {
            yield { from: event.peerId, val: event.value };
            gotValues++;
            if (gotValues === nVals) {
              break;
            }
          }
        }
        if (gotValues === 0) {
          throw errCode69(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
        }
      }
    };
    module2.exports = ContentRouting;
  }
});

// node_modules/libp2p/src/get-peer.js
var require_get_peer = __commonJS({
  "node_modules/libp2p/src/get-peer.js"(exports2, module2) {
    "use strict";
    init_globals();
    var PeerId14 = require_src5();
    var { Multiaddr: Multiaddr22 } = require_src();
    var errCode69 = require_err_code();
    var { codes } = require_errors3();
    function getPeer(peer) {
      if (typeof peer === "string") {
        peer = new Multiaddr22(peer);
      }
      let addr;
      if (Multiaddr22.isMultiaddr(peer)) {
        addr = peer;
        const idStr = peer.getPeerId();
        if (!idStr) {
          throw errCode69(new Error(`${peer} does not have a valid peer type`), codes.ERR_INVALID_MULTIADDR);
        }
        try {
          peer = PeerId14.createFromB58String(idStr);
        } catch (err) {
          throw errCode69(new Error(`${peer} is not a valid peer type`), codes.ERR_INVALID_MULTIADDR);
        }
      }
      return {
        id: peer,
        multiaddrs: addr ? [addr] : void 0
      };
    }
    module2.exports = getPeer;
  }
});

// node_modules/receptacle/index.js
var require_receptacle = __commonJS({
  "node_modules/receptacle/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = Receptacle;
    var toMS = require_ms();
    var cache2 = Receptacle.prototype;
    var counter = new Date() % 1e9;
    function getUID() {
      return (Math.random() * 1e9 >>> 0) + counter++;
    }
    function Receptacle(options) {
      options = options || {};
      this.id = options.id || getUID();
      this.max = options.max || Infinity;
      this.items = options.items || [];
      this._lookup = {};
      this.size = this.items.length;
      this.lastModified = new Date(options.lastModified || new Date());
      for (var item, ttl2, i = this.items.length; i--; ) {
        item = this.items[i];
        ttl2 = new Date(item.expires) - new Date();
        this._lookup[item.key] = item;
        if (ttl2 > 0)
          this.expire(item.key, ttl2);
        else if (ttl2 <= 0)
          this.delete(item.key);
      }
    }
    cache2.has = function(key) {
      return key in this._lookup;
    };
    cache2.get = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (record.refresh)
        this.expire(key, record.refresh);
      this.items.splice(this.items.indexOf(record), 1);
      this.items.push(record);
      return record.value;
    };
    cache2.meta = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (!("meta" in record))
        return null;
      return record.meta;
    };
    cache2.set = function(key, value, options) {
      var oldRecord = this._lookup[key];
      var record = this._lookup[key] = { key, value };
      this.lastModified = new Date();
      if (oldRecord) {
        clearTimeout(oldRecord.timeout);
        this.items.splice(this.items.indexOf(oldRecord), 1, record);
      } else {
        if (this.size >= this.max)
          this.delete(this.items[0].key);
        this.items.push(record);
        this.size++;
      }
      if (options) {
        if ("ttl" in options)
          this.expire(key, options.ttl);
        if ("meta" in options)
          record.meta = options.meta;
        if (options.refresh)
          record.refresh = options.ttl;
      }
      return this;
    };
    cache2.delete = function(key) {
      var record = this._lookup[key];
      if (!record)
        return false;
      this.lastModified = new Date();
      this.items.splice(this.items.indexOf(record), 1);
      clearTimeout(record.timeout);
      delete this._lookup[key];
      this.size--;
      return this;
    };
    cache2.expire = function(key, ttl2) {
      var ms = ttl2 || 0;
      var record = this._lookup[key];
      if (!record)
        return this;
      if (typeof ms === "string")
        ms = toMS(ttl2);
      if (typeof ms !== "number")
        throw new TypeError("Expiration time must be a string or number.");
      clearTimeout(record.timeout);
      record.timeout = setTimeout(this.delete.bind(this, record.key), ms);
      record.expires = Number(new Date()) + ms;
      return this;
    };
    cache2.clear = function() {
      for (var i = this.items.length; i--; )
        this.delete(this.items[i].key);
      return this;
    };
    cache2.toJSON = function() {
      var items = new Array(this.items.length);
      var item;
      for (var i = items.length; i--; ) {
        item = this.items[i];
        items[i] = {
          key: item.key,
          meta: item.meta,
          value: item.value,
          expires: item.expires,
          refresh: item.refresh
        };
      }
      return {
        id: this.id,
        max: isFinite(this.max) ? this.max : void 0,
        lastModified: this.lastModified,
        items
      };
    };
  }
});

// node_modules/dns-over-http-resolver/src/utils.js
var require_utils9 = __commonJS({
  "node_modules/dns-over-http-resolver/src/utils.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { default: nativeFetch, Headers } = require_src4();
    function buildResource({ serverResolver, hostname, recordType }) {
      return `${serverResolver}?name=${hostname}&type=${recordType}`;
    }
    function fetch(resource) {
      return nativeFetch(resource, {
        headers: new Headers({
          accept: "application/dns-json"
        })
      });
    }
    function getCacheKey(hostname, recordType) {
      return `${recordType}_${hostname}`;
    }
    module2.exports = {
      buildResource,
      fetch,
      getCacheKey
    };
  }
});

// node_modules/dns-over-http-resolver/src/index.js
var require_src24 = __commonJS({
  "node_modules/dns-over-http-resolver/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = debug50("dns-over-http-resolver");
    log48.error = debug50("dns-over-http-resolver:error");
    var Receptacle = require_receptacle();
    var utils = require_utils9();
    var Resolver = class {
      constructor({ maxCache = 100 } = {}) {
        this._cache = new Receptacle({ max: maxCache });
        this._servers = [
          "https://cloudflare-dns.com/dns-query",
          "https://dns.google/resolve"
        ];
      }
      getServers() {
        return this._servers;
      }
      _getShuffledServers() {
        const newServers = [].concat(this._servers);
        for (let i = newServers.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * i);
          const temp = newServers[i];
          newServers[i] = newServers[j];
          newServers[j] = temp;
        }
        return newServers;
      }
      setServers(servers) {
        this._servers = servers;
      }
      resolve(hostname, rrType = "A") {
        switch (rrType) {
          case "A":
            return this.resolve4(hostname);
          case "AAAA":
            return this.resolve6(hostname);
          case "TXT":
            return this.resolveTxt(hostname);
          default:
            throw new Error(`${rrType} is not supported`);
        }
      }
      async resolve4(hostname) {
        const recordType = "A";
        const cached = this._cache.get(utils.getCacheKey(hostname, recordType));
        if (cached) {
          return cached;
        }
        for (const server of this._getShuffledServers()) {
          try {
            const response = await utils.fetch(utils.buildResource({
              serverResolver: server,
              hostname,
              recordType
            }));
            const d = await response.json();
            const data = d.Answer.map((a) => a.data);
            const ttl2 = Math.min(d.Answer.map((a) => a.TTL));
            this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl: ttl2 });
            return data;
          } catch (err) {
            log48.error(`${server} could not resolve ${hostname} record ${recordType}`);
          }
        }
        throw new Error(`Could not resolve ${hostname} record ${recordType}`);
      }
      async resolve6(hostname) {
        const recordType = "AAAA";
        const cached = this._cache.get(utils.getCacheKey(hostname, recordType));
        if (cached) {
          return cached;
        }
        for (const server of this._getShuffledServers()) {
          try {
            const response = await utils.fetch(utils.buildResource({
              serverResolver: server,
              hostname,
              recordType
            }));
            const d = await response.json();
            const data = d.Answer.map((a) => a.data);
            const ttl2 = Math.min(d.Answer.map((a) => a.TTL));
            this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl: ttl2 });
            return data;
          } catch (err) {
            log48.error(`${server} could not resolve ${hostname} record ${recordType}`);
          }
        }
        throw new Error(`Could not resolve ${hostname} record ${recordType}`);
      }
      async resolveTxt(hostname) {
        const recordType = "TXT";
        const cached = this._cache.get(utils.getCacheKey(hostname, recordType));
        if (cached) {
          return cached;
        }
        for (const server of this._getShuffledServers()) {
          try {
            const response = await utils.fetch(utils.buildResource({
              serverResolver: server,
              hostname,
              recordType
            }));
            const d = await response.json();
            const data = d.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
            const ttl2 = Math.min(d.Answer.map((a) => a.TTL));
            this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl: ttl2 });
            return data;
          } catch (err) {
            log48.error(`${server} could not resolve ${hostname} record ${recordType}`);
          }
        }
        throw new Error(`Could not resolve ${hostname} record ${recordType}`);
      }
    };
    Resolver.Resolver = Resolver;
    module2.exports = Resolver;
  }
});

// node_modules/multiaddr/src/resolvers/dns.browser.js
var require_dns_browser = __commonJS({
  "node_modules/multiaddr/src/resolvers/dns.browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    var dns = require_src24();
    module2.exports = dns;
  }
});

// node_modules/multiaddr/src/resolvers/index.js
var require_resolvers = __commonJS({
  "node_modules/multiaddr/src/resolvers/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var protocols = require_protocols_table();
    var { code: dnsaddrCode } = protocols("dnsaddr");
    async function dnsaddrResolver(addr) {
      const Resolver = require_dns_browser();
      const resolver = new Resolver();
      const peerId = addr.getPeerId();
      const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) || [];
      const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
      let addresses = records.flat().map((a) => a.split("=")[1]);
      if (peerId) {
        addresses = addresses.filter((entry) => entry.includes(peerId));
      }
      return addresses;
    }
    module2.exports = {
      dnsaddrResolver
    };
  }
});

// node_modules/libp2p/src/constants.js
var require_constants11 = __commonJS({
  "node_modules/libp2p/src/constants.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      DIAL_TIMEOUT: 3e4,
      MAX_PARALLEL_DIALS: 100,
      MAX_PER_PEER_DIALS: 4,
      MAX_ADDRS_TO_DIAL: 25,
      METRICS: {
        computeThrottleMaxQueueSize: 1e3,
        computeThrottleTimeout: 2e3,
        movingAverageIntervals: [
          60 * 1e3,
          5 * 60 * 1e3,
          15 * 60 * 1e3
        ],
        maxOldPeersRetention: 50
      }
    };
  }
});

// node_modules/libp2p/package.json
var require_package = __commonJS({
  "node_modules/libp2p/package.json"(exports2, module2) {
    module2.exports = {
      name: "libp2p",
      version: "0.36.2",
      description: "JavaScript implementation of libp2p, a modular peer to peer network stack",
      leadMaintainer: "Jacob Heun <jacobheun@gmail.com>",
      main: "src/index.js",
      types: "dist/src/index.d.ts",
      typesVersions: {
        "*": {
          "src/*": [
            "dist/src/*",
            "dist/src/*/index"
          ]
        }
      },
      files: [
        "dist",
        "src"
      ],
      scripts: {
        lint: "aegir lint",
        build: "aegir build",
        "build:proto": "npm run build:proto:circuit && npm run build:proto:fetch && npm run build:proto:identify && npm run build:proto:plaintext && npm run build:proto:address-book && npm run build:proto:proto-book && npm run build:proto:peer && npm run build:proto:peer-record && npm run build:proto:envelope",
        "build:proto:circuit": "pbjs -t static-module -w commonjs -r libp2p-circuit --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/circuit/protocol/index.js ./src/circuit/protocol/index.proto",
        "build:proto:fetch": "pbjs -t static-module -w commonjs -r libp2p-fetch --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/fetch/proto.js ./src/fetch/proto.proto",
        "build:proto:identify": "pbjs -t static-module -w commonjs -r libp2p-identify --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/identify/message.js ./src/identify/message.proto",
        "build:proto:plaintext": "pbjs -t static-module -w commonjs -r libp2p-plaintext --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/insecure/proto.js ./src/insecure/proto.proto",
        "build:proto:peer": "pbjs -t static-module -w commonjs -r libp2p-peer --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/peer-store/pb/peer.js ./src/peer-store/pb/peer.proto",
        "build:proto:peer-record": "pbjs -t static-module -w commonjs -r libp2p-peer-record --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/record/peer-record/peer-record.js ./src/record/peer-record/peer-record.proto",
        "build:proto:envelope": "pbjs -t static-module -w commonjs -r libp2p-envelope --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/record/envelope/envelope.js ./src/record/envelope/envelope.proto",
        "build:proto-types": "npm run build:proto-types:circuit && npm run build:proto-types:fetch && npm run build:proto-types:identify && npm run build:proto-types:plaintext && npm run build:proto-types:address-book && npm run build:proto-types:proto-book && npm run build:proto-types:peer && npm run build:proto-types:peer-record && npm run build:proto-types:envelope",
        "build:proto-types:circuit": "pbts -o src/circuit/protocol/index.d.ts src/circuit/protocol/index.js",
        "build:proto-types:fetch": "pbts -o src/fetch/proto.d.ts src/fetch/proto.js",
        "build:proto-types:identify": "pbts -o src/identify/message.d.ts src/identify/message.js",
        "build:proto-types:plaintext": "pbts -o src/insecure/proto.d.ts src/insecure/proto.js",
        "build:proto-types:peer": "pbts -o src/peer-store/pb/peer.d.ts src/peer-store/pb/peer.js",
        "build:proto-types:peer-record": "pbts -o src/record/peer-record/peer-record.d.ts src/record/peer-record/peer-record.js",
        "build:proto-types:envelope": "pbts -o src/record/envelope/envelope.d.ts src/record/envelope/envelope.js",
        test: "aegir test",
        "test:ts": "aegir build --no-bundle && npm run test --prefix test/ts-use",
        "test:node": 'aegir test -t node -f "./test/**/*.{node,spec}.js"',
        "test:browser": "aegir test -t browser",
        "test:examples": "cd examples && npm run test:all",
        "test:interop": "LIBP2P_JS=$PWD npx aegir test -t node -f ./node_modules/libp2p-interop/test/*",
        prepare: "npm run build",
        coverage: "nyc --reporter=text --reporter=lcov npm run test:node"
      },
      repository: {
        type: "git",
        url: "https://github.com/libp2p/js-libp2p.git"
      },
      keywords: [
        "libp2p",
        "network",
        "p2p",
        "peer",
        "peer-to-peer",
        "IPFS"
      ],
      bugs: {
        url: "https://github.com/libp2p/js-libp2p/issues"
      },
      homepage: "https://libp2p.io",
      license: "MIT",
      engines: {
        node: ">=15.0.0"
      },
      browser: {
        "nat-api": false
      },
      eslintConfig: {
        extends: "ipfs",
        ignorePatterns: [
          "!.aegir.js",
          "test/ts-use",
          "*.d.ts"
        ]
      },
      dependencies: {
        "@vascosantos/moving-average": "^1.1.0",
        "abortable-iterator": "^3.0.0",
        "aggregate-error": "^3.1.0",
        "any-signal": "^3.0.0",
        "bignumber.js": "^9.0.1",
        "class-is": "^1.1.0",
        "datastore-core": "^7.0.0",
        debug: "^4.3.1",
        "err-code": "^3.0.0",
        "es6-promisify": "^7.0.0",
        events: "^3.3.0",
        hashlru: "^2.3.0",
        "interface-datastore": "^6.0.2",
        "it-all": "^1.0.4",
        "it-buffer": "^0.1.2",
        "it-drain": "^1.0.3",
        "it-filter": "^1.0.1",
        "it-first": "^1.0.4",
        "it-foreach": "^0.1.1",
        "it-handshake": "^2.0.0",
        "it-length-prefixed": "^5.0.2",
        "it-map": "^1.0.4",
        "it-merge": "^1.0.0",
        "it-pipe": "^1.1.0",
        "it-sort": "^1.0.1",
        "it-take": "^1.0.0",
        "libp2p-crypto": "^0.21.2",
        "libp2p-interfaces": "^4.0.0",
        "libp2p-utils": "^0.4.0",
        mafmt: "^10.0.0",
        "merge-options": "^3.0.4",
        mortice: "^2.0.1",
        multiaddr: "^10.0.0",
        multiformats: "^9.0.0",
        "multistream-select": "^3.0.0",
        "mutable-proxy": "^1.0.0",
        "nat-api": "^0.3.1",
        "node-forge": "^1.2.1",
        "p-any": "^3.0.0",
        "p-fifo": "^1.0.0",
        "p-retry": "^4.4.0",
        "p-settle": "^4.1.1",
        "peer-id": "^0.16.0",
        "private-ip": "^2.1.0",
        protobufjs: "^6.10.2",
        retimer: "^3.0.0",
        "sanitize-filename": "^1.6.3",
        "set-delayed-interval": "^1.0.0",
        "streaming-iterables": "^6.0.0",
        "timeout-abort-controller": "^3.0.0",
        uint8arrays: "^3.0.0",
        varint: "^6.0.0",
        wherearewe: "^1.0.0",
        xsalsa20: "^1.1.0"
      },
      devDependencies: {
        "@chainsafe/libp2p-noise": "^5.0.0",
        "@nodeutils/defaults-deep": "^1.1.0",
        "@types/es6-promisify": "^6.0.0",
        "@types/node": "^16.0.1",
        "@types/node-forge": "^1.0.0",
        "@types/varint": "^6.0.0",
        aegir: "^36.0.0",
        buffer: "^6.0.3",
        delay: "^5.0.0",
        "into-stream": "^6.0.0",
        "ipfs-http-client": "^54.0.2",
        "it-concat": "^2.0.0",
        "it-pair": "^1.0.0",
        "it-pushable": "^1.4.0",
        libp2p: ".",
        "libp2p-bootstrap": "^0.14.0",
        "libp2p-delegated-content-routing": "^0.11.0",
        "libp2p-delegated-peer-routing": "^0.11.1",
        "libp2p-interfaces-compliance-tests": "^4.0.8",
        "libp2p-interop": "^0.7.1",
        "libp2p-kad-dht": "^0.28.6",
        "libp2p-mdns": "^0.18.0",
        "libp2p-mplex": "^0.10.4",
        "libp2p-tcp": "^0.17.0",
        "libp2p-webrtc-star": "^0.25.0",
        "libp2p-websockets": "^0.16.0",
        nock: "^13.0.3",
        "p-defer": "^3.0.0",
        "p-times": "^3.0.0",
        "p-wait-for": "^3.2.0",
        rimraf: "^3.0.2",
        sinon: "^12.0.1",
        util: "^0.12.3"
      },
      contributors: [
        "Vasco Santos <vasco.santos@moxy.studio>",
        "David Dias <daviddias.p@gmail.com>",
        "Jacob Heun <jacobheun@gmail.com>",
        "Alex Potsides <alex@achingbrain.net>",
        "Alan Shaw <alan@tableflip.io>",
        "Cayman <caymannava@gmail.com>",
        "Pedro Teixeira <i@pgte.me>",
        "Friedel Ziegelmayer <dignifiedquire@gmail.com>",
        "Maciej Kr\xFCger <mkg20001@gmail.com>",
        "Hugo Dias <mail@hugodias.me>",
        "dirkmc <dirkmdev@gmail.com>",
        "Volker Mische <volker.mische@gmail.com>",
        "Chris Dostert <chrisdostert@users.noreply.github.com>",
        "zeim839 <50573884+zeim839@users.noreply.github.com>",
        "Robert Kiel <robert.kiel@hoprnet.org>",
        "Richard Littauer <richard.littauer@gmail.com>",
        "a1300 <matthias-knopp@gmx.net>",
        "Ryan Bell <ryan@piing.net>",
        "\u1D20\u026A\u1D04\u1D1B\u1D0F\u0280 \u0299\u1D0A\u1D07\u029F\u1D0B\u029C\u1D0F\u029F\u1D0D <victorbjelkholm@gmail.com>",
        "Andrew Nesbitt <andrewnez@gmail.com>",
        "Franck Royer <franck@royer.one>",
        "Thomas Eizinger <thomas@eizinger.io>",
        "V\xEDt Habada <vithabada93@gmail.com>",
        "Giovanni T. Parra <fiatjaf@gmail.com>",
        "acolytec3 <17355484+acolytec3@users.noreply.github.com>",
        "Alan Smithee <ggnore.alan.smithee@gmail.com>",
        "Elven <mon.samuel@qq.com>",
        "Samlior <samlior@foxmail.com>",
        "Didrik Nordstr\xF6m <didrik.nordstrom@gmail.com>",
        "Aditya Bose <13054902+adbose@users.noreply.github.com>",
        "TJKoury <TJKoury@gmail.com>",
        "TheStarBoys <41286328+TheStarBoys@users.noreply.github.com>",
        "Tiago Alves <alvesjtiago@gmail.com>",
        "Tim Daubensch\xFCtz <tim@daubenschuetz.de>",
        "XiaoZhang <zxinmyth@gmail.com>",
        "Yusef Napora <yusef@napora.org>",
        "Zane Starr <zcstarr@gmail.com>",
        "ebinks <elizabethjbinks@gmail.com>",
        "greenSnot <greenSnot@users.noreply.github.com>",
        "isan_rivkin <isanrivkin@gmail.com>",
        "mayerwin <mayerwin@users.noreply.github.com>",
        "mcclure <andi.m.mcclure@gmail.com>",
        "patrickwoodhead <91056047+patrickwoodhead@users.noreply.github.com>",
        "phillmac <phillmac@users.noreply.github.com>",
        "robertkiel <robert.kiel@validitylabs.org>",
        "shresthagrawal <34920931+shresthagrawal@users.noreply.github.com>",
        "swedneck <40505480+swedneck@users.noreply.github.com>",
        "tuyennhv <vutuyen2636@gmail.com>",
        "S\xF6nke Hahn <soenkehahn@gmail.com>",
        "Aleksei <vozhdb@gmail.com>",
        "Bernd Strehl <bernd.strehl@gmail.com>",
        "Chris Bratlien <chrisbratlien@gmail.com>",
        "Cindy Wu <ciindy.wu@gmail.com>",
        "Daijiro Wachi <daijiro.wachi@gmail.com>",
        "Diogo Silva <fsdiogo@gmail.com>",
        "Dmitriy Ryajov <dryajov@gmail.com>",
        "Ethan Lam <elmemphis2000@gmail.com>",
        "Fei Liu <liu.feiwood@gmail.com>",
        "Felipe Martins <felipebrasil93@gmail.com>",
        "Florian-Merle <florian.david.merle@gmail.com>",
        "Francis Gulotta <wizard@roborooter.com>",
        "Guy Sviry <32539816+guysv@users.noreply.github.com>",
        "Henrique Dias <hacdias@gmail.com>",
        "Irakli Gozalishvili <rfobic@gmail.com>",
        "Joel Gustafson <joelg@mit.edu>",
        "John Rees <johnrees@users.noreply.github.com>",
        "Jo\xE3o Santos <joaosantos15@users.noreply.github.com>",
        "Julien Bouquillon <contact@revolunet.com>",
        "Kevin Kwok <antimatter15@gmail.com>",
        "Kevin Lacker <lacker@gmail.com>",
        "Lars Gierth <lgierth@users.noreply.github.com>",
        "Leask Wong <i@leaskh.com>",
        "Marcin Tojek <mtojek@users.noreply.github.com>",
        "Marston Connell <34043723+TheMarstonConnell@users.noreply.github.com>",
        "Michael Burns <5170+mburns@users.noreply.github.com>",
        "Miguel Mota <miguelmota2@gmail.com>",
        "Nuno Nogueira <nunofmn@gmail.com>",
        "Philipp Muens <raute1337@gmx.de>",
        "RasmusErik Voel Jensen <github@solsort.com>",
        "Smite Chow <xiaopengyou@live.com>",
        "Soeren <nikorpoulsen@gmail.com>"
      ]
    };
  }
});

// node_modules/libp2p/src/identify/consts.js
var require_consts = __commonJS({
  "node_modules/libp2p/src/identify/consts.js"(exports2, module2) {
    "use strict";
    init_globals();
    var libp2pVersion = require_package().version;
    module2.exports.PROTOCOL_VERSION = "ipfs/0.1.0";
    module2.exports.AGENT_VERSION = `js-libp2p/${libp2pVersion}`;
    module2.exports.MULTICODEC_IDENTIFY = "/ipfs/id/1.0.0";
    module2.exports.MULTICODEC_IDENTIFY_PUSH = "/ipfs/id/push/1.0.0";
    module2.exports.IDENTIFY_PROTOCOL_VERSION = "0.1.0";
    module2.exports.MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
    module2.exports.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
    module2.exports.MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
    module2.exports.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
  }
});

// node_modules/libp2p/src/circuit/constants.js
var require_constants12 = __commonJS({
  "node_modules/libp2p/src/circuit/constants.js"(exports2, module2) {
    "use strict";
    init_globals();
    var minute2 = 60 * 1e3;
    module2.exports = {
      ADVERTISE_BOOT_DELAY: 15 * minute2,
      ADVERTISE_TTL: 30 * minute2,
      CIRCUIT_PROTO_CODE: 290,
      HOP_METADATA_KEY: "hop_relay",
      HOP_METADATA_VALUE: "true",
      RELAY_RENDEZVOUS_NS: "/libp2p/relay"
    };
  }
});

// node_modules/libp2p-utils/src/multiaddr/is-private.js
var require_is_private = __commonJS({
  "node_modules/libp2p-utils/src/multiaddr/is-private.js"(exports2, module2) {
    "use strict";
    init_globals();
    var isIpPrivate = require_private_ip();
    function isPrivate(ma) {
      const { address } = ma.nodeAddress();
      return isIpPrivate(address);
    }
    module2.exports = isPrivate;
  }
});

// node_modules/libp2p-utils/src/address-sort.js
var require_address_sort = __commonJS({
  "node_modules/libp2p-utils/src/address-sort.js"(exports2, module2) {
    "use strict";
    init_globals();
    var isPrivate = require_is_private();
    function addressesPublicFirstCompareFunction(a, b) {
      const isAPrivate = isPrivate(a.multiaddr);
      const isBPrivate = isPrivate(b.multiaddr);
      if (isAPrivate && !isBPrivate) {
        return 1;
      } else if (!isAPrivate && isBPrivate) {
        return -1;
      }
      if (a.isCertified && !b.isCertified) {
        return -1;
      } else if (!a.isCertified && b.isCertified) {
        return 1;
      }
      return 0;
    }
    function publicAddressesFirst(addresses) {
      return [...addresses].sort(addressesPublicFirstCompareFunction);
    }
    module2.exports.publicAddressesFirst = publicAddressesFirst;
  }
});

// node_modules/p-reflect/index.js
var require_p_reflect = __commonJS({
  "node_modules/p-reflect/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var pReflect = async (promise) => {
      try {
        const value = await promise;
        return {
          isFulfilled: true,
          isRejected: false,
          value
        };
      } catch (error) {
        return {
          isFulfilled: false,
          isRejected: true,
          reason: error
        };
      }
    };
    module2.exports = pReflect;
    module2.exports.default = pReflect;
  }
});

// node_modules/p-try/index.js
var require_p_try = __commonJS({
  "node_modules/p-try/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var pTry = (fn, ...arguments_) => new Promise((resolve11) => {
      resolve11(fn(...arguments_));
    });
    module2.exports = pTry;
    module2.exports.default = pTry;
  }
});

// node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "node_modules/p-limit/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var pTry = require_p_try();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
      }
      const queue = [];
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.length > 0) {
          queue.shift()();
        }
      };
      const run = (fn, resolve11, ...args) => {
        activeCount++;
        const result = pTry(fn, ...args);
        resolve11(result);
        result.then(next, next);
      };
      const enqueue = (fn, resolve11, ...args) => {
        if (activeCount < concurrency) {
          run(fn, resolve11, ...args);
        } else {
          queue.push(run.bind(null, fn, resolve11, ...args));
        }
      };
      const generator = (fn, ...args) => new Promise((resolve11) => enqueue(fn, resolve11, ...args));
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.length
        },
        clearQueue: {
          value: () => {
            queue.length = 0;
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
    module2.exports.default = pLimit;
  }
});

// node_modules/p-settle/index.js
var require_p_settle = __commonJS({
  "node_modules/p-settle/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var pReflect = require_p_reflect();
    var pLimit = require_p_limit();
    module2.exports = async (array, options = {}) => {
      const { concurrency = Infinity } = options;
      const limit = pLimit(concurrency);
      return Promise.all(array.map((element) => {
        if (element && typeof element.then === "function") {
          return pReflect(element);
        }
        if (typeof element === "function") {
          return pReflect(limit(() => element()));
        }
        return pReflect(Promise.resolve(element));
      }));
    };
  }
});

// node_modules/libp2p-utils/src/array-equals.js
var require_array_equals = __commonJS({
  "node_modules/libp2p-utils/src/array-equals.js"(exports2, module2) {
    "use strict";
    init_globals();
    function arrayEquals(a, b) {
      return a.length === b.length && b.sort() && a.sort().every((item, index) => b[index].equals(item));
    }
    module2.exports = arrayEquals;
  }
});

// node_modules/libp2p/src/record/peer-record/peer-record.js
var require_peer_record = __commonJS({
  "node_modules/libp2p/src/record/peer-record/peer-record.js"(exports2, module2) {
    "use strict";
    init_globals();
    var $protobuf12 = require_minimal2();
    var $Reader11 = $protobuf12.Reader;
    var $Writer11 = $protobuf12.Writer;
    var $util11 = $protobuf12.util;
    var $root11 = $protobuf12.roots["libp2p-peer-record"] || ($protobuf12.roots["libp2p-peer-record"] = {});
    $root11.PeerRecord = function() {
      function PeerRecord2(p) {
        this.addresses = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      PeerRecord2.prototype.peerId = $util11.newBuffer([]);
      PeerRecord2.prototype.seq = $util11.Long ? $util11.Long.fromBits(0, 0, true) : 0;
      PeerRecord2.prototype.addresses = $util11.emptyArray;
      PeerRecord2.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.peerId != null && Object.hasOwnProperty.call(m, "peerId"))
          w.uint32(10).bytes(m.peerId);
        if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
          w.uint32(16).uint64(m.seq);
        if (m.addresses != null && m.addresses.length) {
          for (var i = 0; i < m.addresses.length; ++i)
            $root11.PeerRecord.AddressInfo.encode(m.addresses[i], w.uint32(26).fork()).ldelim();
        }
        return w;
      };
      PeerRecord2.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.PeerRecord();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.peerId = r.bytes();
              break;
            case 2:
              m.seq = r.uint64();
              break;
            case 3:
              if (!(m.addresses && m.addresses.length))
                m.addresses = [];
              m.addresses.push($root11.PeerRecord.AddressInfo.decode(r, r.uint32()));
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      PeerRecord2.fromObject = function fromObject(d) {
        if (d instanceof $root11.PeerRecord)
          return d;
        var m = new $root11.PeerRecord();
        if (d.peerId != null) {
          if (typeof d.peerId === "string")
            $util11.base64.decode(d.peerId, m.peerId = $util11.newBuffer($util11.base64.length(d.peerId)), 0);
          else if (d.peerId.length)
            m.peerId = d.peerId;
        }
        if (d.seq != null) {
          if ($util11.Long)
            (m.seq = $util11.Long.fromValue(d.seq)).unsigned = true;
          else if (typeof d.seq === "string")
            m.seq = parseInt(d.seq, 10);
          else if (typeof d.seq === "number")
            m.seq = d.seq;
          else if (typeof d.seq === "object")
            m.seq = new $util11.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
        }
        if (d.addresses) {
          if (!Array.isArray(d.addresses))
            throw TypeError(".PeerRecord.addresses: array expected");
          m.addresses = [];
          for (var i = 0; i < d.addresses.length; ++i) {
            if (typeof d.addresses[i] !== "object")
              throw TypeError(".PeerRecord.addresses: object expected");
            m.addresses[i] = $root11.PeerRecord.AddressInfo.fromObject(d.addresses[i]);
          }
        }
        return m;
      };
      PeerRecord2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.addresses = [];
        }
        if (o.defaults) {
          if (o.bytes === String)
            d.peerId = "";
          else {
            d.peerId = [];
            if (o.bytes !== Array)
              d.peerId = $util11.newBuffer(d.peerId);
          }
          if ($util11.Long) {
            var n = new $util11.Long(0, 0, true);
            d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.seq = o.longs === String ? "0" : 0;
        }
        if (m.peerId != null && m.hasOwnProperty("peerId")) {
          d.peerId = o.bytes === String ? $util11.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;
        }
        if (m.seq != null && m.hasOwnProperty("seq")) {
          if (typeof m.seq === "number")
            d.seq = o.longs === String ? String(m.seq) : m.seq;
          else
            d.seq = o.longs === String ? $util11.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util11.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
        }
        if (m.addresses && m.addresses.length) {
          d.addresses = [];
          for (var j = 0; j < m.addresses.length; ++j) {
            d.addresses[j] = $root11.PeerRecord.AddressInfo.toObject(m.addresses[j], o);
          }
        }
        return d;
      };
      PeerRecord2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      PeerRecord2.AddressInfo = function() {
        function AddressInfo(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        AddressInfo.prototype.multiaddr = $util11.newBuffer([]);
        AddressInfo.encode = function encode19(m, w) {
          if (!w)
            w = $Writer11.create();
          if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
            w.uint32(10).bytes(m.multiaddr);
          return w;
        };
        AddressInfo.decode = function decode22(r, l) {
          if (!(r instanceof $Reader11))
            r = $Reader11.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root11.PeerRecord.AddressInfo();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.multiaddr = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        AddressInfo.fromObject = function fromObject(d) {
          if (d instanceof $root11.PeerRecord.AddressInfo)
            return d;
          var m = new $root11.PeerRecord.AddressInfo();
          if (d.multiaddr != null) {
            if (typeof d.multiaddr === "string")
              $util11.base64.decode(d.multiaddr, m.multiaddr = $util11.newBuffer($util11.base64.length(d.multiaddr)), 0);
            else if (d.multiaddr.length)
              m.multiaddr = d.multiaddr;
          }
          return m;
        };
        AddressInfo.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            if (o.bytes === String)
              d.multiaddr = "";
            else {
              d.multiaddr = [];
              if (o.bytes !== Array)
                d.multiaddr = $util11.newBuffer(d.multiaddr);
            }
          }
          if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
            d.multiaddr = o.bytes === String ? $util11.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
          }
          return d;
        };
        AddressInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
        };
        return AddressInfo;
      }();
      return PeerRecord2;
    }();
    module2.exports = $root11;
  }
});

// node_modules/libp2p/src/record/peer-record/consts.js
var require_consts2 = __commonJS({
  "node_modules/libp2p/src/record/peer-record/consts.js"(exports2, module2) {
    "use strict";
    init_globals();
    var domain = "libp2p-peer-record";
    var payloadType = Uint8Array.from([3, 1]);
    module2.exports = {
      ENVELOPE_DOMAIN_PEER_RECORD: domain,
      ENVELOPE_PAYLOAD_TYPE_PEER_RECORD: payloadType
    };
  }
});

// node_modules/libp2p/src/record/peer-record/index.js
var require_peer_record2 = __commonJS({
  "node_modules/libp2p/src/record/peer-record/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Multiaddr: Multiaddr22 } = require_src();
    var PeerId14 = require_src5();
    var arrayEquals = require_array_equals();
    var { PeerRecord: Protobuf } = require_peer_record();
    var {
      ENVELOPE_DOMAIN_PEER_RECORD,
      ENVELOPE_PAYLOAD_TYPE_PEER_RECORD
    } = require_consts2();
    var PeerRecord2 = class {
      constructor({ peerId, multiaddrs = [], seqNumber = Date.now() }) {
        this.domain = ENVELOPE_DOMAIN_PEER_RECORD;
        this.codec = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
        this.peerId = peerId;
        this.multiaddrs = multiaddrs;
        this.seqNumber = seqNumber;
        this._marshal = void 0;
      }
      marshal() {
        if (this._marshal) {
          return this._marshal;
        }
        this._marshal = Protobuf.encode({
          peerId: this.peerId.toBytes(),
          seq: this.seqNumber,
          addresses: this.multiaddrs.map((m) => ({
            multiaddr: m.bytes
          }))
        }).finish();
        return this._marshal;
      }
      equals(other) {
        if (!(other instanceof PeerRecord2)) {
          return false;
        }
        if (!this.peerId.equals(other.peerId)) {
          return false;
        }
        if (this.seqNumber !== other.seqNumber) {
          return false;
        }
        if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
          return false;
        }
        return true;
      }
    };
    PeerRecord2.createFromProtobuf = (buf3) => {
      const peerRecord = Protobuf.decode(buf3);
      const peerId = PeerId14.createFromBytes(peerRecord.peerId);
      const multiaddrs = (peerRecord.addresses || []).map((a) => new Multiaddr22(a.multiaddr));
      const seqNumber = Number(peerRecord.seq);
      return new PeerRecord2({ peerId, multiaddrs, seqNumber });
    };
    PeerRecord2.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
    module2.exports = PeerRecord2;
  }
});

// node_modules/libp2p/src/record/utils.js
var require_utils10 = __commonJS({
  "node_modules/libp2p/src/record/utils.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Envelope2 = require_envelope2();
    var PeerRecord2 = require_peer_record2();
    async function updateSelfPeerRecord(libp2p) {
      const peerRecord = new PeerRecord2({
        peerId: libp2p.peerId,
        multiaddrs: libp2p.multiaddrs
      });
      const envelope = await Envelope2.seal(peerRecord, libp2p.peerId);
      await libp2p.peerStore.addressBook.consumePeerRecord(envelope);
    }
    module2.exports.updateSelfPeerRecord = updateSelfPeerRecord;
  }
});

// node_modules/libp2p/src/transport-manager.js
var require_transport_manager = __commonJS({
  "node_modules/libp2p/src/transport-manager.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:transports"), {
      error: debug50("libp2p:transports:err")
    });
    var pSettle = require_p_settle();
    var { codes } = require_errors3();
    var errCode69 = require_err_code();
    var { updateSelfPeerRecord } = require_utils10();
    var TransportManager = class {
      constructor({ libp2p, upgrader, faultTolerance = FAULT_TOLERANCE.FATAL_ALL }) {
        this.libp2p = libp2p;
        this.upgrader = upgrader;
        this._transports = /* @__PURE__ */ new Map();
        this._listeners = /* @__PURE__ */ new Map();
        this._listenerOptions = /* @__PURE__ */ new Map();
        this.faultTolerance = faultTolerance;
      }
      add(key, Transport, transportOptions = {}) {
        log48("adding %s", key);
        if (!key) {
          throw errCode69(new Error(`Transport must have a valid key, was given '${key}'`), codes.ERR_INVALID_KEY);
        }
        if (this._transports.has(key)) {
          throw errCode69(new Error("There is already a transport with this key"), codes.ERR_DUPLICATE_TRANSPORT);
        }
        const transport = new Transport({
          ...transportOptions,
          libp2p: this.libp2p,
          upgrader: this.upgrader
        });
        this._transports.set(key, transport);
        this._listenerOptions.set(key, transportOptions.listenerOptions || {});
        if (!this._listeners.has(key)) {
          this._listeners.set(key, []);
        }
      }
      async close() {
        const tasks = [];
        for (const [key, listeners] of this._listeners) {
          log48("closing listeners for %s", key);
          while (listeners.length) {
            const listener = listeners.pop();
            listener.removeAllListeners("listening");
            listener.removeAllListeners("close");
            tasks.push(listener.close());
          }
        }
        await Promise.all(tasks);
        log48("all listeners closed");
        for (const key of this._listeners.keys()) {
          this._listeners.set(key, []);
        }
      }
      async dial(ma, options) {
        const transport = this.transportForMultiaddr(ma);
        if (!transport) {
          throw errCode69(new Error(`No transport available for address ${String(ma)}`), codes.ERR_TRANSPORT_UNAVAILABLE);
        }
        try {
          return await transport.dial(ma, options);
        } catch (err) {
          if (!err.code)
            err.code = codes.ERR_TRANSPORT_DIAL_FAILED;
          throw err;
        }
      }
      getAddrs() {
        let addrs = [];
        for (const listeners of this._listeners.values()) {
          for (const listener of listeners) {
            addrs = [...addrs, ...listener.getAddrs()];
          }
        }
        return addrs;
      }
      getTransports() {
        return this._transports.values();
      }
      transportForMultiaddr(ma) {
        for (const transport of this._transports.values()) {
          const addrs = transport.filter([ma]);
          if (addrs.length)
            return transport;
        }
        return null;
      }
      async listen(addrs) {
        if (!addrs || addrs.length === 0) {
          log48("no addresses were provided for listening, this node is dial only");
          return;
        }
        const couldNotListen = [];
        for (const [key, transport] of this._transports.entries()) {
          const supportedAddrs = transport.filter(addrs);
          const tasks = [];
          for (const addr of supportedAddrs) {
            log48("creating listener for %s on %s", key, addr);
            const listener = transport.createListener(this._listenerOptions.get(key));
            this._listeners.get(key).push(listener);
            listener.on("listening", () => updateSelfPeerRecord(this.libp2p));
            listener.on("close", () => updateSelfPeerRecord(this.libp2p));
            tasks.push(listener.listen(addr));
          }
          if (tasks.length === 0) {
            couldNotListen.push(key);
            continue;
          }
          const results = await pSettle(tasks);
          const isListening = results.find((r) => r.isFulfilled === true);
          if (!isListening && this.faultTolerance !== FAULT_TOLERANCE.NO_FATAL) {
            throw errCode69(new Error(`Transport (${key}) could not listen on any available address`), codes.ERR_NO_VALID_ADDRESSES);
          }
        }
        if (couldNotListen.length === this._transports.size) {
          const message = `no valid addresses were provided for transports [${couldNotListen}]`;
          if (this.faultTolerance === FAULT_TOLERANCE.FATAL_ALL) {
            throw errCode69(new Error(message), codes.ERR_NO_VALID_ADDRESSES);
          }
          log48(`libp2p in dial mode only: ${message}`);
        }
      }
      async remove(key) {
        log48("removing %s", key);
        if (this._listeners.has(key)) {
          for (const listener of this._listeners.get(key)) {
            listener.removeAllListeners("listening");
            listener.removeAllListeners("close");
            await listener.close();
          }
        }
        this._transports.delete(key);
        this._listeners.delete(key);
      }
      async removeAll() {
        const tasks = [];
        for (const key of this._transports.keys()) {
          tasks.push(this.remove(key));
        }
        await Promise.all(tasks);
      }
    };
    var FAULT_TOLERANCE = {
      FATAL_ALL: 0,
      NO_FATAL: 1
    };
    TransportManager.FaultTolerance = FAULT_TOLERANCE;
    module2.exports = TransportManager;
  }
});

// node_modules/libp2p/src/config.js
var require_config = __commonJS({
  "node_modules/libp2p/src/config.js"(exports2, module2) {
    "use strict";
    init_globals();
    var mergeOptions17 = require_merge_options();
    var { dnsaddrResolver } = require_resolvers();
    var Constants = require_constants11();
    var { AGENT_VERSION } = require_consts();
    var RelayConstants = require_constants12();
    var { publicAddressesFirst } = require_address_sort();
    var { FaultTolerance } = require_transport_manager();
    var DefaultConfig = {
      addresses: {
        listen: [],
        announce: [],
        noAnnounce: [],
        announceFilter: (multiaddrs) => multiaddrs
      },
      connectionManager: {
        minConnections: 25
      },
      connectionGater: {},
      transportManager: {
        faultTolerance: FaultTolerance.FATAL_ALL
      },
      dialer: {
        maxParallelDials: Constants.MAX_PARALLEL_DIALS,
        maxDialsPerPeer: Constants.MAX_PER_PEER_DIALS,
        dialTimeout: Constants.DIAL_TIMEOUT,
        resolvers: {
          dnsaddr: dnsaddrResolver
        },
        addressSorter: publicAddressesFirst
      },
      host: {
        agentVersion: AGENT_VERSION
      },
      metrics: {
        enabled: false
      },
      peerStore: {
        persistence: false,
        threshold: 5
      },
      peerRouting: {
        refreshManager: {
          enabled: true,
          interval: 6e5,
          bootDelay: 1e4
        }
      },
      config: {
        protocolPrefix: "ipfs",
        dht: {
          enabled: false,
          kBucketSize: 20
        },
        nat: {
          enabled: true,
          ttl: 7200,
          keepAlive: true,
          gateway: null,
          externalIp: null,
          pmp: {
            enabled: false
          }
        },
        peerDiscovery: {
          autoDial: true
        },
        pubsub: {
          enabled: true
        },
        relay: {
          enabled: true,
          advertise: {
            bootDelay: RelayConstants.ADVERTISE_BOOT_DELAY,
            enabled: false,
            ttl: RelayConstants.ADVERTISE_TTL
          },
          hop: {
            enabled: false,
            active: false
          },
          autoRelay: {
            enabled: false,
            maxListeners: 2
          }
        },
        transport: {}
      }
    };
    module2.exports.validate = (opts) => {
      const resultingOptions = mergeOptions17(DefaultConfig, opts);
      if (resultingOptions.modules.transport.length < 1)
        throw new Error("'options.modules.transport' must contain at least 1 transport");
      return resultingOptions;
    };
  }
});

// node_modules/libp2p/src/address-manager/index.js
var require_address_manager = __commonJS({
  "node_modules/libp2p/src/address-manager/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { EventEmitter: EventEmitter4 } = require_events();
    var { Multiaddr: Multiaddr22 } = require_src();
    var PeerId14 = require_src5();
    var AddressManager = class extends EventEmitter4 {
      constructor(peerId, { listen = [], announce = [] } = {}) {
        super();
        this.peerId = peerId;
        this.listen = new Set(listen.map((ma) => ma.toString()));
        this.announce = new Set(announce.map((ma) => ma.toString()));
        this.observed = /* @__PURE__ */ new Set();
      }
      getListenAddrs() {
        return Array.from(this.listen).map((a) => new Multiaddr22(a));
      }
      getAnnounceAddrs() {
        return Array.from(this.announce).map((a) => new Multiaddr22(a));
      }
      getObservedAddrs() {
        return Array.from(this.observed).map((a) => new Multiaddr22(a));
      }
      addObservedAddr(addr) {
        let ma = new Multiaddr22(addr);
        const remotePeer = ma.getPeerId();
        if (remotePeer) {
          const remotePeerId = PeerId14.createFromB58String(remotePeer);
          if (remotePeerId.equals(this.peerId)) {
            ma = ma.decapsulate(new Multiaddr22(`/p2p/${this.peerId}`));
          }
        }
        const addrString = ma.toString();
        if (this.observed.has(addrString)) {
          return;
        }
        this.observed.add(addrString);
        this.emit("change:addresses");
      }
    };
    module2.exports = AddressManager;
  }
});

// node_modules/libp2p/src/connection-manager/visibility-change-emitter.js
var require_visibility_change_emitter = __commonJS({
  "node_modules/libp2p/src/connection-manager/visibility-change-emitter.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { EventEmitter: EventEmitter4 } = require_events();
    var debug50 = require_browser2()("latency-monitor:VisibilityChangeEmitter");
    var VisibilityChangeEmitter = class extends EventEmitter4 {
      constructor() {
        super();
        if (typeof document === "undefined") {
          debug50('This is not a browser, no "document" found. Stopping.');
          return;
        }
        this._initializeVisibilityVarNames();
        this._addVisibilityChangeListener();
      }
      _initializeVisibilityVarNames() {
        let hidden3;
        let visibilityChange;
        if (typeof document.hidden !== "undefined") {
          hidden3 = "hidden";
          visibilityChange = "visibilitychange";
        } else if (typeof document.mozHidden !== "undefined") {
          hidden3 = "mozHidden";
          visibilityChange = "mozvisibilitychange";
        } else if (typeof document.msHidden !== "undefined") {
          hidden3 = "msHidden";
          visibilityChange = "msvisibilitychange";
        } else if (typeof document.webkitHidden !== "undefined") {
          hidden3 = "webkitHidden";
          visibilityChange = "webkitvisibilitychange";
        }
        this._hidden = hidden3;
        this._visibilityChange = visibilityChange;
      }
      _addVisibilityChangeListener() {
        if (typeof document.addEventListener === "undefined" || typeof document[this._hidden] === "undefined") {
          debug50("Checking page visibility requires a browser that supports the Page Visibility API.");
        } else {
          document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), false);
        }
      }
      isVisible() {
        if (this._hidden === void 0 || document[this._hidden] === void 0) {
          return void 0;
        }
        return !document[this._hidden];
      }
      _handleVisibilityChange() {
        const visible = !document[this._hidden];
        debug50(visible ? "Page Visible" : "Page Hidden");
        this.emit("visibilityChange", visible);
      }
    };
    module2.exports = VisibilityChangeEmitter;
  }
});

// node_modules/libp2p/src/connection-manager/latency-monitor.js
var require_latency_monitor = __commonJS({
  "node_modules/libp2p/src/connection-manager/latency-monitor.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { EventEmitter: EventEmitter4 } = require_events();
    var VisibilityChangeEmitter = require_visibility_change_emitter();
    var debug50 = require_browser2()("latency-monitor:LatencyMonitor");
    var LatencyMonitor = class extends EventEmitter4 {
      constructor({ latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage } = {}) {
        super();
        const that = this;
        that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500;
        that.latencyRandomPercentage = latencyRandomPercentage || 10;
        that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100) * that.latencyCheckIntervalMs;
        that._latecyCheckSubtract = that._latecyCheckMultiply / 2;
        that.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? void 0 : dataEmitIntervalMs || 5 * 1e3;
        debug50("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", that.latencyCheckIntervalMs, that.dataEmitIntervalMs);
        if (that.dataEmitIntervalMs) {
          debug50("Expecting ~%s events per summary", that.latencyCheckIntervalMs / that.dataEmitIntervalMs);
        } else {
          debug50("Not emitting summaries");
        }
        that.asyncTestFn = asyncTestFn;
      }
      start() {
        if (globalThis.process && globalThis.process.hrtime) {
          debug50("Using process.hrtime for timing");
          this.now = globalThis.process.hrtime;
          this.getDeltaMS = (startTime) => {
            const hrtime = this.now(startTime);
            return hrtime[0] * 1e3 + hrtime[1] / 1e6;
          };
        } else if (typeof window !== "undefined" && window.performance && window.performance.now) {
          debug50("Using performance.now for timing");
          this.now = window.performance.now.bind(window.performance);
          this.getDeltaMS = (startTime) => Math.round(this.now() - startTime);
        } else {
          debug50("Using Date.now for timing");
          this.now = Date.now;
          this.getDeltaMS = (startTime) => this.now() - startTime;
        }
        this._latencyData = this._initLatencyData();
        if (isBrowser2()) {
          this._visibilityChangeEmitter = new VisibilityChangeEmitter();
          this._visibilityChangeEmitter.on("visibilityChange", (pageInFocus) => {
            if (pageInFocus) {
              this._startTimers();
            } else {
              this._emitSummary();
              this._stopTimers();
            }
          });
        }
        if (!this._visibilityChangeEmitter || this._visibilityChangeEmitter.isVisible()) {
          this._startTimers();
        }
      }
      stop() {
        this._stopTimers();
      }
      _startTimers() {
        if (this._checkLatencyID) {
          return;
        }
        this._checkLatency();
        if (this.dataEmitIntervalMs) {
          this._emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);
          if (typeof this._emitIntervalID.unref === "function") {
            this._emitIntervalID.unref();
          }
        }
      }
      _stopTimers() {
        if (this._checkLatencyID) {
          clearTimeout(this._checkLatencyID);
          this._checkLatencyID = void 0;
        }
        if (this._emitIntervalID) {
          clearInterval(this._emitIntervalID);
          this._emitIntervalID = void 0;
        }
      }
      _emitSummary() {
        const summary = this.getSummary();
        if (summary.events > 0) {
          this.emit("data", summary);
        }
      }
      getSummary() {
        const latency = {
          events: this._latencyData.events,
          minMs: this._latencyData.minMs,
          maxMs: this._latencyData.maxMs,
          avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events : Number.POSITIVE_INFINITY,
          lengthMs: this.getDeltaMS(this._latencyData.startTime)
        };
        this._latencyData = this._initLatencyData();
        debug50("Summary: %O", latency);
        return latency;
      }
      _checkLatency() {
        const that = this;
        const randomness = Math.random() * that._latecyCheckMultiply - that._latecyCheckSubtract;
        const localData = {
          deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),
          startTime: that.now()
        };
        const cb = () => {
          if (!this._checkLatencyID) {
            return;
          }
          const deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;
          that._checkLatency();
          that._latencyData.events++;
          that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);
          that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);
          that._latencyData.totalMs += deltaMS;
          debug50("MS: %s Data: %O", deltaMS, that._latencyData);
        };
        debug50("localData: %O", localData);
        this._checkLatencyID = setTimeout(() => {
          if (that.asyncTestFn) {
            localData.deltaOffset = 0;
            localData.startTime = that.now();
            that.asyncTestFn(cb);
          } else {
            localData.deltaOffset -= 1;
            cb();
          }
        }, localData.deltaOffset);
        if (typeof this._checkLatencyID.unref === "function") {
          this._checkLatencyID.unref();
        }
      }
      _initLatencyData() {
        return {
          startTime: this.now(),
          minMs: Number.POSITIVE_INFINITY,
          maxMs: Number.NEGATIVE_INFINITY,
          events: 0,
          totalMs: 0
        };
      }
    };
    function isBrowser2() {
      return typeof window !== "undefined";
    }
    module2.exports = LatencyMonitor;
  }
});

// node_modules/libp2p/src/metrics/tracked-map.js
var require_tracked_map = __commonJS({
  "node_modules/libp2p/src/metrics/tracked-map.js"(exports2, module2) {
    "use strict";
    init_globals();
    var TrackedMap = class extends Map {
      constructor(options) {
        super();
        const { system, component, metric, metrics } = options;
        this._system = system;
        this._component = component;
        this._metric = metric;
        this._metrics = metrics;
        this._metrics.updateComponentMetric({
          system: this._system,
          component: this._component,
          metric: this._metric,
          value: this.size
        });
      }
      set(key, value) {
        super.set(key, value);
        this._metrics.updateComponentMetric({
          system: this._system,
          component: this._component,
          metric: this._metric,
          value: this.size
        });
        return this;
      }
      delete(key) {
        const deleted = super.delete(key);
        this._metrics.updateComponentMetric({
          system: this._system,
          component: this._component,
          metric: this._metric,
          value: this.size
        });
        return deleted;
      }
      clear() {
        super.clear();
        this._metrics.updateComponentMetric({
          system: this._system,
          component: this._component,
          metric: this._metric,
          value: this.size
        });
      }
    };
    module2.exports = ({ system = "libp2p", component, metric, metrics }) => {
      let map12;
      if (metrics) {
        map12 = new TrackedMap({ system, component, metric, metrics });
      } else {
        map12 = /* @__PURE__ */ new Map();
      }
      return map12;
    };
  }
});

// node_modules/libp2p/src/connection-manager/index.js
var require_connection_manager = __commonJS({
  "node_modules/libp2p/src/connection-manager/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:connection-manager"), {
      error: debug50("libp2p:connection-manager:err")
    });
    var errcode17 = require_err_code();
    var mergeOptions17 = require_merge_options();
    var LatencyMonitor = require_latency_monitor();
    var retimer = require_retimer();
    var { EventEmitter: EventEmitter4 } = require_events();
    var trackedMap5 = require_tracked_map();
    var PeerId14 = require_src5();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors3();
    var defaultOptions16 = {
      maxConnections: Infinity,
      minConnections: 0,
      maxData: Infinity,
      maxSentData: Infinity,
      maxReceivedData: Infinity,
      maxEventLoopDelay: Infinity,
      pollInterval: 2e3,
      autoDialInterval: 1e4,
      movingAverageInterval: 6e4,
      defaultPeerValue: 1
    };
    var METRICS_COMPONENT = "connection-manager";
    var METRICS_PEER_CONNECTIONS = "peer-connections";
    var METRICS_PEER_VALUES = "peer-values";
    var ConnectionManager = class extends EventEmitter4 {
      constructor(libp2p, options = {}) {
        super();
        this._libp2p = libp2p;
        this._peerId = libp2p.peerId.toB58String();
        this._options = mergeOptions17.call({ ignoreUndefined: true }, defaultOptions16, options);
        if (this._options.maxConnections < this._options.minConnections) {
          throw errcode17(new Error("Connection Manager maxConnections must be greater than minConnections"), ERR_INVALID_PARAMETERS);
        }
        log48("options: %j", this._options);
        this._peerValues = trackedMap5({
          component: METRICS_COMPONENT,
          metric: METRICS_PEER_VALUES,
          metrics: this._libp2p.metrics
        });
        this.connections = trackedMap5({
          component: METRICS_COMPONENT,
          metric: METRICS_PEER_CONNECTIONS,
          metrics: this._libp2p.metrics
        });
        this._started = false;
        this._timer = null;
        this._checkMetrics = this._checkMetrics.bind(this);
        this._latencyMonitor = new LatencyMonitor({
          latencyCheckIntervalMs: this._options.pollInterval,
          dataEmitIntervalMs: this._options.pollInterval
        });
        this.setMaxListeners(Infinity);
      }
      get size() {
        return Array.from(this.connections.values()).reduce((accumulator, value) => accumulator + value.length, 0);
      }
      start() {
        if (this._libp2p.metrics) {
          this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);
        }
        this._latencyMonitor.start();
        this._onLatencyMeasure = this._onLatencyMeasure.bind(this);
        this._latencyMonitor.on("data", this._onLatencyMeasure);
        this._started = true;
        log48("started");
      }
      async stop() {
        this._timer && this._timer.clear();
        this._latencyMonitor.removeListener("data", this._onLatencyMeasure);
        this._latencyMonitor.stop();
        this._started = false;
        await this._close();
        log48("stopped");
      }
      async _close() {
        const tasks = [];
        for (const connectionList of this.connections.values()) {
          for (const connection of connectionList) {
            tasks.push(connection.close());
          }
        }
        await Promise.all(tasks);
        this.connections.clear();
      }
      setPeerValue(peerId, value) {
        if (value < 0 || value > 1) {
          throw new Error("value should be a number between 0 and 1");
        }
        this._peerValues.set(peerId.toB58String(), value);
      }
      async _checkMetrics() {
        if (this._libp2p.metrics) {
          try {
            const movingAverages = this._libp2p.metrics.global.movingAverages;
            const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();
            await this._checkMaxLimit("maxReceivedData", received);
            const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();
            await this._checkMaxLimit("maxSentData", sent);
            const total = received + sent;
            await this._checkMaxLimit("maxData", total);
            log48("metrics update", total);
          } finally {
            this._timer = retimer(this._checkMetrics, this._options.pollInterval);
          }
        }
      }
      async onConnect(connection) {
        if (!this._started) {
          await connection.close();
          return;
        }
        const peerId = connection.remotePeer;
        const peerIdStr = peerId.toB58String();
        const storedConn = this.connections.get(peerIdStr);
        this.emit("peer:connect", connection);
        if (storedConn) {
          storedConn.push(connection);
        } else {
          this.connections.set(peerIdStr, [connection]);
        }
        await this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey);
        if (!this._peerValues.has(peerIdStr)) {
          this._peerValues.set(peerIdStr, this._options.defaultPeerValue);
        }
        await this._checkMaxLimit("maxConnections", this.size);
      }
      onDisconnect(connection) {
        if (!this._started) {
          return;
        }
        const peerId = connection.remotePeer.toB58String();
        let storedConn = this.connections.get(peerId);
        if (storedConn && storedConn.length > 1) {
          storedConn = storedConn.filter((conn) => conn.id !== connection.id);
          this.connections.set(peerId, storedConn);
        } else if (storedConn) {
          this.connections.delete(peerId);
          this._peerValues.delete(connection.remotePeer.toB58String());
          this.emit("peer:disconnect", connection);
          this._libp2p.metrics && this._libp2p.metrics.onPeerDisconnected(connection.remotePeer);
        }
      }
      get(peerId) {
        const connections = this.getAll(peerId);
        if (connections.length) {
          return connections[0];
        }
        return null;
      }
      getAll(peerId) {
        if (!PeerId14.isPeerId(peerId)) {
          throw errcode17(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const id = peerId.toB58String();
        const connections = this.connections.get(id);
        if (connections) {
          return connections.filter((connection) => connection.stat.status === "open");
        }
        return [];
      }
      _onLatencyMeasure(summary) {
        this._checkMaxLimit("maxEventLoopDelay", summary.avgMs).catch((err) => {
          log48.error(err);
        });
      }
      async _checkMaxLimit(name10, value) {
        const limit = this._options[name10];
        log48("checking limit of %s. current value: %d of %d", name10, value, limit);
        if (value > limit) {
          log48("%s: limit exceeded: %s, %d", this._peerId, name10, value);
          await this._maybeDisconnectOne();
        }
      }
      async _maybeDisconnectOne() {
        if (this._options.minConnections < this.connections.size) {
          const peerValues = Array.from(new Map([...this._peerValues.entries()].sort((a, b) => a[1] - b[1])));
          log48("%s: sorted peer values: %j", this._peerId, peerValues);
          const disconnectPeer = peerValues[0];
          if (disconnectPeer) {
            const peerId = disconnectPeer[0];
            log48("%s: lowest value peer is %s", this._peerId, peerId);
            log48("%s: closing a connection to %j", this._peerId, peerId);
            for (const connections of this.connections.values()) {
              if (connections[0].remotePeer.toB58String() === peerId) {
                connections[0].close().catch((err) => {
                  log48.error(err);
                });
                this.onDisconnect(connections[0]);
                break;
              }
            }
          }
        }
      }
    };
    module2.exports = ConnectionManager;
  }
});

// node_modules/libp2p/src/connection-manager/auto-dialler.js
var require_auto_dialler = __commonJS({
  "node_modules/libp2p/src/connection-manager/auto-dialler.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var mergeOptions17 = require_merge_options();
    var retimer = require_retimer();
    var all6 = require_it_all();
    var { pipe: pipe8 } = require_it_pipe();
    var filter10 = require_it_filter();
    var sort2 = require_it_sort();
    var log48 = Object.assign(debug50("libp2p:connection-manager:auto-dialler"), {
      error: debug50("libp2p:connection-manager:auto-dialler:err")
    });
    var defaultOptions16 = {
      enabled: true,
      minConnections: 0,
      autoDialInterval: 1e4
    };
    var AutoDialler = class {
      constructor(libp2p, options = {}) {
        this._options = mergeOptions17.call({ ignoreUndefined: true }, defaultOptions16, options);
        this._libp2p = libp2p;
        this._running = false;
        this._autoDialTimeout = null;
        this._autoDial = this._autoDial.bind(this);
        log48("options: %j", this._options);
      }
      async start() {
        if (!this._options.enabled) {
          log48("not enabled");
          return;
        }
        this._running = true;
        this._autoDial().catch((err) => {
          log48.error("could start autodial", err);
        });
        log48("started");
      }
      async stop() {
        if (!this._options.enabled) {
          log48("not enabled");
          return;
        }
        this._running = false;
        this._autoDialTimeout && this._autoDialTimeout.clear();
        log48("stopped");
      }
      async _autoDial() {
        const minConnections = this._options.minConnections;
        if (this._libp2p.connections.size >= minConnections) {
          this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);
          return;
        }
        const peers = await pipe8(this._libp2p.peerStore.getPeers(), (source) => filter10(source, (peer) => !peer.id.equals(this._libp2p.peerId)), (source) => sort2(source, (a, b) => {
          if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {
            return 1;
          } else if (b.id.pubKey && !a.id.pubKey) {
            return 1;
          }
          return -1;
        }), (source) => all6(source));
        for (let i = 0; this._running && i < peers.length && this._libp2p.connections.size < minConnections; i++) {
          const peer = peers[i];
          if (!this._libp2p.connectionManager.get(peer.id)) {
            log48("connecting to a peerStore stored peer %s", peer.id.toB58String());
            try {
              await this._libp2p.dialer.connectToPeer(peer.id);
            } catch (err) {
              log48.error("could not connect to peerStore stored peer", err);
            }
          }
        }
        if (!this._running) {
          return;
        }
        this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);
      }
    };
    module2.exports = AutoDialler;
  }
});

// node_modules/libp2p/src/circuit/protocol/index.js
var require_protocol = __commonJS({
  "node_modules/libp2p/src/circuit/protocol/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var $protobuf12 = require_minimal2();
    var $Reader11 = $protobuf12.Reader;
    var $Writer11 = $protobuf12.Writer;
    var $util11 = $protobuf12.util;
    var $root11 = $protobuf12.roots["libp2p-circuit"] || ($protobuf12.roots["libp2p-circuit"] = {});
    $root11.CircuitRelay = function() {
      function CircuitRelay(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      CircuitRelay.prototype.type = 1;
      CircuitRelay.prototype.srcPeer = null;
      CircuitRelay.prototype.dstPeer = null;
      CircuitRelay.prototype.code = 100;
      CircuitRelay.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.type != null && Object.hasOwnProperty.call(m, "type"))
          w.uint32(8).int32(m.type);
        if (m.srcPeer != null && Object.hasOwnProperty.call(m, "srcPeer"))
          $root11.CircuitRelay.Peer.encode(m.srcPeer, w.uint32(18).fork()).ldelim();
        if (m.dstPeer != null && Object.hasOwnProperty.call(m, "dstPeer"))
          $root11.CircuitRelay.Peer.encode(m.dstPeer, w.uint32(26).fork()).ldelim();
        if (m.code != null && Object.hasOwnProperty.call(m, "code"))
          w.uint32(32).int32(m.code);
        return w;
      };
      CircuitRelay.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.CircuitRelay();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.type = r.int32();
              break;
            case 2:
              m.srcPeer = $root11.CircuitRelay.Peer.decode(r, r.uint32());
              break;
            case 3:
              m.dstPeer = $root11.CircuitRelay.Peer.decode(r, r.uint32());
              break;
            case 4:
              m.code = r.int32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      CircuitRelay.fromObject = function fromObject(d) {
        if (d instanceof $root11.CircuitRelay)
          return d;
        var m = new $root11.CircuitRelay();
        switch (d.type) {
          case "HOP":
          case 1:
            m.type = 1;
            break;
          case "STOP":
          case 2:
            m.type = 2;
            break;
          case "STATUS":
          case 3:
            m.type = 3;
            break;
          case "CAN_HOP":
          case 4:
            m.type = 4;
            break;
        }
        if (d.srcPeer != null) {
          if (typeof d.srcPeer !== "object")
            throw TypeError(".CircuitRelay.srcPeer: object expected");
          m.srcPeer = $root11.CircuitRelay.Peer.fromObject(d.srcPeer);
        }
        if (d.dstPeer != null) {
          if (typeof d.dstPeer !== "object")
            throw TypeError(".CircuitRelay.dstPeer: object expected");
          m.dstPeer = $root11.CircuitRelay.Peer.fromObject(d.dstPeer);
        }
        switch (d.code) {
          case "SUCCESS":
          case 100:
            m.code = 100;
            break;
          case "HOP_SRC_ADDR_TOO_LONG":
          case 220:
            m.code = 220;
            break;
          case "HOP_DST_ADDR_TOO_LONG":
          case 221:
            m.code = 221;
            break;
          case "HOP_SRC_MULTIADDR_INVALID":
          case 250:
            m.code = 250;
            break;
          case "HOP_DST_MULTIADDR_INVALID":
          case 251:
            m.code = 251;
            break;
          case "HOP_NO_CONN_TO_DST":
          case 260:
            m.code = 260;
            break;
          case "HOP_CANT_DIAL_DST":
          case 261:
            m.code = 261;
            break;
          case "HOP_CANT_OPEN_DST_STREAM":
          case 262:
            m.code = 262;
            break;
          case "HOP_CANT_SPEAK_RELAY":
          case 270:
            m.code = 270;
            break;
          case "HOP_CANT_RELAY_TO_SELF":
          case 280:
            m.code = 280;
            break;
          case "STOP_SRC_ADDR_TOO_LONG":
          case 320:
            m.code = 320;
            break;
          case "STOP_DST_ADDR_TOO_LONG":
          case 321:
            m.code = 321;
            break;
          case "STOP_SRC_MULTIADDR_INVALID":
          case 350:
            m.code = 350;
            break;
          case "STOP_DST_MULTIADDR_INVALID":
          case 351:
            m.code = 351;
            break;
          case "STOP_RELAY_REFUSED":
          case 390:
            m.code = 390;
            break;
          case "MALFORMED_MESSAGE":
          case 400:
            m.code = 400;
            break;
        }
        return m;
      };
      CircuitRelay.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.type = o.enums === String ? "HOP" : 1;
          d.srcPeer = null;
          d.dstPeer = null;
          d.code = o.enums === String ? "SUCCESS" : 100;
        }
        if (m.type != null && m.hasOwnProperty("type")) {
          d.type = o.enums === String ? $root11.CircuitRelay.Type[m.type] : m.type;
        }
        if (m.srcPeer != null && m.hasOwnProperty("srcPeer")) {
          d.srcPeer = $root11.CircuitRelay.Peer.toObject(m.srcPeer, o);
        }
        if (m.dstPeer != null && m.hasOwnProperty("dstPeer")) {
          d.dstPeer = $root11.CircuitRelay.Peer.toObject(m.dstPeer, o);
        }
        if (m.code != null && m.hasOwnProperty("code")) {
          d.code = o.enums === String ? $root11.CircuitRelay.Status[m.code] : m.code;
        }
        return d;
      };
      CircuitRelay.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      CircuitRelay.Status = function() {
        var valuesById = {}, values2 = Object.create(valuesById);
        values2[valuesById[100] = "SUCCESS"] = 100;
        values2[valuesById[220] = "HOP_SRC_ADDR_TOO_LONG"] = 220;
        values2[valuesById[221] = "HOP_DST_ADDR_TOO_LONG"] = 221;
        values2[valuesById[250] = "HOP_SRC_MULTIADDR_INVALID"] = 250;
        values2[valuesById[251] = "HOP_DST_MULTIADDR_INVALID"] = 251;
        values2[valuesById[260] = "HOP_NO_CONN_TO_DST"] = 260;
        values2[valuesById[261] = "HOP_CANT_DIAL_DST"] = 261;
        values2[valuesById[262] = "HOP_CANT_OPEN_DST_STREAM"] = 262;
        values2[valuesById[270] = "HOP_CANT_SPEAK_RELAY"] = 270;
        values2[valuesById[280] = "HOP_CANT_RELAY_TO_SELF"] = 280;
        values2[valuesById[320] = "STOP_SRC_ADDR_TOO_LONG"] = 320;
        values2[valuesById[321] = "STOP_DST_ADDR_TOO_LONG"] = 321;
        values2[valuesById[350] = "STOP_SRC_MULTIADDR_INVALID"] = 350;
        values2[valuesById[351] = "STOP_DST_MULTIADDR_INVALID"] = 351;
        values2[valuesById[390] = "STOP_RELAY_REFUSED"] = 390;
        values2[valuesById[400] = "MALFORMED_MESSAGE"] = 400;
        return values2;
      }();
      CircuitRelay.Type = function() {
        var valuesById = {}, values2 = Object.create(valuesById);
        values2[valuesById[1] = "HOP"] = 1;
        values2[valuesById[2] = "STOP"] = 2;
        values2[valuesById[3] = "STATUS"] = 3;
        values2[valuesById[4] = "CAN_HOP"] = 4;
        return values2;
      }();
      CircuitRelay.Peer = function() {
        function Peer3(p) {
          this.addrs = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Peer3.prototype.id = $util11.newBuffer([]);
        Peer3.prototype.addrs = $util11.emptyArray;
        Peer3.encode = function encode19(m, w) {
          if (!w)
            w = $Writer11.create();
          w.uint32(10).bytes(m.id);
          if (m.addrs != null && m.addrs.length) {
            for (var i = 0; i < m.addrs.length; ++i)
              w.uint32(18).bytes(m.addrs[i]);
          }
          return w;
        };
        Peer3.decode = function decode22(r, l) {
          if (!(r instanceof $Reader11))
            r = $Reader11.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root11.CircuitRelay.Peer();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.id = r.bytes();
                break;
              case 2:
                if (!(m.addrs && m.addrs.length))
                  m.addrs = [];
                m.addrs.push(r.bytes());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          if (!m.hasOwnProperty("id"))
            throw $util11.ProtocolError("missing required 'id'", { instance: m });
          return m;
        };
        Peer3.fromObject = function fromObject(d) {
          if (d instanceof $root11.CircuitRelay.Peer)
            return d;
          var m = new $root11.CircuitRelay.Peer();
          if (d.id != null) {
            if (typeof d.id === "string")
              $util11.base64.decode(d.id, m.id = $util11.newBuffer($util11.base64.length(d.id)), 0);
            else if (d.id.length)
              m.id = d.id;
          }
          if (d.addrs) {
            if (!Array.isArray(d.addrs))
              throw TypeError(".CircuitRelay.Peer.addrs: array expected");
            m.addrs = [];
            for (var i = 0; i < d.addrs.length; ++i) {
              if (typeof d.addrs[i] === "string")
                $util11.base64.decode(d.addrs[i], m.addrs[i] = $util11.newBuffer($util11.base64.length(d.addrs[i])), 0);
              else if (d.addrs[i].length)
                m.addrs[i] = d.addrs[i];
            }
          }
          return m;
        };
        Peer3.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.addrs = [];
          }
          if (o.defaults) {
            if (o.bytes === String)
              d.id = "";
            else {
              d.id = [];
              if (o.bytes !== Array)
                d.id = $util11.newBuffer(d.id);
            }
          }
          if (m.id != null && m.hasOwnProperty("id")) {
            d.id = o.bytes === String ? $util11.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;
          }
          if (m.addrs && m.addrs.length) {
            d.addrs = [];
            for (var j = 0; j < m.addrs.length; ++j) {
              d.addrs[j] = o.bytes === String ? $util11.base64.encode(m.addrs[j], 0, m.addrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.addrs[j]) : m.addrs[j];
            }
          }
          return d;
        };
        Peer3.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
        };
        return Peer3;
      }();
      return CircuitRelay;
    }();
    module2.exports = $root11;
  }
});

// node_modules/libp2p-utils/src/stream-to-ma-conn.js
var require_stream_to_ma_conn = __commonJS({
  "node_modules/libp2p-utils/src/stream-to-ma-conn.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { source: abortable } = require_abortable_iterator();
    var debug50 = require_browser2();
    var log48 = debug50("libp2p:stream:converter");
    function streamToMaConnection({ stream, remoteAddr, localAddr }, options = {}) {
      const { sink, source } = stream;
      const maConn = {
        async sink(source2) {
          if (options.signal) {
            source2 = abortable(source2, options.signal);
          }
          try {
            await sink(source2);
          } catch (err) {
            if (err.type !== "aborted") {
              log48(err);
            }
          }
          close();
        },
        source: options.signal ? abortable(source, options.signal) : source,
        conn: stream,
        localAddr,
        remoteAddr,
        timeline: { open: Date.now(), close: void 0 },
        close() {
          sink(new Uint8Array(0));
          return close();
        }
      };
      function close() {
        if (!maConn.timeline.close) {
          maConn.timeline.close = Date.now();
        }
        return Promise.resolve();
      }
      return maConn;
    }
    module2.exports = streamToMaConnection;
  }
});

// node_modules/libp2p/src/circuit/multicodec.js
var require_multicodec = __commonJS({
  "node_modules/libp2p/src/circuit/multicodec.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      relay: "/libp2p/circuit/relay/0.1.0"
    };
  }
});

// node_modules/libp2p/src/circuit/listener.js
var require_listener2 = __commonJS({
  "node_modules/libp2p/src/circuit/listener.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { EventEmitter: EventEmitter4 } = require_events();
    var { Multiaddr: Multiaddr22 } = require_src();
    module2.exports = (libp2p) => {
      const listeningAddrs = /* @__PURE__ */ new Map();
      async function listen(addr) {
        const addrString = String(addr).split("/p2p-circuit").find((a) => a !== "");
        const relayConn = await libp2p.dial(new Multiaddr22(addrString));
        const relayedAddr = relayConn.remoteAddr.encapsulate("/p2p-circuit");
        listeningAddrs.set(relayConn.remotePeer.toB58String(), relayedAddr);
        listener.emit("listening");
      }
      function getAddrs() {
        const addrs = [];
        for (const addr of listeningAddrs.values()) {
          addrs.push(addr);
        }
        return addrs;
      }
      const listener = Object.assign(new EventEmitter4(), {
        close: () => Promise.resolve(),
        listen,
        getAddrs
      });
      libp2p.connectionManager.on("peer:disconnect", (connection) => {
        const deleted = listeningAddrs.delete(connection.remotePeer.toB58String());
        if (deleted) {
          listener.emit("close");
        }
      });
      return listener;
    };
  }
});

// node_modules/libp2p/src/circuit/circuit/utils.js
var require_utils11 = __commonJS({
  "node_modules/libp2p/src/circuit/circuit/utils.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { Multiaddr: Multiaddr22 } = require_src();
    var { CircuitRelay } = require_protocol();
    function writeResponse(streamHandler, status) {
      streamHandler.write({
        type: CircuitRelay.Type.STATUS,
        code: status
      });
    }
    function validateAddrs(msg, streamHandler) {
      try {
        if (msg.dstPeer && msg.dstPeer.addrs) {
          msg.dstPeer.addrs.forEach((addr) => {
            return new Multiaddr22(addr);
          });
        }
      } catch (err) {
        writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);
        throw err;
      }
      try {
        if (msg.srcPeer && msg.srcPeer.addrs) {
          msg.srcPeer.addrs.forEach((addr) => {
            return new Multiaddr22(addr);
          });
        }
      } catch (err) {
        writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);
        throw err;
      }
    }
    module2.exports = {
      validateAddrs
    };
  }
});

// node_modules/libp2p/src/circuit/circuit/stream-handler.js
var require_stream_handler = __commonJS({
  "node_modules/libp2p/src/circuit/circuit/stream-handler.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:circuit:stream-handler"), {
      error: debug50("libp2p:circuit:stream-handler:err")
    });
    var lp2 = require_src11();
    var handshake = require_src18();
    var { CircuitRelay } = require_protocol();
    var StreamHandler = class {
      constructor({ stream, maxLength = 4096 }) {
        this.stream = stream;
        this.shake = handshake(this.stream);
        this.decoder = lp2.decode.fromReader(this.shake.reader, { maxDataLength: maxLength });
      }
      async read() {
        const msg = await this.decoder.next();
        if (msg.value) {
          const value = CircuitRelay.decode(msg.value.slice());
          log48("read message type", value.type);
          return value;
        }
        log48("read received no value, closing stream");
        this.close();
      }
      write(msg) {
        log48("write message type %s", msg.type);
        this.shake.write(lp2.encode.single(CircuitRelay.encode(msg).finish()));
      }
      rest() {
        this.shake.rest();
        return this.shake.stream;
      }
      end(msg) {
        this.write(msg);
        this.close();
      }
      close() {
        log48("closing the stream");
        this.rest().sink([]);
      }
    };
    module2.exports = StreamHandler;
  }
});

// node_modules/libp2p/src/circuit/circuit/stop.js
var require_stop = __commonJS({
  "node_modules/libp2p/src/circuit/circuit/stop.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:circuit:stop"), {
      error: debug50("libp2p:circuit:stop:err")
    });
    var { CircuitRelay: CircuitPB } = require_protocol();
    var multicodec = require_multicodec();
    var StreamHandler = require_stream_handler();
    var { validateAddrs } = require_utils11();
    module2.exports.handleStop = function handleStop({
      connection,
      request,
      streamHandler
    }) {
      try {
        validateAddrs(request, streamHandler);
      } catch (err) {
        return log48.error("invalid stop request via peer %s", connection.remotePeer.toB58String(), err);
      }
      log48("stop request is valid");
      streamHandler.write({
        type: CircuitPB.Type.STATUS,
        code: CircuitPB.Status.SUCCESS
      });
      return streamHandler.rest();
    };
    module2.exports.stop = async function stop({
      connection,
      request
    }) {
      const { stream } = await connection.newStream([multicodec.relay]);
      log48("starting stop request to %s", connection.remotePeer.toB58String());
      const streamHandler = new StreamHandler({ stream });
      streamHandler.write(request);
      const response = await streamHandler.read();
      if (!response) {
        return streamHandler.close();
      }
      if (response.code === CircuitPB.Status.SUCCESS) {
        log48("stop request to %s was successful", connection.remotePeer.toB58String());
        return streamHandler.rest();
      }
      log48("stop request failed with code %d", response.code);
      streamHandler.close();
    };
  }
});

// node_modules/libp2p/src/circuit/circuit/hop.js
var require_hop = __commonJS({
  "node_modules/libp2p/src/circuit/circuit/hop.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:circuit:hop"), {
      error: debug50("libp2p:circuit:hop:err")
    });
    var errCode69 = require_err_code();
    var PeerId14 = require_src5();
    var { validateAddrs } = require_utils11();
    var StreamHandler = require_stream_handler();
    var { CircuitRelay: CircuitPB } = require_protocol();
    var { pipe: pipe8 } = require_it_pipe();
    var { codes: Errors3 } = require_errors3();
    var { stop } = require_stop();
    var multicodec = require_multicodec();
    async function handleHop({
      connection,
      request,
      streamHandler,
      circuit
    }) {
      if (!circuit._options.hop.enabled) {
        log48("HOP request received but we are not acting as a relay");
        return streamHandler.end({
          type: CircuitPB.Type.STATUS,
          code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY
        });
      }
      try {
        validateAddrs(request, streamHandler);
      } catch (err) {
        return log48.error("invalid hop request via peer %s", connection.remotePeer.toB58String(), err);
      }
      if (!request.dstPeer) {
        log48("HOP request received but we do not receive a dstPeer");
        return;
      }
      const destinationPeer = new PeerId14(request.dstPeer.id);
      const destinationConnection = circuit._connectionManager.get(destinationPeer);
      if (!destinationConnection && !circuit._options.hop.active) {
        log48("HOP request received but we are not connected to the destination peer");
        return streamHandler.end({
          type: CircuitPB.Type.STATUS,
          code: CircuitPB.Status.HOP_NO_CONN_TO_DST
        });
      }
      if (!destinationConnection) {
        return;
      }
      const stopRequest = {
        type: CircuitPB.Type.STOP,
        dstPeer: request.dstPeer,
        srcPeer: request.srcPeer
      };
      let destinationStream;
      try {
        destinationStream = await stop({
          connection: destinationConnection,
          request: stopRequest
        });
      } catch (err) {
        return log48.error(err);
      }
      log48("hop request from %s is valid", connection.remotePeer.toB58String());
      streamHandler.write({
        type: CircuitPB.Type.STATUS,
        code: CircuitPB.Status.SUCCESS
      });
      const sourceStream = streamHandler.rest();
      return pipe8(sourceStream, destinationStream, sourceStream);
    }
    async function hop({
      connection,
      request
    }) {
      const { stream } = await connection.newStream([multicodec.relay]);
      const streamHandler = new StreamHandler({ stream });
      streamHandler.write(request);
      const response = await streamHandler.read();
      if (!response) {
        throw errCode69(new Error("HOP request had no response"), Errors3.ERR_HOP_REQUEST_FAILED);
      }
      if (response.code === CircuitPB.Status.SUCCESS) {
        log48("hop request was successful");
        return streamHandler.rest();
      }
      log48("hop request failed with code %d, closing stream", response.code);
      streamHandler.close();
      throw errCode69(new Error(`HOP request failed with code ${response.code}`), Errors3.ERR_HOP_REQUEST_FAILED);
    }
    async function canHop({
      connection
    }) {
      const { stream } = await connection.newStream([multicodec.relay]);
      const streamHandler = new StreamHandler({ stream });
      streamHandler.write({
        type: CircuitPB.Type.CAN_HOP
      });
      const response = await streamHandler.read();
      await streamHandler.close();
      if (!response || response.code !== CircuitPB.Status.SUCCESS) {
        return false;
      }
      return true;
    }
    function handleCanHop({
      connection,
      streamHandler,
      circuit
    }) {
      const canHop2 = circuit._options.hop.enabled;
      log48("can hop (%s) request from %s", canHop2, connection.remotePeer.toB58String());
      streamHandler.end({
        type: CircuitPB.Type.STATUS,
        code: canHop2 ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY
      });
    }
    module2.exports = {
      handleHop,
      hop,
      canHop,
      handleCanHop
    };
  }
});

// node_modules/libp2p/src/circuit/transport.js
var require_transport2 = __commonJS({
  "node_modules/libp2p/src/circuit/transport.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:circuit"), {
      error: debug50("libp2p:circuit:err")
    });
    var errCode69 = require_err_code();
    var mafmt2 = require_src2();
    var { Multiaddr: Multiaddr22 } = require_src();
    var PeerId14 = require_src5();
    var { CircuitRelay: CircuitPB } = require_protocol();
    var { codes } = require_errors3();
    var toConnection = require_stream_to_ma_conn();
    var { relay: multicodec } = require_multicodec();
    var createListener = require_listener2();
    var { handleCanHop, handleHop, hop } = require_hop();
    var { handleStop } = require_stop();
    var StreamHandler = require_stream_handler();
    var transportSymbol = Symbol.for("@libp2p/js-libp2p-circuit/circuit");
    var Circuit = class {
      constructor({ libp2p, upgrader }) {
        this._dialer = libp2p.dialer;
        this._registrar = libp2p.registrar;
        this._connectionManager = libp2p.connectionManager;
        this._upgrader = upgrader;
        this._options = libp2p._config.relay;
        this._libp2p = libp2p;
        this.peerId = libp2p.peerId;
        this._registrar.handle(multicodec, this._onProtocol.bind(this));
      }
      async _onProtocol({ connection, stream }) {
        const streamHandler = new StreamHandler({ stream });
        const request = await streamHandler.read();
        if (!request) {
          return;
        }
        const circuit = this;
        let virtualConnection;
        switch (request.type) {
          case CircuitPB.Type.CAN_HOP: {
            log48("received CAN_HOP request from %s", connection.remotePeer.toB58String());
            await handleCanHop({ circuit, connection, streamHandler });
            break;
          }
          case CircuitPB.Type.HOP: {
            log48("received HOP request from %s", connection.remotePeer.toB58String());
            virtualConnection = await handleHop({
              connection,
              request,
              streamHandler,
              circuit
            });
            break;
          }
          case CircuitPB.Type.STOP: {
            log48("received STOP request from %s", connection.remotePeer.toB58String());
            virtualConnection = await handleStop({
              connection,
              request,
              streamHandler
            });
            break;
          }
          default: {
            log48("Request of type %s not supported", request.type);
          }
        }
        if (virtualConnection) {
          const remoteAddr = new Multiaddr22(request.dstPeer.addrs[0]);
          const localAddr = new Multiaddr22(request.srcPeer.addrs[0]);
          const maConn = toConnection({
            stream: virtualConnection,
            remoteAddr,
            localAddr
          });
          const type = request.type === CircuitPB.Type.HOP ? "relay" : "inbound";
          log48("new %s connection %s", type, maConn.remoteAddr);
          const conn = await this._upgrader.upgradeInbound(maConn);
          log48("%s connection %s upgraded", type, maConn.remoteAddr);
          this.handler && this.handler(conn);
        }
      }
      async dial(ma, options) {
        const addrs = ma.toString().split("/p2p-circuit");
        const relayAddr = new Multiaddr22(addrs[0]);
        const destinationAddr = new Multiaddr22(addrs[addrs.length - 1]);
        const relayId = relayAddr.getPeerId();
        const destinationId = destinationAddr.getPeerId();
        if (!relayId || !destinationId) {
          const errMsg = "Circuit relay dial failed as addresses did not have peer id";
          log48.error(errMsg);
          throw errCode69(new Error(errMsg), codes.ERR_RELAYED_DIAL);
        }
        const relayPeer = PeerId14.createFromB58String(relayId);
        const destinationPeer = PeerId14.createFromB58String(destinationId);
        let disconnectOnFailure = false;
        let relayConnection = this._connectionManager.get(relayPeer);
        if (!relayConnection) {
          relayConnection = await this._dialer.connectToPeer(relayAddr, options);
          disconnectOnFailure = true;
        }
        try {
          const virtualConnection = await hop({
            connection: relayConnection,
            request: {
              type: CircuitPB.Type.HOP,
              srcPeer: {
                id: this.peerId.toBytes(),
                addrs: this._libp2p.multiaddrs.map((addr) => addr.bytes)
              },
              dstPeer: {
                id: destinationPeer.toBytes(),
                addrs: [new Multiaddr22(destinationAddr).bytes]
              }
            }
          });
          const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toB58String()}`);
          const maConn = toConnection({
            stream: virtualConnection,
            remoteAddr: ma,
            localAddr
          });
          log48("new outbound connection %s", maConn.remoteAddr);
          return this._upgrader.upgradeOutbound(maConn);
        } catch (err) {
          log48.error("Circuit relay dial failed", err);
          disconnectOnFailure && await relayConnection.close();
          throw err;
        }
      }
      createListener(options, handler) {
        if (typeof options === "function") {
          handler = options;
          options = {};
        }
        this.handler = handler;
        return createListener(this._libp2p);
      }
      filter(multiaddrs) {
        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
        return multiaddrs.filter((ma) => {
          return mafmt2.Circuit.matches(ma);
        });
      }
      get [Symbol.toStringTag]() {
        return "Circuit";
      }
      static isTransport(other) {
        return Boolean(other && other[transportSymbol]);
      }
    };
    module2.exports = Circuit;
  }
});

// node_modules/libp2p/src/circuit/utils.js
var require_utils12 = __commonJS({
  "node_modules/libp2p/src/circuit/utils.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { CID: CID3 } = (init_cid(), __toCommonJS(cid_exports));
    var { sha256: sha2563 } = (init_sha2_browser(), __toCommonJS(sha2_browser_exports));
    module2.exports.namespaceToCid = async (namespace3) => {
      const bytes2 = new TextEncoder().encode(namespace3);
      const hash2 = await sha2563.digest(bytes2);
      return CID3.createV0(hash2);
    };
  }
});

// node_modules/libp2p/src/circuit/auto-relay.js
var require_auto_relay = __commonJS({
  "node_modules/libp2p/src/circuit/auto-relay.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:auto-relay"), {
      error: debug50("libp2p:auto-relay:err")
    });
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { Multiaddr: Multiaddr22 } = require_src();
    var all6 = require_it_all();
    var { relay: multicodec } = require_multicodec();
    var { canHop } = require_hop();
    var { namespaceToCid } = require_utils12();
    var {
      CIRCUIT_PROTO_CODE,
      HOP_METADATA_KEY,
      HOP_METADATA_VALUE,
      RELAY_RENDEZVOUS_NS
    } = require_constants12();
    var AutoRelay = class {
      constructor({ libp2p, maxListeners: maxListeners2 = 1, onError }) {
        this._libp2p = libp2p;
        this._peerId = libp2p.peerId;
        this._peerStore = libp2p.peerStore;
        this._connectionManager = libp2p.connectionManager;
        this._transportManager = libp2p.transportManager;
        this._addressSorter = libp2p.dialer.addressSorter;
        this.maxListeners = maxListeners2;
        this._listenRelays = /* @__PURE__ */ new Set();
        this._onProtocolChange = this._onProtocolChange.bind(this);
        this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
        this._peerStore.on("change:protocols", this._onProtocolChange);
        this._connectionManager.on("peer:disconnect", this._onPeerDisconnected);
        this._onError = (error, msg) => {
          log48.error(msg || error);
          onError && onError(error, msg);
        };
      }
      async _onProtocolChange({ peerId, protocols }) {
        const id = peerId.toB58String();
        const hasProtocol = protocols.find((protocol) => protocol === multicodec);
        if (!hasProtocol && this._listenRelays.has(id)) {
          await this._removeListenRelay(id);
          return;
        } else if (!hasProtocol || this._listenRelays.has(id)) {
          return;
        }
        try {
          const connection = this._connectionManager.get(peerId);
          if (!connection) {
            return;
          }
          if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {
            log48(`relayed connection to ${id} will not be used to hop on`);
            return;
          }
          const supportsHop = await canHop({ connection });
          if (supportsHop) {
            await this._peerStore.metadataBook.setValue(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));
            await this._addListenRelay(connection, id);
          }
        } catch (err) {
          this._onError(err);
        }
      }
      _onPeerDisconnected(connection) {
        const peerId = connection.remotePeer;
        const id = peerId.toB58String();
        if (!this._listenRelays.has(id)) {
          return;
        }
        this._removeListenRelay(id).catch((err) => {
          log48.error(err);
        });
      }
      async _addListenRelay(connection, id) {
        try {
          if (this._listenRelays.size >= this.maxListeners) {
            return;
          }
          const remoteAddrs = await this._peerStore.addressBook.getMultiaddrsForPeer(connection.remotePeer, this._addressSorter);
          const result = await Promise.all(remoteAddrs.map(async (addr) => {
            try {
              await this._transportManager.listen([new Multiaddr22(`${addr.toString()}/p2p-circuit`)]);
              return true;
            } catch (err) {
              this._onError(err);
            }
            return false;
          }));
          if (result.includes(true)) {
            this._listenRelays.add(id);
          }
        } catch (err) {
          this._onError(err);
          this._listenRelays.delete(id);
        }
      }
      async _removeListenRelay(id) {
        if (this._listenRelays.delete(id)) {
          await this._listenOnAvailableHopRelays([id]);
        }
      }
      async _listenOnAvailableHopRelays(peersToIgnore = []) {
        if (this._listenRelays.size >= this.maxListeners) {
          return;
        }
        const knownHopsToDial = [];
        const peers = await all6(this._peerStore.getPeers());
        for await (const { id, metadata } of peers) {
          const idStr = id.toB58String();
          if (this._listenRelays.has(idStr)) {
            continue;
          }
          if (peersToIgnore.includes(idStr)) {
            continue;
          }
          const supportsHop = metadata.get(HOP_METADATA_KEY);
          if (!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {
            continue;
          }
          const connection = this._connectionManager.get(id);
          if (!connection) {
            knownHopsToDial.push(id);
            continue;
          }
          await this._addListenRelay(connection, idStr);
          if (this._listenRelays.size >= this.maxListeners) {
            return;
          }
        }
        for (const peerId of knownHopsToDial) {
          await this._tryToListenOnRelay(peerId);
          if (this._listenRelays.size >= this.maxListeners) {
            return;
          }
        }
        try {
          const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
          for await (const provider of this._libp2p.contentRouting.findProviders(cid)) {
            if (!provider.multiaddrs.length) {
              continue;
            }
            const peerId = provider.id;
            await this._peerStore.addressBook.add(peerId, provider.multiaddrs);
            await this._tryToListenOnRelay(peerId);
            if (this._listenRelays.size >= this.maxListeners) {
              return;
            }
          }
        } catch (err) {
          this._onError(err);
        }
      }
      async _tryToListenOnRelay(peerId) {
        try {
          const connection = await this._libp2p.dial(peerId);
          await this._addListenRelay(connection, peerId.toB58String());
        } catch (err) {
          this._onError(err, `could not connect and listen on known hop relay ${peerId.toB58String()}`);
        }
      }
    };
    module2.exports = AutoRelay;
  }
});

// node_modules/libp2p/src/circuit/index.js
var require_circuit = __commonJS({
  "node_modules/libp2p/src/circuit/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:relay"), {
      error: debug50("libp2p:relay:err")
    });
    var { codes } = require_errors3();
    var {
      setDelayedInterval,
      clearDelayedInterval
    } = require_src23();
    var AutoRelay = require_auto_relay();
    var { namespaceToCid } = require_utils12();
    var {
      RELAY_RENDEZVOUS_NS
    } = require_constants12();
    var Relay = class {
      constructor(libp2p) {
        this._libp2p = libp2p;
        this._options = {
          ...libp2p._config.relay
        };
        this._autoRelay = this._options.autoRelay.enabled && new AutoRelay({ libp2p, ...this._options.autoRelay });
        this._advertiseService = this._advertiseService.bind(this);
      }
      start() {
        const canHop = this._options.hop.enabled;
        if (canHop && this._options.advertise.enabled) {
          this._timeout = setDelayedInterval(this._advertiseService, this._options.advertise.ttl, this._options.advertise.bootDelay);
        }
      }
      stop() {
        clearDelayedInterval(this._timeout);
      }
      async _advertiseService() {
        try {
          const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
          await this._libp2p.contentRouting.provide(cid);
        } catch (err) {
          if (err.code === codes.ERR_NO_ROUTERS_AVAILABLE) {
            log48.error("a content router, such as a DHT, must be provided in order to advertise the relay service", err);
            this.stop();
          } else {
            log48.error(err);
          }
        }
      }
    };
    module2.exports = Relay;
  }
});

// node_modules/p-fifo/index.js
var require_p_fifo = __commonJS({
  "node_modules/p-fifo/index.js"(exports2, module2) {
    init_globals();
    var Fifo = require_fast_fifo();
    var defer = require_p_defer();
    module2.exports = class PFifo {
      constructor() {
        this._buffer = new Fifo();
        this._waitingConsumers = new Fifo();
      }
      push(chunk) {
        const { promise, resolve: resolve11 } = defer();
        this._buffer.push({ chunk, resolve: resolve11 });
        this._consume();
        return promise;
      }
      _consume() {
        while (!this._waitingConsumers.isEmpty() && !this._buffer.isEmpty()) {
          const nextConsumer = this._waitingConsumers.shift();
          const nextChunk = this._buffer.shift();
          nextConsumer.resolve(nextChunk.chunk);
          nextChunk.resolve();
        }
      }
      shift() {
        const { promise, resolve: resolve11 } = defer();
        this._waitingConsumers.push({ resolve: resolve11 });
        this._consume();
        return promise;
      }
      isEmpty() {
        return this._buffer.isEmpty();
      }
    };
  }
});

// node_modules/p-cancelable/index.js
var require_p_cancelable = __commonJS({
  "node_modules/p-cancelable/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var CancelError = class extends Error {
      constructor(reason) {
        super(reason || "Promise was canceled");
        this.name = "CancelError";
      }
      get isCanceled() {
        return true;
      }
    };
    var PCancelable = class {
      static fn(userFn) {
        return (...arguments_) => {
          return new PCancelable((resolve11, reject, onCancel) => {
            arguments_.push(onCancel);
            userFn(...arguments_).then(resolve11, reject);
          });
        };
      }
      constructor(executor) {
        this._cancelHandlers = [];
        this._isPending = true;
        this._isCanceled = false;
        this._rejectOnCancel = true;
        this._promise = new Promise((resolve11, reject) => {
          this._reject = reject;
          const onResolve = (value) => {
            if (!this._isCanceled || !onCancel.shouldReject) {
              this._isPending = false;
              resolve11(value);
            }
          };
          const onReject = (error) => {
            this._isPending = false;
            reject(error);
          };
          const onCancel = (handler) => {
            if (!this._isPending) {
              throw new Error("The `onCancel` handler was attached after the promise settled.");
            }
            this._cancelHandlers.push(handler);
          };
          Object.defineProperties(onCancel, {
            shouldReject: {
              get: () => this._rejectOnCancel,
              set: (boolean) => {
                this._rejectOnCancel = boolean;
              }
            }
          });
          return executor(onResolve, onReject, onCancel);
        });
      }
      then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this._promise.catch(onRejected);
      }
      finally(onFinally) {
        return this._promise.finally(onFinally);
      }
      cancel(reason) {
        if (!this._isPending || this._isCanceled) {
          return;
        }
        this._isCanceled = true;
        if (this._cancelHandlers.length > 0) {
          try {
            for (const handler of this._cancelHandlers) {
              handler();
            }
          } catch (error) {
            this._reject(error);
            return;
          }
        }
        if (this._rejectOnCancel) {
          this._reject(new CancelError(reason));
        }
      }
      get isCanceled() {
        return this._isCanceled;
      }
    };
    Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
    module2.exports = PCancelable;
    module2.exports.CancelError = CancelError;
  }
});

// node_modules/p-some/index.js
var require_p_some = __commonJS({
  "node_modules/p-some/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var AggregateError2 = require_aggregate_error();
    var PCancelable = require_p_cancelable();
    var FilterError = class extends Error {
    };
    var pSome = (iterable, options) => new PCancelable((resolve11, reject, onCancel) => {
      const {
        count,
        filter: filter10 = () => true
      } = options;
      if (!Number.isFinite(count)) {
        reject(new TypeError(`Expected a finite number, got ${typeof options.count}`));
        return;
      }
      const values2 = [];
      const errors2 = [];
      let elementCount = 0;
      let isSettled = false;
      const completed = /* @__PURE__ */ new Set();
      const maybeSettle = () => {
        if (values2.length === count) {
          resolve11(values2);
          isSettled = true;
        }
        if (elementCount - errors2.length < count) {
          reject(new AggregateError2(errors2));
          isSettled = true;
        }
        return isSettled;
      };
      const cancelPending = () => {
        for (const promise of iterable) {
          if (!completed.has(promise) && typeof promise.cancel === "function") {
            promise.cancel();
          }
        }
      };
      onCancel(cancelPending);
      for (const element of iterable) {
        elementCount++;
        (async () => {
          try {
            const value = await element;
            if (isSettled) {
              return;
            }
            if (!filter10(value)) {
              throw new FilterError("Value does not satisfy filter");
            }
            values2.push(value);
          } catch (error) {
            errors2.push(error);
          } finally {
            completed.add(element);
            if (!isSettled && maybeSettle()) {
              cancelPending();
            }
          }
        })();
      }
      if (count > elementCount) {
        reject(new RangeError(`Expected input to contain at least ${options.count} items, but contains ${elementCount} items`));
        cancelPending();
      }
    });
    module2.exports = pSome;
    module2.exports.AggregateError = AggregateError2;
    module2.exports.FilterError = FilterError;
  }
});

// node_modules/p-any/index.js
var require_p_any = __commonJS({
  "node_modules/p-any/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var pSome = require_p_some();
    var PCancelable = require_p_cancelable();
    module2.exports = (iterable, options) => {
      const anyCancelable = pSome(iterable, { ...options, count: 1 });
      return PCancelable.fn(async (onCancel) => {
        onCancel(() => {
          anyCancelable.cancel();
        });
        const [value] = await anyCancelable;
        return value;
      })();
    };
    module2.exports.AggregateError = pSome.AggregateError;
  }
});

// node_modules/libp2p/src/dialer/dial-request.js
var require_dial_request = __commonJS({
  "node_modules/libp2p/src/dialer/dial-request.js"(exports2, module2) {
    "use strict";
    init_globals();
    var errCode69 = require_err_code();
    var { anySignal: anySignal5 } = require_any_signal();
    var FIFO = require_p_fifo();
    var pAny = require_p_any();
    var { setMaxListeners } = require_events();
    var { codes } = require_errors3();
    var DialRequest = class {
      constructor({
        addrs,
        dialAction,
        dialer
      }) {
        this.addrs = addrs;
        this.dialer = dialer;
        this.dialAction = dialAction;
      }
      async run(options = {}) {
        const tokens = this.dialer.getTokens(this.addrs.length);
        if (tokens.length < 1) {
          throw errCode69(new Error("No dial tokens available"), codes.ERR_NO_DIAL_TOKENS);
        }
        const tokenHolder = new FIFO();
        tokens.forEach((token) => tokenHolder.push(token));
        const dialAbortControllers = this.addrs.map(() => {
          const controller = new AbortController();
          try {
            setMaxListeners && setMaxListeners(Infinity, controller.signal);
          } catch {
          }
          return controller;
        });
        let completedDials = 0;
        try {
          return await pAny(this.addrs.map(async (addr, i) => {
            const token = await tokenHolder.shift();
            let conn;
            try {
              const signal = dialAbortControllers[i].signal;
              conn = await this.dialAction(addr, { ...options, signal: options.signal ? anySignal5([signal, options.signal]) : signal });
              dialAbortControllers.splice(i, 1);
            } finally {
              completedDials++;
              if (this.addrs.length - completedDials >= tokens.length) {
                tokenHolder.push(token);
              } else {
                this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
              }
            }
            return conn;
          }));
        } finally {
          dialAbortControllers.map((c) => c.abort());
          tokens.forEach((token) => this.dialer.releaseToken(token));
        }
      }
    };
    module2.exports = DialRequest;
  }
});

// node_modules/libp2p/src/dialer/index.js
var require_dialer = __commonJS({
  "node_modules/libp2p/src/dialer/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var all6 = require_it_all();
    var filter10 = require_it_filter();
    var { pipe: pipe8 } = require_it_pipe();
    var log48 = Object.assign(debug50("libp2p:dialer"), {
      error: debug50("libp2p:dialer:err")
    });
    var errCode69 = require_err_code();
    var { Multiaddr: Multiaddr22 } = require_src();
    var { TimeoutController: TimeoutController3 } = require_timeout_abort_controller();
    var { AbortError } = require_abortable_iterator();
    var { anySignal: anySignal5 } = require_any_signal();
    var { setMaxListeners } = require_events();
    var DialRequest = require_dial_request();
    var { publicAddressesFirst } = require_address_sort();
    var getPeer = require_get_peer();
    var trackedMap5 = require_tracked_map();
    var { codes } = require_errors3();
    var {
      DIAL_TIMEOUT,
      MAX_PARALLEL_DIALS,
      MAX_PER_PEER_DIALS,
      MAX_ADDRS_TO_DIAL
    } = require_constants11();
    var METRICS_COMPONENT = "dialler";
    var METRICS_PENDING_DIALS = "pending-dials";
    var METRICS_PENDING_DIAL_TARGETS = "pending-dial-targets";
    var Dialer = class {
      constructor({
        transportManager,
        peerStore,
        connectionGater,
        addressSorter = publicAddressesFirst,
        maxParallelDials = MAX_PARALLEL_DIALS,
        maxAddrsToDial = MAX_ADDRS_TO_DIAL,
        dialTimeout = DIAL_TIMEOUT,
        maxDialsPerPeer = MAX_PER_PEER_DIALS,
        resolvers: resolvers3 = {},
        metrics
      }) {
        this.connectionGater = connectionGater;
        this.transportManager = transportManager;
        this.peerStore = peerStore;
        this.addressSorter = addressSorter;
        this.maxParallelDials = maxParallelDials;
        this.maxAddrsToDial = maxAddrsToDial;
        this.timeout = dialTimeout;
        this.maxDialsPerPeer = maxDialsPerPeer;
        this.tokens = [...new Array(maxParallelDials)].map((_, index) => index);
        this._pendingDials = trackedMap5({
          component: METRICS_COMPONENT,
          metric: METRICS_PENDING_DIALS,
          metrics
        });
        this._pendingDialTargets = trackedMap5({
          component: METRICS_COMPONENT,
          metric: METRICS_PENDING_DIAL_TARGETS,
          metrics
        });
        for (const [key, value] of Object.entries(resolvers3)) {
          Multiaddr22.resolvers.set(key, value);
        }
      }
      destroy() {
        for (const dial of this._pendingDials.values()) {
          try {
            dial.controller.abort();
          } catch (err) {
            log48.error(err);
          }
        }
        this._pendingDials.clear();
        for (const pendingTarget of this._pendingDialTargets.values()) {
          pendingTarget.reject(new AbortError("Dialer was destroyed"));
        }
        this._pendingDialTargets.clear();
      }
      async connectToPeer(peer, options = {}) {
        const { id } = getPeer(peer);
        if (await this.connectionGater.denyDialPeer(id)) {
          throw errCode69(new Error("The dial request is blocked by gater.allowDialPeer"), codes.ERR_PEER_DIAL_INTERCEPTED);
        }
        const dialTarget = await this._createCancellableDialTarget(peer);
        if (!dialTarget.addrs.length) {
          throw errCode69(new Error("The dial request has no valid addresses"), codes.ERR_NO_VALID_ADDRESSES);
        }
        const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);
        try {
          const connection = await pendingDial.promise;
          log48("dial succeeded to %s", dialTarget.id);
          return connection;
        } catch (err) {
          if (pendingDial.controller.signal.aborted) {
            err.code = codes.ERR_TIMEOUT;
          }
          log48.error(err);
          throw err;
        } finally {
          pendingDial.destroy();
        }
      }
      async _createCancellableDialTarget(peer) {
        const id = `${parseInt(String(Math.random() * 1e9), 10).toString() + Date.now()}`;
        const cancellablePromise = new Promise((resolve11, reject) => {
          this._pendingDialTargets.set(id, { resolve: resolve11, reject });
        });
        try {
          const dialTarget = await Promise.race([
            this._createDialTarget(peer),
            cancellablePromise
          ]);
          return dialTarget;
        } finally {
          this._pendingDialTargets.delete(id);
        }
      }
      async _createDialTarget(peer) {
        const { id, multiaddrs } = getPeer(peer);
        if (multiaddrs) {
          await this.peerStore.addressBook.add(id, multiaddrs);
        }
        let knownAddrs = await pipe8(await this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter), (source) => filter10(source, async (multiaddr) => {
          return !await this.connectionGater.denyDialMultiaddr(id, multiaddr);
        }), (source) => all6(source));
        if (Multiaddr22.isMultiaddr(peer)) {
          knownAddrs = knownAddrs.filter((addr) => !peer.equals(addr));
          knownAddrs.unshift(peer);
        }
        const addrs = [];
        for (const a of knownAddrs) {
          const resolvedAddrs = await this._resolve(a);
          resolvedAddrs.forEach((ra) => addrs.push(ra));
        }
        const supportedAddrs = addrs.filter((a) => this.transportManager.transportForMultiaddr(a));
        if (supportedAddrs.length > this.maxAddrsToDial) {
          await this.peerStore.delete(id);
          throw errCode69(new Error("dial with more addresses than allowed"), codes.ERR_TOO_MANY_ADDRESSES);
        }
        return {
          id: id.toB58String(),
          addrs: supportedAddrs
        };
      }
      _createPendingDial(dialTarget, options = {}) {
        const dialAction = (addr, options2) => {
          if (options2.signal.aborted)
            throw errCode69(new Error("already aborted"), codes.ERR_ALREADY_ABORTED);
          return this.transportManager.dial(addr, options2);
        };
        const dialRequest = new DialRequest({
          addrs: dialTarget.addrs,
          dialAction,
          dialer: this
        });
        const timeoutController = new TimeoutController3(this.timeout);
        const signals = [timeoutController.signal];
        options.signal && signals.push(options.signal);
        const signal = anySignal5(signals);
        try {
          setMaxListeners && setMaxListeners(Infinity, signal);
        } catch {
        }
        const pendingDial = {
          dialRequest,
          controller: timeoutController,
          promise: dialRequest.run({ ...options, signal }),
          destroy: () => {
            timeoutController.clear();
            this._pendingDials.delete(dialTarget.id);
          }
        };
        this._pendingDials.set(dialTarget.id, pendingDial);
        return pendingDial;
      }
      getTokens(num) {
        const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);
        const tokens = this.tokens.splice(0, total);
        log48("%d tokens request, returning %d, %d remaining", num, total, this.tokens.length);
        return tokens;
      }
      releaseToken(token) {
        if (this.tokens.indexOf(token) > -1)
          return;
        log48("token %d released", token);
        this.tokens.push(token);
      }
      async _resolve(ma) {
        const resolvableProto = ma.protoNames().includes("dnsaddr");
        if (!resolvableProto) {
          return [ma];
        }
        const resolvedMultiaddrs = await this._resolveRecord(ma);
        const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map((nm) => {
          return this._resolve(nm);
        }));
        const addrs = recursiveMultiaddrs.flat();
        return addrs.reduce((array, newM) => {
          if (!array.find((m) => m.equals(newM))) {
            array.push(newM);
          }
          return array;
        }, []);
      }
      async _resolveRecord(ma) {
        try {
          ma = new Multiaddr22(ma.toString());
          const multiaddrs = await ma.resolve();
          return multiaddrs;
        } catch (_) {
          log48.error(`multiaddr ${ma} could not be resolved`);
          return [];
        }
      }
    };
    module2.exports = Dialer;
  }
});

// node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS({
  "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports2, module2) {
    "use strict";
    init_globals();
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function truncate(getLength, string3, byteLength) {
      if (typeof string3 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string3.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i = 0; i < charLength; i += 1) {
        codePoint = string3.charCodeAt(i);
        segment = string3[i];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string3.charCodeAt(i + 1))) {
          i += 1;
          segment += string3[i];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength) {
          return string3.slice(0, i + 1);
        } else if (curByteLength > byteLength) {
          return string3.slice(0, i - segment.length + 1);
        }
      }
      return string3;
    };
  }
});

// node_modules/utf8-byte-length/browser.js
var require_browser10 = __commonJS({
  "node_modules/utf8-byte-length/browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function getByteLength(string3) {
      if (typeof string3 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string3.length;
      var byteLength = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i = 0; i < charLength; i++) {
        codePoint = string3.charCodeAt(i);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength += 1;
          } else {
            byteLength += 3;
          }
        } else if (codePoint <= 127) {
          byteLength += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength;
    };
  }
});

// node_modules/truncate-utf8-bytes/browser.js
var require_browser11 = __commonJS({
  "node_modules/truncate-utf8-bytes/browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    var truncate = require_truncate();
    var getLength = require_browser10();
    module2.exports = truncate.bind(null, getLength);
  }
});

// node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS({
  "node_modules/sanitize-filename/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var truncate = require_browser11();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate(sanitized, 255);
    }
    module2.exports = function(input, options) {
      var replacement = options && options.replacement || "";
      var output = sanitize(input, replacement);
      if (replacement === "") {
        return output;
      }
      return sanitize(output, "");
    };
  }
});

// node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "node_modules/node-forge/lib/pkcs7asn1.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_asn1();
    require_util();
    var asn1 = forge.asn1;
    var p7v = module2.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
    forge.pkcs7 = forge.pkcs7 || {};
    forge.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "node_modules/node-forge/lib/mgf1.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_util();
    forge.mgf = forge.mgf || {};
    var mgf1 = module2.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        generate: function(seed, maskLen) {
          var t = new forge.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i = 0; i < len; i++) {
            var c = new forge.util.ByteBuffer();
            c.putInt32(i);
            md.start();
            md.update(seed + c.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
  }
});

// node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "node_modules/node-forge/lib/mgf.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_mgf1();
    module2.exports = forge.mgf = forge.mgf || {};
    forge.mgf.mgf1 = forge.mgf1;
  }
});

// node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "node_modules/node-forge/lib/pss.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_random();
    require_util();
    var pss = module2.exports = forge.pss = forge.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash2 = options.md;
      var mgf = options.mgf;
      var hLen = hash2.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h = hash2.digest().getBytes();
        var ps = new forge.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(1);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i = 0; i < maskLen; i++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = "";
        for (i = 0; i < maskLen; i++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i = 0; i < checkLen; i++) {
          if (db.charCodeAt(i) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h_ = hash2.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});

// node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "node_modules/node-forge/lib/x509.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util();
    var asn1 = forge.asn1;
    var pki = module2.exports = forge.pki = forge.pki || {};
    var oids = pki.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          publicKeyValidator,
          {
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set2, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set2 = rdn.value[si];
        for (var i = 0; i < set2.value.length; ++i) {
          obj = {};
          attr = set2.value[i];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values2 = seq.value[1].value;
        for (var vi = 0; vi < values2.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values2[vi].value;
          obj.valueTagClass = values2[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
        attr = obj.attributes[i];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors2)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors2;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return forge.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge.md.sha512.create();
        case "RSASSA-PSS":
          return forge.md.sha256.create();
        default:
          var error = new Error("Could not compute " + options.type + " digest. Unknown signature OID.");
          error.signatureOid = options.signatureOid;
          throw error;
      }
    };
    var _verifySignature = function(options) {
      var cert = options.certificate;
      var scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash2, mgf;
          hash2 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
          if (hash2 === void 0 || forge.md[hash2] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash2;
            throw error;
          }
          mgf = oids[cert.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            error.oid = cert.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }
          mgf = forge.mgf[mgf].create(forge.md[hash2].create());
          hash2 = oids[cert.signatureParameters.hash.algorithmOid];
          if (hash2 === void 0 || forge.md[hash2] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            error.oid = cert.signatureParameters.hash.algorithmOid;
            error.name = hash2;
            throw error;
          }
          scheme = forge.pss.create(forge.md[hash2].create(), mgf, cert.signatureParameters.saltLength);
          break;
      }
      return cert.publicKey.verify(options.md.digest().getBytes(), options.signature, scheme);
    };
    pki.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificateFromAsn1(obj, computeHash);
    };
    pki.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.publicKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.publicKeyFromAsn1(obj);
    };
    pki.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes2;
      switch (type) {
        case "RSAPublicKey":
          bytes2 = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes2 = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes2);
      var digest3 = md.digest();
      if (options.encoding === "hex") {
        var hex = digest3.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest3.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest3;
    };
    pki.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificationRequestFromAsn1(obj, computeHash);
    };
    pki.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i = 0; i < exts.length; ++i) {
          _fillMissingExtensionFields(exts[i], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
          ext = cert.extensions[i];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md) {
        cert.md = md || forge.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki.getTBSCertificate(cert);
        var bytes2 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes2.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
          error.expectedIssuer = subject.attributes;
          error.actualIssuer = issuer.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
          var bytes2 = asn1.toDer(tbsCertificate);
          md.update(bytes2.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: cert,
            md,
            signature: child.signature
          });
        }
        return rval;
      };
      cert.isIssuer = function(parent2) {
        var rval = false;
        var i = cert.issuer;
        var s = parent2.subject;
        if (i.hash && s.hash) {
          rval = i.hash === s.hash;
        } else if (i.attributes.length === s.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n = 0; rval && n < i.attributes.length; ++n) {
            iattr = i.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i = 0; i < cert.extensions.length; ++i) {
          var ext = cert.extensions[i];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors2)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
      cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = _createSignatureDigest({
          signatureOid: cert.signatureOid,
          type: "certificate"
        });
        var bytes2 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes2.getBytes());
      }
      var imd = forge.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i = 0; i < exts.value.length; ++i) {
        var extseq = exts.value[i];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === "keyUsage") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 128) === 128;
          e.nonRepudiation = (b2 & 64) === 64;
          e.keyEncipherment = (b2 & 32) === 32;
          e.dataEncipherment = (b2 & 16) === 16;
          e.keyAgreement = (b2 & 8) === 8;
          e.keyCertSign = (b2 & 4) === 4;
          e.cRLSign = (b2 & 2) === 2;
          e.encipherOnly = (b2 & 1) === 1;
          e.decipherOnly = (b3 & 128) === 128;
        } else if (e.name === "basicConstraints") {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e.name === "extKeyUsage") {
          var ev = asn1.fromDer(e.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === "nsCertType") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 128) === 128;
          e.server = (b2 & 64) === 64;
          e.email = (b2 & 32) === 32;
          e.objsign = (b2 & 16) === 16;
          e.reserved = (b2 & 8) === 8;
          e.sslCA = (b2 & 4) === 4;
          e.emailCA = (b2 & 2) === 2;
          e.objCA = (b2 & 1) === 1;
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.altNames = [];
          var gn;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e.altNames.push(altName);
            switch (gn.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge.util.bytesToIP(gn.value);
                break;
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
      csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes2 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes2.getBytes());
      }
      var smd = forge.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
      return csr;
    };
    pki.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
        var bytes2 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes2.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
          var bytes2 = asn1.toDer(cri);
          md.update(bytes2.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: csr,
            md,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var attr, set2;
      var attrs = obj.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge.util.encodeUtf8(value);
          }
        }
        set2 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set2);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki.oids) {
            attr.name = pki.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki.oids) {
            attr.type = pki.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === "undefined") {
        if (e.id && e.id in pki.oids) {
          e.name = pki.oids[e.id];
        }
      }
      if (typeof e.id === "undefined") {
        if (e.name && e.name in pki.oids) {
          e.id = pki.oids[e.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== "undefined") {
        return e;
      }
      if (e.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
      } else if (e.name === "basicConstraints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        if (e.cA) {
          e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
        }
        if ("pathLenConstraint" in e) {
          e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));
        }
      } else if (e.name === "extKeyUsage") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));
          } else if (key.indexOf(".") !== -1) {
            seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));
          }
        }
      } else if (e.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
        }
      } else if (e.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
      } else if (e.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
      } else if (e.name === "authorityKeyIdentifier" && options.cert) {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        if (e.keyIdentifier) {
          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
        }
        if (e.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
            ])
          ];
          seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
        }
        if (e.serialNumber) {
          var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
          seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
        }
      } else if (e.name === "cRLDistributionPoints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
        }
        subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
        seq.push(subSeq);
      }
      if (typeof e.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        var attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
      } else {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
      }
    }
    pki.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),
          _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)
        ]),
        _dnToAsn1(cert.issuer),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        _dnToAsn1(cert.subject),
        pki.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.issuer.uniqueId)
        ]));
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.subject.uniqueId)
        ]));
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()),
        _dnToAsn1(csr.subject),
        pki.publicKeyToAsn1(csr.publicKey),
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        tbsCertificate,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()),
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.signature)
      ]);
    };
    pki.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i = 0; i < exts.length; ++i) {
        seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
      }
      return rval;
    };
    pki.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes()));
      if (ext.critical) {
        extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
      }
      var value = ext.value;
      if (typeof ext.value !== "string") {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));
      return extseq;
    };
    pki.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        cri,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()),
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + csr.signature)
      ]);
    };
    pki.createCaStore = function(certs) {
      var caStore = {
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge.pki.certificateFromPem(cert2);
        }
        var match = getBySubject(cert2.subject);
        if (!match) {
          return false;
        }
        if (!forge.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash2 in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash2)) {
            var value = caStore.certs[hash2];
            if (!forge.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i2 = 0; i2 < value.length; ++i2) {
                certList.push(value[i2]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result;
        if (typeof cert2 === "string") {
          cert2 = forge.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match = getBySubject(cert2.subject);
        if (!forge.util.isArray(match)) {
          result = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            result = match[i2];
            match.splice(i2, 1);
          }
        }
        if (match.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge.md.sha1.create();
          subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i = 0; i < certs.length; ++i) {
          var cert = certs[i];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = new Date();
      }
      var first4 = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent2 = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent2 = chain[0] || caStore.getIssuer(cert);
          if (parent2 === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent2 = cert;
            }
          }
          if (parent2) {
            var parents = parent2;
            if (!forge.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent2 = parents.shift();
              try {
                verified = parent2.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent2 || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent2 && !cert.isIssuer(parent2)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i = 0; error === null && i < cert.extensions.length; ++i) {
            var ext = cert.extensions[i];
            if (ext.critical && !(ext.name in se)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first4 || chain.length === 0 && (!parent2 || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first4 = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});

// node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "node_modules/node-forge/lib/pkcs7.js"(exports2, module2) {
    init_globals();
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util();
    require_x509();
    var asn1 = forge.asn1;
    var p7 = module2.exports = forge.pkcs7 = forge.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors2;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        signers: [],
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i = 0; i < certs.length; ++i) {
              msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i = 0; i < msg.certificates.length; ++i) {
            certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers),
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
          }
          signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos));
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
            signedData
          ]);
        },
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error("Could not add PKCS#7 signer; no private key specified.");
          }
          if (typeof key === "string") {
            key = forge.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge.pki.oids.sha1:
            case forge.pki.oids.sha256:
            case forge.pki.oids.sha384:
            case forge.pki.oids.sha512:
            case forge.pki.oids.md5:
              break;
            default:
              throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm);
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i = 0; i < authenticatedAttributes.length; ++i) {
              var attr = authenticatedAttributes[i];
              if (!contentType && attr.type === forge.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())
            ]);
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)
                ]));
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge.md[forge.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge.md[forge.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]));
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes2 = asn1.toDer(content);
        bytes2.getByte();
        asn1.getBerValueLength(bytes2);
        bytes2 = bytes2.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes2);
        }
        var signingTime = new Date();
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge.pki.oids.data) {
              throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
            var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes2 = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes2);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        decrypt: function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))
              ])
            ])
          ]);
        },
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i = 0; i < msg.recipients.length; ++i) {
            var r = msg.recipients[i];
            var rAttr = r.issuer;
            if (r.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r;
            }
          }
          return null;
        },
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
              case forge.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              algorithm: forge.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge.util.createBuffer(forge.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i = 0; i < msg.recipients.length; ++i) {
            var recipient = msg.recipients[i];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors2;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i = 0; i < infos.length; ++i) {
        ret.push(_recipientFromAsn1(infos[i]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i = 0; i < recipients.length; ++i) {
        ret.push(_recipientToAsn1(recipients[i]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
          var attr = obj.unauthenticatedAttributes[i];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i = 0; i < signers.length; ++i) {
        ret.push(_signerToAsn1(signers[i]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge.pki.oids.contentType) {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());
      } else if (attr.type === forge.pki.oids.messageDigest) {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());
      } else if (attr.type === forge.pki.oids.signingTime) {
        var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
        } else {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          value
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec) {
      return [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()),
          !ec.parameter ? void 0 : asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())
        ]),
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator3) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, validator3, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge.util.isArray(capture.encryptedContent)) {
          for (var i = 0; i < capture.encryptedContent.length; ++i) {
            if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge.util.createBuffer(capture.encParameter.value),
          content: forge.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge.util.isArray(capture.content)) {
          for (var i = 0; i < capture.content.length; ++i) {
            if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge.pki.oids["aes128-CBC"]:
          case forge.pki.oids["aes192-CBC"]:
          case forge.pki.oids["aes256-CBC"]:
            ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge.pki.oids["desCBC"]:
          case forge.pki.oids["des-EDE3-CBC"]:
            ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});

// node_modules/libp2p/src/keychain/util.js
var require_util7 = __commonJS({
  "node_modules/libp2p/src/keychain/util.js"(exports2, module2) {
    "use strict";
    init_globals();
    require_x509();
    var forge = require_forge();
    var pki = forge.pki;
    var certificateForKey = (key, privateKey) => {
      const publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e);
      const cert = pki.createCertificate();
      cert.publicKey = publicKey;
      cert.serialNumber = "01";
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);
      const attrs = [{
        name: "organizationName",
        value: "ipfs"
      }, {
        shortName: "OU",
        value: "keystore"
      }, {
        name: "commonName",
        value: key.id
      }];
      cert.setSubject(attrs);
      cert.setIssuer(attrs);
      cert.setExtensions([{
        name: "basicConstraints",
        cA: true
      }, {
        name: "keyUsage",
        keyCertSign: true,
        digitalSignature: true,
        nonRepudiation: true,
        keyEncipherment: true,
        dataEncipherment: true
      }, {
        name: "extKeyUsage",
        serverAuth: true,
        clientAuth: true,
        codeSigning: true,
        emailProtection: true,
        timeStamping: true
      }, {
        name: "nsCertType",
        client: true,
        server: true,
        email: true,
        objsign: true,
        sslCA: true,
        emailCA: true,
        objCA: true
      }]);
      cert.sign(privateKey);
      return cert;
    };
    async function findAsync(array, asyncCompare) {
      const promises = array.map(asyncCompare);
      const results = await Promise.all(promises);
      const index = results.findIndex((result) => result);
      return array[index];
    }
    module2.exports = {
      certificateForKey,
      findAsync
    };
  }
});

// node_modules/libp2p/src/keychain/cms.js
var require_cms = __commonJS({
  "node_modules/libp2p/src/keychain/cms.js"(exports2, module2) {
    "use strict";
    init_globals();
    require_pkcs7();
    require_pbe();
    var forge = require_forge();
    var { certificateForKey, findAsync } = require_util7();
    var errcode17 = require_err_code();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { codes } = require_errors3();
    var privates = /* @__PURE__ */ new WeakMap();
    var CMS = class {
      constructor(keychain, dek) {
        if (!keychain) {
          throw errcode17(new Error("keychain is required"), codes.ERR_KEYCHAIN_REQUIRED);
        }
        this.keychain = keychain;
        privates.set(this, { dek });
      }
      async encrypt(name10, plain) {
        if (!(plain instanceof Uint8Array)) {
          throw errcode17(new Error("Plain data must be a Uint8Array"), codes.ERR_INVALID_PARAMETERS);
        }
        const key = await this.keychain.findKeyByName(name10);
        const pem = await this.keychain._getPrivateKey(name10);
        const dek = privates.get(this).dek;
        const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);
        const certificate = await certificateForKey(key, privateKey);
        const p7 = forge.pkcs7.createEnvelopedData();
        p7.addRecipient(certificate);
        p7.content = forge.util.createBuffer(plain);
        p7.encrypt();
        const der = forge.asn1.toDer(p7.toAsn1()).getBytes();
        return uint8ArrayFromString(der, "ascii");
      }
      async decrypt(cmsData) {
        if (!(cmsData instanceof Uint8Array)) {
          throw errcode17(new Error("CMS data is required"), codes.ERR_INVALID_PARAMETERS);
        }
        let cms;
        try {
          const buf3 = forge.util.createBuffer(uint8ArrayToString(cmsData, "ascii"));
          const obj = forge.asn1.fromDer(buf3);
          cms = forge.pkcs7.messageFromAsn1(obj);
        } catch (err) {
          throw errcode17(new Error("Invalid CMS: " + err.message), codes.ERR_INVALID_CMS);
        }
        const recipients = cms.recipients.filter((r2) => r2.issuer.find((a) => a.shortName === "O" && a.value === "ipfs")).filter((r2) => r2.issuer.find((a) => a.shortName === "CN")).map((r2) => {
          return {
            recipient: r2,
            keyId: r2.issuer.find((a) => a.shortName === "CN").value
          };
        });
        const r = await findAsync(recipients, async (recipient) => {
          try {
            const key2 = await this.keychain.findKeyById(recipient.keyId);
            if (key2)
              return true;
          } catch (err) {
            return false;
          }
          return false;
        });
        if (!r) {
          const missingKeys = recipients.map((r2) => r2.keyId);
          throw errcode17(new Error("Decryption needs one of the key(s): " + missingKeys.join(", ")), codes.ERR_MISSING_KEYS, {
            missingKeys
          });
        }
        const key = await this.keychain.findKeyById(r.keyId);
        if (!key) {
          throw errcode17(new Error("No key available to decrypto"), codes.ERR_NO_KEY);
        }
        const pem = await this.keychain._getPrivateKey(key.name);
        const dek = privates.get(this).dek;
        const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);
        cms.decrypt(r.recipient, privateKey);
        return uint8ArrayFromString(cms.content.getBytes(), "ascii");
      }
    };
    module2.exports = CMS;
  }
});

// node_modules/libp2p/src/keychain/index.js
var require_keychain = __commonJS({
  "node_modules/libp2p/src/keychain/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:keychain"), {
      error: debug50("libp2p:keychain:err")
    });
    var sanitize = require_sanitize_filename();
    var mergeOptions17 = require_merge_options();
    var crypto6 = require_src6();
    var { Key: Key2 } = (init_key(), __toCommonJS(key_exports));
    var CMS = require_cms();
    var errcode17 = require_err_code();
    var { codes } = require_errors3();
    var { toString: uint8ArrayToString } = (init_to_string(), __toCommonJS(to_string_exports));
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    require_sha512();
    var keyPrefix = "/pkcs8/";
    var infoPrefix = "/info/";
    var privates = /* @__PURE__ */ new WeakMap();
    var NIST = {
      minKeyLength: 112 / 8,
      minSaltLength: 128 / 8,
      minIterationCount: 1e3
    };
    var defaultOptions16 = {
      dek: {
        keyLength: 512 / 8,
        iterationCount: 1e4,
        salt: "you should override this value with a crypto secure random number",
        hash: "sha2-512"
      }
    };
    function validateKeyName(name10) {
      if (!name10)
        return false;
      if (typeof name10 !== "string")
        return false;
      return name10 === sanitize(name10.trim());
    }
    async function throwDelayed(err) {
      const min = 200;
      const max = 1e3;
      const delay = Math.random() * (max - min) + min;
      await new Promise((resolve11) => setTimeout(resolve11, delay));
      throw err;
    }
    function DsName(name10) {
      return new Key2(keyPrefix + name10);
    }
    function DsInfoName(name10) {
      return new Key2(infoPrefix + name10);
    }
    var Keychain = class {
      constructor(store, options) {
        if (!store) {
          throw new Error("store is required");
        }
        this.store = store;
        this.opts = mergeOptions17(defaultOptions16, options);
        if (this.opts.pass && this.opts.pass.length < 20) {
          throw new Error("pass must be least 20 characters");
        }
        if (this.opts.dek.keyLength < NIST.minKeyLength) {
          throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
        }
        if (this.opts.dek.salt.length < NIST.minSaltLength) {
          throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
        }
        if (this.opts.dek.iterationCount < NIST.minIterationCount) {
          throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
        }
        const dek = this.opts.pass ? crypto6.pbkdf2(this.opts.pass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : "";
        privates.set(this, { dek });
      }
      get cms() {
        return new CMS(this, privates.get(this).dek);
      }
      static generateOptions() {
        const options = Object.assign({}, defaultOptions16);
        const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
        options.dek.salt = uint8ArrayToString(crypto6.randomBytes(saltLength), "base64");
        return options;
      }
      static get options() {
        return defaultOptions16;
      }
      async createKey(name10, type, size = 2048) {
        const self2 = this;
        if (!validateKeyName(name10) || name10 === "self") {
          return throwDelayed(errcode17(new Error(`Invalid key name '${name10}'`), codes.ERR_INVALID_KEY_NAME));
        }
        if (typeof type !== "string") {
          return throwDelayed(errcode17(new Error(`Invalid key type '${type}'`), codes.ERR_INVALID_KEY_TYPE));
        }
        const dsname = DsName(name10);
        const exists = await self2.store.has(dsname);
        if (exists)
          return throwDelayed(errcode17(new Error(`Key '${name10}' already exists`), codes.ERR_KEY_ALREADY_EXISTS));
        switch (type.toLowerCase()) {
          case "rsa":
            if (!Number.isSafeInteger(size) || size < 2048) {
              return throwDelayed(errcode17(new Error(`Invalid RSA key size ${size}`), codes.ERR_INVALID_KEY_SIZE));
            }
            break;
          default:
            break;
        }
        let keyInfo;
        try {
          const keypair = await crypto6.keys.generateKeyPair(type, size);
          const kid = await keypair.id();
          const dek = privates.get(this).dek;
          const pem = await keypair.export(dek);
          keyInfo = {
            name: name10,
            id: kid
          };
          const batch3 = self2.store.batch();
          batch3.put(dsname, uint8ArrayFromString(pem));
          batch3.put(DsInfoName(name10), uint8ArrayFromString(JSON.stringify(keyInfo)));
          await batch3.commit();
        } catch (err) {
          return throwDelayed(err);
        }
        return keyInfo;
      }
      async listKeys() {
        const self2 = this;
        const query = {
          prefix: infoPrefix
        };
        const info = [];
        for await (const value of self2.store.query(query)) {
          info.push(JSON.parse(uint8ArrayToString(value.value)));
        }
        return info;
      }
      async findKeyById(id) {
        try {
          const keys2 = await this.listKeys();
          return keys2.find((k) => k.id === id);
        } catch (err) {
          return throwDelayed(err);
        }
      }
      async findKeyByName(name10) {
        if (!validateKeyName(name10)) {
          return throwDelayed(errcode17(new Error(`Invalid key name '${name10}'`), codes.ERR_INVALID_KEY_NAME));
        }
        const dsname = DsInfoName(name10);
        try {
          const res = await this.store.get(dsname);
          return JSON.parse(uint8ArrayToString(res));
        } catch (err) {
          return throwDelayed(errcode17(new Error(`Key '${name10}' does not exist. ${err.message}`), codes.ERR_KEY_NOT_FOUND));
        }
      }
      async removeKey(name10) {
        const self2 = this;
        if (!validateKeyName(name10) || name10 === "self") {
          return throwDelayed(errcode17(new Error(`Invalid key name '${name10}'`), codes.ERR_INVALID_KEY_NAME));
        }
        const dsname = DsName(name10);
        const keyInfo = await self2.findKeyByName(name10);
        const batch3 = self2.store.batch();
        batch3.delete(dsname);
        batch3.delete(DsInfoName(name10));
        await batch3.commit();
        return keyInfo;
      }
      async renameKey(oldName, newName) {
        const self2 = this;
        if (!validateKeyName(oldName) || oldName === "self") {
          return throwDelayed(errcode17(new Error(`Invalid old key name '${oldName}'`), codes.ERR_OLD_KEY_NAME_INVALID));
        }
        if (!validateKeyName(newName) || newName === "self") {
          return throwDelayed(errcode17(new Error(`Invalid new key name '${newName}'`), codes.ERR_NEW_KEY_NAME_INVALID));
        }
        const oldDsname = DsName(oldName);
        const newDsname = DsName(newName);
        const oldInfoName = DsInfoName(oldName);
        const newInfoName = DsInfoName(newName);
        const exists = await self2.store.has(newDsname);
        if (exists)
          return throwDelayed(errcode17(new Error(`Key '${newName}' already exists`), codes.ERR_KEY_ALREADY_EXISTS));
        try {
          const pem = await self2.store.get(oldDsname);
          const res = await self2.store.get(oldInfoName);
          const keyInfo = JSON.parse(uint8ArrayToString(res));
          keyInfo.name = newName;
          const batch3 = self2.store.batch();
          batch3.put(newDsname, pem);
          batch3.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)));
          batch3.delete(oldDsname);
          batch3.delete(oldInfoName);
          await batch3.commit();
          return keyInfo;
        } catch (err) {
          return throwDelayed(err);
        }
      }
      async exportKey(name10, password) {
        if (!validateKeyName(name10)) {
          return throwDelayed(errcode17(new Error(`Invalid key name '${name10}'`), codes.ERR_INVALID_KEY_NAME));
        }
        if (!password) {
          return throwDelayed(errcode17(new Error("Password is required"), codes.ERR_PASSWORD_REQUIRED));
        }
        const dsname = DsName(name10);
        try {
          const res = await this.store.get(dsname);
          const pem = uint8ArrayToString(res);
          const dek = privates.get(this).dek;
          const privateKey = await crypto6.keys.import(pem, dek);
          return privateKey.export(password);
        } catch (err) {
          return throwDelayed(err);
        }
      }
      async importKey(name10, pem, password) {
        const self2 = this;
        if (!validateKeyName(name10) || name10 === "self") {
          return throwDelayed(errcode17(new Error(`Invalid key name '${name10}'`), codes.ERR_INVALID_KEY_NAME));
        }
        if (!pem) {
          return throwDelayed(errcode17(new Error("PEM encoded key is required"), codes.ERR_PEM_REQUIRED));
        }
        const dsname = DsName(name10);
        const exists = await self2.store.has(dsname);
        if (exists)
          return throwDelayed(errcode17(new Error(`Key '${name10}' already exists`), codes.ERR_KEY_ALREADY_EXISTS));
        let privateKey;
        try {
          privateKey = await crypto6.keys.import(pem, password);
        } catch (err) {
          return throwDelayed(errcode17(new Error("Cannot read the key, most likely the password is wrong"), codes.ERR_CANNOT_READ_KEY));
        }
        let kid;
        try {
          kid = await privateKey.id();
          const dek = privates.get(this).dek;
          pem = await privateKey.export(dek);
        } catch (err) {
          return throwDelayed(err);
        }
        const keyInfo = {
          name: name10,
          id: kid
        };
        const batch3 = self2.store.batch();
        batch3.put(dsname, uint8ArrayFromString(pem));
        batch3.put(DsInfoName(name10), uint8ArrayFromString(JSON.stringify(keyInfo)));
        await batch3.commit();
        return keyInfo;
      }
      async importPeer(name10, peer) {
        const self2 = this;
        if (!validateKeyName(name10)) {
          return throwDelayed(errcode17(new Error(`Invalid key name '${name10}'`), codes.ERR_INVALID_KEY_NAME));
        }
        if (!peer || !peer.privKey) {
          return throwDelayed(errcode17(new Error("Peer.privKey is required"), codes.ERR_MISSING_PRIVATE_KEY));
        }
        const privateKey = peer.privKey;
        const dsname = DsName(name10);
        const exists = await self2.store.has(dsname);
        if (exists)
          return throwDelayed(errcode17(new Error(`Key '${name10}' already exists`), codes.ERR_KEY_ALREADY_EXISTS));
        try {
          const kid = await privateKey.id();
          const dek = privates.get(this).dek;
          const pem = await privateKey.export(dek);
          const keyInfo = {
            name: name10,
            id: kid
          };
          const batch3 = self2.store.batch();
          batch3.put(dsname, uint8ArrayFromString(pem));
          batch3.put(DsInfoName(name10), uint8ArrayFromString(JSON.stringify(keyInfo)));
          await batch3.commit();
          return keyInfo;
        } catch (err) {
          return throwDelayed(err);
        }
      }
      async _getPrivateKey(name10) {
        if (!validateKeyName(name10)) {
          return throwDelayed(errcode17(new Error(`Invalid key name '${name10}'`), codes.ERR_INVALID_KEY_NAME));
        }
        try {
          const dsname = DsName(name10);
          const res = await this.store.get(dsname);
          return uint8ArrayToString(res);
        } catch (err) {
          return throwDelayed(errcode17(new Error(`Key '${name10}' does not exist. ${err.message}`), codes.ERR_KEY_NOT_FOUND));
        }
      }
      async rotateKeychainPass(oldPass, newPass) {
        if (typeof oldPass !== "string") {
          return throwDelayed(errcode17(new Error(`Invalid old pass type '${typeof oldPass}'`), codes.ERR_INVALID_OLD_PASS_TYPE));
        }
        if (typeof newPass !== "string") {
          return throwDelayed(errcode17(new Error(`Invalid new pass type '${typeof newPass}'`), codes.ERR_INVALID_NEW_PASS_TYPE));
        }
        if (newPass.length < 20) {
          return throwDelayed(errcode17(new Error(`Invalid pass length ${newPass.length}`), codes.ERR_INVALID_PASS_LENGTH));
        }
        log48("recreating keychain");
        const oldDek = privates.get(this).dek;
        this.opts.pass = newPass;
        const newDek = newPass ? crypto6.pbkdf2(newPass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : "";
        privates.set(this, { dek: newDek });
        const keys2 = await this.listKeys();
        for (const key of keys2) {
          const res = await this.store.get(DsName(key.name));
          const pem = uint8ArrayToString(res);
          const privateKey = await crypto6.keys.import(pem, oldDek);
          const password = newDek.toString();
          const keyAsPEM = await privateKey.export(password);
          const batch3 = this.store.batch();
          const keyInfo = {
            name: key.name,
            id: key.id
          };
          batch3.put(DsName(key.name), uint8ArrayFromString(keyAsPEM));
          batch3.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)));
          await batch3.commit();
        }
        log48("keychain reconstructed");
      }
    };
    module2.exports = Keychain;
  }
});

// node_modules/streaming-iterables/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/streaming-iterables/dist/index.js"(exports2, module2) {
    init_globals();
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.streamingIterables = {}));
    })(exports2, function(exports3) {
      "use strict";
      async function* _batch(size, iterable) {
        let dataBatch = [];
        for await (const data of iterable) {
          dataBatch.push(data);
          if (dataBatch.length === size) {
            yield dataBatch;
            dataBatch = [];
          }
        }
        if (dataBatch.length > 0) {
          yield dataBatch;
        }
      }
      function* _syncBatch(size, iterable) {
        let dataBatch = [];
        for (const data of iterable) {
          dataBatch.push(data);
          if (dataBatch.length === size) {
            yield dataBatch;
            dataBatch = [];
          }
        }
        if (dataBatch.length > 0) {
          yield dataBatch;
        }
      }
      function batch3(size, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => batch3(size, curriedIterable);
        }
        if (iterable[Symbol.asyncIterator]) {
          return _batch(size, iterable);
        }
        return _syncBatch(size, iterable);
      }
      const TIMEOUT = Symbol("TIMEOUT");
      const createTimer = (duration) => {
        let timeoutId;
        return [
          new Promise((resolve11) => {
            timeoutId = setTimeout(() => resolve11(TIMEOUT), duration);
          }),
          () => {
            clearTimeout(timeoutId);
          }
        ];
      };
      async function* _batchWithTimeout(size, timeout, iterable) {
        const iterator = iterable[Symbol.asyncIterator]();
        let pendingData;
        let batchData = [];
        let timer;
        let clearTimer;
        const startTimer = () => {
          deleteTimer();
          [timer, clearTimer] = createTimer(timeout);
        };
        const deleteTimer = () => {
          if (clearTimer) {
            clearTimer();
          }
          timer = void 0;
        };
        pendingData = iterator.next();
        while (true) {
          const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);
          if (res === TIMEOUT || res.done) {
            if (batchData.length) {
              yield batchData;
              batchData = [];
            }
            deleteTimer();
            if (res !== TIMEOUT) {
              break;
            }
            continue;
          }
          pendingData = iterator.next();
          batchData.push(res.value);
          if (batchData.length === 1) {
            startTimer();
          }
          if (batchData.length === size) {
            yield batchData;
            batchData = [];
            deleteTimer();
            continue;
          }
        }
      }
      function batchWithTimeout(size, timeout, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => batchWithTimeout(size, timeout, curriedIterable);
        }
        if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {
          return _batchWithTimeout(size, timeout, iterable);
        }
        return batch3(size, iterable);
      }
      function getIterator(iterable) {
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (typeof iterable[Symbol.iterator] === "function") {
          return iterable[Symbol.iterator]();
        }
        if (typeof iterable[Symbol.asyncIterator] === "function") {
          return iterable[Symbol.asyncIterator]();
        }
        throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols');
      }
      function defer() {
        let reject;
        let resolve11;
        const promise = new Promise((resolveFunc, rejectFunc) => {
          resolve11 = resolveFunc;
          reject = rejectFunc;
        });
        return {
          promise,
          reject,
          resolve: resolve11
        };
      }
      function _buffer(size, iterable) {
        const iterator = getIterator(iterable);
        const resultQueue = [];
        const readQueue = [];
        let reading = false;
        let ended = false;
        function fulfillReadQueue() {
          while (readQueue.length > 0 && resultQueue.length > 0) {
            const readDeferred = readQueue.shift();
            const { error, value } = resultQueue.shift();
            if (error) {
              readDeferred.reject(error);
            } else {
              readDeferred.resolve({ done: false, value });
            }
          }
          while (readQueue.length > 0 && ended) {
            const { resolve: resolve11 } = readQueue.shift();
            resolve11({ done: true, value: void 0 });
          }
        }
        async function fillQueue() {
          if (ended) {
            return;
          }
          if (reading) {
            return;
          }
          if (resultQueue.length >= size) {
            return;
          }
          reading = true;
          try {
            const { done, value } = await iterator.next();
            if (done) {
              ended = true;
            } else {
              resultQueue.push({ value });
            }
          } catch (error) {
            ended = true;
            resultQueue.push({ error });
          }
          fulfillReadQueue();
          reading = false;
          fillQueue();
        }
        async function next() {
          if (resultQueue.length > 0) {
            const { error, value } = resultQueue.shift();
            if (error) {
              throw error;
            }
            fillQueue();
            return { done: false, value };
          }
          if (ended) {
            return { done: true, value: void 0 };
          }
          const deferred = defer();
          readQueue.push(deferred);
          fillQueue();
          return deferred.promise;
        }
        const asyncIterableIterator = {
          next,
          [Symbol.asyncIterator]: () => asyncIterableIterator
        };
        return asyncIterableIterator;
      }
      function* syncBuffer(size, iterable) {
        const valueQueue = [];
        let e;
        try {
          for (const value of iterable) {
            valueQueue.push(value);
            if (valueQueue.length <= size) {
              continue;
            }
            yield valueQueue.shift();
          }
        } catch (error) {
          e = error;
        }
        for (const value of valueQueue) {
          yield value;
        }
        if (e) {
          throw e;
        }
      }
      function buffer3(size, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => buffer3(size, curriedIterable);
        }
        if (size === 0) {
          return iterable;
        }
        if (iterable[Symbol.asyncIterator]) {
          return _buffer(size, iterable);
        }
        return syncBuffer(size, iterable);
      }
      async function _collect(iterable) {
        const values2 = [];
        for await (const value of iterable) {
          values2.push(value);
        }
        return values2;
      }
      function collect(iterable) {
        if (iterable[Symbol.asyncIterator]) {
          return _collect(iterable);
        }
        return Array.from(iterable);
      }
      async function* _concat(iterables) {
        for await (const iterable of iterables) {
          yield* iterable;
        }
      }
      function* _syncConcat(iterables) {
        for (const iterable of iterables) {
          yield* iterable;
        }
      }
      function concat5(...iterables) {
        const hasAnyAsync = iterables.find((itr) => itr[Symbol.asyncIterator] !== void 0);
        if (hasAnyAsync) {
          return _concat(iterables);
        } else {
          return _syncConcat(iterables);
        }
      }
      async function _consume(iterable) {
        for await (const val of iterable) {
        }
      }
      function consume(iterable) {
        if (iterable[Symbol.asyncIterator]) {
          return _consume(iterable);
        }
        for (const val of iterable) {
        }
      }
      async function* _filter(filterFunc, iterable) {
        for await (const data of iterable) {
          if (await filterFunc(data)) {
            yield data;
          }
        }
      }
      function filter10(filterFunc, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => _filter(filterFunc, curriedIterable);
        }
        return _filter(filterFunc, iterable);
      }
      async function* flatten2(iterable) {
        for await (const maybeItr of iterable) {
          if (maybeItr && typeof maybeItr !== "string" && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {
            yield* flatten2(maybeItr);
          } else {
            yield maybeItr;
          }
        }
      }
      async function* _map(func, iterable) {
        for await (const val of iterable) {
          yield await func(val);
        }
      }
      function map12(func, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => _map(func, curriedIterable);
        }
        return _map(func, iterable);
      }
      function flatMap(func, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => flatMap(func, curriedIterable);
        }
        return filter10((i) => i !== void 0 && i !== null, flatten2(map12(func, iterable)));
      }
      function _flatTransform(concurrency, func, iterable) {
        const iterator = getIterator(iterable);
        const resultQueue = [];
        const readQueue = [];
        let ended = false;
        let reading = false;
        let inflightCount = 0;
        let lastError = null;
        function fulfillReadQueue() {
          while (readQueue.length > 0 && resultQueue.length > 0) {
            const { resolve: resolve11 } = readQueue.shift();
            const value = resultQueue.shift();
            resolve11({ done: false, value });
          }
          while (readQueue.length > 0 && inflightCount === 0 && ended) {
            const { resolve: resolve11, reject } = readQueue.shift();
            if (lastError) {
              reject(lastError);
              lastError = null;
            } else {
              resolve11({ done: true, value: void 0 });
            }
          }
        }
        async function fillQueue() {
          if (ended) {
            fulfillReadQueue();
            return;
          }
          if (reading) {
            return;
          }
          if (inflightCount + resultQueue.length >= concurrency) {
            return;
          }
          reading = true;
          inflightCount++;
          try {
            const { done, value } = await iterator.next();
            if (done) {
              ended = true;
              inflightCount--;
              fulfillReadQueue();
            } else {
              mapAndQueue(value);
            }
          } catch (error) {
            ended = true;
            inflightCount--;
            lastError = error;
            fulfillReadQueue();
          }
          reading = false;
          fillQueue();
        }
        async function mapAndQueue(itrValue) {
          try {
            const value = await func(itrValue);
            if (value && value[Symbol.asyncIterator]) {
              for await (const asyncVal of value) {
                resultQueue.push(asyncVal);
              }
            } else {
              resultQueue.push(value);
            }
          } catch (error) {
            ended = true;
            lastError = error;
          }
          inflightCount--;
          fulfillReadQueue();
          fillQueue();
        }
        async function next() {
          if (resultQueue.length === 0) {
            const deferred = defer();
            readQueue.push(deferred);
            fillQueue();
            return deferred.promise;
          }
          const value = resultQueue.shift();
          fillQueue();
          return { done: false, value };
        }
        const asyncIterableIterator = {
          next,
          [Symbol.asyncIterator]: () => asyncIterableIterator
        };
        return asyncIterableIterator;
      }
      function flatTransform(concurrency, func, iterable) {
        if (func === void 0) {
          return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);
        }
        if (iterable === void 0) {
          return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);
        }
        return filter10((i) => i !== void 0 && i !== null, flatten2(_flatTransform(concurrency, func, iterable)));
      }
      async function onceReadable(stream) {
        return new Promise((resolve11) => {
          stream.once("readable", () => {
            resolve11();
          });
        });
      }
      async function* _fromStream(stream) {
        while (true) {
          const data = stream.read();
          if (data !== null) {
            yield data;
            continue;
          }
          if (stream._readableState.ended) {
            break;
          }
          await onceReadable(stream);
        }
      }
      function fromStream(stream) {
        if (typeof stream[Symbol.asyncIterator] === "function") {
          return stream;
        }
        return _fromStream(stream);
      }
      async function* merge5(...iterables) {
        const sources = new Set(iterables.map(getIterator));
        while (sources.size > 0) {
          for (const iterator of sources) {
            const nextVal = await iterator.next();
            if (nextVal.done) {
              sources.delete(iterator);
            } else {
              yield nextVal.value;
            }
          }
        }
      }
      function pipeline(firstFn, ...fns) {
        let previousFn = firstFn();
        for (const func of fns) {
          previousFn = func(previousFn);
        }
        return previousFn;
      }
      async function* _parallelMap(concurrency, func, iterable) {
        let transformError = null;
        const wrapFunc = (value) => ({
          value: func(value)
        });
        const stopOnError = async function* (source) {
          for await (const value of source) {
            if (transformError) {
              return;
            }
            yield value;
          }
        };
        const output = pipeline(() => iterable, buffer3(1), stopOnError, map12(wrapFunc), buffer3(concurrency - 1));
        const itr = getIterator(output);
        while (true) {
          const { value, done } = await itr.next();
          if (done) {
            break;
          }
          try {
            const val = await value.value;
            if (!transformError) {
              yield val;
            }
          } catch (error) {
            transformError = error;
          }
        }
        if (transformError) {
          throw transformError;
        }
      }
      function parallelMap(concurrency, func, iterable) {
        if (func === void 0) {
          return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);
        }
        if (iterable === void 0) {
          return (curriedIterable) => parallelMap(concurrency, func, curriedIterable);
        }
        if (concurrency === 1) {
          return map12(func, iterable);
        }
        return _parallelMap(concurrency, func, iterable);
      }
      function parallelFlatMap(concurrency, func, iterable) {
        if (func === void 0) {
          return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);
        }
        if (iterable === void 0) {
          return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);
        }
        return filter10((i) => i !== void 0 && i !== null, flatten2(parallelMap(concurrency, func, iterable)));
      }
      async function* parallelMerge(...iterables) {
        const inputs = iterables.map(getIterator);
        const concurrentWork = /* @__PURE__ */ new Set();
        const values2 = /* @__PURE__ */ new Map();
        let lastError = null;
        let errCb = null;
        let valueCb = null;
        const notifyError = (err) => {
          lastError = err;
          if (errCb) {
            errCb(err);
          }
        };
        const notifyDone = (value) => {
          if (valueCb) {
            valueCb(value);
          }
        };
        const waitForQueue = () => new Promise((resolve11, reject) => {
          if (lastError) {
            reject(lastError);
          }
          if (values2.size > 0) {
            return resolve11();
          }
          valueCb = resolve11;
          errCb = reject;
        });
        const queueNext = (input) => {
          const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {
            if (!done) {
              values2.set(input, value);
            }
            concurrentWork.delete(nextVal);
          });
          concurrentWork.add(nextVal);
          nextVal.then(notifyDone, notifyError);
        };
        for (const input of inputs) {
          queueNext(input);
        }
        while (true) {
          if (concurrentWork.size === 0 && values2.size === 0) {
            return;
          }
          await waitForQueue();
          for (const [input, value] of values2) {
            values2.delete(input);
            yield value;
            queueNext(input);
          }
        }
      }
      async function _reduce(func, start, iterable) {
        let value = start;
        for await (const nextItem of iterable) {
          value = await func(value, nextItem);
        }
        return value;
      }
      function reduce2(func, start, iterable) {
        if (start === void 0) {
          return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce2(func, curriedStart);
        }
        if (iterable === void 0) {
          return (curriedIterable) => reduce2(func, start, curriedIterable);
        }
        return _reduce(func, start, iterable);
      }
      async function* _take(count, iterable) {
        let taken = 0;
        for await (const val of iterable) {
          yield await val;
          taken++;
          if (taken >= count) {
            break;
          }
        }
      }
      function* _syncTake(count, iterable) {
        let taken = 0;
        for (const val of iterable) {
          yield val;
          taken++;
          if (taken >= count) {
            break;
          }
        }
      }
      function take5(count, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => take5(count, curriedIterable);
        }
        if (iterable[Symbol.asyncIterator]) {
          return _take(count, iterable);
        }
        return _syncTake(count, iterable);
      }
      async function* _asyncTap(func, iterable) {
        for await (const val of iterable) {
          await func(val);
          yield val;
        }
      }
      function tap(func, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => _asyncTap(func, curriedIterable);
        }
        return _asyncTap(func, iterable);
      }
      const sleep = (ms) => new Promise((resolve11) => setTimeout(resolve11, ms));
      function _throttle(limit, interval, iterable) {
        if (!Number.isFinite(limit)) {
          throw new TypeError("Expected `limit` to be a finite number");
        }
        if (limit <= 0) {
          throw new TypeError("Expected `limit` to be greater than 0");
        }
        if (!Number.isFinite(interval)) {
          throw new TypeError("Expected `interval` to be a finite number");
        }
        return async function* __throttle() {
          let sent = 0;
          let time2;
          for await (const val of iterable) {
            if (sent < limit) {
              if (typeof time2 === "undefined") {
                time2 = Date.now();
              }
              sent++;
              yield val;
              continue;
            }
            const elapsedMs = Date.now() - time2;
            const waitFor = interval - elapsedMs;
            if (waitFor > 0) {
              await sleep(waitFor);
            }
            time2 = Date.now();
            sent = 1;
            yield val;
          }
        }();
      }
      function throttle(limit, interval, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => _throttle(limit, interval, curriedIterable);
        }
        return _throttle(limit, interval, iterable);
      }
      function addTime(a, b) {
        let seconds = a[0] + b[0];
        let nanoseconds = a[1] + b[1];
        if (nanoseconds >= 1e9) {
          const remainder = nanoseconds % 1e9;
          seconds += (nanoseconds - remainder) / 1e9;
          nanoseconds = remainder;
        }
        return [seconds, nanoseconds];
      }
      async function* _asyncTime(config2, iterable) {
        const itr = iterable[Symbol.asyncIterator]();
        let total = [0, 0];
        while (true) {
          const start = process.hrtime();
          const { value, done } = await itr.next();
          const delta = process.hrtime(start);
          total = addTime(total, delta);
          if (config2.progress) {
            config2.progress(delta, total);
          }
          if (done) {
            if (config2.total) {
              config2.total(total);
            }
            return value;
          }
          yield value;
        }
      }
      function* _syncTime(config2, iterable) {
        const itr = iterable[Symbol.iterator]();
        let total = [0, 0];
        while (true) {
          const start = process.hrtime();
          const { value, done } = itr.next();
          const delta = process.hrtime(start);
          total = addTime(total, delta);
          if (config2.progress) {
            config2.progress(delta, total);
          }
          if (done) {
            if (config2.total) {
              config2.total(total);
            }
            return value;
          }
          yield value;
        }
      }
      function time(config2 = {}, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => time(config2, curriedIterable);
        }
        if (iterable[Symbol.asyncIterator] !== void 0) {
          return _asyncTime(config2, iterable);
        } else {
          return _syncTime(config2, iterable);
        }
      }
      function _transform(concurrency, func, iterable) {
        const iterator = getIterator(iterable);
        const resultQueue = [];
        const readQueue = [];
        let ended = false;
        let reading = false;
        let inflightCount = 0;
        let lastError = null;
        function fulfillReadQueue() {
          while (readQueue.length > 0 && resultQueue.length > 0) {
            const { resolve: resolve11 } = readQueue.shift();
            const value = resultQueue.shift();
            resolve11({ done: false, value });
          }
          while (readQueue.length > 0 && inflightCount === 0 && ended) {
            const { resolve: resolve11, reject } = readQueue.shift();
            if (lastError) {
              reject(lastError);
              lastError = null;
            } else {
              resolve11({ done: true, value: void 0 });
            }
          }
        }
        async function fillQueue() {
          if (ended) {
            fulfillReadQueue();
            return;
          }
          if (reading) {
            return;
          }
          if (inflightCount + resultQueue.length >= concurrency) {
            return;
          }
          reading = true;
          inflightCount++;
          try {
            const { done, value } = await iterator.next();
            if (done) {
              ended = true;
              inflightCount--;
              fulfillReadQueue();
            } else {
              mapAndQueue(value);
            }
          } catch (error) {
            ended = true;
            inflightCount--;
            lastError = error;
            fulfillReadQueue();
          }
          reading = false;
          fillQueue();
        }
        async function mapAndQueue(itrValue) {
          try {
            const value = await func(itrValue);
            resultQueue.push(value);
          } catch (error) {
            ended = true;
            lastError = error;
          }
          inflightCount--;
          fulfillReadQueue();
          fillQueue();
        }
        async function next() {
          if (resultQueue.length === 0) {
            const deferred = defer();
            readQueue.push(deferred);
            fillQueue();
            return deferred.promise;
          }
          const value = resultQueue.shift();
          fillQueue();
          return { done: false, value };
        }
        const asyncIterableIterator = {
          next,
          [Symbol.asyncIterator]: () => asyncIterableIterator
        };
        return asyncIterableIterator;
      }
      function transform(concurrency, func, iterable) {
        if (func === void 0) {
          return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);
        }
        if (iterable === void 0) {
          return (curriedIterable) => transform(concurrency, func, curriedIterable);
        }
        return _transform(concurrency, func, iterable);
      }
      async function _writeToStream(stream, iterable) {
        let lastError = null;
        let errCb = null;
        let drainCb = null;
        const notifyError = (err) => {
          lastError = err;
          if (errCb) {
            errCb(err);
          }
        };
        const notifyDrain = () => {
          if (drainCb) {
            drainCb();
          }
        };
        const cleanup = () => {
          stream.removeListener("error", notifyError);
          stream.removeListener("drain", notifyDrain);
        };
        stream.once("error", notifyError);
        const waitForDrain = () => new Promise((resolve11, reject) => {
          if (lastError) {
            return reject(lastError);
          }
          stream.once("drain", notifyDrain);
          drainCb = resolve11;
          errCb = reject;
        });
        for await (const value of iterable) {
          if (stream.write(value) === false) {
            await waitForDrain();
          }
          if (lastError) {
            break;
          }
        }
        cleanup();
        if (lastError) {
          throw lastError;
        }
      }
      function writeToStream(stream, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => _writeToStream(stream, curriedIterable);
        }
        return _writeToStream(stream, iterable);
      }
      exports3.batch = batch3;
      exports3.batchWithTimeout = batchWithTimeout;
      exports3.buffer = buffer3;
      exports3.collect = collect;
      exports3.concat = concat5;
      exports3.consume = consume;
      exports3.filter = filter10;
      exports3.flatMap = flatMap;
      exports3.flatTransform = flatTransform;
      exports3.flatten = flatten2;
      exports3.fromStream = fromStream;
      exports3.getIterator = getIterator;
      exports3.map = map12;
      exports3.merge = merge5;
      exports3.parallelFlatMap = parallelFlatMap;
      exports3.parallelMap = parallelMap;
      exports3.parallelMerge = parallelMerge;
      exports3.pipeline = pipeline;
      exports3.reduce = reduce2;
      exports3.take = take5;
      exports3.tap = tap;
      exports3.throttle = throttle;
      exports3.time = time;
      exports3.transform = transform;
      exports3.writeToStream = writeToStream;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/libp2p/src/metrics/old-peers.js
var require_old_peers = __commonJS({
  "node_modules/libp2p/src/metrics/old-peers.js"(exports2, module2) {
    "use strict";
    init_globals();
    var LRU = require_hashlru();
    module2.exports = (maxSize) => {
      const patched = LRU(maxSize);
      patched.delete = patched.remove;
      return patched;
    };
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    init_globals();
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2))
            return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber2.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE;
                if (i < 1)
                  i += LOG_BASE;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; )
            sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign3, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign3;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = function() {
          function multiply(x, k, base4) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base4 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base4;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare5(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base4) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base4 + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base4) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base4) {
              base4 = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base4 / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base4);
                xc = multiply(xc, n, base4);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base4 / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare5(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base4 + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base4)
                      n = base4 - 1;
                    prod = multiply(yc, n, base4);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare5(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base4);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base4);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare5(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base4);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base4 == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method) {
          var n, i = 1, m = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            n = new BigNumber2(args[i]);
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base4, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base4 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base4 ? p1 : m;
                });
                if (b) {
                  base4 = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base4);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare4(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare4(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare4(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare4(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare4(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare4(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy)
            t = xc, xc = yc, yc = t, y.s = -y.s;
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base4, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL)
            zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base4 = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base4 | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base4;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0)
            t = yc, yc = xc, xc = t, b = a;
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2)
              i = g1, g1 = g2, g2 = i, len -= i;
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare4(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name10) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name10 || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  }
});

// node_modules/@vascosantos/moving-average/index.js
var require_moving_average = __commonJS({
  "node_modules/@vascosantos/moving-average/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var exp = Math.exp;
    exports2 = module2.exports = function MovingAverage2(timespan) {
      if (typeof timespan !== "number") {
        throw new Error("must provide a timespan to the moving average constructor");
      }
      if (timespan <= 0) {
        throw new Error("must provide a timespan > 0 to the moving average constructor");
      }
      let ma;
      let v = 0;
      let d = 0;
      let f = 0;
      let previousTime;
      let ret = {};
      function alpha(t, pt) {
        return 1 - exp(-(t - pt) / timespan);
      }
      ret.push = function push(time, value) {
        if (previousTime) {
          const a = alpha(time, previousTime);
          const diff = value - ma;
          const incr = a * diff;
          ma = a * value + (1 - a) * ma;
          v = (1 - a) * (v + diff * incr);
          d = Math.sqrt(v);
          f = ma + a * diff;
        } else {
          ma = value;
        }
        previousTime = time;
      };
      ret.movingAverage = function movingAverage() {
        return ma;
      };
      ret.variance = function variance() {
        return v;
      };
      ret.deviation = function deviation() {
        return d;
      };
      ret.forecast = function forecast() {
        return f;
      };
      return ret;
    };
  }
});

// node_modules/libp2p/src/metrics/stats.js
var require_stats = __commonJS({
  "node_modules/libp2p/src/metrics/stats.js"(exports2, module2) {
    "use strict";
    init_globals();
    var { EventEmitter: EventEmitter4 } = require_events();
    var { BigNumber: Big } = require_bignumber();
    var MovingAverage2 = require_moving_average();
    var retimer = require_retimer();
    var Stats2 = class extends EventEmitter4 {
      constructor(initialCounters, options) {
        super();
        this._options = options;
        this._queue = [];
        this._stats = {
          dataReceived: Big(0),
          dataSent: Big(0)
        };
        this._frequencyLastTime = Date.now();
        this._frequencyAccumulators = {};
        this._movingAverages = {};
        this._update = this._update.bind(this);
        const intervals = this._options.movingAverageIntervals;
        for (let i = 0; i < initialCounters.length; i++) {
          const key = initialCounters[i];
          this._stats[key] = Big(0);
          this._movingAverages[key] = {};
          for (let k = 0; k < intervals.length; k++) {
            const interval = intervals[k];
            const ma = this._movingAverages[key][interval] = MovingAverage2(interval);
            ma.push(this._frequencyLastTime, 0);
          }
        }
      }
      start() {
        if (this._queue.length) {
          this._resetComputeTimeout();
        }
      }
      stop() {
        if (this._timeout) {
          this._timeout.clear();
          this._timeout = null;
        }
      }
      get snapshot() {
        return Object.assign({}, this._stats);
      }
      get movingAverages() {
        return Object.assign({}, this._movingAverages);
      }
      toJSON() {
        const snapshot = this.snapshot;
        const movingAverages = this.movingAverages;
        const data = {
          dataReceived: snapshot.dataReceived.toString(),
          dataSent: snapshot.dataSent.toString(),
          movingAverages: {}
        };
        const counters = Object.keys(movingAverages);
        for (const key of counters) {
          data.movingAverages[key] = {};
          for (const interval of Object.keys(movingAverages[key])) {
            data.movingAverages[key][interval] = movingAverages[key][interval].movingAverage();
          }
        }
        return data;
      }
      push(counter, inc) {
        this._queue.push([counter, inc, Date.now()]);
        this._resetComputeTimeout();
      }
      _resetComputeTimeout() {
        this._timeout = retimer(this._update, this._nextTimeout());
      }
      _nextTimeout() {
        const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
        const timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
        return timeout;
      }
      _update() {
        this._timeout = null;
        if (this._queue.length) {
          let last15;
          for (last15 of this._queue) {
            this._applyOp(last15);
          }
          this._queue = [];
          this._updateFrequency(last15[2]);
          this.emit("update", this._stats);
        }
      }
      _updateFrequency(latestTime) {
        const timeDiff = latestTime - this._frequencyLastTime;
        Object.keys(this._stats).forEach((key) => {
          this._updateFrequencyFor(key, timeDiff, latestTime);
        });
        this._frequencyLastTime = latestTime;
      }
      _updateFrequencyFor(key, timeDiffMS, latestTime) {
        const count = this._frequencyAccumulators[key] || 0;
        this._frequencyAccumulators[key] = 0;
        const safeTimeDiff = timeDiffMS || 1;
        const hz = count / safeTimeDiff * 1e3;
        let movingAverages = this._movingAverages[key];
        if (!movingAverages) {
          movingAverages = this._movingAverages[key] = {};
        }
        const intervals = this._options.movingAverageIntervals;
        for (let i = 0; i < intervals.length; i++) {
          const movingAverageInterval = intervals[i];
          let movingAverage = movingAverages[movingAverageInterval];
          if (!movingAverage) {
            movingAverage = movingAverages[movingAverageInterval] = MovingAverage2(movingAverageInterval);
          }
          movingAverage.push(latestTime, hz);
        }
      }
      _applyOp(op) {
        const key = op[0];
        const inc = op[1];
        if (typeof inc !== "number") {
          throw new Error(`invalid increment number: ${inc}`);
        }
        let n;
        if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
          n = this._stats[key] = Big(0);
        } else {
          n = this._stats[key];
        }
        this._stats[key] = n.plus(inc);
        if (!this._frequencyAccumulators[key]) {
          this._frequencyAccumulators[key] = 0;
        }
        this._frequencyAccumulators[key] += inc;
      }
    };
    module2.exports = Stats2;
  }
});

// node_modules/libp2p/src/metrics/index.js
var require_metrics = __commonJS({
  "node_modules/libp2p/src/metrics/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var mergeOptions17 = require_merge_options();
    var { pipe: pipe8 } = require_it_pipe();
    var { tap } = require_dist2();
    var oldPeerLRU = require_old_peers();
    var { METRICS: defaultOptions16 } = require_constants11();
    var Stats2 = require_stats();
    var initialCounters = [
      "dataReceived",
      "dataSent"
    ];
    var directionToEvent = {
      in: "dataReceived",
      out: "dataSent"
    };
    var Metrics = class {
      constructor(options) {
        this._options = mergeOptions17(defaultOptions16, options);
        this._globalStats = new Stats2(initialCounters, this._options);
        this._peerStats = /* @__PURE__ */ new Map();
        this._protocolStats = /* @__PURE__ */ new Map();
        this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);
        this._running = false;
        this._onMessage = this._onMessage.bind(this);
        this._systems = /* @__PURE__ */ new Map();
      }
      start() {
        this._running = true;
      }
      stop() {
        this._running = false;
        this._globalStats.stop();
        for (const stats of this._peerStats.values()) {
          stats.stop();
        }
        for (const stats of this._protocolStats.values()) {
          stats.stop();
        }
      }
      get global() {
        return this._globalStats;
      }
      get peers() {
        return Array.from(this._peerStats.keys());
      }
      getComponentMetrics() {
        return this._systems;
      }
      updateComponentMetric({ system = "libp2p", component, metric, value }) {
        if (!this._systems.has(system)) {
          this._systems.set(system, /* @__PURE__ */ new Map());
        }
        const systemMetrics = this._systems.get(system);
        if (!systemMetrics.has(component)) {
          systemMetrics.set(component, /* @__PURE__ */ new Map());
        }
        const componentMetrics = systemMetrics.get(component);
        componentMetrics.set(metric, value);
      }
      forPeer(peerId) {
        const idString = peerId.toB58String();
        return this._peerStats.get(idString) || this._oldPeers.get(idString);
      }
      get protocols() {
        return Array.from(this._protocolStats.keys());
      }
      forProtocol(protocol) {
        return this._protocolStats.get(protocol);
      }
      onPeerDisconnected(peerId) {
        const idString = peerId.toB58String();
        const peerStats = this._peerStats.get(idString);
        if (peerStats) {
          peerStats.stop();
          this._peerStats.delete(idString);
          this._oldPeers.set(idString, peerStats);
        }
      }
      _onMessage({ remotePeer, protocol, direction, dataLength }) {
        if (!this._running)
          return;
        const key = directionToEvent[direction];
        let peerStats = this.forPeer(remotePeer);
        if (!peerStats) {
          peerStats = new Stats2(initialCounters, this._options);
          this._peerStats.set(remotePeer.toB58String(), peerStats);
        }
        peerStats.push(key, dataLength);
        this._globalStats.push(key, dataLength);
        if (protocol) {
          let protocolStats = this.forProtocol(protocol);
          if (!protocolStats) {
            protocolStats = new Stats2(initialCounters, this._options);
            this._protocolStats.set(protocol, protocolStats);
          }
          protocolStats.push(key, dataLength);
        }
      }
      updatePlaceholder(placeholder, peerId) {
        if (!this._running)
          return;
        const placeholderStats = this.forPeer(placeholder);
        const peerIdString = peerId.toB58String();
        const existingStats = this.forPeer(peerId);
        let mergedStats = placeholderStats;
        if (existingStats) {
          mergedStats = Metrics.mergeStats(existingStats, mergedStats);
          this._oldPeers.delete(peerIdString);
        }
        this._peerStats.delete(placeholder.toB58String());
        this._peerStats.set(peerIdString, mergedStats);
        mergedStats.start();
      }
      trackStream({ stream, remotePeer, protocol }) {
        const metrics = this;
        const _source = stream.source;
        stream.source = tap((chunk) => metrics._onMessage({
          remotePeer,
          protocol,
          direction: "in",
          dataLength: chunk.length
        }))(_source);
        const _sink = stream.sink;
        stream.sink = (source) => {
          return pipe8(source, tap((chunk) => metrics._onMessage({
            remotePeer,
            protocol,
            direction: "out",
            dataLength: chunk.length
          })), _sink);
        };
        return stream;
      }
      static mergeStats(target, other) {
        target.stop();
        other.stop();
        target._queue = [...target._queue, ...other._queue];
        return target;
      }
    };
    module2.exports = Metrics;
  }
});

// node_modules/multistream-select/src/multistream.js
var require_multistream = __commonJS({
  "node_modules/multistream-select/src/multistream.js"(exports2, module2) {
    "use strict";
    init_globals();
    var BufferList3 = require_BufferList();
    var lp2 = require_src11();
    var { pipe: pipe8 } = require_it_pipe();
    var errCode69 = require_err_code();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var first4 = require_it_first();
    var { source } = require_abortable_iterator();
    var NewLine = uint8ArrayFromString("\n");
    function encode19(buffer3) {
      return lp2.encode.single(new BufferList3([buffer3, NewLine]));
    }
    function write2(writer, buffer3) {
      writer.push(encode19(buffer3));
    }
    async function writeAll(writer, buffers) {
      writer.push(buffers.reduce((bl, buffer3) => bl.append(encode19(buffer3)), new BufferList3()));
    }
    async function read3(reader, options) {
      let byteLength = 1;
      const varByteSource = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next: () => reader.next(byteLength)
      };
      let input = varByteSource;
      if (options && options.signal) {
        input = source(varByteSource, options.signal);
      }
      const onLength = (l) => {
        byteLength = l;
      };
      const buf3 = await pipe8(input, lp2.decode({ onLength }), first4);
      if (buf3.get(buf3.length - 1) !== NewLine[0]) {
        throw errCode69(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
      }
      return buf3.shallowSlice(0, -1);
    }
    module2.exports = {
      encode: encode19,
      write: write2,
      writeAll,
      read: read3
    };
  }
});

// node_modules/multistream-select/src/select.js
var require_select = __commonJS({
  "node_modules/multistream-select/src/select.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var errCode69 = require_err_code();
    var multistream = require_multistream();
    var handshake = require_src18();
    var log48 = Object.assign(debug50("mss:select"), {
      error: debug50("mss:select:error")
    });
    module2.exports = async function select(stream, protocols, protocolId, options) {
      protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
      const { reader, writer, rest, stream: shakeStream } = handshake(stream);
      const protocol = protocols.shift();
      if (!protocol) {
        throw new Error("At least one protocol must be specified");
      }
      if (protocolId) {
        log48('select: write ["%s", "%s"]', protocolId, protocol);
        multistream.writeAll(writer, [protocolId, protocol]);
      } else {
        log48('select: write "%s"', protocol);
        multistream.write(writer, protocol);
      }
      let response = (await multistream.read(reader, options)).toString();
      log48('select: read "%s"', response);
      if (response === protocolId) {
        response = (await multistream.read(reader, options)).toString();
        log48('select: read "%s"', response);
      }
      if (response === protocol) {
        rest();
        return { stream: shakeStream, protocol };
      }
      for (const protocol2 of protocols) {
        log48('select: write "%s"', protocol2);
        multistream.write(writer, protocol2);
        const response2 = (await multistream.read(reader, options)).toString();
        log48('select: read "%s" for "%s"', response2, protocol2);
        if (response2 === protocol2) {
          rest();
          return { stream: shakeStream, protocol: protocol2 };
        }
      }
      rest();
      throw errCode69(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL");
    };
  }
});

// node_modules/multistream-select/src/constants.js
var require_constants13 = __commonJS({
  "node_modules/multistream-select/src/constants.js"(exports2) {
    "use strict";
    init_globals();
    exports2.PROTOCOL_ID = "/multistream/1.0.0";
  }
});

// node_modules/multistream-select/src/handle.js
var require_handle = __commonJS({
  "node_modules/multistream-select/src/handle.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var BufferList3 = require_BufferList();
    var multistream = require_multistream();
    var handshake = require_src18();
    var { PROTOCOL_ID } = require_constants13();
    var log48 = Object.assign(debug50("mss:handle"), {
      error: debug50("mss:handle:error")
    });
    module2.exports = async function handle(stream, protocols, options) {
      protocols = Array.isArray(protocols) ? protocols : [protocols];
      const { writer, reader, rest, stream: shakeStream } = handshake(stream);
      while (true) {
        const protocol = (await multistream.read(reader, options)).toString();
        log48('read "%s"', protocol);
        if (protocol === PROTOCOL_ID) {
          log48('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
          multistream.write(writer, PROTOCOL_ID);
          continue;
        }
        if (protocols.includes(protocol)) {
          multistream.write(writer, protocol);
          log48('respond with "%s" for "%s"', protocol, protocol);
          rest();
          return { stream: shakeStream, protocol };
        }
        if (protocol === "ls") {
          multistream.write(writer, new BufferList3(protocols.map((p) => multistream.encode(p))));
          log48('respond with "%s" for %s', protocols, protocol);
          continue;
        }
        multistream.write(writer, "na");
        log48('respond with "na" for "%s"', protocol);
      }
    };
  }
});

// node_modules/multistream-select/src/ls.js
var require_ls = __commonJS({
  "node_modules/multistream-select/src/ls.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Reader = require_it_reader();
    var debug50 = require_browser2();
    var multistream = require_multistream();
    var handshake = require_src18();
    var lp2 = require_src11();
    var { pipe: pipe8 } = require_it_pipe();
    var log48 = Object.assign(debug50("mss:ls"), {
      error: debug50("mss:ls:error")
    });
    module2.exports = async function ls(stream, options) {
      const { reader, writer, rest, stream: shakeStream } = handshake(stream);
      log48('write "ls"');
      multistream.write(writer, "ls");
      rest();
      const res = await multistream.read(reader, options);
      const protocolsReader = Reader([res]);
      const protocols = [];
      await pipe8(protocolsReader, lp2.decode(), async (source) => {
        for await (const protocol of source) {
          protocols.push(protocol.shallowSlice(0, -1).toString());
        }
      });
      const output = { stream: shakeStream, protocols };
      return output;
    };
  }
});

// node_modules/multistream-select/src/index.js
var require_src25 = __commonJS({
  "node_modules/multistream-select/src/index.js"(exports2) {
    "use strict";
    init_globals();
    var select = require_select();
    var handle = require_handle();
    var ls = require_ls();
    var { PROTOCOL_ID } = require_constants13();
    exports2.PROTOCOL_ID = PROTOCOL_ID;
    var MultistreamSelect = class {
      constructor(stream) {
        this._stream = stream;
        this._shaken = false;
      }
      async _handshake(options) {
        if (this._shaken)
          return;
        const { stream } = await select(this._stream, PROTOCOL_ID, void 0, options);
        this._stream = stream;
        this._shaken = true;
      }
    };
    var Dialer = class extends MultistreamSelect {
      select(protocols, options) {
        return select(this._stream, protocols, this._shaken ? void 0 : PROTOCOL_ID, options);
      }
      async ls(options) {
        await this._handshake(options);
        const res = await ls(this._stream, options);
        const { stream, protocols } = res;
        this._stream = stream;
        return protocols;
      }
    };
    exports2.Dialer = Dialer;
    var Listener = class extends MultistreamSelect {
      handle(protocols, options) {
        return handle(this._stream, protocols, options);
      }
    };
    exports2.Listener = Listener;
  }
});

// node_modules/libp2p-interfaces/src/connection/status.js
var require_status = __commonJS({
  "node_modules/libp2p-interfaces/src/connection/status.js"(exports2, module2) {
    "use strict";
    init_globals();
    var STATUS = {
      OPEN: "open",
      CLOSING: "closing",
      CLOSED: "closed"
    };
    module2.exports = STATUS;
  }
});

// node_modules/libp2p-interfaces/src/connection/connection.js
var require_connection = __commonJS({
  "node_modules/libp2p-interfaces/src/connection/connection.js"(exports2, module2) {
    "use strict";
    init_globals();
    var PeerId14 = require_src5();
    var { Multiaddr: Multiaddr22 } = require_src();
    var errCode69 = require_err_code();
    var { OPEN, CLOSING, CLOSED } = require_status();
    var connectionSymbol = Symbol.for("@libp2p/interface-connection/connection");
    var Connection = class {
      constructor({ localAddr, remoteAddr, localPeer, remotePeer, newStream, close, getStreams, stat }) {
        validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat);
        this.id = parseInt(String(Math.random() * 1e9)).toString(36) + Date.now();
        this.localAddr = localAddr;
        this.remoteAddr = remoteAddr;
        this.localPeer = localPeer;
        this.remotePeer = remotePeer;
        this._stat = {
          ...stat,
          status: OPEN
        };
        this._newStream = newStream;
        this._close = close;
        this._getStreams = getStreams;
        this.registry = /* @__PURE__ */ new Map();
        this.tags = [];
      }
      get [Symbol.toStringTag]() {
        return "Connection";
      }
      get [connectionSymbol]() {
        return true;
      }
      static isConnection(other) {
        return Boolean(other && other[connectionSymbol]);
      }
      get stat() {
        return this._stat;
      }
      get streams() {
        return this._getStreams();
      }
      async newStream(protocols) {
        if (this.stat.status === CLOSING) {
          throw errCode69(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED");
        }
        if (this.stat.status === CLOSED) {
          throw errCode69(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED");
        }
        if (!Array.isArray(protocols))
          protocols = [protocols];
        const { stream, protocol } = await this._newStream(protocols);
        this.addStream(stream, { protocol });
        return {
          stream,
          protocol
        };
      }
      addStream(muxedStream, { protocol, metadata = {} }) {
        this.registry.set(muxedStream.id, {
          protocol,
          ...metadata
        });
      }
      removeStream(id) {
        this.registry.delete(id);
      }
      async close() {
        if (this.stat.status === CLOSED) {
          return;
        }
        if (this._closing) {
          return this._closing;
        }
        this.stat.status = CLOSING;
        this._closing = await this._close();
        this._stat.timeline.close = Date.now();
        this.stat.status = CLOSED;
      }
    };
    module2.exports = Connection;
    function validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {
      if (localAddr && !Multiaddr22.isMultiaddr(localAddr)) {
        throw errCode69(new Error("localAddr must be an instance of multiaddr"), "ERR_INVALID_PARAMETERS");
      }
      if (!PeerId14.isPeerId(localPeer)) {
        throw errCode69(new Error("localPeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS");
      }
      if (!PeerId14.isPeerId(remotePeer)) {
        throw errCode69(new Error("remotePeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS");
      }
      if (typeof newStream !== "function") {
        throw errCode69(new Error("new stream must be a function"), "ERR_INVALID_PARAMETERS");
      }
      if (typeof close !== "function") {
        throw errCode69(new Error("close must be a function"), "ERR_INVALID_PARAMETERS");
      }
      if (typeof getStreams !== "function") {
        throw errCode69(new Error("getStreams must be a function"), "ERR_INVALID_PARAMETERS");
      }
      if (!stat) {
        throw errCode69(new Error("connection metadata object must be provided"), "ERR_INVALID_PARAMETERS");
      }
      if (stat.direction !== "inbound" && stat.direction !== "outbound") {
        throw errCode69(new Error('direction must be "inbound" or "outbound"'), "ERR_INVALID_PARAMETERS");
      }
      if (!stat.timeline) {
        throw errCode69(new Error("connection timeline object must be provided in the stat object"), "ERR_INVALID_PARAMETERS");
      }
      if (!stat.timeline.open) {
        throw errCode69(new Error("connection open timestamp must be provided"), "ERR_INVALID_PARAMETERS");
      }
      if (!stat.timeline.upgraded) {
        throw errCode69(new Error("connection upgraded timestamp must be provided"), "ERR_INVALID_PARAMETERS");
      }
    }
  }
});

// node_modules/libp2p-interfaces/src/connection/index.js
var require_connection2 = __commonJS({
  "node_modules/libp2p-interfaces/src/connection/index.js"(exports2) {
    "use strict";
    init_globals();
    exports2.Connection = require_connection();
  }
});

// node_modules/mutable-proxy/build/index.js
var require_build = __commonJS({
  "node_modules/mutable-proxy/build/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    module2.exports = function mutableProxyFactory(defaultTarget) {
      var mutableHandler = void 0;
      var mutableTarget = void 0;
      function setTarget(target) {
        if (!(target instanceof Object)) {
          throw new Error('Target "' + target + '" is not an object');
        }
        mutableTarget = target;
      }
      function setHandler(handler2) {
        Object.keys(handler2).forEach(function(key) {
          var value = handler2[key];
          if (typeof value !== "function") {
            throw new Error('Trap "' + key + ": " + value + '" is not a function');
          }
          if (!Reflect[key]) {
            throw new Error('Trap "' + key + ": " + value + '" is not a valid trap');
          }
        });
        mutableHandler = handler2;
      }
      setTarget(function() {
      });
      if (defaultTarget) {
        setTarget(defaultTarget);
      }
      setHandler(Reflect);
      var handler = new Proxy({}, {
        get: function get6(target, property) {
          return function() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return mutableHandler[property].apply(null, [mutableTarget].concat(_toConsumableArray(args.slice(1))));
          };
        }
      });
      return {
        setTarget,
        setHandler,
        getTarget: function getTarget() {
          return mutableTarget;
        },
        getHandler: function getHandler() {
          return mutableHandler;
        },
        proxy: new Proxy(mutableTarget, handler)
      };
    };
  }
});

// node_modules/libp2p/src/upgrader.js
var require_upgrader = __commonJS({
  "node_modules/libp2p/src/upgrader.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:upgrader"), {
      error: debug50("libp2p:upgrader:err")
    });
    var errCode69 = require_err_code();
    var Multistream = require_src25();
    var { Connection } = require_connection2();
    var PeerId14 = require_src5();
    var { pipe: pipe8 } = require_it_pipe();
    var mutableProxy = require_build();
    var { codes } = require_errors3();
    var Upgrader = class {
      constructor({
        localPeer,
        metrics,
        connectionGater,
        cryptos = /* @__PURE__ */ new Map(),
        muxers = /* @__PURE__ */ new Map(),
        onConnectionEnd = () => {
        },
        onConnection = () => {
        }
      }) {
        this.connectionGater = connectionGater;
        this.localPeer = localPeer;
        this.metrics = metrics;
        this.cryptos = cryptos;
        this.muxers = muxers;
        this.protector = null;
        this.protocols = /* @__PURE__ */ new Map();
        this.onConnection = onConnection;
        this.onConnectionEnd = onConnectionEnd;
      }
      async upgradeInbound(maConn) {
        let encryptedConn;
        let remotePeer;
        let upgradedConn;
        let Muxer;
        let cryptoProtocol;
        let setPeer;
        let proxyPeer;
        if (await this.connectionGater.denyInboundConnection(maConn)) {
          throw errCode69(new Error("The multiaddr connection is blocked by gater.acceptConnection"), codes.ERR_CONNECTION_INTERCEPTED);
        }
        if (this.metrics) {
          ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy());
          const idString = (Math.random() * 1e9).toString(36) + Date.now();
          setPeer({ toB58String: () => idString });
          maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
        }
        log48("Starting the inbound connection upgrade");
        let protectedConn = maConn;
        if (this.protector) {
          protectedConn = await this.protector.protect(maConn);
        }
        try {
          ({
            conn: encryptedConn,
            remotePeer,
            protocol: cryptoProtocol
          } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos));
          if (await this.connectionGater.denyInboundEncryptedConnection(remotePeer, encryptedConn)) {
            throw errCode69(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
          }
          if (this.muxers.size) {
            ({ stream: upgradedConn, Muxer } = await this._multiplexInbound(encryptedConn, this.muxers));
          } else {
            upgradedConn = encryptedConn;
          }
        } catch (err) {
          log48.error("Failed to upgrade inbound connection", err);
          await maConn.close(err);
          throw err;
        }
        if (await this.connectionGater.denyInboundUpgradedConnection(remotePeer, encryptedConn)) {
          throw errCode69(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
        }
        if (this.metrics) {
          this.metrics.updatePlaceholder(proxyPeer, remotePeer);
          setPeer(remotePeer);
        }
        log48("Successfully upgraded inbound connection");
        return this._createConnection({
          cryptoProtocol,
          direction: "inbound",
          maConn,
          upgradedConn,
          Muxer,
          remotePeer
        });
      }
      async upgradeOutbound(maConn) {
        const idStr = maConn.remoteAddr.getPeerId();
        if (!idStr) {
          throw errCode69(new Error("outbound connection must have a peer id"), codes.ERR_INVALID_MULTIADDR);
        }
        const remotePeerId = PeerId14.createFromB58String(idStr);
        if (await this.connectionGater.denyOutboundConnection(remotePeerId, maConn)) {
          throw errCode69(new Error("The multiaddr connection is blocked by connectionGater.denyOutboundConnection"), codes.ERR_CONNECTION_INTERCEPTED);
        }
        let encryptedConn;
        let remotePeer;
        let upgradedConn;
        let cryptoProtocol;
        let Muxer;
        let setPeer;
        let proxyPeer;
        if (this.metrics) {
          ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy());
          const idString = (Math.random() * 1e9).toString(36) + Date.now();
          setPeer({ toB58String: () => idString });
          maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
        }
        log48("Starting the outbound connection upgrade");
        let protectedConn = maConn;
        if (this.protector) {
          protectedConn = await this.protector.protect(maConn);
        }
        try {
          ({
            conn: encryptedConn,
            remotePeer,
            protocol: cryptoProtocol
          } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos));
          if (await this.connectionGater.denyOutboundEncryptedConnection(remotePeer, encryptedConn)) {
            throw errCode69(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
          }
          if (this.muxers.size) {
            ({ stream: upgradedConn, Muxer } = await this._multiplexOutbound(encryptedConn, this.muxers));
          } else {
            upgradedConn = encryptedConn;
          }
        } catch (err) {
          log48.error("Failed to upgrade outbound connection", err);
          await maConn.close(err);
          throw err;
        }
        if (await this.connectionGater.denyOutboundUpgradedConnection(remotePeer, encryptedConn)) {
          throw errCode69(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
        }
        if (this.metrics) {
          this.metrics.updatePlaceholder(proxyPeer, remotePeer);
          setPeer(remotePeer);
        }
        log48("Successfully upgraded outbound connection");
        return this._createConnection({
          cryptoProtocol,
          direction: "outbound",
          maConn,
          upgradedConn,
          Muxer,
          remotePeer
        });
      }
      _createConnection({
        cryptoProtocol,
        direction,
        maConn,
        upgradedConn,
        Muxer,
        remotePeer
      }) {
        let muxer;
        let newStream;
        let connection;
        if (Muxer) {
          muxer = new Muxer({
            onStream: async (muxedStream) => {
              if (!connection)
                return;
              const mss = new Multistream.Listener(muxedStream);
              try {
                const { stream, protocol } = await mss.handle(Array.from(this.protocols.keys()));
                log48("%s: incoming stream opened on %s", direction, protocol);
                if (this.metrics)
                  this.metrics.trackStream({ stream, remotePeer, protocol });
                connection.addStream(muxedStream, { protocol });
                this._onStream({ connection, stream: { ...muxedStream, ...stream }, protocol });
              } catch (err) {
                log48.error(err);
              }
            },
            onStreamEnd: (muxedStream) => {
              connection.removeStream(muxedStream.id);
            }
          });
          newStream = async (protocols) => {
            log48("%s: starting new stream on %s", direction, protocols);
            const muxedStream = muxer.newStream();
            const mss = new Multistream.Dialer(muxedStream);
            try {
              const { stream, protocol } = await mss.select(protocols);
              if (this.metrics)
                this.metrics.trackStream({ stream, remotePeer, protocol });
              return { stream: { ...muxedStream, ...stream }, protocol };
            } catch (err) {
              log48.error("could not create new stream", err);
              throw errCode69(err, codes.ERR_UNSUPPORTED_PROTOCOL);
            }
          };
          pipe8(upgradedConn, muxer, upgradedConn).catch(log48.error);
        }
        const _timeline = maConn.timeline;
        maConn.timeline = new Proxy(_timeline, {
          set: (...args) => {
            if (connection && args[1] === "close" && args[2] && !_timeline.close) {
              (async () => {
                try {
                  if (connection.stat.status === "open") {
                    await connection.close();
                  }
                } catch (err) {
                  log48.error(err);
                } finally {
                  this.onConnectionEnd(connection);
                }
              })().catch((err) => {
                log48.error(err);
              });
            }
            return Reflect.set(...args);
          }
        });
        maConn.timeline.upgraded = Date.now();
        const errConnectionNotMultiplexed = () => {
          throw errCode69(new Error("connection is not multiplexed"), codes.ERR_CONNECTION_NOT_MULTIPLEXED);
        };
        connection = new Connection({
          localAddr: maConn.localAddr,
          remoteAddr: maConn.remoteAddr,
          localPeer: this.localPeer,
          remotePeer,
          stat: {
            direction,
            timeline: maConn.timeline,
            multiplexer: Muxer && Muxer.multicodec,
            encryption: cryptoProtocol
          },
          newStream: newStream || errConnectionNotMultiplexed,
          getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),
          close: async () => {
            await maConn.close();
            if (muxer) {
              muxer.streams.map((stream) => stream.abort());
            }
          }
        });
        this.onConnection(connection);
        return connection;
      }
      _onStream({ connection, stream, protocol }) {
        const handler = this.protocols.get(protocol);
        handler({ connection, stream, protocol });
      }
      async _encryptInbound(localPeer, connection, cryptos) {
        const mss = new Multistream.Listener(connection);
        const protocols = Array.from(cryptos.keys());
        log48("handling inbound crypto protocol selection", protocols);
        try {
          const { stream, protocol } = await mss.handle(protocols);
          const crypto6 = cryptos.get(protocol);
          log48("encrypting inbound connection...");
          if (!crypto6) {
            throw new Error(`no crypto module found for ${protocol}`);
          }
          return {
            ...await crypto6.secureInbound(localPeer, stream),
            protocol
          };
        } catch (err) {
          throw errCode69(err, codes.ERR_ENCRYPTION_FAILED);
        }
      }
      async _encryptOutbound(localPeer, connection, remotePeerId, cryptos) {
        const mss = new Multistream.Dialer(connection);
        const protocols = Array.from(cryptos.keys());
        log48("selecting outbound crypto protocol", protocols);
        try {
          const { stream, protocol } = await mss.select(protocols);
          const crypto6 = cryptos.get(protocol);
          log48("encrypting outbound connection to %j", remotePeerId);
          if (!crypto6) {
            throw new Error(`no crypto module found for ${protocol}`);
          }
          return {
            ...await crypto6.secureOutbound(localPeer, stream, remotePeerId),
            protocol
          };
        } catch (err) {
          throw errCode69(err, codes.ERR_ENCRYPTION_FAILED);
        }
      }
      async _multiplexOutbound(connection, muxers) {
        const dialer = new Multistream.Dialer(connection);
        const protocols = Array.from(muxers.keys());
        log48("outbound selecting muxer %s", protocols);
        try {
          const { stream, protocol } = await dialer.select(protocols);
          log48("%s selected as muxer protocol", protocol);
          const Muxer = muxers.get(protocol);
          return { stream, Muxer };
        } catch (err) {
          throw errCode69(err, codes.ERR_MUXER_UNAVAILABLE);
        }
      }
      async _multiplexInbound(connection, muxers) {
        const listener = new Multistream.Listener(connection);
        const protocols = Array.from(muxers.keys());
        log48("inbound handling muxers %s", protocols);
        try {
          const { stream, protocol } = await listener.handle(protocols);
          const Muxer = muxers.get(protocol);
          return { stream, Muxer };
        } catch (err) {
          throw errCode69(err, codes.ERR_MUXER_UNAVAILABLE);
        }
      }
    };
    module2.exports = Upgrader;
  }
});

// node_modules/it-foreach/index.js
var require_it_foreach = __commonJS({
  "node_modules/it-foreach/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var each = async function* (source, fn) {
      for await (const thing of source) {
        await fn(thing);
        yield thing;
      }
    };
    module2.exports = each;
  }
});

// node_modules/libp2p/src/peer-store/address-book.js
var require_address_book = __commonJS({
  "node_modules/libp2p/src/peer-store/address-book.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var errcode17 = require_err_code();
    var { Multiaddr: Multiaddr22 } = require_src();
    var PeerId14 = require_src5();
    var { codes } = require_errors3();
    var PeerRecord2 = require_peer_record2();
    var Envelope2 = require_envelope2();
    var { pipe: pipe8 } = require_it_pipe();
    var all6 = require_it_all();
    var filter10 = require_it_filter();
    var map12 = require_it_map();
    var each = require_it_foreach();
    var log48 = Object.assign(debug50("libp2p:peer-store:address-book"), {
      error: debug50("libp2p:peer-store:address-book:err")
    });
    var EVENT_NAME = "change:multiaddrs";
    var PeerStoreAddressBook = class {
      constructor(emit, store, addressFilter) {
        this._emit = emit;
        this._store = store;
        this._addressFilter = addressFilter;
      }
      async consumePeerRecord(envelope) {
        log48("consumePeerRecord await write lock");
        const release = await this._store.lock.writeLock();
        log48("consumePeerRecord got write lock");
        let peerId;
        let updatedPeer;
        try {
          let peerRecord;
          try {
            peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
          } catch (err) {
            log48.error("invalid peer record received");
            return false;
          }
          peerId = peerRecord.peerId;
          const multiaddrs = peerRecord.multiaddrs;
          if (!peerId.equals(envelope.peerId)) {
            log48("signing key does not match PeerId in the PeerRecord");
            return false;
          }
          if (!multiaddrs || !multiaddrs.length) {
            return false;
          }
          if (await this._store.has(peerId)) {
            const peer = await this._store.load(peerId);
            if (peer.peerRecordEnvelope) {
              const storedEnvelope = await Envelope2.createFromProtobuf(peer.peerRecordEnvelope);
              const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
              if (storedRecord.seqNumber >= peerRecord.seqNumber) {
                return false;
              }
            }
          }
          updatedPeer = await this._store.patchOrCreate(peerId, {
            addresses: await filterMultiaddrs(peerId, multiaddrs, this._addressFilter, true),
            peerRecordEnvelope: envelope.marshal()
          });
          log48(`stored provided peer record for ${peerRecord.peerId.toB58String()}`);
        } finally {
          log48("consumePeerRecord release write lock");
          release();
        }
        this._emit(EVENT_NAME, { peerId, multiaddrs: updatedPeer.addresses.map(({ multiaddr }) => multiaddr) });
        return true;
      }
      async getRawEnvelope(peerId) {
        log48("getRawEnvelope await read lock");
        const release = await this._store.lock.readLock();
        log48("getRawEnvelope got read lock");
        try {
          const peer = await this._store.load(peerId);
          return peer.peerRecordEnvelope;
        } catch (err) {
          if (err.code !== codes.ERR_NOT_FOUND) {
            throw err;
          }
        } finally {
          log48("getRawEnvelope release read lock");
          release();
        }
      }
      async getPeerRecord(peerId) {
        const raw = await this.getRawEnvelope(peerId);
        if (!raw) {
          return void 0;
        }
        return Envelope2.createFromProtobuf(raw);
      }
      async get(peerId) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("get wait for read lock");
        const release = await this._store.lock.readLock();
        log48("get got read lock");
        try {
          const peer = await this._store.load(peerId);
          return peer.addresses;
        } catch (err) {
          if (err.code !== codes.ERR_NOT_FOUND) {
            throw err;
          }
        } finally {
          log48("get release read lock");
          release();
        }
        return [];
      }
      async set(peerId, multiaddrs) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        if (!Array.isArray(multiaddrs)) {
          log48.error("multiaddrs must be an array of Multiaddrs");
          throw errcode17(new Error("multiaddrs must be an array of Multiaddrs"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("set await write lock");
        const release = await this._store.lock.writeLock();
        log48("set got write lock");
        let hasPeer = false;
        let updatedPeer;
        try {
          const addresses = await filterMultiaddrs(peerId, multiaddrs, this._addressFilter);
          if (!addresses.length) {
            return;
          }
          try {
            const peer = await this._store.load(peerId);
            hasPeer = true;
            if ((/* @__PURE__ */ new Set([
              ...addresses.map(({ multiaddr }) => multiaddr.toString()),
              ...peer.addresses.map(({ multiaddr }) => multiaddr.toString())
            ])).size === peer.addresses.length && addresses.length === peer.addresses.length) {
              return;
            }
          } catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
              throw err;
            }
          }
          updatedPeer = await this._store.patchOrCreate(peerId, { addresses });
          log48(`set multiaddrs for ${peerId.toB58String()}`);
        } finally {
          log48("set release write lock");
          release();
        }
        this._emit(EVENT_NAME, { peerId, multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr) });
        if (!hasPeer) {
          this._emit("peer", peerId);
        }
      }
      async add(peerId, multiaddrs) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        if (!Array.isArray(multiaddrs)) {
          log48.error("multiaddrs must be an array of Multiaddrs");
          throw errcode17(new Error("multiaddrs must be an array of Multiaddrs"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("add await write lock");
        const release = await this._store.lock.writeLock();
        log48("add got write lock");
        let hasPeer;
        let updatedPeer;
        try {
          const addresses = await filterMultiaddrs(peerId, multiaddrs, this._addressFilter);
          if (!addresses.length) {
            return;
          }
          try {
            const peer = await this._store.load(peerId);
            hasPeer = true;
            if ((/* @__PURE__ */ new Set([
              ...addresses.map(({ multiaddr }) => multiaddr.toString()),
              ...peer.addresses.map(({ multiaddr }) => multiaddr.toString())
            ])).size === peer.addresses.length) {
              return;
            }
          } catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
              throw err;
            }
          }
          updatedPeer = await this._store.mergeOrCreate(peerId, { addresses });
          log48(`added multiaddrs for ${peerId.toB58String()}`);
        } finally {
          log48("set release write lock");
          release();
        }
        this._emit(EVENT_NAME, { peerId, multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr) });
        if (!hasPeer) {
          this._emit("peer", peerId);
        }
      }
      async delete(peerId) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("delete await write lock");
        const release = await this._store.lock.writeLock();
        log48("delete got write lock");
        let has;
        try {
          has = await this._store.has(peerId);
          await this._store.patchOrCreate(peerId, {
            addresses: []
          });
        } finally {
          log48("delete release write lock");
          release();
        }
        if (has) {
          this._emit(EVENT_NAME, { peerId, multiaddrs: [] });
        }
      }
      async getMultiaddrsForPeer(peerId, addressSorter = (ms) => ms) {
        const addresses = await this.get(peerId);
        return addressSorter(addresses).map((address) => {
          const multiaddr = address.multiaddr;
          const idString = multiaddr.getPeerId();
          if (idString && idString === peerId.toB58String())
            return multiaddr;
          return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`);
        });
      }
    };
    function filterMultiaddrs(peerId, multiaddrs, addressFilter, isCertified = false) {
      return pipe8(multiaddrs, (source) => each(source, (multiaddr) => {
        if (!Multiaddr22.isMultiaddr(multiaddr)) {
          log48.error("multiaddr must be an instance of Multiaddr");
          throw errcode17(new Error("multiaddr must be an instance of Multiaddr"), codes.ERR_INVALID_PARAMETERS);
        }
      }), (source) => filter10(source, (multiaddr) => addressFilter(peerId, multiaddr)), (source) => map12(source, (multiaddr) => {
        return {
          multiaddr: new Multiaddr22(multiaddr.toString()),
          isCertified
        };
      }), (source) => all6(source));
    }
    module2.exports = PeerStoreAddressBook;
  }
});

// node_modules/libp2p/src/peer-store/key-book.js
var require_key_book = __commonJS({
  "node_modules/libp2p/src/peer-store/key-book.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var errcode17 = require_err_code();
    var { codes } = require_errors3();
    var PeerId14 = require_src5();
    var { equals: uint8arrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var log48 = Object.assign(debug50("libp2p:peer-store:key-book"), {
      error: debug50("libp2p:peer-store:key-book:err")
    });
    var EVENT_NAME = "change:pubkey";
    var PeerStoreKeyBook = class {
      constructor(emit, store) {
        this._emit = emit;
        this._store = store;
      }
      async set(peerId, publicKey) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        if (!publicKey) {
          log48.error("publicKey must be an instance of PublicKey to store data");
          throw errcode17(new Error("publicKey must be an instance of PublicKey"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("set await write lock");
        const release = await this._store.lock.writeLock();
        log48("set got write lock");
        let updatedKey = false;
        try {
          try {
            const existing = await this._store.load(peerId);
            if (existing.pubKey && uint8arrayEquals(existing.pubKey.bytes, publicKey.bytes)) {
              return;
            }
          } catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
              throw err;
            }
          }
          await this._store.patchOrCreate(peerId, {
            pubKey: publicKey
          });
          updatedKey = true;
        } finally {
          log48("set release write lock");
          release();
        }
        if (updatedKey) {
          this._emit(EVENT_NAME, { peerId, pubKey: publicKey });
        }
      }
      async get(peerId) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("get await write lock");
        const release = await this._store.lock.readLock();
        log48("get got write lock");
        try {
          const peer = await this._store.load(peerId);
          return peer.pubKey;
        } catch (err) {
          if (err.code !== codes.ERR_NOT_FOUND) {
            throw err;
          }
        } finally {
          log48("get release write lock");
          release();
        }
      }
      async delete(peerId) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("delete await write lock");
        const release = await this._store.lock.writeLock();
        log48("delete got write lock");
        try {
          await this._store.patchOrCreate(peerId, {
            pubKey: void 0
          });
        } finally {
          log48("delete release write lock");
          release();
        }
        this._emit(EVENT_NAME, { peerId, pubKey: void 0 });
      }
    };
    module2.exports = PeerStoreKeyBook;
  }
});

// node_modules/libp2p/src/peer-store/metadata-book.js
var require_metadata_book = __commonJS({
  "node_modules/libp2p/src/peer-store/metadata-book.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var errcode17 = require_err_code();
    var { codes } = require_errors3();
    var PeerId14 = require_src5();
    var { equals: uint8ArrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var log48 = Object.assign(debug50("libp2p:peer-store:metadata-book"), {
      error: debug50("libp2p:peer-store:metadata-book:err")
    });
    var EVENT_NAME = "change:metadata";
    var PeerStoreMetadataBook = class {
      constructor(emit, store) {
        this._emit = emit;
        this._store = store;
      }
      async get(peerId) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("get await read lock");
        const release = await this._store.lock.readLock();
        log48("get got read lock");
        try {
          const peer = await this._store.load(peerId);
          return peer.metadata;
        } catch (err) {
          if (err.code !== codes.ERR_NOT_FOUND) {
            throw err;
          }
        } finally {
          log48("get release read lock");
          release();
        }
        return /* @__PURE__ */ new Map();
      }
      async getValue(peerId, key) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("getValue await read lock");
        const release = await this._store.lock.readLock();
        log48("getValue got read lock");
        try {
          const peer = await this._store.load(peerId);
          return peer.metadata.get(key);
        } catch (err) {
          if (err.code !== codes.ERR_NOT_FOUND) {
            throw err;
          }
        } finally {
          log48("getValue release write lock");
          release();
        }
      }
      async set(peerId, metadata) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        if (!metadata || !(metadata instanceof Map)) {
          log48.error("valid metadata must be provided to store data");
          throw errcode17(new Error("valid metadata must be provided"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("set await write lock");
        const release = await this._store.lock.writeLock();
        log48("set got write lock");
        try {
          await this._store.mergeOrCreate(peerId, {
            metadata
          });
        } finally {
          log48("set release write lock");
          release();
        }
        this._emit(EVENT_NAME, { peerId, metadata });
      }
      async setValue(peerId, key, value) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        if (typeof key !== "string" || !(value instanceof Uint8Array)) {
          log48.error("valid key and value must be provided to store data");
          throw errcode17(new Error("valid key and value must be provided"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("setValue await write lock");
        const release = await this._store.lock.writeLock();
        log48("setValue got write lock");
        let updatedPeer;
        try {
          try {
            const existingPeer = await this._store.load(peerId);
            const existingValue = existingPeer.metadata.get(key);
            if (existingValue != null && uint8ArrayEquals(value, existingValue)) {
              return;
            }
          } catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
              throw err;
            }
          }
          updatedPeer = await this._store.mergeOrCreate(peerId, {
            metadata: /* @__PURE__ */ new Map([[key, value]])
          });
        } finally {
          log48("setValue release write lock");
          release();
        }
        this._emit(EVENT_NAME, { peerId, metadata: updatedPeer.metadata });
      }
      async delete(peerId) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("delete await write lock");
        const release = await this._store.lock.writeLock();
        log48("delete got write lock");
        let has;
        try {
          has = await this._store.has(peerId);
          if (has) {
            await this._store.patch(peerId, {
              metadata: /* @__PURE__ */ new Map()
            });
          }
        } finally {
          log48("delete release write lock");
          release();
        }
        if (has) {
          this._emit(EVENT_NAME, { peerId, metadata: /* @__PURE__ */ new Map() });
        }
      }
      async deleteValue(peerId, key) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("deleteValue await write lock");
        const release = await this._store.lock.writeLock();
        log48("deleteValue got write lock");
        let metadata;
        try {
          const peer = await this._store.load(peerId);
          metadata = peer.metadata;
          metadata.delete(key);
          await this._store.patch(peerId, {
            metadata
          });
        } catch (err) {
          if (err.code !== codes.ERR_NOT_FOUND) {
            throw err;
          }
        } finally {
          log48("deleteValue release write lock");
          release();
        }
        if (metadata) {
          this._emit(EVENT_NAME, { peerId, metadata });
        }
      }
    };
    module2.exports = PeerStoreMetadataBook;
  }
});

// node_modules/libp2p/src/peer-store/proto-book.js
var require_proto_book = __commonJS({
  "node_modules/libp2p/src/peer-store/proto-book.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var errcode17 = require_err_code();
    var { codes } = require_errors3();
    var PeerId14 = require_src5();
    var log48 = Object.assign(debug50("libp2p:peer-store:proto-book"), {
      error: debug50("libp2p:peer-store:proto-book:err")
    });
    var EVENT_NAME = "change:protocols";
    var PersistentProtoBook = class {
      constructor(emit, store) {
        this._emit = emit;
        this._store = store;
      }
      async get(peerId) {
        log48("get wait for read lock");
        const release = await this._store.lock.readLock();
        log48("get got read lock");
        try {
          const peer = await this._store.load(peerId);
          return peer.protocols;
        } catch (err) {
          if (err.code !== codes.ERR_NOT_FOUND) {
            throw err;
          }
        } finally {
          log48("get release read lock");
          release();
        }
        return [];
      }
      async set(peerId, protocols) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        if (!Array.isArray(protocols)) {
          log48.error("protocols must be provided to store data");
          throw errcode17(new Error("protocols must be provided"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("set await write lock");
        const release = await this._store.lock.writeLock();
        log48("set got write lock");
        let updatedPeer;
        try {
          try {
            const peer = await this._store.load(peerId);
            if ((/* @__PURE__ */ new Set([
              ...protocols
            ])).size === peer.protocols.length) {
              return;
            }
          } catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
              throw err;
            }
          }
          updatedPeer = await this._store.patchOrCreate(peerId, {
            protocols
          });
          log48(`stored provided protocols for ${peerId.toB58String()}`);
        } finally {
          log48("set release write lock");
          release();
        }
        this._emit(EVENT_NAME, { peerId, protocols: updatedPeer.protocols });
      }
      async add(peerId, protocols) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        if (!Array.isArray(protocols)) {
          log48.error("protocols must be provided to store data");
          throw errcode17(new Error("protocols must be provided"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("add await write lock");
        const release = await this._store.lock.writeLock();
        log48("add got write lock");
        let updatedPeer;
        try {
          try {
            const peer = await this._store.load(peerId);
            if ((/* @__PURE__ */ new Set([
              ...peer.protocols,
              ...protocols
            ])).size === peer.protocols.length) {
              return;
            }
          } catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
              throw err;
            }
          }
          updatedPeer = await this._store.mergeOrCreate(peerId, {
            protocols
          });
          log48(`added provided protocols for ${peerId.toB58String()}`);
        } finally {
          log48("add release write lock");
          release();
        }
        this._emit(EVENT_NAME, { peerId, protocols: updatedPeer.protocols });
      }
      async remove(peerId, protocols) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        if (!Array.isArray(protocols)) {
          log48.error("protocols must be provided to store data");
          throw errcode17(new Error("protocols must be provided"), codes.ERR_INVALID_PARAMETERS);
        }
        log48("remove await write lock");
        const release = await this._store.lock.writeLock();
        log48("remove got write lock");
        let updatedPeer;
        try {
          try {
            const peer = await this._store.load(peerId);
            const protocolSet = new Set(peer.protocols);
            for (const protocol of protocols) {
              protocolSet.delete(protocol);
            }
            if (peer.protocols.length === protocolSet.size) {
              return;
            }
            protocols = Array.from(protocolSet);
          } catch (err) {
            if (err.code !== codes.ERR_NOT_FOUND) {
              throw err;
            }
          }
          updatedPeer = await this._store.patchOrCreate(peerId, {
            protocols
          });
        } finally {
          log48("remove release write lock");
          release();
        }
        this._emit(EVENT_NAME, { peerId, protocols: updatedPeer.protocols });
      }
      async delete(peerId) {
        log48("delete await write lock");
        const release = await this._store.lock.writeLock();
        log48("delete got write lock");
        let has;
        try {
          has = await this._store.has(peerId);
          await this._store.patchOrCreate(peerId, {
            protocols: []
          });
        } catch (err) {
          if (err.code !== codes.ERR_NOT_FOUND) {
            throw err;
          }
        } finally {
          log48("delete release write lock");
          release();
        }
        if (has) {
          this._emit(EVENT_NAME, { peerId, protocols: [] });
        }
      }
    };
    module2.exports = PersistentProtoBook;
  }
});

// node_modules/libp2p/src/peer-store/pb/peer.js
var require_peer = __commonJS({
  "node_modules/libp2p/src/peer-store/pb/peer.js"(exports2, module2) {
    "use strict";
    init_globals();
    var $protobuf12 = require_minimal2();
    var $Reader11 = $protobuf12.Reader;
    var $Writer11 = $protobuf12.Writer;
    var $util11 = $protobuf12.util;
    var $root11 = $protobuf12.roots["libp2p-peer"] || ($protobuf12.roots["libp2p-peer"] = {});
    $root11.Peer = function() {
      function Peer3(p) {
        this.addresses = [];
        this.protocols = [];
        this.metadata = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Peer3.prototype.addresses = $util11.emptyArray;
      Peer3.prototype.protocols = $util11.emptyArray;
      Peer3.prototype.metadata = $util11.emptyArray;
      Peer3.prototype.pubKey = null;
      Peer3.prototype.peerRecordEnvelope = null;
      var $oneOfFields;
      Object.defineProperty(Peer3.prototype, "_pubKey", {
        get: $util11.oneOfGetter($oneOfFields = ["pubKey"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Peer3.prototype, "_peerRecordEnvelope", {
        get: $util11.oneOfGetter($oneOfFields = ["peerRecordEnvelope"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Peer3.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.addresses != null && m.addresses.length) {
          for (var i = 0; i < m.addresses.length; ++i)
            $root11.Address.encode(m.addresses[i], w.uint32(10).fork()).ldelim();
        }
        if (m.protocols != null && m.protocols.length) {
          for (var i = 0; i < m.protocols.length; ++i)
            w.uint32(18).string(m.protocols[i]);
        }
        if (m.metadata != null && m.metadata.length) {
          for (var i = 0; i < m.metadata.length; ++i)
            $root11.Metadata.encode(m.metadata[i], w.uint32(26).fork()).ldelim();
        }
        if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
          w.uint32(34).bytes(m.pubKey);
        if (m.peerRecordEnvelope != null && Object.hasOwnProperty.call(m, "peerRecordEnvelope"))
          w.uint32(42).bytes(m.peerRecordEnvelope);
        return w;
      };
      Peer3.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.Peer();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              if (!(m.addresses && m.addresses.length))
                m.addresses = [];
              m.addresses.push($root11.Address.decode(r, r.uint32()));
              break;
            case 2:
              if (!(m.protocols && m.protocols.length))
                m.protocols = [];
              m.protocols.push(r.string());
              break;
            case 3:
              if (!(m.metadata && m.metadata.length))
                m.metadata = [];
              m.metadata.push($root11.Metadata.decode(r, r.uint32()));
              break;
            case 4:
              m.pubKey = r.bytes();
              break;
            case 5:
              m.peerRecordEnvelope = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Peer3.fromObject = function fromObject(d) {
        if (d instanceof $root11.Peer)
          return d;
        var m = new $root11.Peer();
        if (d.addresses) {
          if (!Array.isArray(d.addresses))
            throw TypeError(".Peer.addresses: array expected");
          m.addresses = [];
          for (var i = 0; i < d.addresses.length; ++i) {
            if (typeof d.addresses[i] !== "object")
              throw TypeError(".Peer.addresses: object expected");
            m.addresses[i] = $root11.Address.fromObject(d.addresses[i]);
          }
        }
        if (d.protocols) {
          if (!Array.isArray(d.protocols))
            throw TypeError(".Peer.protocols: array expected");
          m.protocols = [];
          for (var i = 0; i < d.protocols.length; ++i) {
            m.protocols[i] = String(d.protocols[i]);
          }
        }
        if (d.metadata) {
          if (!Array.isArray(d.metadata))
            throw TypeError(".Peer.metadata: array expected");
          m.metadata = [];
          for (var i = 0; i < d.metadata.length; ++i) {
            if (typeof d.metadata[i] !== "object")
              throw TypeError(".Peer.metadata: object expected");
            m.metadata[i] = $root11.Metadata.fromObject(d.metadata[i]);
          }
        }
        if (d.pubKey != null) {
          if (typeof d.pubKey === "string")
            $util11.base64.decode(d.pubKey, m.pubKey = $util11.newBuffer($util11.base64.length(d.pubKey)), 0);
          else if (d.pubKey.length)
            m.pubKey = d.pubKey;
        }
        if (d.peerRecordEnvelope != null) {
          if (typeof d.peerRecordEnvelope === "string")
            $util11.base64.decode(d.peerRecordEnvelope, m.peerRecordEnvelope = $util11.newBuffer($util11.base64.length(d.peerRecordEnvelope)), 0);
          else if (d.peerRecordEnvelope.length)
            m.peerRecordEnvelope = d.peerRecordEnvelope;
        }
        return m;
      };
      Peer3.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.addresses = [];
          d.protocols = [];
          d.metadata = [];
        }
        if (m.addresses && m.addresses.length) {
          d.addresses = [];
          for (var j = 0; j < m.addresses.length; ++j) {
            d.addresses[j] = $root11.Address.toObject(m.addresses[j], o);
          }
        }
        if (m.protocols && m.protocols.length) {
          d.protocols = [];
          for (var j = 0; j < m.protocols.length; ++j) {
            d.protocols[j] = m.protocols[j];
          }
        }
        if (m.metadata && m.metadata.length) {
          d.metadata = [];
          for (var j = 0; j < m.metadata.length; ++j) {
            d.metadata[j] = $root11.Metadata.toObject(m.metadata[j], o);
          }
        }
        if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
          d.pubKey = o.bytes === String ? $util11.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
          if (o.oneofs)
            d._pubKey = "pubKey";
        }
        if (m.peerRecordEnvelope != null && m.hasOwnProperty("peerRecordEnvelope")) {
          d.peerRecordEnvelope = o.bytes === String ? $util11.base64.encode(m.peerRecordEnvelope, 0, m.peerRecordEnvelope.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerRecordEnvelope) : m.peerRecordEnvelope;
          if (o.oneofs)
            d._peerRecordEnvelope = "peerRecordEnvelope";
        }
        return d;
      };
      Peer3.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      return Peer3;
    }();
    $root11.Address = function() {
      function Address2(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Address2.prototype.multiaddr = $util11.newBuffer([]);
      Address2.prototype.isCertified = null;
      var $oneOfFields;
      Object.defineProperty(Address2.prototype, "_isCertified", {
        get: $util11.oneOfGetter($oneOfFields = ["isCertified"]),
        set: $util11.oneOfSetter($oneOfFields)
      });
      Address2.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
          w.uint32(10).bytes(m.multiaddr);
        if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
          w.uint32(16).bool(m.isCertified);
        return w;
      };
      Address2.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.Address();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.multiaddr = r.bytes();
              break;
            case 2:
              m.isCertified = r.bool();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Address2.fromObject = function fromObject(d) {
        if (d instanceof $root11.Address)
          return d;
        var m = new $root11.Address();
        if (d.multiaddr != null) {
          if (typeof d.multiaddr === "string")
            $util11.base64.decode(d.multiaddr, m.multiaddr = $util11.newBuffer($util11.base64.length(d.multiaddr)), 0);
          else if (d.multiaddr.length)
            m.multiaddr = d.multiaddr;
        }
        if (d.isCertified != null) {
          m.isCertified = Boolean(d.isCertified);
        }
        return m;
      };
      Address2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.multiaddr = "";
          else {
            d.multiaddr = [];
            if (o.bytes !== Array)
              d.multiaddr = $util11.newBuffer(d.multiaddr);
          }
        }
        if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
          d.multiaddr = o.bytes === String ? $util11.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
        }
        if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
          d.isCertified = m.isCertified;
          if (o.oneofs)
            d._isCertified = "isCertified";
        }
        return d;
      };
      Address2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      return Address2;
    }();
    $root11.Metadata = function() {
      function Metadata4(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Metadata4.prototype.key = "";
      Metadata4.prototype.value = $util11.newBuffer([]);
      Metadata4.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.key != null && Object.hasOwnProperty.call(m, "key"))
          w.uint32(10).string(m.key);
        if (m.value != null && Object.hasOwnProperty.call(m, "value"))
          w.uint32(18).bytes(m.value);
        return w;
      };
      Metadata4.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.Metadata();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.key = r.string();
              break;
            case 2:
              m.value = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Metadata4.fromObject = function fromObject(d) {
        if (d instanceof $root11.Metadata)
          return d;
        var m = new $root11.Metadata();
        if (d.key != null) {
          m.key = String(d.key);
        }
        if (d.value != null) {
          if (typeof d.value === "string")
            $util11.base64.decode(d.value, m.value = $util11.newBuffer($util11.base64.length(d.value)), 0);
          else if (d.value.length)
            m.value = d.value;
        }
        return m;
      };
      Metadata4.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.key = "";
          if (o.bytes === String)
            d.value = "";
          else {
            d.value = [];
            if (o.bytes !== Array)
              d.value = $util11.newBuffer(d.value);
          }
        }
        if (m.key != null && m.hasOwnProperty("key")) {
          d.key = m.key;
        }
        if (m.value != null && m.hasOwnProperty("value")) {
          d.value = o.bytes === String ? $util11.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
        }
        return d;
      };
      Metadata4.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      return Metadata4;
    }();
    module2.exports = $root11;
  }
});

// node_modules/libp2p/src/peer-store/store.js
var require_store = __commonJS({
  "node_modules/libp2p/src/peer-store/store.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var PeerId14 = require_src5();
    var errcode17 = require_err_code();
    var { codes } = require_errors3();
    var { Key: Key2 } = (init_key(), __toCommonJS(key_exports));
    var { base32: base323 } = (init_base32(), __toCommonJS(base32_exports));
    var { keys: { unmarshalPublicKey, marshalPublicKey } } = require_src6();
    var { Multiaddr: Multiaddr22 } = require_src();
    var { Peer: PeerPB } = require_peer();
    var mortice3 = require_lib6();
    var { equals: uint8arrayEquals } = (init_equals(), __toCommonJS(equals_exports));
    var log48 = Object.assign(debug50("libp2p:peer-store:store"), {
      error: debug50("libp2p:peer-store:store:err")
    });
    var NAMESPACE_COMMON = "/peers/";
    var PersistentStore = class {
      constructor(datastore) {
        this._datastore = datastore;
        this.lock = mortice3("peer-store", {
          singleProcess: true
        });
      }
      _peerIdToDatastoreKey(peerId) {
        if (!PeerId14.isPeerId(peerId)) {
          log48.error("peerId must be an instance of peer-id to store data");
          throw errcode17(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
        }
        const b32key = peerId.toString();
        return new Key2(`${NAMESPACE_COMMON}${b32key}`);
      }
      async has(peerId) {
        return this._datastore.has(this._peerIdToDatastoreKey(peerId));
      }
      async delete(peerId) {
        await this._datastore.delete(this._peerIdToDatastoreKey(peerId));
      }
      async load(peerId) {
        const buf3 = await this._datastore.get(this._peerIdToDatastoreKey(peerId));
        const peer = PeerPB.decode(buf3);
        const pubKey = peer.pubKey ? unmarshalPublicKey(peer.pubKey) : peerId.pubKey;
        const metadata = /* @__PURE__ */ new Map();
        for (const meta of peer.metadata) {
          metadata.set(meta.key, meta.value);
        }
        return {
          ...peer,
          id: peerId,
          pubKey,
          addresses: peer.addresses.map(({ multiaddr, isCertified }) => ({
            multiaddr: new Multiaddr22(multiaddr),
            isCertified: isCertified || false
          })),
          metadata,
          peerRecordEnvelope: peer.peerRecordEnvelope || void 0
        };
      }
      async save(peer) {
        if (peer.pubKey != null && peer.id.pubKey != null && !uint8arrayEquals(peer.pubKey.bytes, peer.id.pubKey.bytes)) {
          log48.error("peer publicKey bytes do not match peer id publicKey bytes");
          throw errcode17(new Error("publicKey bytes do not match peer id publicKey bytes"), codes.ERR_INVALID_PARAMETERS);
        }
        const addressSet = /* @__PURE__ */ new Set();
        const buf3 = PeerPB.encode({
          addresses: peer.addresses.filter((address) => {
            if (addressSet.has(address.multiaddr.toString())) {
              return false;
            }
            addressSet.add(address.multiaddr.toString());
            return true;
          }).sort((a, b) => {
            return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
          }).map(({ multiaddr, isCertified }) => ({
            multiaddr: multiaddr.bytes,
            isCertified
          })),
          protocols: peer.protocols.sort(),
          pubKey: peer.pubKey ? marshalPublicKey(peer.pubKey) : void 0,
          metadata: [...peer.metadata.keys()].sort().map((key) => ({ key, value: peer.metadata.get(key) })),
          peerRecordEnvelope: peer.peerRecordEnvelope
        }).finish();
        await this._datastore.put(this._peerIdToDatastoreKey(peer.id), buf3);
        return this.load(peer.id);
      }
      async patch(peerId, data) {
        const peer = await this.load(peerId);
        return await this._patch(peerId, data, peer);
      }
      async patchOrCreate(peerId, data) {
        let peer;
        try {
          peer = await this.load(peerId);
        } catch (err) {
          if (err.code !== codes.ERR_NOT_FOUND) {
            throw err;
          }
          peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
        }
        return await this._patch(peerId, data, peer);
      }
      async _patch(peerId, data, peer) {
        return await this.save({
          ...peer,
          ...data,
          id: peerId
        });
      }
      async merge(peerId, data) {
        const peer = await this.load(peerId);
        return this._merge(peerId, data, peer);
      }
      async mergeOrCreate(peerId, data) {
        let peer;
        try {
          peer = await this.load(peerId);
        } catch (err) {
          if (err.code !== codes.ERR_NOT_FOUND) {
            throw err;
          }
          peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
        }
        return await this._merge(peerId, data, peer);
      }
      async _merge(peerId, data, peer) {
        const addresses = /* @__PURE__ */ new Map();
        (data.addresses || []).forEach((addr) => {
          addresses.set(addr.multiaddr.toString(), addr.isCertified);
        });
        peer.addresses.forEach(({ multiaddr, isCertified }) => {
          const addrStr = multiaddr.toString();
          addresses.set(addrStr, Boolean(addresses.get(addrStr) || isCertified));
        });
        return await this.save({
          id: peerId,
          addresses: Array.from(addresses.entries()).map(([addrStr, isCertified]) => {
            return {
              multiaddr: new Multiaddr22(addrStr),
              isCertified
            };
          }),
          protocols: Array.from(/* @__PURE__ */ new Set([
            ...peer.protocols || [],
            ...data.protocols || []
          ])),
          metadata: new Map([
            ...peer.metadata ? peer.metadata.entries() : [],
            ...data.metadata ? data.metadata.entries() : []
          ]),
          pubKey: data.pubKey || (peer != null ? peer.pubKey : void 0),
          peerRecordEnvelope: data.peerRecordEnvelope || (peer != null ? peer.peerRecordEnvelope : void 0)
        });
      }
      async *all() {
        for await (const key of this._datastore.queryKeys({
          prefix: NAMESPACE_COMMON
        })) {
          const base32Str = key.toString().split("/")[2];
          const buf3 = base323.decode(base32Str);
          yield this.load(PeerId14.createFromBytes(buf3));
        }
      }
    };
    module2.exports = PersistentStore;
  }
});

// node_modules/libp2p/src/peer-store/index.js
var require_peer_store = __commonJS({
  "node_modules/libp2p/src/peer-store/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var { EventEmitter: EventEmitter4 } = require_events();
    var AddressBook = require_address_book();
    var KeyBook = require_key_book();
    var MetadataBook = require_metadata_book();
    var ProtoBook = require_proto_book();
    var Store = require_store();
    var log48 = Object.assign(debug50("libp2p:peer-store"), {
      error: debug50("libp2p:peer-store:err")
    });
    var DefaultPeerStore = class extends EventEmitter4 {
      constructor({ peerId, datastore, addressFilter }) {
        super();
        this._peerId = peerId;
        this._store = new Store(datastore);
        this.addressBook = new AddressBook(this.emit.bind(this), this._store, addressFilter);
        this.keyBook = new KeyBook(this.emit.bind(this), this._store);
        this.metadataBook = new MetadataBook(this.emit.bind(this), this._store);
        this.protoBook = new ProtoBook(this.emit.bind(this), this._store);
      }
      async *getPeers() {
        log48("getPeers await read lock");
        const release = await this._store.lock.readLock();
        log48("getPeers got read lock");
        try {
          for await (const peer of this._store.all()) {
            if (peer.id.toB58String() === this._peerId.toB58String()) {
              continue;
            }
            yield peer;
          }
        } finally {
          log48("getPeers release read lock");
          release();
        }
      }
      async delete(peerId) {
        log48("delete await write lock");
        const release = await this._store.lock.writeLock();
        log48("delete got write lock");
        try {
          await this._store.delete(peerId);
        } finally {
          log48("delete release write lock");
          release();
        }
      }
      async get(peerId) {
        log48("get await read lock");
        const release = await this._store.lock.readLock();
        log48("get got read lock");
        try {
          return this._store.load(peerId);
        } finally {
          log48("get release read lock");
          release();
        }
      }
      async has(peerId) {
        log48("has await read lock");
        const release = await this._store.lock.readLock();
        log48("has got read lock");
        try {
          return this._store.has(peerId);
        } finally {
          log48("has release read lock");
          release();
        }
      }
    };
    module2.exports = DefaultPeerStore;
  }
});

// node_modules/libp2p/src/pubsub-adapter.js
var require_pubsub_adapter = __commonJS({
  "node_modules/libp2p/src/pubsub-adapter.js"(exports2, module2) {
    "use strict";
    init_globals();
    function pubsubAdapter(PubsubRouter, libp2p, options) {
      const pubsub = new PubsubRouter(libp2p, options);
      pubsub._subscribeAdapter = pubsub.subscribe;
      pubsub._unsubscribeAdapter = pubsub.unsubscribe;
      function subscribe(topic, handler) {
        handler && pubsub.on(topic, handler);
        pubsub._subscribeAdapter(topic);
      }
      function unsubscribe(topic, handler) {
        if (!handler) {
          pubsub.removeAllListeners(topic);
        } else {
          pubsub.removeListener(topic, handler);
        }
        if (pubsub.listenerCount(topic) === 0) {
          pubsub._unsubscribeAdapter(topic);
        }
      }
      pubsub.subscribe = subscribe;
      pubsub.unsubscribe = unsubscribe;
      return pubsub;
    }
    module2.exports = pubsubAdapter;
  }
});

// node_modules/libp2p/src/registrar.js
var require_registrar = __commonJS({
  "node_modules/libp2p/src/registrar.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:registrar"), {
      error: debug50("libp2p:registrar:err")
    });
    var errcode17 = require_err_code();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors3();
    var Topology = require_topology();
    var Registrar = class {
      constructor({ peerStore, connectionManager }) {
        this.peerStore = peerStore;
        this.connectionManager = connectionManager;
        this.topologies = /* @__PURE__ */ new Map();
        this._handle = void 0;
        this._onDisconnect = this._onDisconnect.bind(this);
        this.connectionManager.on("peer:disconnect", this._onDisconnect);
      }
      get handle() {
        return this._handle;
      }
      set handle(handle) {
        this._handle = handle;
      }
      getConnection(peerId) {
        return this.connectionManager.get(peerId);
      }
      async register(topology) {
        if (!Topology.isTopology(topology)) {
          log48.error("topology must be an instance of interfaces/topology");
          throw errcode17(new Error("topology must be an instance of interfaces/topology"), ERR_INVALID_PARAMETERS);
        }
        const id = (Math.random() * 1e9).toString(36) + Date.now();
        this.topologies.set(id, topology);
        await topology.setRegistrar(this);
        return id;
      }
      unregister(id) {
        return this.topologies.delete(id);
      }
      _onDisconnect(connection) {
        for (const [, topology] of this.topologies) {
          topology.disconnect(connection.remotePeer);
        }
      }
    };
    module2.exports = Registrar;
  }
});

// node_modules/libp2p/src/identify/message.js
var require_message2 = __commonJS({
  "node_modules/libp2p/src/identify/message.js"(exports2, module2) {
    "use strict";
    init_globals();
    var $protobuf12 = require_minimal2();
    var $Reader11 = $protobuf12.Reader;
    var $Writer11 = $protobuf12.Writer;
    var $util11 = $protobuf12.util;
    var $root11 = $protobuf12.roots["libp2p-identify"] || ($protobuf12.roots["libp2p-identify"] = {});
    $root11.Identify = function() {
      function Identify(p) {
        this.listenAddrs = [];
        this.protocols = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Identify.prototype.protocolVersion = "";
      Identify.prototype.agentVersion = "";
      Identify.prototype.publicKey = $util11.newBuffer([]);
      Identify.prototype.listenAddrs = $util11.emptyArray;
      Identify.prototype.observedAddr = $util11.newBuffer([]);
      Identify.prototype.protocols = $util11.emptyArray;
      Identify.prototype.signedPeerRecord = $util11.newBuffer([]);
      Identify.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
          w.uint32(10).bytes(m.publicKey);
        if (m.listenAddrs != null && m.listenAddrs.length) {
          for (var i = 0; i < m.listenAddrs.length; ++i)
            w.uint32(18).bytes(m.listenAddrs[i]);
        }
        if (m.protocols != null && m.protocols.length) {
          for (var i = 0; i < m.protocols.length; ++i)
            w.uint32(26).string(m.protocols[i]);
        }
        if (m.observedAddr != null && Object.hasOwnProperty.call(m, "observedAddr"))
          w.uint32(34).bytes(m.observedAddr);
        if (m.protocolVersion != null && Object.hasOwnProperty.call(m, "protocolVersion"))
          w.uint32(42).string(m.protocolVersion);
        if (m.agentVersion != null && Object.hasOwnProperty.call(m, "agentVersion"))
          w.uint32(50).string(m.agentVersion);
        if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord"))
          w.uint32(66).bytes(m.signedPeerRecord);
        return w;
      };
      Identify.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.Identify();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 5:
              m.protocolVersion = r.string();
              break;
            case 6:
              m.agentVersion = r.string();
              break;
            case 1:
              m.publicKey = r.bytes();
              break;
            case 2:
              if (!(m.listenAddrs && m.listenAddrs.length))
                m.listenAddrs = [];
              m.listenAddrs.push(r.bytes());
              break;
            case 4:
              m.observedAddr = r.bytes();
              break;
            case 3:
              if (!(m.protocols && m.protocols.length))
                m.protocols = [];
              m.protocols.push(r.string());
              break;
            case 8:
              m.signedPeerRecord = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Identify.fromObject = function fromObject(d) {
        if (d instanceof $root11.Identify)
          return d;
        var m = new $root11.Identify();
        if (d.protocolVersion != null) {
          m.protocolVersion = String(d.protocolVersion);
        }
        if (d.agentVersion != null) {
          m.agentVersion = String(d.agentVersion);
        }
        if (d.publicKey != null) {
          if (typeof d.publicKey === "string")
            $util11.base64.decode(d.publicKey, m.publicKey = $util11.newBuffer($util11.base64.length(d.publicKey)), 0);
          else if (d.publicKey.length)
            m.publicKey = d.publicKey;
        }
        if (d.listenAddrs) {
          if (!Array.isArray(d.listenAddrs))
            throw TypeError(".Identify.listenAddrs: array expected");
          m.listenAddrs = [];
          for (var i = 0; i < d.listenAddrs.length; ++i) {
            if (typeof d.listenAddrs[i] === "string")
              $util11.base64.decode(d.listenAddrs[i], m.listenAddrs[i] = $util11.newBuffer($util11.base64.length(d.listenAddrs[i])), 0);
            else if (d.listenAddrs[i].length)
              m.listenAddrs[i] = d.listenAddrs[i];
          }
        }
        if (d.observedAddr != null) {
          if (typeof d.observedAddr === "string")
            $util11.base64.decode(d.observedAddr, m.observedAddr = $util11.newBuffer($util11.base64.length(d.observedAddr)), 0);
          else if (d.observedAddr.length)
            m.observedAddr = d.observedAddr;
        }
        if (d.protocols) {
          if (!Array.isArray(d.protocols))
            throw TypeError(".Identify.protocols: array expected");
          m.protocols = [];
          for (var i = 0; i < d.protocols.length; ++i) {
            m.protocols[i] = String(d.protocols[i]);
          }
        }
        if (d.signedPeerRecord != null) {
          if (typeof d.signedPeerRecord === "string")
            $util11.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util11.newBuffer($util11.base64.length(d.signedPeerRecord)), 0);
          else if (d.signedPeerRecord.length)
            m.signedPeerRecord = d.signedPeerRecord;
        }
        return m;
      };
      Identify.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.listenAddrs = [];
          d.protocols = [];
        }
        if (o.defaults) {
          if (o.bytes === String)
            d.publicKey = "";
          else {
            d.publicKey = [];
            if (o.bytes !== Array)
              d.publicKey = $util11.newBuffer(d.publicKey);
          }
          if (o.bytes === String)
            d.observedAddr = "";
          else {
            d.observedAddr = [];
            if (o.bytes !== Array)
              d.observedAddr = $util11.newBuffer(d.observedAddr);
          }
          d.protocolVersion = "";
          d.agentVersion = "";
          if (o.bytes === String)
            d.signedPeerRecord = "";
          else {
            d.signedPeerRecord = [];
            if (o.bytes !== Array)
              d.signedPeerRecord = $util11.newBuffer(d.signedPeerRecord);
          }
        }
        if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
          d.publicKey = o.bytes === String ? $util11.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
        }
        if (m.listenAddrs && m.listenAddrs.length) {
          d.listenAddrs = [];
          for (var j = 0; j < m.listenAddrs.length; ++j) {
            d.listenAddrs[j] = o.bytes === String ? $util11.base64.encode(m.listenAddrs[j], 0, m.listenAddrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.listenAddrs[j]) : m.listenAddrs[j];
          }
        }
        if (m.protocols && m.protocols.length) {
          d.protocols = [];
          for (var j = 0; j < m.protocols.length; ++j) {
            d.protocols[j] = m.protocols[j];
          }
        }
        if (m.observedAddr != null && m.hasOwnProperty("observedAddr")) {
          d.observedAddr = o.bytes === String ? $util11.base64.encode(m.observedAddr, 0, m.observedAddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.observedAddr) : m.observedAddr;
        }
        if (m.protocolVersion != null && m.hasOwnProperty("protocolVersion")) {
          d.protocolVersion = m.protocolVersion;
        }
        if (m.agentVersion != null && m.hasOwnProperty("agentVersion")) {
          d.agentVersion = m.agentVersion;
        }
        if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
          d.signedPeerRecord = o.bytes === String ? $util11.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
        }
        return d;
      };
      Identify.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      return Identify;
    }();
    module2.exports = $root11;
  }
});

// node_modules/libp2p/src/identify/index.js
var require_identify = __commonJS({
  "node_modules/libp2p/src/identify/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:identify"), {
      error: debug50("libp2p:identify:err")
    });
    var errCode69 = require_err_code();
    var lp2 = require_src11();
    var { pipe: pipe8 } = require_it_pipe();
    var { collect, take: take5, consume } = require_dist2();
    var { fromString: uint8ArrayFromString } = (init_from_string(), __toCommonJS(from_string_exports));
    var PeerId14 = require_src5();
    var { Multiaddr: Multiaddr22 } = require_src();
    var { toBuffer: toBuffer2 } = require_it_buffer();
    var Message2 = require_message2();
    var Envelope2 = require_envelope2();
    var PeerRecord2 = require_peer_record2();
    var {
      MULTICODEC_IDENTIFY,
      MULTICODEC_IDENTIFY_PUSH,
      IDENTIFY_PROTOCOL_VERSION,
      MULTICODEC_IDENTIFY_PROTOCOL_NAME,
      MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,
      MULTICODEC_IDENTIFY_PROTOCOL_VERSION,
      MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION
    } = require_consts();
    var { codes } = require_errors3();
    var IdentifyService = class {
      static getProtocolStr(libp2p) {
        return {
          identifyProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
          identifyPushProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`
        };
      }
      constructor({ libp2p }) {
        this._libp2p = libp2p;
        this.peerStore = libp2p.peerStore;
        this.addressManager = libp2p.addressManager;
        this.connectionManager = libp2p.connectionManager;
        this.peerId = libp2p.peerId;
        this.handleMessage = this.handleMessage.bind(this);
        const protocolStr = IdentifyService.getProtocolStr(libp2p);
        this.identifyProtocolStr = protocolStr.identifyProtocolStr;
        this.identifyPushProtocolStr = protocolStr.identifyPushProtocolStr;
        this._host = {
          protocolVersion: `${libp2p._config.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
          ...libp2p._options.host
        };
        this.connectionManager.on("peer:connect", (connection) => {
          this.identify(connection).catch(log48.error);
        });
        this.peerStore.on("change:multiaddrs", ({ peerId }) => {
          if (peerId.toString() === this.peerId.toString()) {
            this.pushToPeerStore().catch((err) => log48.error(err));
          }
        });
        this.peerStore.on("change:protocols", ({ peerId }) => {
          if (peerId.toString() === this.peerId.toString()) {
            this.pushToPeerStore().catch((err) => log48.error(err));
          }
        });
      }
      async start() {
        await this.peerStore.metadataBook.setValue(this.peerId, "AgentVersion", uint8ArrayFromString(this._host.agentVersion));
        await this.peerStore.metadataBook.setValue(this.peerId, "ProtocolVersion", uint8ArrayFromString(this._host.protocolVersion));
      }
      async stop() {
      }
      async push(connections) {
        const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId);
        const listenAddrs = this._libp2p.multiaddrs.map((ma) => ma.bytes);
        const protocols = await this.peerStore.protoBook.get(this.peerId);
        const pushes = connections.map(async (connection) => {
          try {
            const { stream } = await connection.newStream(this.identifyPushProtocolStr);
            await pipe8([Message2.Identify.encode({
              listenAddrs,
              signedPeerRecord,
              protocols
            }).finish()], lp2.encode(), stream, consume);
          } catch (err) {
            log48.error("could not push identify update to peer", err);
          }
        });
        return Promise.all(pushes);
      }
      async pushToPeerStore() {
        if (!this._libp2p.isStarted()) {
          return;
        }
        const connections = [];
        let connection;
        for await (const peer of this.peerStore.getPeers()) {
          if (peer.protocols.includes(this.identifyPushProtocolStr) && (connection = this.connectionManager.get(peer.id))) {
            connections.push(connection);
          }
        }
        await this.push(connections);
      }
      async identify(connection) {
        const { stream } = await connection.newStream(this.identifyProtocolStr);
        const [data] = await pipe8([], stream, lp2.decode(), take5(1), toBuffer2, collect);
        if (!data) {
          throw errCode69(new Error("No data could be retrieved"), codes.ERR_CONNECTION_ENDED);
        }
        let message;
        try {
          message = Message2.Identify.decode(data);
        } catch (err) {
          throw errCode69(err, codes.ERR_INVALID_MESSAGE);
        }
        const {
          publicKey,
          listenAddrs,
          protocols,
          observedAddr,
          signedPeerRecord
        } = message;
        const id = await PeerId14.createFromPubKey(publicKey);
        if (connection.remotePeer.toB58String() !== id.toB58String()) {
          throw errCode69(new Error("identified peer does not match the expected peer"), codes.ERR_INVALID_PEER);
        }
        const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);
        try {
          const envelope = await Envelope2.openAndCertify(signedPeerRecord, PeerRecord2.DOMAIN);
          if (await this.peerStore.addressBook.consumePeerRecord(envelope)) {
            await this.peerStore.protoBook.set(id, protocols);
            await this.peerStore.metadataBook.setValue(id, "AgentVersion", uint8ArrayFromString(message.agentVersion));
            await this.peerStore.metadataBook.setValue(id, "ProtocolVersion", uint8ArrayFromString(message.protocolVersion));
            return;
          }
        } catch (err) {
          log48("received invalid envelope, discard it and fallback to listenAddrs is available", err);
        }
        try {
          await this.peerStore.addressBook.set(id, listenAddrs.map((addr) => new Multiaddr22(addr)));
        } catch (err) {
          log48.error("received invalid addrs", err);
        }
        await this.peerStore.protoBook.set(id, protocols);
        await this.peerStore.metadataBook.setValue(id, "AgentVersion", uint8ArrayFromString(message.agentVersion));
        await this.peerStore.metadataBook.setValue(id, "ProtocolVersion", uint8ArrayFromString(message.protocolVersion));
        log48("received observed address of %s", cleanObservedAddr);
      }
      handleMessage({ connection, stream, protocol }) {
        switch (protocol) {
          case this.identifyProtocolStr:
            return this._handleIdentify({ connection, stream });
          case this.identifyPushProtocolStr:
            return this._handlePush({ connection, stream });
          default:
            log48.error("cannot handle unknown protocol %s", protocol);
        }
      }
      async _handleIdentify({ connection, stream }) {
        try {
          let publicKey = new Uint8Array(0);
          if (this.peerId.pubKey) {
            publicKey = this.peerId.pubKey.bytes;
          }
          const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId);
          const protocols = await this.peerStore.protoBook.get(this.peerId);
          const message = Message2.Identify.encode({
            protocolVersion: this._host.protocolVersion,
            agentVersion: this._host.agentVersion,
            publicKey,
            listenAddrs: this._libp2p.multiaddrs.map((ma) => ma.bytes),
            signedPeerRecord,
            observedAddr: connection.remoteAddr.bytes,
            protocols
          }).finish();
          await pipe8([message], lp2.encode(), stream, consume);
        } catch (err) {
          log48.error("could not respond to identify request", err);
        }
      }
      async _handlePush({ connection, stream }) {
        let message;
        try {
          const [data] = await pipe8([], stream, lp2.decode(), take5(1), toBuffer2, collect);
          message = Message2.Identify.decode(data);
        } catch (err) {
          return log48.error("received invalid message", err);
        }
        const id = connection.remotePeer;
        try {
          const envelope = await Envelope2.openAndCertify(message.signedPeerRecord, PeerRecord2.DOMAIN);
          if (await this.peerStore.addressBook.consumePeerRecord(envelope)) {
            await this.peerStore.protoBook.set(id, message.protocols);
            return;
          }
        } catch (err) {
          log48("received invalid envelope, discard it and fallback to listenAddrs is available", err);
        }
        try {
          await this.peerStore.addressBook.set(id, message.listenAddrs.map((addr) => new Multiaddr22(addr)));
        } catch (err) {
          log48.error("received invalid addrs", err);
        }
        try {
          await this.peerStore.protoBook.set(id, message.protocols);
        } catch (err) {
          log48.error("received invalid protocols", err);
        }
      }
      static getCleanMultiaddr(addr) {
        if (addr && addr.length > 0) {
          try {
            return new Multiaddr22(addr);
          } catch (_) {
            return null;
          }
        }
        return null;
      }
    };
    var multicodecs = {
      IDENTIFY: MULTICODEC_IDENTIFY,
      IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH
    };
    IdentifyService.multicodecs = multicodecs;
    IdentifyService.Messsage = Message2;
    module2.exports = IdentifyService;
  }
});

// node_modules/libp2p/src/fetch/proto.js
var require_proto2 = __commonJS({
  "node_modules/libp2p/src/fetch/proto.js"(exports2, module2) {
    "use strict";
    init_globals();
    var $protobuf12 = require_minimal2();
    var $Reader11 = $protobuf12.Reader;
    var $Writer11 = $protobuf12.Writer;
    var $util11 = $protobuf12.util;
    var $root11 = $protobuf12.roots["libp2p-fetch"] || ($protobuf12.roots["libp2p-fetch"] = {});
    $root11.FetchRequest = function() {
      function FetchRequest(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      FetchRequest.prototype.identifier = "";
      FetchRequest.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.identifier != null && Object.hasOwnProperty.call(m, "identifier"))
          w.uint32(10).string(m.identifier);
        return w;
      };
      FetchRequest.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.FetchRequest();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.identifier = r.string();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      FetchRequest.fromObject = function fromObject(d) {
        if (d instanceof $root11.FetchRequest)
          return d;
        var m = new $root11.FetchRequest();
        if (d.identifier != null) {
          m.identifier = String(d.identifier);
        }
        return m;
      };
      FetchRequest.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.identifier = "";
        }
        if (m.identifier != null && m.hasOwnProperty("identifier")) {
          d.identifier = m.identifier;
        }
        return d;
      };
      FetchRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      return FetchRequest;
    }();
    $root11.FetchResponse = function() {
      function FetchResponse(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      FetchResponse.prototype.status = 0;
      FetchResponse.prototype.data = $util11.newBuffer([]);
      FetchResponse.encode = function encode19(m, w) {
        if (!w)
          w = $Writer11.create();
        if (m.status != null && Object.hasOwnProperty.call(m, "status"))
          w.uint32(8).int32(m.status);
        if (m.data != null && Object.hasOwnProperty.call(m, "data"))
          w.uint32(18).bytes(m.data);
        return w;
      };
      FetchResponse.decode = function decode22(r, l) {
        if (!(r instanceof $Reader11))
          r = $Reader11.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root11.FetchResponse();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.status = r.int32();
              break;
            case 2:
              m.data = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      FetchResponse.fromObject = function fromObject(d) {
        if (d instanceof $root11.FetchResponse)
          return d;
        var m = new $root11.FetchResponse();
        switch (d.status) {
          case "OK":
          case 0:
            m.status = 0;
            break;
          case "NOT_FOUND":
          case 1:
            m.status = 1;
            break;
          case "ERROR":
          case 2:
            m.status = 2;
            break;
        }
        if (d.data != null) {
          if (typeof d.data === "string")
            $util11.base64.decode(d.data, m.data = $util11.newBuffer($util11.base64.length(d.data)), 0);
          else if (d.data.length)
            m.data = d.data;
        }
        return m;
      };
      FetchResponse.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.status = o.enums === String ? "OK" : 0;
          if (o.bytes === String)
            d.data = "";
          else {
            d.data = [];
            if (o.bytes !== Array)
              d.data = $util11.newBuffer(d.data);
          }
        }
        if (m.status != null && m.hasOwnProperty("status")) {
          d.status = o.enums === String ? $root11.FetchResponse.StatusCode[m.status] : m.status;
        }
        if (m.data != null && m.hasOwnProperty("data")) {
          d.data = o.bytes === String ? $util11.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
        }
        return d;
      };
      FetchResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf12.util.toJSONOptions);
      };
      FetchResponse.StatusCode = function() {
        var valuesById = {}, values2 = Object.create(valuesById);
        values2[valuesById[0] = "OK"] = 0;
        values2[valuesById[1] = "NOT_FOUND"] = 1;
        values2[valuesById[2] = "ERROR"] = 2;
        return values2;
      }();
      return FetchResponse;
    }();
    module2.exports = $root11;
  }
});

// node_modules/libp2p/src/fetch/constants.js
var require_constants14 = __commonJS({
  "node_modules/libp2p/src/fetch/constants.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      PROTOCOL: "/libp2p/fetch/0.0.1"
    };
  }
});

// node_modules/libp2p/src/fetch/index.js
var require_fetch2 = __commonJS({
  "node_modules/libp2p/src/fetch/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:fetch"), {
      error: debug50("libp2p:fetch:err")
    });
    var errCode69 = require_err_code();
    var { codes } = require_errors3();
    var lp2 = require_src11();
    var { FetchRequest, FetchResponse } = require_proto2();
    var handshake = require_src18();
    var { PROTOCOL } = require_constants14();
    var FetchProtocol = class {
      constructor(libp2p) {
        this._lookupFunctions = /* @__PURE__ */ new Map();
        this._libp2p = libp2p;
        this.handleMessage = this.handleMessage.bind(this);
      }
      async fetch(peer, key) {
        log48("dialing %s to %s", this._protocol, peer.toB58String ? peer.toB58String() : peer);
        const connection = await this._libp2p.dial(peer);
        const { stream } = await connection.newStream(FetchProtocol.PROTOCOL);
        const shake = handshake(stream);
        const request = new FetchRequest({ identifier: key });
        shake.write(lp2.encode.single(FetchRequest.encode(request).finish()));
        const response = FetchResponse.decode((await lp2.decode.fromReader(shake.reader).next()).value.slice());
        switch (response.status) {
          case FetchResponse.StatusCode.OK: {
            return response.data;
          }
          case FetchResponse.StatusCode.NOT_FOUND: {
            return null;
          }
          case FetchResponse.StatusCode.ERROR: {
            const errmsg = new TextDecoder().decode(response.data);
            throw errCode69(new Error("Error in fetch protocol response: " + errmsg), codes.ERR_INVALID_PARAMETERS);
          }
          default: {
            throw errCode69(new Error("Unknown response status"), codes.ERR_INVALID_MESSAGE);
          }
        }
      }
      async handleMessage(options) {
        const { stream } = options;
        const shake = handshake(stream);
        const request = FetchRequest.decode((await lp2.decode.fromReader(shake.reader).next()).value.slice());
        let response;
        const lookup = this._getLookupFunction(request.identifier);
        if (lookup) {
          const data = await lookup(request.identifier);
          if (data) {
            response = new FetchResponse({ status: FetchResponse.StatusCode.OK, data });
          } else {
            response = new FetchResponse({ status: FetchResponse.StatusCode.NOT_FOUND });
          }
        } else {
          const errmsg = new TextEncoder().encode("No lookup function registered for key: " + request.identifier);
          response = new FetchResponse({ status: FetchResponse.StatusCode.ERROR, data: errmsg });
        }
        shake.write(lp2.encode.single(FetchResponse.encode(response).finish()));
      }
      _getLookupFunction(key) {
        for (const prefix of this._lookupFunctions.keys()) {
          if (key.startsWith(prefix)) {
            return this._lookupFunctions.get(prefix);
          }
        }
        return null;
      }
      registerLookupFunction(prefix, lookup) {
        if (this._lookupFunctions.has(prefix)) {
          throw errCode69(new Error("Fetch protocol handler for key prefix '" + prefix + "' already registered"), codes.ERR_KEY_ALREADY_EXISTS);
        }
        this._lookupFunctions.set(prefix, lookup);
      }
      unregisterLookupFunction(prefix, lookup) {
        if (lookup != null) {
          const existingLookup = this._lookupFunctions.get(prefix);
          if (existingLookup !== lookup) {
            return;
          }
        }
        this._lookupFunctions.delete(prefix);
      }
    };
    FetchProtocol.PROTOCOL = PROTOCOL;
    exports2 = module2.exports = FetchProtocol;
  }
});

// node_modules/libp2p/src/ping/constants.js
var require_constants15 = __commonJS({
  "node_modules/libp2p/src/ping/constants.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {
      PROTOCOL: "/ipfs/ping/1.0.0",
      PING_LENGTH: 32,
      PROTOCOL_VERSION: "1.0.0",
      PROTOCOL_NAME: "ping"
    };
  }
});

// node_modules/libp2p/src/ping/index.js
var require_ping2 = __commonJS({
  "node_modules/libp2p/src/ping/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p:ping"), {
      error: debug50("libp2p:ping:err")
    });
    var errCode69 = require_err_code();
    var { codes } = require_errors3();
    var crypto6 = require_src6();
    var { pipe: pipe8 } = require_it_pipe();
    var { toBuffer: toBuffer2 } = require_it_buffer();
    var { collect, take: take5 } = require_dist2();
    var { equals: equals6 } = (init_equals(), __toCommonJS(equals_exports));
    var { PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION } = require_constants15();
    var PingService = class {
      static getProtocolStr(libp2p) {
        return `/${libp2p._config.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
      }
      constructor(libp2p) {
        this._libp2p = libp2p;
      }
      handleMessage({ stream }) {
        return pipe8(stream, stream);
      }
      async ping(peer) {
        const protocol = `/${this._libp2p._config.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
        log48("dialing %s to %s", protocol, peer.toB58String ? peer.toB58String() : peer);
        const connection = await this._libp2p.dial(peer);
        const { stream } = await connection.newStream(protocol);
        const start = Date.now();
        const data = crypto6.randomBytes(PING_LENGTH);
        const [result] = await pipe8([data], stream, (stream2) => take5(1, stream2), toBuffer2, collect);
        const end = Date.now();
        if (!equals6(data, result)) {
          throw errCode69(new Error("Received wrong ping ack"), codes.ERR_WRONG_PING_ACK);
        }
        return end - start;
      }
    };
    module2.exports = PingService;
  }
});

// (disabled):node_modules/nat-api/index.js
var require_nat_api = __commonJS({
  "(disabled):node_modules/nat-api/index.js"() {
    init_globals();
  }
});

// node_modules/es6-promisify/dist/promisify.js
var require_promisify = __commonJS({
  "node_modules/es6-promisify/dist/promisify.js"(exports2) {
    "use strict";
    init_globals();
    Object.defineProperty(exports2, "__esModule", { value: true }), exports2.promisify = promisify;
    var customArgumentsToken = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__";
    function promisify(a) {
      if (typeof a != "function")
        throw new TypeError("Argument to promisify must be a function");
      var b = a[customArgumentsToken], c = promisify.Promise || Promise;
      if (typeof c != "function")
        throw new Error("No Promise implementation found; do you need a polyfill?");
      return function() {
        for (var d = this, e = arguments.length, f = Array(e), g = 0; g < e; g++)
          f[g] = arguments[g];
        return new c(function(c2, e2) {
          f.push(function(a2) {
            if (a2)
              return e2(a2);
            for (var d2 = arguments.length, f2 = Array(1 < d2 ? d2 - 1 : 0), g2 = 1; g2 < d2; g2++)
              f2[g2 - 1] = arguments[g2];
            if (f2.length === 1 || !b)
              return c2(f2[0]);
            var h = {};
            f2.forEach(function(a3, c3) {
              var d3 = b[c3];
              d3 && (h[d3] = a3);
            }), c2(h);
          }), a.apply(d, f);
        });
      };
    }
    promisify.argumentNames = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__", promisify.Promise = void 0;
  }
});

// node_modules/wherearewe/src/index.js
var require_src26 = __commonJS({
  "node_modules/wherearewe/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var isElectron = require_is_electron();
    var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
    var IS_ELECTRON = isElectron();
    var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
    var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
    var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
    var IS_NODE = typeof __require === "function" && typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !IS_ELECTRON;
    var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    var IS_TEST = typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env["NODE" + (() => "_")() + "ENV"] === "test";
    var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    module2.exports = {
      isTest: IS_TEST,
      isElectron: IS_ELECTRON,
      isElectronMain: IS_ELECTRON_MAIN,
      isElectronRenderer: IS_ELECTRON_RENDERER,
      isNode: IS_NODE,
      isBrowser: IS_BROWSER,
      isWebWorker: IS_WEBWORKER,
      isEnvWithDom: IS_ENV_WITH_DOM,
      isReactNative: IS_REACT_NATIVE
    };
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    init_globals();
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    init_globals();
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random2 = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    init_globals();
    module2.exports = require_retry();
  }
});

// node_modules/p-retry/index.js
var require_p_retry = __commonJS({
  "node_modules/p-retry/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var retry = require_retry2();
    var networkErrorMsgs = [
      "Failed to fetch",
      "NetworkError when attempting to fetch resource.",
      "The Internet connection appears to be offline.",
      "Network request failed"
    ];
    var AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    var decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
    var pRetry = (input, options) => new Promise((resolve11, reject) => {
      options = {
        onFailedAttempt: () => {
        },
        retries: 10,
        ...options
      };
      const operation = retry.operation(options);
      operation.attempt(async (attemptNumber) => {
        try {
          resolve11(await input(attemptNumber));
        } catch (error) {
          if (!(error instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
            return;
          }
          if (error instanceof AbortError) {
            operation.stop();
            reject(error.originalError);
          } else if (error instanceof TypeError && !isNetworkError(error.message)) {
            operation.stop();
            reject(error);
          } else {
            decorateErrorWithCounts(error, attemptNumber, options);
            try {
              await options.onFailedAttempt(error);
            } catch (error2) {
              reject(error2);
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        }
      });
    });
    module2.exports = pRetry;
    module2.exports.default = pRetry;
    module2.exports.AbortError = AbortError;
  }
});

// node_modules/is-loopback-addr/index.js
var require_is_loopback_addr = __commonJS({
  "node_modules/is-loopback-addr/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    function isLoopbackAddr(ip) {
      return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
    }
    module2.exports = isLoopbackAddr;
  }
});

// node_modules/libp2p-utils/src/multiaddr/is-loopback.js
var require_is_loopback = __commonJS({
  "node_modules/libp2p-utils/src/multiaddr/is-loopback.js"(exports2, module2) {
    "use strict";
    init_globals();
    var isLoopbackAddr = require_is_loopback_addr();
    function isLoopback(ma) {
      const { address } = ma.nodeAddress();
      return isLoopbackAddr(address);
    }
    module2.exports = isLoopback;
  }
});

// node_modules/libp2p/src/nat-manager.js
var require_nat_manager = __commonJS({
  "node_modules/libp2p/src/nat-manager.js"(exports2, module2) {
    "use strict";
    init_globals();
    var NatAPI = require_nat_api();
    var debug50 = require_browser2();
    var { promisify } = require_promisify();
    var { Multiaddr: Multiaddr22 } = require_src();
    var log48 = Object.assign(debug50("libp2p:nat"), {
      error: debug50("libp2p:nat:err")
    });
    var { isBrowser: isBrowser2 } = require_src26();
    var retry = require_p_retry();
    var isPrivateIp = require_private_ip();
    var pkg = require_package();
    var errcode17 = require_err_code();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors3();
    var isLoopback = require_is_loopback();
    var DEFAULT_TTL = 7200;
    function highPort(min = 1024, max = 65535) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }
    var NatManager = class {
      constructor({ peerId, addressManager, transportManager, ...options }) {
        this._peerId = peerId;
        this._addressManager = addressManager;
        this._transportManager = transportManager;
        this._enabled = options.enabled;
        this._externalIp = options.externalIp;
        this._options = {
          description: options.description || `${pkg.name}@${pkg.version} ${this._peerId}`,
          ttl: options.ttl || DEFAULT_TTL,
          autoUpdate: options.keepAlive || true,
          gateway: options.gateway,
          enablePMP: Boolean(options.pmp && options.pmp.enabled)
        };
        if (this._options.ttl < DEFAULT_TTL) {
          throw errcode17(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), ERR_INVALID_PARAMETERS);
        }
      }
      start() {
        if (isBrowser2 || !this._enabled) {
          return;
        }
        this._start().catch((err) => {
          log48.error(err);
        });
      }
      async _start() {
        const addrs = this._transportManager.getAddrs();
        for (const addr of addrs) {
          const { family, host, port, transport } = addr.toOptions();
          if (!addr.isThinWaistAddress() || transport !== "tcp") {
            continue;
          }
          if (isLoopback(addr)) {
            continue;
          }
          if (family !== 4) {
            continue;
          }
          const client = this._getClient();
          const publicIp = this._externalIp || await client.externalIp();
          if (isPrivateIp(publicIp)) {
            throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
          }
          const publicPort = highPort();
          log48(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);
          await client.map({
            publicPort,
            privatePort: port,
            protocol: transport.toUpperCase()
          });
          this._addressManager.addObservedAddr(Multiaddr22.fromNodeAddress({
            family: 4,
            address: publicIp,
            port: publicPort
          }, transport));
        }
      }
      _getClient() {
        if (this._client) {
          return this._client;
        }
        const client = new NatAPI(this._options);
        const map12 = promisify(client.map.bind(client));
        const destroy = promisify(client.destroy.bind(client));
        const externalIp = promisify(client.externalIp.bind(client));
        this._client = {
          map: (...args) => retry(() => map12(...args), { onFailedAttempt: log48.error, unref: true }),
          destroy: (...args) => retry(() => destroy(...args), { onFailedAttempt: log48.error, unref: true }),
          externalIp: (...args) => retry(() => externalIp(...args), { onFailedAttempt: log48.error, unref: true })
        };
        return this._client;
      }
      async stop() {
        if (isBrowser2 || !this._client) {
          return;
        }
        try {
          await this._client.destroy();
          this._client = null;
        } catch (err) {
          log48.error(err);
        }
      }
    };
    module2.exports = NatManager;
  }
});

// node_modules/libp2p/src/index.js
var require_src27 = __commonJS({
  "node_modules/libp2p/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var debug50 = require_browser2();
    var log48 = Object.assign(debug50("libp2p"), {
      error: debug50("libp2p:err")
    });
    var { EventEmitter: EventEmitter4 } = require_events();
    var errCode69 = require_err_code();
    var PeerId14 = require_src5();
    var { Multiaddr: Multiaddr22 } = require_src();
    var { MemoryDatastore: MemoryDatastore2 } = (init_memory(), __toCommonJS(memory_exports));
    var PeerRouting = require_peer_routing2();
    var ContentRouting = require_content_routing2();
    var getPeer = require_get_peer();
    var { validate: validateConfig } = require_config();
    var { codes, messages } = require_errors3();
    var AddressManager = require_address_manager();
    var ConnectionManager = require_connection_manager();
    var AutoDialler = require_auto_dialler();
    var Circuit = require_transport2();
    var Relay = require_circuit();
    var Dialer = require_dialer();
    var Keychain = require_keychain();
    var Metrics = require_metrics();
    var TransportManager = require_transport_manager();
    var Upgrader = require_upgrader();
    var PeerStore = require_peer_store();
    var PubsubAdapter = require_pubsub_adapter();
    var Registrar = require_registrar();
    var IdentifyService = require_identify();
    var FetchService = require_fetch2();
    var PingService = require_ping2();
    var NatManager = require_nat_manager();
    var { updateSelfPeerRecord } = require_utils10();
    var Libp2p2 = class extends EventEmitter4 {
      static async create(options) {
        if (options.peerId) {
          return new Libp2p2(options);
        }
        const peerId = await PeerId14.create();
        options.peerId = peerId;
        return new Libp2p2(options);
      }
      constructor(_options) {
        super();
        this._options = validateConfig(_options);
        this.peerId = this._options.peerId;
        this.datastore = this._options.datastore;
        if (this._options.metrics.enabled) {
          const metrics = new Metrics({
            ...this._options.metrics
          });
          this.metrics = metrics;
        }
        this.connectionGater = {
          denyDialPeer: async () => Promise.resolve(false),
          denyDialMultiaddr: async () => Promise.resolve(false),
          denyInboundConnection: async () => Promise.resolve(false),
          denyOutboundConnection: async () => Promise.resolve(false),
          denyInboundEncryptedConnection: async () => Promise.resolve(false),
          denyOutboundEncryptedConnection: async () => Promise.resolve(false),
          denyInboundUpgradedConnection: async () => Promise.resolve(false),
          denyOutboundUpgradedConnection: async () => Promise.resolve(false),
          filterMultiaddrForPeer: async () => Promise.resolve(true),
          ...this._options.connectionGater
        };
        this.peerStore = new PeerStore({
          peerId: this.peerId,
          datastore: this.datastore && this._options.peerStore.persistence ? this.datastore : new MemoryDatastore2(),
          addressFilter: this.connectionGater.filterMultiaddrForPeer
        });
        this.addresses = this._options.addresses;
        this.addressManager = new AddressManager(this.peerId, this._options.addresses);
        this.addressManager.on("change:addresses", () => {
          updateSelfPeerRecord(this).catch((err) => {
            log48.error("Error updating self peer record", err);
          });
        });
        this._modules = this._options.modules;
        this._config = this._options.config;
        this._transport = [];
        this._discovery = /* @__PURE__ */ new Map();
        this.connectionManager = new ConnectionManager(this, {
          ...this._options.connectionManager
        });
        this._autodialler = new AutoDialler(this, {
          enabled: this._config.peerDiscovery.autoDial,
          minConnections: this._options.connectionManager.minConnections,
          autoDialInterval: this._options.connectionManager.autoDialInterval
        });
        if (this._options.keychain && this._options.keychain.datastore) {
          log48("creating keychain");
          const keychainOpts = Keychain.generateOptions();
          this.keychain = new Keychain(this._options.keychain.datastore, {
            ...keychainOpts,
            ...this._options.keychain
          });
          log48("keychain constructed");
        }
        this.upgrader = new Upgrader({
          connectionGater: this.connectionGater,
          localPeer: this.peerId,
          metrics: this.metrics,
          onConnection: (connection) => this.connectionManager.onConnect(connection),
          onConnectionEnd: (connection) => this.connectionManager.onDisconnect(connection)
        });
        this.transportManager = new TransportManager({
          libp2p: this,
          upgrader: this.upgrader,
          faultTolerance: this._options.transportManager.faultTolerance
        });
        this.natManager = new NatManager({
          peerId: this.peerId,
          addressManager: this.addressManager,
          transportManager: this.transportManager,
          ...this._options.config.nat
        });
        this.registrar = new Registrar({
          peerStore: this.peerStore,
          connectionManager: this.connectionManager
        });
        this.handle = this.handle.bind(this);
        this.registrar.handle = this.handle;
        if (!this._modules.connEncryption || !this._modules.connEncryption.length) {
          throw errCode69(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);
        }
        const cryptos = this._modules.connEncryption;
        cryptos.forEach((crypto6) => {
          this.upgrader.cryptos.set(crypto6.protocol, crypto6);
        });
        this.dialer = new Dialer({
          transportManager: this.transportManager,
          connectionGater: this.connectionGater,
          peerStore: this.peerStore,
          metrics: this.metrics,
          ...this._options.dialer
        });
        this._modules.transport.forEach((Transport) => {
          const key = Transport.prototype[Symbol.toStringTag];
          const transportOptions = this._config.transport[key];
          this.transportManager.add(key, Transport, transportOptions);
        });
        if (this._config.relay.enabled) {
          this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);
          this.relay = new Relay(this);
        }
        if (this._modules.streamMuxer) {
          const muxers = this._modules.streamMuxer;
          muxers.forEach((muxer) => {
            this.upgrader.muxers.set(muxer.multicodec, muxer);
          });
          this.identifyService = new IdentifyService({ libp2p: this });
        }
        if (this._modules.connProtector) {
          this.upgrader.protector = this._modules.connProtector;
        } else if (globalThis.process !== void 0 && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {
          throw new Error("Private network is enforced, but no protector was provided");
        }
        if (this._modules.dht) {
          const DHT = this._modules.dht;
          this._dht = DHT.create({
            libp2p: this,
            ...this._config.dht
          });
        }
        if (this._modules.pubsub) {
          const Pubsub = this._modules.pubsub;
          this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub);
        }
        this.peerRouting = new PeerRouting(this);
        this.contentRouting = new ContentRouting(this);
        this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this);
        this.fetchService = new FetchService(this);
        this.pingService = new PingService(this);
      }
      emit(eventName, ...args) {
        if (eventName === "error" && !this._events.error) {
          log48.error(args);
          return false;
        } else {
          return super.emit(eventName, ...args);
        }
      }
      async start() {
        log48("libp2p is starting");
        if (this.identifyService) {
          await this.handle(Object.values(IdentifyService.getProtocolStr(this)), this.identifyService.handleMessage);
        }
        if (this.fetchService) {
          await this.handle(FetchService.PROTOCOL, this.fetchService.handleMessage);
        }
        if (this.pingService) {
          await this.handle(PingService.getProtocolStr(this), this.pingService.handleMessage);
        }
        try {
          await this._onStarting();
          await this._onDidStart();
          log48("libp2p has started");
        } catch (err) {
          this.emit("error", err);
          log48.error("An error occurred starting libp2p", err);
          await this.stop();
          throw err;
        }
      }
      async stop() {
        log48("libp2p is stopping");
        try {
          this._isStarted = false;
          if (this.identifyService) {
            await this.identifyService.stop();
          }
          this.relay && this.relay.stop();
          this.peerRouting.stop();
          await this._autodialler.stop();
          await (this._dht && this._dht.stop());
          for (const service of this._discovery.values()) {
            service.removeListener("peer", this._onDiscoveryPeer);
          }
          await Promise.all(Array.from(this._discovery.values(), (s) => s.stop()));
          this._discovery = /* @__PURE__ */ new Map();
          await this.connectionManager.stop();
          await Promise.all([
            this.pubsub && this.pubsub.stop(),
            this.metrics && this.metrics.stop()
          ]);
          await this.natManager.stop();
          await this.transportManager.close();
          await this.unhandle(FetchService.PROTOCOL);
          await this.unhandle(PingService.getProtocolStr(this));
          this.dialer.destroy();
        } catch (err) {
          if (err) {
            log48.error(err);
            this.emit("error", err);
          }
        }
        log48("libp2p has stopped");
      }
      async loadKeychain() {
        if (!this.keychain) {
          return;
        }
        try {
          await this.keychain.findKeyByName("self");
        } catch (err) {
          await this.keychain.importPeer("self", this.peerId);
        }
      }
      isStarted() {
        return this._isStarted;
      }
      get connections() {
        return this.connectionManager.connections;
      }
      dial(peer, options) {
        return this._dial(peer, options);
      }
      async dialProtocol(peer, protocols, options) {
        if (!protocols || !protocols.length) {
          throw errCode69(new Error("no protocols were provided to open a stream"), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);
        }
        const connection = await this._dial(peer, options);
        return connection.newStream(protocols);
      }
      async _dial(peer, options) {
        const { id, multiaddrs } = getPeer(peer);
        if (id.equals(this.peerId)) {
          throw errCode69(new Error("Cannot dial self"), codes.ERR_DIALED_SELF);
        }
        let connection = this.connectionManager.get(id);
        if (!connection) {
          connection = await this.dialer.connectToPeer(peer, options);
        } else if (multiaddrs) {
          await this.peerStore.addressBook.add(id, multiaddrs);
        }
        return connection;
      }
      get multiaddrs() {
        let addrs = this.addressManager.getAnnounceAddrs().map((ma) => ma.toString());
        if (!addrs.length) {
          addrs = this.transportManager.getAddrs().map((ma) => ma.toString());
        }
        addrs = addrs.concat(this.addressManager.getObservedAddrs().map((ma) => ma.toString()));
        const announceFilter = this._options.addresses.announceFilter;
        const addrSet = new Set(addrs);
        return announceFilter(Array.from(addrSet).map((str) => new Multiaddr22(str)));
      }
      async hangUp(peer) {
        const { id } = getPeer(peer);
        const connections = this.connectionManager.connections.get(id.toB58String());
        if (!connections) {
          return;
        }
        await Promise.all(connections.map((connection) => {
          return connection.close();
        }));
      }
      fetch(peer, key) {
        return this.fetchService.fetch(peer, key);
      }
      ping(peer) {
        const { id, multiaddrs } = getPeer(peer);
        if (multiaddrs) {
          return this.pingService.ping(multiaddrs[0]);
        }
        return this.pingService.ping(id);
      }
      async handle(protocols, handler) {
        protocols = Array.isArray(protocols) ? protocols : [protocols];
        protocols.forEach((protocol) => {
          this.upgrader.protocols.set(protocol, handler);
        });
        await this.peerStore.protoBook.add(this.peerId, protocols);
      }
      async unhandle(protocols) {
        protocols = Array.isArray(protocols) ? protocols : [protocols];
        protocols.forEach((protocol) => {
          this.upgrader.protocols.delete(protocol);
        });
        await this.peerStore.protoBook.remove(this.peerId, protocols);
      }
      async _onStarting() {
        const addrs = this.addressManager.getListenAddrs();
        await this.transportManager.listen(addrs);
        this.natManager.start();
        if (this._config.pubsub.enabled) {
          this.pubsub && await this.pubsub.start();
        }
        if (this._config.dht.enabled) {
          this._dht && await this._dht.start();
          this._dht.on("peer", this._onDiscoveryPeer);
        }
        this.metrics && this.metrics.start();
        if (this.identifyService) {
          await this.identifyService.start();
        }
      }
      async _onDidStart() {
        this._isStarted = true;
        this.peerStore.on("peer", (peerId) => {
          this.emit("peer:discovery", peerId);
          this._maybeConnect(peerId).catch((err) => {
            log48.error(err);
          });
        });
        for await (const peer of this.peerStore.getPeers()) {
          this.emit("peer:discovery", peer.id);
        }
        this.connectionManager.start();
        await this._autodialler.start();
        await this._setupPeerDiscovery();
        this.relay && this.relay.start();
        this.peerRouting.start();
      }
      _onDiscoveryPeer(peer) {
        if (peer.id.toB58String() === this.peerId.toB58String()) {
          log48.error(new Error(codes.ERR_DISCOVERED_SELF));
          return;
        }
        peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs).catch((err) => log48.error(err));
        peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols).catch((err) => log48.error(err));
      }
      async _maybeConnect(peerId) {
        if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {
          const minConnections = this._options.connectionManager.minConnections || 0;
          if (minConnections > this.connectionManager.size) {
            log48("connecting to discovered peer %s", peerId.toB58String());
            try {
              await this.dialer.connectToPeer(peerId);
            } catch (err) {
              log48.error(`could not connect to discovered peer ${peerId.toB58String()} with ${err}`);
            }
          }
        }
      }
      async _setupPeerDiscovery() {
        const setupService = (DiscoveryService) => {
          let config2 = {
            enabled: true
          };
          if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {
            config2 = { ...config2, ...this._config.peerDiscovery[DiscoveryService.tag] };
          }
          if (config2.enabled && !this._discovery.has(DiscoveryService.tag)) {
            let discoveryService;
            if (typeof DiscoveryService === "function") {
              discoveryService = new DiscoveryService(Object.assign({}, config2, {
                peerId: this.peerId,
                libp2p: this
              }));
            } else {
              discoveryService = DiscoveryService;
            }
            discoveryService.on("peer", this._onDiscoveryPeer);
            this._discovery.set(DiscoveryService.tag, discoveryService);
          }
        };
        for (const DiscoveryService of this._modules.peerDiscovery || []) {
          setupService(DiscoveryService);
        }
        for (const Transport of this.transportManager.getTransports()) {
          if (Transport.discovery) {
            setupService(Transport.discovery);
          }
        }
        await Promise.all(Array.from(this._discovery.values(), (d) => d.start()));
      }
    };
    module2.exports = Libp2p2;
  }
});

// node_modules/varint-decoder/node_modules/varint/encode.js
var require_encode3 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/encode.js"(exports2, module2) {
    init_globals();
    module2.exports = encode19;
    var MSB3 = 128;
    var REST3 = 127;
    var MSBALL3 = ~REST3;
    var INT3 = Math.pow(2, 31);
    function encode19(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT3) {
        out[offset++] = num & 255 | MSB3;
        num /= 128;
      }
      while (num & MSBALL3) {
        out[offset++] = num & 255 | MSB3;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode19.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint-decoder/node_modules/varint/decode.js
var require_decode4 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/decode.js"(exports2, module2) {
    init_globals();
    module2.exports = read3;
    var MSB3 = 128;
    var REST3 = 127;
    function read3(buf3, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
      do {
        if (counter >= l) {
          read3.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf3[counter++];
        res += shift < 28 ? (b & REST3) << shift : (b & REST3) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB3);
      read3.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint-decoder/node_modules/varint/length.js
var require_length2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/length.js"(exports2, module2) {
    init_globals();
    var N13 = Math.pow(2, 7);
    var N23 = Math.pow(2, 14);
    var N33 = Math.pow(2, 21);
    var N43 = Math.pow(2, 28);
    var N53 = Math.pow(2, 35);
    var N63 = Math.pow(2, 42);
    var N73 = Math.pow(2, 49);
    var N83 = Math.pow(2, 56);
    var N93 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N13 ? 1 : value < N23 ? 2 : value < N33 ? 3 : value < N43 ? 4 : value < N53 ? 5 : value < N63 ? 6 : value < N73 ? 7 : value < N83 ? 8 : value < N93 ? 9 : 10;
    };
  }
});

// node_modules/varint-decoder/node_modules/varint/index.js
var require_varint2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/index.js"(exports2, module2) {
    init_globals();
    module2.exports = {
      encode: require_encode3(),
      decode: require_decode4(),
      encodingLength: require_length2()
    };
  }
});

// node_modules/varint-decoder/src/index.js
var require_src28 = __commonJS({
  "node_modules/varint-decoder/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var varint7 = require_varint2();
    module2.exports = (buf3) => {
      if (!(buf3 instanceof Uint8Array)) {
        throw new Error("arg needs to be a Uint8Array");
      }
      const result = [];
      while (buf3.length > 0) {
        const num = varint7.decode(buf3);
        result.push(num);
        buf3 = buf3.slice(varint7.decode.bytes);
      }
      return result;
    };
  }
});

// node_modules/just-debounce-it/index.js
var require_just_debounce_it = __commonJS({
  "node_modules/just-debounce-it/index.js"(exports2, module2) {
    init_globals();
    module2.exports = debounce2;
    function debounce2(fn, wait, callFirst) {
      var timeout = null;
      var debouncedFn = null;
      var clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          debouncedFn = null;
          timeout = null;
        }
      };
      var flush3 = function() {
        var call = debouncedFn;
        clear();
        if (call) {
          call();
        }
      };
      var debounceWrapper = function() {
        if (!wait) {
          return fn.apply(this, arguments);
        }
        var context = this;
        var args = arguments;
        var callNow = callFirst && !timeout;
        clear();
        debouncedFn = function() {
          fn.apply(context, args);
        };
        timeout = setTimeout(function() {
          timeout = null;
          if (!callNow) {
            var call = debouncedFn;
            debouncedFn = null;
            return call();
          }
        }, wait);
        if (callNow) {
          return debouncedFn();
        }
      };
      debounceWrapper.cancel = clear;
      debounceWrapper.flush = flush3;
      return debounceWrapper;
    }
  }
});

// make-fetch/node_modules/base64-js/index.js
var require_base64_js2 = __commonJS({
  "make-fetch/node_modules/base64-js/index.js"(exports2) {
    "use strict";
    init_globals();
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code13 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code13.length; i < len; ++i) {
      lookup[i] = code13[i];
      revLookup[code13.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
  }
});

// make-fetch/node_modules/ieee754/index.js
var require_ieee7542 = __commonJS({
  "make-fetch/node_modules/ieee754/index.js"(exports2) {
    init_globals();
    exports2.read = function(buffer3, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer3[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer3[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer3[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer3, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer3[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer3[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer3[offset + i - d] |= s * 128;
    };
  }
});

// make-fetch/node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "make-fetch/node_modules/buffer/index.js"(exports2) {
    "use strict";
    init_globals();
    var base643 = require_base64_js2();
    var ieee754 = require_ieee7542();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length5) {
      if (length5 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length5 + '" is invalid for option "size"');
      }
      const buf3 = new Uint8Array(length5);
      Object.setPrototypeOf(buf3, Buffer2.prototype);
      return buf3;
    }
    function Buffer2(arg, encodingOrOffset, length5) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from5(arg, encodingOrOffset, length5);
    }
    Buffer2.poolSize = 8192;
    function from5(value, encodingOrOffset, length5) {
      if (typeof value === "string") {
        return fromString7(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length5);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length5);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length5);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length5);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer2.from = function(value, encodingOrOffset, length5) {
      return from5(value, encodingOrOffset, length5);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc3(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc3(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString7(string3, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length5 = byteLength(string3, encoding) | 0;
      let buf3 = createBuffer(length5);
      const actual = buf3.write(string3, encoding);
      if (actual !== length5) {
        buf3 = buf3.slice(0, actual);
      }
      return buf3;
    }
    function fromArrayLike(array) {
      const length5 = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf3 = createBuffer(length5);
      for (let i = 0; i < length5; i += 1) {
        buf3[i] = array[i] & 255;
      }
      return buf3;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length5) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length5 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf3;
      if (byteOffset === void 0 && length5 === void 0) {
        buf3 = new Uint8Array(array);
      } else if (length5 === void 0) {
        buf3 = new Uint8Array(array, byteOffset);
      } else {
        buf3 = new Uint8Array(array, byteOffset, length5);
      }
      Object.setPrototypeOf(buf3, Buffer2.prototype);
      return buf3;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf3 = createBuffer(len);
        if (buf3.length === 0) {
          return buf3;
        }
        obj.copy(buf3, 0, 0, len);
        return buf3;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length5) {
      if (length5 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length5 | 0;
    }
    function SlowBuffer(length5) {
      if (+length5 != length5) {
        length5 = 0;
      }
      return Buffer2.alloc(+length5);
    }
    Buffer2.isBuffer = function isBuffer5(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare4(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat5(list, length5) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length5 === void 0) {
        length5 = 0;
        for (i = 0; i < list.length; ++i) {
          length5 += list[i].length;
        }
      }
      const buffer3 = Buffer2.allocUnsafe(length5);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf3 = list[i];
        if (isInstance(buf3, Uint8Array)) {
          if (pos + buf3.length > buffer3.length) {
            if (!Buffer2.isBuffer(buf3))
              buf3 = Buffer2.from(buf3);
            buf3.copy(buffer3, pos);
          } else {
            Uint8Array.prototype.set.call(buffer3, buf3, pos);
          }
        } else if (!Buffer2.isBuffer(buf3)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf3.copy(buffer3, pos);
        }
        pos += buf3.length;
      }
      return buffer3;
    };
    function byteLength(string3, encoding) {
      if (Buffer2.isBuffer(string3)) {
        return string3.length;
      }
      if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer)) {
        return string3.byteLength;
      }
      if (typeof string3 !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3);
      }
      const len = string3.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes3(string3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string3).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes3(string3).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice3(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString6() {
      const length5 = this.length;
      if (length5 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice3(this, 0, length5);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals6(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare4(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer3, val, byteOffset, encoding, dir) {
      if (buffer3.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer3.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer3.length + byteOffset;
      if (byteOffset >= buffer3.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer3.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer3, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer3, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read3(buf3, i2) {
        if (indexSize === 1) {
          return buf3[i2];
        } else {
          return buf3.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read3(arr, i) === read3(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read3(arr, i + j) !== read3(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf3, string3, offset, length5) {
      offset = Number(offset) || 0;
      const remaining = buf3.length - offset;
      if (!length5) {
        length5 = remaining;
      } else {
        length5 = Number(length5);
        if (length5 > remaining) {
          length5 = remaining;
        }
      }
      const strLen = string3.length;
      if (length5 > strLen / 2) {
        length5 = strLen / 2;
      }
      let i;
      for (i = 0; i < length5; ++i) {
        const parsed = parseInt(string3.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf3[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf3, string3, offset, length5) {
      return blitBuffer(utf8ToBytes3(string3, buf3.length - offset), buf3, offset, length5);
    }
    function asciiWrite(buf3, string3, offset, length5) {
      return blitBuffer(asciiToBytes(string3), buf3, offset, length5);
    }
    function base64Write(buf3, string3, offset, length5) {
      return blitBuffer(base64ToBytes(string3), buf3, offset, length5);
    }
    function ucs2Write(buf3, string3, offset, length5) {
      return blitBuffer(utf16leToBytes(string3, buf3.length - offset), buf3, offset, length5);
    }
    Buffer2.prototype.write = function write2(string3, offset, length5, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length5 = this.length;
        offset = 0;
      } else if (length5 === void 0 && typeof offset === "string") {
        encoding = offset;
        length5 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length5)) {
          length5 = length5 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length5;
          length5 = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length5 === void 0 || length5 > remaining)
        length5 = remaining;
      if (string3.length > 0 && (length5 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset, length5);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset, length5);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string3, offset, length5);
          case "base64":
            return base64Write(this, string3, offset, length5);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset, length5);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf3, start, end) {
      if (start === 0 && end === buf3.length) {
        return base643.fromByteArray(buf3);
      } else {
        return base643.fromByteArray(buf3.slice(start, end));
      }
    }
    function utf8Slice3(buf3, start, end) {
      end = Math.min(buf3.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf3[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf3[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf3[i + 1];
              thirdByte = buf3[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf3[i + 1];
              thirdByte = buf3[i + 2];
              fourthByte = buf3[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray3(res);
    }
    var MAX_ARGUMENTS_LENGTH3 = 4096;
    function decodeCodePointsArray3(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH3) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH3));
      }
      return res;
    }
    function asciiSlice(buf3, start, end) {
      let ret = "";
      end = Math.min(buf3.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf3[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf3, start, end) {
      let ret = "";
      end = Math.min(buf3.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf3[i]);
      }
      return ret;
    }
    function hexSlice(buf3, start, end) {
      const len = buf3.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf3[i]];
      }
      return out;
    }
    function utf16leSlice(buf3, start, end) {
      const bytes2 = buf3.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes2.length - 1; i += 2) {
        res += String.fromCharCode(bytes2[i] + bytes2[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice3(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length5) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length5)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first4 = this[offset];
      const last15 = this[offset + 7];
      if (first4 === void 0 || last15 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first4 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last15 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first4 = this[offset];
      const last15 = this[offset + 7];
      if (first4 === void 0 || last15 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first4 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last15;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first4 = this[offset];
      const last15 = this[offset + 7];
      if (first4 === void 0 || last15 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last15 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first4 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first4 = this[offset];
      const last15 = this[offset + 7];
      if (first4 === void 0 || last15 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first4 << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last15);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf3, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf3))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf3.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf3, value, offset, min, max) {
      checkIntBI(value, min, max, buf3, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      lo = lo >> 8;
      buf3[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      hi = hi >> 8;
      buf3[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf3, value, offset, min, max) {
      checkIntBI(value, min, max, buf3, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf3[offset + 7] = lo;
      lo = lo >> 8;
      buf3[offset + 6] = lo;
      lo = lo >> 8;
      buf3[offset + 5] = lo;
      lo = lo >> 8;
      buf3[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf3[offset + 3] = hi;
      hi = hi >> 8;
      buf3[offset + 2] = hi;
      hi = hi >> 8;
      buf3[offset + 1] = hi;
      hi = hi >> 8;
      buf3[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf3, value, offset, ext, max, min) {
      if (offset + ext > buf3.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf3, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf3, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf3, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf3, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf3, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf3, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code13 = val.charCodeAt(0);
          if (encoding === "utf8" && code13 < 128 || encoding === "latin1") {
            val = code13;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes2.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes2[i % len];
        }
      }
      return this;
    };
    var errors2 = {};
    function E(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E("ERR_BUFFER_OUT_OF_BOUNDS", function(name10) {
      if (name10) {
        return `${name10} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E("ERR_INVALID_ARG_TYPE", function(name10, actual) {
      return `The "${name10}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf3, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf3[offset] === void 0 || buf3[offset + byteLength2] === void 0) {
        boundsError(offset, buf3.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf3, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf3, offset, byteLength2);
    }
    function validateNumber(value, name10) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name10, "number", value);
      }
    }
    function boundsError(value, length5, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length5 < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length5}`, value);
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes3(string3, units) {
      units = units || Infinity;
      let codePoint;
      const length5 = string3.length;
      let leadSurrogate = null;
      const bytes2 = [];
      for (let i = 0; i < length5; ++i) {
        codePoint = string3.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            } else if (i + 1 === length5) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes2.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes2;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base643.toByteArray(base64clean(str));
    }
    function blitBuffer(src3, dst, offset, length5) {
      let i;
      for (i = 0; i < length5; ++i) {
        if (i + offset >= dst.length || i >= src3.length)
          break;
        dst[i + offset] = src3[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// make-fetch/node_modules/fetch-headers/headers.js
var require_headers = __commonJS({
  "make-fetch/node_modules/fetch-headers/headers.js"(exports2, module2) {
    "use strict";
    init_globals();
    var map12 = /* @__PURE__ */ new WeakMap();
    var wm = (o) => map12.get(o);
    var normalizeValue = (v) => typeof v === "string" ? v : String(v);
    var isIterable2 = (o) => o != null && typeof o[Symbol.iterator] === "function";
    function normalizeName(name10) {
      if (typeof name10 !== "string")
        name10 = String(name10);
      if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name10))
        throw new TypeError("Invalid character in header field name");
      return name10.toLowerCase();
    }
    var Headers = class {
      constructor(headers) {
        map12.set(this, /* @__PURE__ */ Object.create(null));
        if (isIterable2(headers))
          for (let [name10, value] of headers)
            this.append(name10, value);
        else if (headers)
          for (let name10 of Object.getOwnPropertyNames(headers))
            this.append(name10, headers[name10]);
      }
      append(name10, value) {
        let map13 = wm(this);
        name10 = normalizeName(name10);
        value = normalizeValue(value);
        if (!map13[name10])
          map13[name10] = [];
        map13[name10].push(value);
      }
      delete(name10) {
        delete wm(this)[normalizeName(name10)];
      }
      *entries() {
        let map13 = wm(this);
        for (let name10 in map13)
          yield [name10, map13[name10].join(",")];
      }
      get(name10) {
        let map13 = wm(this);
        name10 = normalizeName(name10);
        return map13[name10] ? map13[name10][0] : null;
      }
      has(name10) {
        return normalizeName(name10) in wm(this);
      }
      *keys() {
        for (let [name10] of this)
          yield name10;
      }
      set(name10, value) {
        wm(this)[normalizeName(name10)] = [normalizeValue(value)];
      }
      *values() {
        for (let [name10, value] of this)
          yield value;
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      get [Symbol.toStringTag]() {
        return "Headers";
      }
    };
    module2.exports = Headers;
  }
});

// make-fetch/node_modules/statuses/codes.json
var require_codes = __commonJS({
  "make-fetch/node_modules/statuses/codes.json"(exports2, module2) {
    module2.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// make-fetch/node_modules/statuses/index.js
var require_statuses = __commonJS({
  "make-fetch/node_modules/statuses/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var codes = require_codes();
    module2.exports = status;
    status.message = codes;
    status.code = createMessageToStatusCodeMap(codes);
    status.codes = createStatusCodeList(codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map12 = {};
      Object.keys(codes2).forEach(function forEachCode(code13) {
        var message = codes2[code13];
        var status2 = Number(code13);
        map12[message.toLowerCase()] = status2;
      });
      return map12;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code13) {
        return Number(code13);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status.code[msg];
    }
    function getStatusMessage(code13) {
      if (!Object.prototype.hasOwnProperty.call(status.message, code13)) {
        throw new Error("invalid status code: " + code13);
      }
      return status.message[code13];
    }
    function status(code13) {
      if (typeof code13 === "number") {
        return getStatusMessage(code13);
      }
      if (typeof code13 !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code13, 10);
      if (!isNaN(n)) {
        return getStatusMessage(n);
      }
      return getStatusCode(code13);
    }
  }
});

// make-fetch/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "make-fetch/node_modules/ms/index.js"(exports2, module2) {
    init_globals();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name10) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name10 + (isPlural ? "s" : "");
    }
  }
});

// make-fetch/node_modules/debug/src/common.js
var require_common6 = __commonJS({
  "make-fetch/node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    init_globals();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce3;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms2();
      Object.keys(env).forEach(function(key) {
        createDebug[key] = env[key];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace3) {
        var hash2 = 0;
        for (var i = 0; i < namespace3.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace3.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace3) {
        var prevTime;
        function debug50() {
          if (!debug50.enabled) {
            return;
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var self2 = debug50;
          var curr = Number(new Date());
          var ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
            if (match === "%%") {
              return match;
            }
            index++;
            var formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              var val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          var logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug50.namespace = namespace3;
        debug50.enabled = createDebug.enabled(namespace3);
        debug50.useColors = createDebug.useColors();
        debug50.color = selectColor(namespace3);
        debug50.destroy = destroy;
        debug50.extend = extend;
        if (typeof createDebug.init === "function") {
          createDebug.init(debug50);
        }
        createDebug.instances.push(debug50);
        return debug50;
      }
      function destroy() {
        var index = createDebug.instances.indexOf(this);
        if (index !== -1) {
          createDebug.instances.splice(index, 1);
          return true;
        }
        return false;
      }
      function extend(namespace3, delimiter) {
        return createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace3);
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i;
        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i = 0; i < createDebug.instances.length; i++) {
          var instance = createDebug.instances[i];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      function disable() {
        createDebug.enable("");
      }
      function enabled(name10) {
        if (name10[name10.length - 1] === "*") {
          return true;
        }
        var i;
        var len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name10)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name10)) {
            return true;
          }
        }
        return false;
      }
      function coerce3(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// make-fetch/node_modules/debug/src/browser.js
var require_browser12 = __commonJS({
  "make-fetch/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    init_globals();
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    exports2.log = log48;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log48() {
      var _console;
      return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common6()(exports2);
    var formatters = module2.exports.formatters;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// make-fetch/node_modules/@tootallnate/once/dist/index.js
var require_dist3 = __commonJS({
  "make-fetch/node_modules/@tootallnate/once/dist/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    function noop2() {
    }
    function once(emitter, name10) {
      const o = once.spread(emitter, name10);
      const r = o.then((args) => args[0]);
      r.cancel = o.cancel;
      return r;
    }
    (function(once2) {
      function spread(emitter, name10) {
        let c = null;
        const p = new Promise((resolve11, reject) => {
          function cancel() {
            emitter.removeListener(name10, onEvent);
            emitter.removeListener("error", onError);
            p.cancel = noop2;
          }
          function onEvent(...args) {
            cancel();
            resolve11(args);
          }
          function onError(err) {
            cancel();
            reject(err);
          }
          c = cancel;
          emitter.on(name10, onEvent);
          emitter.on("error", onError);
        });
        if (!c) {
          throw new TypeError("Could not get `cancel()` function");
        }
        p.cancel = c;
        return p;
      }
      once2.spread = spread;
    })(once || (once = {}));
    module2.exports = once;
  }
});

// make-fetch/node_modules/stream-async-iterator/dist/index.js
var require_dist4 = __commonJS({
  "make-fetch/node_modules/stream-async-iterator/dist/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve11) {
          resolve11(value);
        });
      }
      return new (P || (P = Promise))(function(resolve11, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve11(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __asyncValues = exports2 && exports2.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve11, reject) {
            v = o[n](v), settle(resolve11, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve11, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve11({ value: v2, done: d });
        }, reject);
      }
    };
    var __await = exports2 && exports2.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports2 && exports2.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    var debug_1 = __importDefault(require_browser12());
    var once_1 = __importDefault(require_dist3());
    var debug50 = debug_1.default("stream-async-iterator");
    function createAsyncIterator(stream) {
      let bufferPromise = null;
      const it = asyncIterator(stream);
      it.then = (resolve11, reject) => {
        if (!bufferPromise) {
          bufferPromise = buffer3(it);
        }
        return bufferPromise.then(resolve11, reject);
      };
      return it;
    }
    function buffer3(it) {
      var it_1, it_1_1;
      var e_1, _a;
      return __awaiter(this, void 0, void 0, function* () {
        let bytes2 = 0;
        let buffers = [];
        try {
          for (it_1 = __asyncValues(it); it_1_1 = yield it_1.next(), !it_1_1.done; ) {
            const b = it_1_1.value;
            bytes2 += b.length;
            buffers.push(b);
            debug50("Buffered %o buffers, %o bytes", buffers.length, bytes2);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (it_1_1 && !it_1_1.done && (_a = it_1.return))
              yield _a.call(it_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return Buffer.concat(buffers, bytes2);
      });
    }
    function asyncIterator(stream) {
      return __asyncGenerator(this, arguments, function* asyncIterator_1() {
        let ended = false;
        const endPromise = once_1.default(stream, "end").then(() => {
          debug50('Got "end" event');
          ended = true;
        });
        while (!ended) {
          const value = stream.read();
          if (value === null) {
            debug50('Waiting for "readable" or "end"');
            yield __await(Promise.race([once_1.default(stream, "readable"), endPromise]));
          } else {
            yield yield __await(value);
          }
        }
      });
    }
    module2.exports = createAsyncIterator;
  }
});

// (disabled):fs
var require_fs = __commonJS({
  "(disabled):fs"() {
    init_globals();
  }
});

// make-fetch/node_modules/fetch-request-body-to-async-iterator/index.js
var require_fetch_request_body_to_async_iterator = __commonJS({
  "make-fetch/node_modules/fetch-request-body-to-async-iterator/index.js"(exports2, module2) {
    init_globals();
    var nodeStreamToIterator = require_dist4();
    module2.exports = function bodyToIterator(body, ses) {
      if (!body)
        return arrayToIterator([]);
      if (isFn(body.pipe))
        return nodeStreamToIterator(body);
      if (isFn(body.stream)) {
        const stream = body.stream();
        return streamIntoInterator(stream);
      }
      if (isFn(body.arrayBuffer)) {
        return promiseToIterator(body.arrayBuffer());
      }
      if (isFn(body.getReader)) {
        return streamIntoInterator(body);
      }
      if (body.bytes) {
        return intoIterator(body.bytes);
      }
      if (body.blobUUID) {
        if (!ses)
          throw new Error("Must specify session for blobUUIDs");
        return promiseToIterator(ses.getBlobData(body.blobUUID));
      }
      if (isFn(body.entries)) {
        return intoIterator(Buffer.from(body.toString()));
      }
      if (body.file && typeof body.file === "string") {
        if (!ses)
          throw new Error("Must specify session for electron file upload");
        const fs = require_fs();
        return nodeStreamToIterator(fs.createReadStream(body.file));
      }
      return intoIterator(Buffer.from(body));
    };
    function isFn(value) {
      return typeof value === "function";
    }
    function streamIntoInterator(stream) {
      if (stream.getIterator) {
        return stream.getIterator();
      } else {
        return consumeStream(stream);
      }
    }
    async function* consumeStream(stream) {
      const reader = stream.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          return;
        yield value;
      }
    }
    async function* promiseToIterator(promise) {
      yield await promise;
    }
    async function* arrayToIterator(array) {
      yield* array;
    }
    async function* intoIterator(value) {
      yield value;
    }
  }
});

// make-fetch/node_modules/web-streams-polyfill/dist/ponyfill.es6.js
var require_ponyfill_es6 = __commonJS({
  "make-fetch/node_modules/web-streams-polyfill/dist/ponyfill.es6.js"(exports2, module2) {
    init_globals();
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports2, function(exports3) {
      "use strict";
      const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
      function noop2() {
        return void 0;
      }
      function getGlobals() {
        if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else if (typeof global !== "undefined") {
          return global;
        }
        return void 0;
      }
      const globals = getGlobals();
      function typeIsObject(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      const rethrowAssertionErrorRejection = noop2;
      const originalPromise = Promise;
      const originalPromiseThen = Promise.prototype.then;
      const originalPromiseResolve = Promise.resolve.bind(originalPromise);
      const originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      const queueMicrotask2 = (() => {
        const globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask === "function") {
          return globalQueueMicrotask;
        }
        const resolvedPromise = promiseResolvedWith(void 0);
        return (fn) => PerformPromiseThen(resolvedPromise, fn);
      })();
      function reflectCall(F, V, args) {
        if (typeof F !== "function") {
          throw new TypeError("Argument is not a function");
        }
        return Function.prototype.apply.call(F, V, args);
      }
      function promiseCall(F, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      const QUEUE_MAX_ARRAY_SIZE = 16384;
      class SimpleQueue {
        constructor() {
          this._cursor = 0;
          this._size = 0;
          this._front = {
            _elements: [],
            _next: void 0
          };
          this._back = this._front;
          this._cursor = 0;
          this._size = 0;
        }
        get length() {
          return this._size;
        }
        push(element) {
          const oldBack = this._back;
          let newBack = oldBack;
          if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
            newBack = {
              _elements: [],
              _next: void 0
            };
          }
          oldBack._elements.push(element);
          if (newBack !== oldBack) {
            this._back = newBack;
            oldBack._next = newBack;
          }
          ++this._size;
        }
        shift() {
          const oldFront = this._front;
          let newFront = oldFront;
          const oldCursor = this._cursor;
          let newCursor = oldCursor + 1;
          const elements = oldFront._elements;
          const element = elements[oldCursor];
          if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
            newFront = oldFront._next;
            newCursor = 0;
          }
          --this._size;
          this._cursor = newCursor;
          if (oldFront !== newFront) {
            this._front = newFront;
          }
          elements[oldCursor] = void 0;
          return element;
        }
        forEach(callback) {
          let i = this._cursor;
          let node = this._front;
          let elements = node._elements;
          while (i !== elements.length || node._next !== void 0) {
            if (i === elements.length) {
              node = node._next;
              elements = node._elements;
              i = 0;
              if (elements.length === 0) {
                break;
              }
            }
            callback(elements[i]);
            ++i;
          }
        }
        peek() {
          const front = this._front;
          const cursor = this._cursor;
          return front._elements[cursor];
        }
      }
      function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === "readable") {
          defaultReaderClosedPromiseInitialize(reader);
        } else if (stream._state === "closed") {
          defaultReaderClosedPromiseInitializeAsResolved(reader);
        } else {
          defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        if (reader._ownerReadableStream._state === "readable") {
          defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        } else {
          defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        reader._ownerReadableStream._reader = void 0;
        reader._ownerReadableStream = void 0;
      }
      function readerLockException(name10) {
        return new TypeError("Cannot " + name10 + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve11, reject) => {
          reader._closedPromise_resolve = resolve11;
          reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === void 0) {
          return;
        }
        reader._closedPromise_resolve(void 0);
        reader._closedPromise_resolve = void 0;
        reader._closedPromise_reject = void 0;
      }
      const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
      const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
      const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
      const PullSteps = SymbolPolyfill("[[PullSteps]]");
      const NumberIsFinite = Number.isFinite || function(x) {
        return typeof x === "number" && isFinite(x);
      };
      const MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x) {
        return typeof x === "object" || typeof x === "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertFunction(x, context) {
        if (typeof x !== "function") {
          throw new TypeError(`${context} is not a function.`);
        }
      }
      function isObject(x) {
        return typeof x === "object" && x !== null || typeof x === "function";
      }
      function assertObject(x, context) {
        if (!isObject(x)) {
          throw new TypeError(`${context} is not an object.`);
        }
      }
      function assertRequiredArgument(x, position, context) {
        if (x === void 0) {
          throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
      }
      function assertRequiredField(x, field, context) {
        if (x === void 0) {
          throw new TypeError(`${field} is required in '${context}'.`);
        }
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
      }
      function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
          throw new TypeError(`${context} is not a finite number`);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x) || x === 0) {
          return 0;
        }
        return x;
      }
      function assertReadableStream(x, context) {
        if (!IsReadableStream(x)) {
          throw new TypeError(`${context} is not a ReadableStream.`);
        }
      }
      function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
      }
      function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
          readRequest._closeSteps();
        } else {
          readRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamDefaultReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readRequests = new SimpleQueue();
        }
        get closed() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        cancel(reason = void 0) {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read() {
          if (!IsReadableStreamDefaultReader(this)) {
            return promiseRejectedWith(defaultReaderBrandCheckException("read"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve11, reject) => {
            resolvePromise = resolve11;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: () => resolvePromise({ value: void 0, done: true }),
            _errorSteps: (e) => rejectPromise(e)
          };
          ReadableStreamDefaultReaderRead(this, readRequest);
          return promise;
        }
        releaseLock() {
          if (!IsReadableStreamDefaultReader(this)) {
            throw defaultReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultReader",
          configurable: true
        });
      }
      function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
          return false;
        }
        return x instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "closed") {
          readRequest._closeSteps();
        } else if (stream._state === "errored") {
          readRequest._errorSteps(stream._storedError);
        } else {
          stream._readableStreamController[PullSteps](readRequest);
        }
      }
      function defaultReaderBrandCheckException(name10) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name10} can only be used on a ReadableStreamDefaultReader`);
      }
      let AsyncIteratorPrototype;
      if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        AsyncIteratorPrototype = {
          [SymbolPolyfill.asyncIterator]() {
            return this;
          }
        };
        Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });
      }
      class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
          this._ongoingPromise = void 0;
          this._isFinished = false;
          this._reader = reader;
          this._preventCancel = preventCancel;
        }
        next() {
          const nextSteps = () => this._nextSteps();
          this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
          return this._ongoingPromise;
        }
        return(value) {
          const returnSteps = () => this._returnSteps(value);
          return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
        }
        _nextSteps() {
          if (this._isFinished) {
            return Promise.resolve({ value: void 0, done: true });
          }
          const reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("iterate"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve11, reject) => {
            resolvePromise = resolve11;
            rejectPromise = reject;
          });
          const readRequest = {
            _chunkSteps: (chunk) => {
              this._ongoingPromise = void 0;
              queueMicrotask2(() => resolvePromise({ value: chunk, done: false }));
            },
            _closeSteps: () => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              resolvePromise({ value: void 0, done: true });
            },
            _errorSteps: (reason) => {
              this._ongoingPromise = void 0;
              this._isFinished = true;
              ReadableStreamReaderGenericRelease(reader);
              rejectPromise(reason);
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promise;
        }
        _returnSteps(value) {
          if (this._isFinished) {
            return Promise.resolve({ value, done: true });
          }
          this._isFinished = true;
          const reader = this._reader;
          if (reader._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("finish iterating"));
          }
          if (!this._preventCancel) {
            const result = ReadableStreamReaderGenericCancel(reader, value);
            ReadableStreamReaderGenericRelease(reader);
            return transformPromiseWith(result, () => ({ value, done: true }));
          }
          ReadableStreamReaderGenericRelease(reader);
          return promiseResolvedWith({ value, done: true });
        }
      }
      const ReadableStreamAsyncIteratorPrototype = {
        next() {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
          }
          return this._asyncIteratorImpl.next();
        },
        return(value) {
          if (!IsReadableStreamAsyncIterator(this)) {
            return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
          }
          return this._asyncIteratorImpl.return(value);
        }
      };
      if (AsyncIteratorPrototype !== void 0) {
        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      }
      function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
      }
      function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
          return false;
        }
        try {
          return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch (_a) {
          return false;
        }
      }
      function streamAsyncIteratorBrandCheckException(name10) {
        return new TypeError(`ReadableStreamAsyncIterator.${name10} can only be used on a ReadableSteamAsyncIterator`);
      }
      const NumberIsNaN = Number.isNaN || function(x) {
        return x !== x;
      };
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src3, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src3, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O) {
        return O;
      }
      function IsDetachedBuffer(O) {
        return false;
      }
      function ArrayBufferSlice(buffer3, begin, end) {
        if (buffer3.slice) {
          return buffer3.slice(begin, end);
        }
        const length5 = end - begin;
        const slice3 = new ArrayBuffer(length5);
        CopyDataBlockBytes(slice3, 0, buffer3, begin, length5);
        return slice3;
      }
      function IsNonNegativeNumber(v) {
        if (typeof v !== "number") {
          return false;
        }
        if (NumberIsNaN(v)) {
          return false;
        }
        if (v < 0) {
          return false;
        }
        return true;
      }
      function CloneAsUint8Array(O) {
        const buffer3 = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer3);
      }
      function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
          container._queueTotalSize = 0;
        }
        return pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
      }
      class ReadableStreamBYOBRequest {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get view() {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("view");
          }
          return this._view;
        }
        respond(bytesWritten) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respond");
          }
          assertRequiredArgument(bytesWritten, 1, "respond");
          bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(this._view.buffer))
            ;
          ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
          if (!IsReadableStreamBYOBRequest(this)) {
            throw byobRequestBrandCheckException("respondWithNewView");
          }
          assertRequiredArgument(view, 1, "respondWithNewView");
          if (!ArrayBuffer.isView(view)) {
            throw new TypeError("You can only respond with array buffer views");
          }
          if (this._associatedReadableByteStreamController === void 0) {
            throw new TypeError("This BYOB request has been invalidated");
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
      }
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBRequest",
          configurable: true
        });
      }
      class ReadableByteStreamController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get byobRequest() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("byobRequest");
          }
          return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        get desiredSize() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("desiredSize");
          }
          return ReadableByteStreamControllerGetDesiredSize(this);
        }
        close() {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("close");
          }
          if (this._closeRequested) {
            throw new TypeError("The stream has already been closed; do not close it again!");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
          }
          ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("enqueue");
          }
          assertRequiredArgument(chunk, 1, "enqueue");
          if (!ArrayBuffer.isView(chunk)) {
            throw new TypeError("chunk must be an array buffer view");
          }
          if (chunk.byteLength === 0) {
            throw new TypeError("chunk must have non-zero byteLength");
          }
          if (chunk.buffer.byteLength === 0) {
            throw new TypeError(`chunk's buffer must have non-zero byteLength`);
          }
          if (this._closeRequested) {
            throw new TypeError("stream is closed or draining");
          }
          const state = this._controlledReadableByteStream._state;
          if (state !== "readable") {
            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
          }
          ReadableByteStreamControllerEnqueue(this, chunk);
        }
        error(e = void 0) {
          if (!IsReadableByteStreamController(this)) {
            throw byteStreamControllerBrandCheckException("error");
          }
          ReadableByteStreamControllerError(this, e);
        }
        [CancelSteps](reason) {
          ReadableByteStreamControllerClearPendingPullIntos(this);
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableByteStreamControllerClearAlgorithms(this);
          return result;
        }
        [PullSteps](readRequest) {
          const stream = this._controlledReadableByteStream;
          if (this._queueTotalSize > 0) {
            const entry = this._queue.shift();
            this._queueTotalSize -= entry.byteLength;
            ReadableByteStreamControllerHandleQueueDrain(this);
            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
            readRequest._chunkSteps(view);
            return;
          }
          const autoAllocateChunkSize = this._autoAllocateChunkSize;
          if (autoAllocateChunkSize !== void 0) {
            let buffer3;
            try {
              buffer3 = new ArrayBuffer(autoAllocateChunkSize);
            } catch (bufferE) {
              readRequest._errorSteps(bufferE);
              return;
            }
            const pullIntoDescriptor = {
              buffer: buffer3,
              bufferByteLength: autoAllocateChunkSize,
              byteOffset: 0,
              byteLength: autoAllocateChunkSize,
              bytesFilled: 0,
              elementSize: 1,
              viewConstructor: Uint8Array,
              readerType: "default"
            };
            this._pendingPullIntos.push(pullIntoDescriptor);
          }
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableByteStreamControllerCallPullIfNeeded(this);
        }
      }
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableByteStreamController",
          configurable: true
        });
      }
      function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
          return false;
        }
        return x instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
          return false;
        }
        return x instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }, (e) => {
          ReadableByteStreamControllerError(controller, e);
        });
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === "closed") {
          done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === "default") {
          ReadableStreamFulfillReadRequest(stream, filledView, done);
        } else {
          ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer3, byteOffset, byteLength) {
        controller._queue.push({ buffer: buffer3, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const elementSize = pullIntoDescriptor.elementSize;
        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        if (maxAlignedBytes > currentAlignedBytes) {
          totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
          ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
          const headOfQueue = queue.peek();
          const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
          const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
          if (headOfQueue.byteLength === bytesToCopy) {
            queue.shift();
          } else {
            headOfQueue.byteOffset += bytesToCopy;
            headOfQueue.byteLength -= bytesToCopy;
          }
          controller._queueTotalSize -= bytesToCopy;
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
          totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(controller._controlledReadableByteStream);
        } else {
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
          return;
        }
        controller._byobRequest._associatedReadableByteStreamController = void 0;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
          if (controller._queueTotalSize === 0) {
            return;
          }
          const pullIntoDescriptor = controller._pendingPullIntos.peek();
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        let elementSize = 1;
        if (view.constructor !== DataView) {
          elementSize = view.constructor.BYTES_PER_ELEMENT;
        }
        const ctor = view.constructor;
        const buffer3 = TransferArrayBuffer(view.buffer);
        const pullIntoDescriptor = {
          buffer: buffer3,
          bufferByteLength: buffer3.byteLength,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          return;
        }
        if (stream._state === "closed") {
          const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller);
            readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e);
            readIntoRequest._errorSteps(e);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
          while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
          }
        }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
          return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
          const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          ReadableByteStreamControllerRespondInClosedState(controller);
        } else {
          ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return false;
        }
        if (controller._closeRequested) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        if (controller._queueTotalSize > 0) {
          controller._closeRequested = true;
          return;
        }
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (firstPendingPullInto.bytesFilled > 0) {
            const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e);
            throw e;
          }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== "readable") {
          return;
        }
        const buffer3 = chunk.buffer;
        const byteOffset = chunk.byteOffset;
        const byteLength = chunk.byteLength;
        const transferredBuffer = TransferArrayBuffer(buffer3);
        if (controller._pendingPullIntos.length > 0) {
          const firstPendingPullInto = controller._pendingPullIntos.peek();
          if (IsDetachedBuffer(firstPendingPullInto.buffer))
            ;
          firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
        }
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        if (ReadableStreamHasDefaultReader(stream)) {
          if (ReadableStreamGetNumReadRequests(stream) === 0) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          } else {
            if (controller._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
            }
            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
            ReadableStreamFulfillReadRequest(stream, transferredView, false);
          }
        } else if (ReadableStreamHasBYOBReader(stream)) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        } else {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerError(controller, e) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== "readable") {
          return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
          const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
          controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0) {
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
          }
        } else {
          if (bytesWritten === 0) {
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          }
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
            throw new RangeError("bytesWritten out of range");
          }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0) {
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
          }
        } else {
          if (view.byteLength === 0) {
            throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
          }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
          throw new RangeError("The region specified by view does not match byobRequest");
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
          throw new RangeError("The region specified by view is larger than byobRequest");
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        controller._queue = controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, (r) => {
          ReadableByteStreamControllerError(controller, r);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm = () => void 0;
        let pullAlgorithm = () => promiseResolvedWith(void 0);
        let cancelAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingByteSource.start !== void 0) {
          startAlgorithm = () => underlyingByteSource.start(controller);
        }
        if (underlyingByteSource.pull !== void 0) {
          pullAlgorithm = () => underlyingByteSource.pull(controller);
        }
        if (underlyingByteSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
      }
      function byobRequestBrandCheckException(name10) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name10} can only be used on a ReadableStreamBYOBRequest`);
      }
      function byteStreamControllerBrandCheckException(name10) {
        return new TypeError(`ReadableByteStreamController.prototype.${name10} can only be used on a ReadableByteStreamController`);
      }
      function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
      }
      function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
          readIntoRequest._closeSteps(chunk);
        } else {
          readIntoRequest._chunkSteps(chunk);
        }
      }
      function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === void 0) {
          return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
          return false;
        }
        return true;
      }
      class ReadableStreamBYOBReader {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
          assertReadableStream(stream, "First parameter");
          if (IsReadableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive reading by another reader");
          }
          if (!IsReadableByteStreamController(stream._readableStreamController)) {
            throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
          }
          ReadableStreamReaderGenericInitialize(this, stream);
          this._readIntoRequests = new SimpleQueue();
        }
        get closed() {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        cancel(reason = void 0) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("cancel"));
          }
          return ReadableStreamReaderGenericCancel(this, reason);
        }
        read(view) {
          if (!IsReadableStreamBYOBReader(this)) {
            return promiseRejectedWith(byobReaderBrandCheckException("read"));
          }
          if (!ArrayBuffer.isView(view)) {
            return promiseRejectedWith(new TypeError("view must be an array buffer view"));
          }
          if (view.byteLength === 0) {
            return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
          }
          if (view.buffer.byteLength === 0) {
            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
          }
          if (IsDetachedBuffer(view.buffer))
            ;
          if (this._ownerReadableStream === void 0) {
            return promiseRejectedWith(readerLockException("read from"));
          }
          let resolvePromise;
          let rejectPromise;
          const promise = newPromise((resolve11, reject) => {
            resolvePromise = resolve11;
            rejectPromise = reject;
          });
          const readIntoRequest = {
            _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
            _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
            _errorSteps: (e) => rejectPromise(e)
          };
          ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
          return promise;
        }
        releaseLock() {
          if (!IsReadableStreamBYOBReader(this)) {
            throw byobReaderBrandCheckException("releaseLock");
          }
          if (this._ownerReadableStream === void 0) {
            return;
          }
          if (this._readIntoRequests.length > 0) {
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          }
          ReadableStreamReaderGenericRelease(this);
        }
      }
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamBYOBReader",
          configurable: true
        });
      }
      function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
          return false;
        }
        return x instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === "errored") {
          readIntoRequest._errorSteps(stream._storedError);
        } else {
          ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
        }
      }
      function byobReaderBrandCheckException(name10) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name10} can only be used on a ReadableStreamBYOBReader`);
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === void 0) {
          return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
          throw new RangeError("Invalid highWaterMark");
        }
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
          return () => 1;
        }
        return size;
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        const size = init === null || init === void 0 ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
      }
      function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return (chunk) => convertUnrestrictedDouble(fn(chunk));
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write2 = original === null || original === void 0 ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
          write: write2 === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write2, original, `${context} has member 'write' that`),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      function assertWritableStream(x, context) {
        if (!IsWritableStream(x)) {
          throw new TypeError(`${context} is not a WritableStream.`);
        }
      }
      function isAbortSignal(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        try {
          return typeof value.aborted === "boolean";
        } catch (_a) {
          return false;
        }
      }
      const supportsAbortController = typeof AbortController === "function";
      function createAbortController() {
        if (supportsAbortController) {
          return new AbortController();
        }
        return void 0;
      }
      class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
          if (rawUnderlyingSink === void 0) {
            rawUnderlyingSink = null;
          } else {
            assertObject(rawUnderlyingSink, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
          InitializeWritableStream(this);
          const type = underlyingSink.type;
          if (type !== void 0) {
            throw new RangeError("Invalid type is specified");
          }
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        get locked() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("locked");
          }
          return IsWritableStreamLocked(this);
        }
        abort(reason = void 0) {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("abort"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
          }
          return WritableStreamAbort(this, reason);
        }
        close() {
          if (!IsWritableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$2("close"));
          }
          if (IsWritableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
          }
          if (WritableStreamCloseQueuedOrInFlight(this)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamClose(this);
        }
        getWriter() {
          if (!IsWritableStream(this)) {
            throw streamBrandCheckException$2("getWriter");
          }
          return AcquireWritableStreamDefaultWriter(this);
        }
      }
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStream",
          configurable: true
        });
      }
      function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function InitializeWritableStream(stream) {
        stream._state = "writable";
        stream._storedError = void 0;
        stream._writer = void 0;
        stream._writableStreamController = void 0;
        stream._writeRequests = new SimpleQueue();
        stream._inFlightWriteRequest = void 0;
        stream._closeRequest = void 0;
        stream._inFlightCloseRequest = void 0;
        stream._pendingAbortRequest = void 0;
        stream._backpressure = false;
      }
      function IsWritableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
          return false;
        }
        return x instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream) {
        if (stream._writer === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamAbort(stream, reason) {
        var _a;
        if (stream._state === "closed" || stream._state === "errored") {
          return promiseResolvedWith(void 0);
        }
        stream._writableStreamController._abortReason = reason;
        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseResolvedWith(void 0);
        }
        if (stream._pendingAbortRequest !== void 0) {
          return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === "erroring") {
          wasAlreadyErroring = true;
          reason = void 0;
        }
        const promise = newPromise((resolve11, reject) => {
          stream._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve11,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
          WritableStreamStartErroring(stream, reason);
        }
        return promise;
      }
      function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === "closed" || state === "errored") {
          return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve11, reject) => {
          const closeRequest = {
            _resolve: resolve11,
            _reject: reject
          };
          stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== void 0 && stream._backpressure && state === "writable") {
          defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
      }
      function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve11, reject) => {
          const writeRequest = {
            _resolve: resolve11,
            _reject: reject
          };
          stream._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream, error);
          return;
        }
        WritableStreamFinishErroring(stream);
      }
      function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = "erroring";
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== void 0) {
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
          WritableStreamFinishErroring(stream);
        }
      }
      function WritableStreamFinishErroring(stream) {
        stream._state = "errored";
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach((writeRequest) => {
          writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = void 0;
        if (abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
          abortRequest._resolve();
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, (reason) => {
          abortRequest._reject(reason);
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
      }
      function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(void 0);
        stream._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = void 0;
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(void 0);
        stream._inFlightCloseRequest = void 0;
        const state = stream._state;
        if (state === "erroring") {
          stream._storedError = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._resolve();
            stream._pendingAbortRequest = void 0;
          }
        }
        stream._state = "closed";
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseResolve(writer);
        }
      }
      function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = void 0;
        if (stream._pendingAbortRequest !== void 0) {
          stream._pendingAbortRequest._reject(error);
          stream._pendingAbortRequest = void 0;
        }
        WritableStreamDealWithRejection(stream, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
          return false;
        }
        return true;
      }
      function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== void 0) {
          stream._closeRequest._reject(stream._storedError);
          stream._closeRequest = void 0;
        }
        const writer = stream._writer;
        if (writer !== void 0) {
          defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
      }
      function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== void 0 && backpressure !== stream._backpressure) {
          if (backpressure) {
            defaultWriterReadyPromiseReset(writer);
          } else {
            defaultWriterReadyPromiseResolve(writer);
          }
        }
        stream._backpressure = backpressure;
      }
      class WritableStreamDefaultWriter {
        constructor(stream) {
          assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
          assertWritableStream(stream, "First parameter");
          if (IsWritableStreamLocked(stream)) {
            throw new TypeError("This stream has already been locked for exclusive writing by another writer");
          }
          this._ownerWritableStream = stream;
          stream._writer = this;
          const state = stream._state;
          if (state === "writable") {
            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
              defaultWriterReadyPromiseInitialize(this);
            } else {
              defaultWriterReadyPromiseInitializeAsResolved(this);
            }
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "erroring") {
            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
            defaultWriterClosedPromiseInitialize(this);
          } else if (state === "closed") {
            defaultWriterReadyPromiseInitializeAsResolved(this);
            defaultWriterClosedPromiseInitializeAsResolved(this);
          } else {
            const storedError = stream._storedError;
            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
          }
        }
        get closed() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
          }
          return this._closedPromise;
        }
        get desiredSize() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("desiredSize");
          }
          if (this._ownerWritableStream === void 0) {
            throw defaultWriterLockException("desiredSize");
          }
          return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        get ready() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
          }
          return this._readyPromise;
        }
        abort(reason = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("abort"));
          }
          return WritableStreamDefaultWriterAbort(this, reason);
        }
        close() {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("close"));
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("close"));
          }
          if (WritableStreamCloseQueuedOrInFlight(stream)) {
            return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
          }
          return WritableStreamDefaultWriterClose(this);
        }
        releaseLock() {
          if (!IsWritableStreamDefaultWriter(this)) {
            throw defaultWriterBrandCheckException("releaseLock");
          }
          const stream = this._ownerWritableStream;
          if (stream === void 0) {
            return;
          }
          WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = void 0) {
          if (!IsWritableStreamDefaultWriter(this)) {
            return promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }
          if (this._ownerWritableStream === void 0) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          return WritableStreamDefaultWriterWrite(this, chunk);
        }
      }
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultWriter",
          configurable: true
        });
      }
      function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
          return false;
        }
        return x instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === "pending") {
          defaultWriterClosedPromiseReject(writer, error);
        } else {
          defaultWriterClosedPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === "pending") {
          defaultWriterReadyPromiseReject(writer, error);
        } else {
          defaultWriterReadyPromiseResetToRejected(writer, error);
        }
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === "errored" || state === "erroring") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = void 0;
        writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize2 = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        const state = stream._state;
        if (state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        }
        if (state === "erroring") {
          return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize2);
        return promise;
      }
      const closeSentinel = {};
      class WritableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get abortReason() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("abortReason");
          }
          return this._abortReason;
        }
        get signal() {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("signal");
          }
          if (this._abortController === void 0) {
            throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
          }
          return this._abortController.signal;
        }
        error(e = void 0) {
          if (!IsWritableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$2("error");
          }
          const state = this._controlledWritableStream._state;
          if (state !== "writable") {
            return;
          }
          WritableStreamDefaultControllerError(this, e);
        }
        [AbortSteps](reason) {
          const result = this._abortAlgorithm(reason);
          WritableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        [ErrorSteps]() {
          ResetQueue(this);
        }
      }
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "WritableStreamDefaultController",
          configurable: true
        });
      }
      function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
          return false;
        }
        return x instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._abortReason = void 0;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
          controller._started = true;
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (r) => {
          controller._started = true;
          WritableStreamDealWithRejection(stream, r);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm = () => void 0;
        let writeAlgorithm = () => promiseResolvedWith(void 0);
        let closeAlgorithm = () => promiseResolvedWith(void 0);
        let abortAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingSink.start !== void 0) {
          startAlgorithm = () => underlyingSink.start(controller);
        }
        if (underlyingSink.write !== void 0) {
          writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
        }
        if (underlyingSink.close !== void 0) {
          closeAlgorithm = () => underlyingSink.close();
        }
        if (underlyingSink.abort !== void 0) {
          abortAlgorithm = (reason) => underlyingSink.abort(reason);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0;
        controller._closeAlgorithm = void 0;
        controller._abortAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
          return 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize2) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize2);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
          return;
        }
        if (stream._inFlightWriteRequest !== void 0) {
          return;
        }
        const state = stream._state;
        if (state === "erroring") {
          WritableStreamFinishErroring(stream);
          return;
        }
        if (controller._queue.length === 0) {
          return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
          WritableStreamDefaultControllerProcessClose(controller);
        } else {
          WritableStreamDefaultControllerProcessWrite(controller, value);
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === "writable") {
          WritableStreamDefaultControllerError(controller, error);
        }
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
          WritableStreamFinishInFlightClose(stream);
        }, (reason) => {
          WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
          WritableStreamFinishInFlightWrite(stream);
          const state = stream._state;
          DequeueValue(controller);
          if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, (reason) => {
          if (stream._state === "writable") {
            WritableStreamDefaultControllerClearAlgorithms(controller);
          }
          WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
      }
      function streamBrandCheckException$2(name10) {
        return new TypeError(`WritableStream.prototype.${name10} can only be used on a WritableStream`);
      }
      function defaultControllerBrandCheckException$2(name10) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name10} can only be used on a WritableStreamDefaultController`);
      }
      function defaultWriterBrandCheckException(name10) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name10} can only be used on a WritableStreamDefaultWriter`);
      }
      function defaultWriterLockException(name10) {
        return new TypeError("Cannot " + name10 + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve11, reject) => {
          writer._closedPromise_resolve = resolve11;
          writer._closedPromise_reject = reject;
          writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "rejected";
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === void 0) {
          return;
        }
        writer._closedPromise_resolve(void 0);
        writer._closedPromise_resolve = void 0;
        writer._closedPromise_reject = void 0;
        writer._closedPromiseState = "resolved";
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve11, reject) => {
          writer._readyPromise_resolve = resolve11;
          writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === void 0) {
          return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "rejected";
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === void 0) {
          return;
        }
        writer._readyPromise_resolve(void 0);
        writer._readyPromise_resolve = void 0;
        writer._readyPromise_reject = void 0;
        writer._readyPromiseState = "fulfilled";
      }
      const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === "function" || typeof ctor === "object")) {
          return false;
        }
        try {
          new ctor();
          return true;
        } catch (_a) {
          return false;
        }
      }
      function createDOMExceptionPolyfill() {
        const ctor = function DOMException2(message, name10) {
          this.message = message || "";
          this.name = name10 || "Error";
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        };
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
        return ctor;
      }
      const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        let currentWrite = promiseResolvedWith(void 0);
        return newPromise((resolve11, reject) => {
          let abortAlgorithm;
          if (signal !== void 0) {
            abortAlgorithm = () => {
              const error = new DOMException$1("Aborted", "AbortError");
              const actions = [];
              if (!preventAbort) {
                actions.push(() => {
                  if (dest._state === "writable") {
                    return WritableStreamAbort(dest, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              if (!preventCancel) {
                actions.push(() => {
                  if (source._state === "readable") {
                    return ReadableStreamCancel(source, error);
                  }
                  return promiseResolvedWith(void 0);
                });
              }
              shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error);
            };
            if (signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise((resolveLoop, rejectLoop) => {
              function next(done) {
                if (done) {
                  resolveLoop();
                } else {
                  PerformPromiseThen(pipeStep(), next, rejectLoop);
                }
              }
              next(false);
            });
          }
          function pipeStep() {
            if (shuttingDown) {
              return promiseResolvedWith(true);
            }
            return PerformPromiseThen(writer._readyPromise, () => {
              return newPromise((resolveRead, rejectRead) => {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: (chunk) => {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);
                    resolveRead(false);
                  },
                  _closeSteps: () => resolveRead(true),
                  _errorSteps: rejectRead
                });
              });
            });
          }
          isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
            if (!preventAbort) {
              shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
            } else {
              shutdown(true, storedError);
            }
          });
          isOrBecomesClosed(source, reader._closedPromise, () => {
            if (!preventClose) {
              shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
            } else {
              shutdown();
            }
          });
          if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
            if (!preventCancel) {
              shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
            } else {
              shutdown(true, destClosed);
            }
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            const oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
          }
          function isOrBecomesErrored(stream, promise, action) {
            if (stream._state === "errored") {
              action(stream._storedError);
            } else {
              uponRejection(promise, action);
            }
          }
          function isOrBecomesClosed(stream, promise, action) {
            if (stream._state === "closed") {
              action();
            } else {
              uponFulfillment(promise, action);
            }
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), doTheRest);
            } else {
              doTheRest();
            }
            function doTheRest() {
              uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
            }
          }
          function shutdown(isError, error) {
            if (shuttingDown) {
              return;
            }
            shuttingDown = true;
            if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
              uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
            } else {
              finalize(isError, error);
            }
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer);
            ReadableStreamReaderGenericRelease(reader);
            if (signal !== void 0) {
              signal.removeEventListener("abort", abortAlgorithm);
            }
            if (isError) {
              reject(error);
            } else {
              resolve11(void 0);
            }
          }
        });
      }
      class ReadableStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("desiredSize");
          }
          return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        close() {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("close");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits close");
          }
          ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("enqueue");
          }
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
            throw new TypeError("The stream is not in a state that permits enqueue");
          }
          return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        error(e = void 0) {
          if (!IsReadableStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException$1("error");
          }
          ReadableStreamDefaultControllerError(this, e);
        }
        [CancelSteps](reason) {
          ResetQueue(this);
          const result = this._cancelAlgorithm(reason);
          ReadableStreamDefaultControllerClearAlgorithms(this);
          return result;
        }
        [PullSteps](readRequest) {
          const stream = this._controlledReadableStream;
          if (this._queue.length > 0) {
            const chunk = DequeueValue(this);
            if (this._closeRequested && this._queue.length === 0) {
              ReadableStreamDefaultControllerClearAlgorithms(this);
              ReadableStreamClose(stream);
            } else {
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
            readRequest._chunkSteps(chunk);
          } else {
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
        }
      }
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStreamDefaultController",
          configurable: true
        });
      }
      function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
          return false;
        }
        return x instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
          return;
        }
        if (controller._pulling) {
          controller._pullAgain = true;
          return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
          controller._pulling = false;
          if (controller._pullAgain) {
            controller._pullAgain = false;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
        }, (e) => {
          ReadableStreamDefaultControllerError(controller, e);
        });
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return false;
        }
        if (!controller._started) {
          return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
          return true;
        }
        return false;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0;
        controller._cancelAlgorithm = void 0;
        controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
          ReadableStreamFulfillReadRequest(stream, chunk, false);
        } else {
          let chunkSize2;
          try {
            chunkSize2 = controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            ReadableStreamDefaultControllerError(controller, chunkSizeE);
            throw chunkSizeE;
          }
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize2);
          } catch (enqueueE) {
            ReadableStreamDefaultControllerError(controller, enqueueE);
            throw enqueueE;
          }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
      function ReadableStreamDefaultControllerError(controller, e) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== "readable") {
          return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === "errored") {
          return null;
        }
        if (state === "closed") {
          return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
          return false;
        }
        return true;
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === "readable") {
          return true;
        }
        return false;
      }
      function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = void 0;
        controller._queueTotalSize = void 0;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
          controller._started = true;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, (r) => {
          ReadableStreamDefaultControllerError(controller, r);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm = () => void 0;
        let pullAlgorithm = () => promiseResolvedWith(void 0);
        let cancelAlgorithm = () => promiseResolvedWith(void 0);
        if (underlyingSource.start !== void 0) {
          startAlgorithm = () => underlyingSource.start(controller);
        }
        if (underlyingSource.pull !== void 0) {
          pullAlgorithm = () => underlyingSource.pull(controller);
        }
        if (underlyingSource.cancel !== void 0) {
          cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name10) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name10} can only be used on a ReadableStreamDefaultController`);
      }
      function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
          return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
      }
      function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve11) => {
          resolveCancelPromise = resolve11;
        });
        function pullAlgorithm() {
          if (reading) {
            readAgain = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const readRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask2(() => {
                readAgain = false;
                const chunk1 = chunk;
                const chunk2 = chunk;
                if (!canceled1) {
                  ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgain) {
                  pullAlgorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableStreamDefaultControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerClose(branch2._readableStreamController);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r) => {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
          ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(void 0);
          }
        });
        return [branch1, branch2];
      }
      function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise((resolve11) => {
          resolveCancelPromise = resolve11;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, (r) => {
            if (thisReader !== reader) {
              return;
            }
            ReadableByteStreamControllerError(branch1._readableStreamController, r);
            ReadableByteStreamControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
        }
        function pullWithDefaultReader() {
          if (IsReadableStreamBYOBReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamDefaultReader(stream);
            forwardReaderError(reader);
          }
          const readRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask2(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const chunk1 = chunk;
                let chunk2 = chunk;
                if (!canceled1 && !canceled2) {
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                }
                if (!canceled1) {
                  ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: () => {
              reading = false;
              if (!canceled1) {
                ReadableByteStreamControllerClose(branch1._readableStreamController);
              }
              if (!canceled2) {
                ReadableByteStreamControllerClose(branch2._readableStreamController);
              }
              if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
              }
              if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
              }
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          if (IsReadableStreamDefaultReader(reader)) {
            ReadableStreamReaderGenericRelease(reader);
            reader = AcquireReadableStreamBYOBReader(stream);
            forwardReaderError(reader);
          }
          const byobBranch = forBranch2 ? branch2 : branch1;
          const otherBranch = forBranch2 ? branch1 : branch2;
          const readIntoRequest = {
            _chunkSteps: (chunk) => {
              queueMicrotask2(() => {
                readAgainForBranch1 = false;
                readAgainForBranch2 = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!otherCanceled) {
                  let clonedChunk;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                    ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                    resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                    return;
                  }
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                } else if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                reading = false;
                if (readAgainForBranch1) {
                  pull1Algorithm();
                } else if (readAgainForBranch2) {
                  pull2Algorithm();
                }
              });
            },
            _closeSteps: (chunk) => {
              reading = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!byobCanceled) {
                ReadableByteStreamControllerClose(byobBranch._readableStreamController);
              }
              if (!otherCanceled) {
                ReadableByteStreamControllerClose(otherBranch._readableStreamController);
              }
              if (chunk !== void 0) {
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                }
              }
              if (!byobCanceled || !otherCanceled) {
                resolveCancelPromise(void 0);
              }
            },
            _errorSteps: () => {
              reading = false;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading) {
            readAgainForBranch1 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, false);
          }
          return promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading) {
            readAgainForBranch2 = true;
            return promiseResolvedWith(void 0);
          }
          reading = true;
          const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          if (byobRequest === null) {
            pullWithDefaultReader();
          } else {
            pullWithBYOBReader(byobRequest._view, true);
          }
          return promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          canceled1 = true;
          reason1 = reason;
          if (canceled2) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          canceled2 = true;
          reason2 = reason;
          if (canceled1) {
            const compositeReason = CreateArrayFromList([reason1, reason2]);
            const cancelResult = ReadableStreamCancel(stream, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
          return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== "bytes") {
          throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== "byob") {
          throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== void 0) {
          assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal(signal)) {
          throw new TypeError(`${context} is not an AbortSignal.`);
        }
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair");
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, "writable", "ReadableWritablePair");
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
      }
      class ReadableStream {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
          if (rawUnderlyingSource === void 0) {
            rawUnderlyingSource = null;
          } else {
            assertObject(rawUnderlyingSource, "First parameter");
          }
          const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
          const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
          InitializeReadableStream(this);
          if (underlyingSource.type === "bytes") {
            if (strategy.size !== void 0) {
              throw new RangeError("The strategy for a byte stream cannot have a size function");
            }
            const highWaterMark = ExtractHighWaterMark(strategy, 0);
            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
          } else {
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
          }
        }
        get locked() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("locked");
          }
          return IsReadableStreamLocked(this);
        }
        cancel(reason = void 0) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
          }
          return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("getReader");
          }
          const options = convertReaderOptions(rawOptions, "First parameter");
          if (options.mode === void 0) {
            return AcquireReadableStreamDefaultReader(this);
          }
          return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("pipeThrough");
          }
          assertRequiredArgument(rawTransform, 1, "pipeThrough");
          const transform = convertReadableWritablePair(rawTransform, "First parameter");
          const options = convertPipeOptions(rawOptions, "Second parameter");
          if (IsReadableStreamLocked(this)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
          }
          if (IsWritableStreamLocked(transform.writable)) {
            throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
          }
          const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          setPromiseIsHandledToTrue(promise);
          return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
          if (!IsReadableStream(this)) {
            return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
          }
          if (destination === void 0) {
            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
          }
          if (!IsWritableStream(destination)) {
            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
          }
          let options;
          try {
            options = convertPipeOptions(rawOptions, "Second parameter");
          } catch (e) {
            return promiseRejectedWith(e);
          }
          if (IsReadableStreamLocked(this)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
          }
          if (IsWritableStreamLocked(destination)) {
            return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
          }
          return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        tee() {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("tee");
          }
          const branches = ReadableStreamTee(this);
          return CreateArrayFromList(branches);
        }
        values(rawOptions = void 0) {
          if (!IsReadableStream(this)) {
            throw streamBrandCheckException$1("values");
          }
          const options = convertIteratorOptions(rawOptions, "First parameter");
          return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
      }
      Object.defineProperties(ReadableStream.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
          value: "ReadableStream",
          configurable: true
        });
      }
      if (typeof SymbolPolyfill.asyncIterator === "symbol") {
        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
          value: ReadableStream.prototype.values,
          writable: true,
          configurable: true
        });
      }
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
        return stream;
      }
      function InitializeReadableStream(stream) {
        stream._state = "readable";
        stream._reader = void 0;
        stream._storedError = void 0;
        stream._disturbed = false;
      }
      function IsReadableStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
          return false;
        }
        return x instanceof ReadableStream;
      }
      function IsReadableStreamLocked(stream) {
        if (stream._reader === void 0) {
          return false;
        }
        return true;
      }
      function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === "closed") {
          return promiseResolvedWith(void 0);
        }
        if (stream._state === "errored") {
          return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
          reader._readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._closeSteps(void 0);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop2);
      }
      function ReadableStreamClose(stream) {
        stream._state = "closed";
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach((readRequest) => {
            readRequest._closeSteps();
          });
          reader._readRequests = new SimpleQueue();
        }
      }
      function ReadableStreamError(stream, e) {
        stream._state = "errored";
        stream._storedError = e;
        const reader = stream._reader;
        if (reader === void 0) {
          return;
        }
        defaultReaderClosedPromiseReject(reader, e);
        if (IsReadableStreamDefaultReader(reader)) {
          reader._readRequests.forEach((readRequest) => {
            readRequest._errorSteps(e);
          });
          reader._readRequests = new SimpleQueue();
        } else {
          reader._readIntoRequests.forEach((readIntoRequest) => {
            readIntoRequest._errorSteps(e);
          });
          reader._readIntoRequests = new SimpleQueue();
        }
      }
      function streamBrandCheckException$1(name10) {
        return new TypeError(`ReadableStream.prototype.${name10} can only be used on a ReadableStream`);
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
        return {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
      };
      try {
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
      } catch (_a) {
      }
      class ByteLengthQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        get highWaterMark() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("highWaterMark");
          }
          return this._byteLengthQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!IsByteLengthQueuingStrategy(this)) {
            throw byteLengthBrandCheckException("size");
          }
          return byteLengthSizeFunction;
        }
      }
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "ByteLengthQueuingStrategy",
          configurable: true
        });
      }
      function byteLengthBrandCheckException(name10) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name10} can only be used on a ByteLengthQueuingStrategy`);
      }
      function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x instanceof ByteLengthQueuingStrategy;
      }
      const countSizeFunction = () => {
        return 1;
      };
      try {
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
      } catch (_a) {
      }
      class CountQueuingStrategy {
        constructor(options) {
          assertRequiredArgument(options, 1, "CountQueuingStrategy");
          options = convertQueuingStrategyInit(options, "First parameter");
          this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        get highWaterMark() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("highWaterMark");
          }
          return this._countQueuingStrategyHighWaterMark;
        }
        get size() {
          if (!IsCountQueuingStrategy(this)) {
            throw countBrandCheckException("size");
          }
          return countSizeFunction;
        }
      }
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
          value: "CountQueuingStrategy",
          configurable: true
        });
      }
      function countBrandCheckException(name10) {
        return new TypeError(`CountQueuingStrategy.prototype.${name10} can only be used on a CountQueuingStrategy`);
      }
      function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
          return false;
        }
        return x instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        const flush3 = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
          flush: flush3 === void 0 ? void 0 : convertTransformerFlushCallback(flush3, original, `${context} has member 'flush' that`),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
      }
      function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
      }
      function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
      }
      class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
          if (rawTransformer === void 0) {
            rawTransformer = null;
          }
          const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
          const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
          const transformer = convertTransformer(rawTransformer, "First parameter");
          if (transformer.readableType !== void 0) {
            throw new RangeError("Invalid readableType specified");
          }
          if (transformer.writableType !== void 0) {
            throw new RangeError("Invalid writableType specified");
          }
          const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
          const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
          const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
          const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
          let startPromise_resolve;
          const startPromise = newPromise((resolve11) => {
            startPromise_resolve = resolve11;
          });
          InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
          if (transformer.start !== void 0) {
            startPromise_resolve(transformer.start(this._transformStreamController));
          } else {
            startPromise_resolve(void 0);
          }
        }
        get readable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("readable");
          }
          return this._readable;
        }
        get writable() {
          if (!IsTransformStream(this)) {
            throw streamBrandCheckException("writable");
          }
          return this._writable;
        }
      }
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStream",
          configurable: true
        });
      }
      function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
          TransformStreamErrorWritableAndUnblockWrite(stream, reason);
          return promiseResolvedWith(void 0);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        stream._backpressure = void 0;
        stream._backpressureChangePromise = void 0;
        stream._backpressureChangePromise_resolve = void 0;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = void 0;
      }
      function IsTransformStream(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
          return false;
        }
        return x instanceof TransformStream;
      }
      function TransformStreamError(stream, e) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
        if (stream._backpressure) {
          TransformStreamSetBackpressure(stream, false);
        }
      }
      function TransformStreamSetBackpressure(stream, backpressure) {
        if (stream._backpressureChangePromise !== void 0) {
          stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise((resolve11) => {
          stream._backpressureChangePromise_resolve = resolve11;
        });
        stream._backpressure = backpressure;
      }
      class TransformStreamDefaultController {
        constructor() {
          throw new TypeError("Illegal constructor");
        }
        get desiredSize() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("desiredSize");
          }
          const readableController = this._controlledTransformStream._readable._readableStreamController;
          return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("enqueue");
          }
          TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        error(reason = void 0) {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("error");
          }
          TransformStreamDefaultControllerError(this, reason);
        }
        terminate() {
          if (!IsTransformStreamDefaultController(this)) {
            throw defaultControllerBrandCheckException("terminate");
          }
          TransformStreamDefaultControllerTerminate(this);
        }
      }
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
      });
      if (typeof SymbolPolyfill.toStringTag === "symbol") {
        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
          value: "TransformStreamDefaultController",
          configurable: true
        });
      }
      function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
          return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
          return false;
        }
        return x instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm = (chunk) => {
          try {
            TransformStreamDefaultControllerEnqueue(controller, chunk);
            return promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        };
        let flushAlgorithm = () => promiseResolvedWith(void 0);
        if (transformer.transform !== void 0) {
          transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
        }
        if (transformer.flush !== void 0) {
          flushAlgorithm = () => transformer.flush(controller);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0;
        controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
          throw new TypeError("Readable side is not in a state that permits enqueue");
        }
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e) {
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
          throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
          TransformStreamSetBackpressure(stream, true);
        }
      }
      function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, (r) => {
          TransformStreamError(controller._controlledTransformStream, r);
          throw r;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
          const backpressureChangePromise = stream._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, () => {
            const writable = stream._writable;
            const state = writable._state;
            if (state === "erroring") {
              throw writable._storedError;
            }
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        TransformStreamError(stream, reason);
        return promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        const readable = stream._readable;
        const controller = stream._transformStreamController;
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        return transformPromiseWith(flushPromise, () => {
          if (readable._state === "errored") {
            throw readable._storedError;
          }
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, (r) => {
          TransformStreamError(stream, r);
          throw readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream) {
        TransformStreamSetBackpressure(stream, false);
        return stream._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name10) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name10} can only be used on a TransformStreamDefaultController`);
      }
      function streamBrandCheckException(name10) {
        return new TypeError(`TransformStream.prototype.${name10} can only be used on a TransformStream`);
      }
      exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
      exports3.CountQueuingStrategy = CountQueuingStrategy;
      exports3.ReadableByteStreamController = ReadableByteStreamController;
      exports3.ReadableStream = ReadableStream;
      exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
      exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
      exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
      exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
      exports3.TransformStream = TransformStream;
      exports3.TransformStreamDefaultController = TransformStreamDefaultController;
      exports3.WritableStream = WritableStream;
      exports3.WritableStreamDefaultController = WritableStreamDefaultController;
      exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// make-fetch/index.js
var require_make_fetch = __commonJS({
  "make-fetch/index.js"(exports2, module2) {
    init_globals();
    var Buffer2 = require_buffer2().Buffer;
    var Headers = require_headers();
    var getStatus = require_statuses();
    var bodyToIterator = require_fetch_request_body_to_async_iterator();
    var { TransformStream } = require_ponyfill_es6();
    module2.exports = function makeFetch(handler) {
      return async function fetch(resource, init = {}) {
        if (!resource)
          throw new Error("Must specify resource");
        if (typeof resource === "string") {
          return fetch({
            ...init || {},
            url: resource
          });
        }
        const {
          session,
          url,
          headers: rawHeaders,
          method: rawMethod,
          body: rawBody,
          referrer,
          signal
        } = resource;
        const headers = rawHeaders ? headersToObject(rawHeaders) : {};
        const method = (rawMethod || "GET").toUpperCase();
        const body = rawBody ? bodyToIterator(rawBody, session) : null;
        const {
          statusCode,
          statusText: rawStatusText,
          headers: rawResponseHeaders,
          data
        } = await handler({
          url,
          headers,
          method,
          body,
          referrer,
          signal
        });
        const responseHeaders = new Headers(rawResponseHeaders || {});
        const statusText = rawStatusText || getStatus(statusCode);
        return new FakeResponse(statusCode, statusText, responseHeaders, data, url);
      };
    };
    var FakeResponse = class {
      constructor(status, statusText, headers, iterator, url) {
        this.body = makeBody(iterator);
        this.headers = headers;
        this.url = url;
        this.status = status;
        this.statusText = statusText;
      }
      get ok() {
        return this.status && this.status < 400;
      }
      get useFinalURL() {
        return true;
      }
      async arrayBuffer() {
        const buffer3 = await collectBuffers(this.body);
        return buffer3.buffer;
      }
      async text() {
        const buffer3 = await collectBuffers(this.body);
        return buffer3.toString("utf-8");
      }
      async json() {
        return JSON.parse(await this.text());
      }
    };
    function makeBody(iterator) {
      const { readable, writable } = new TransformStream();
      (async () => {
        try {
          const writer = writable.getWriter();
          try {
            for await (const x of iterator)
              await writer.write(x);
          } finally {
            await writer.close();
          }
        } catch {
        }
      })();
      return readable;
    }
    function headersToObject(headers) {
      if (!headers)
        return {};
      if (typeof headers.entries === "function") {
        const result = {};
        for (const [key, value] of headers) {
          result[key] = value;
        }
        return result;
      } else
        return headersToObject(new Headers(headers || {}));
    }
    async function collectBuffers(iterable) {
      const all6 = [];
      for await (const buff of iterable) {
        all6.push(Buffer2.from(buff));
      }
      return Buffer2.concat(all6);
    }
  }
});

// js-ipfs-fetch/node_modules/range-parser/index.js
var require_range_parser = __commonJS({
  "js-ipfs-fetch/node_modules/range-parser/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = rangeParser;
    function rangeParser(size, str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var index = str.indexOf("=");
      if (index === -1) {
        return -2;
      }
      var arr = str.slice(index + 1).split(",");
      var ranges = [];
      ranges.type = str.slice(0, index);
      for (var i = 0; i < arr.length; i++) {
        var range = arr[i].split("-");
        var start = parseInt(range[0], 10);
        var end = parseInt(range[1], 10);
        if (isNaN(start)) {
          start = size - end;
          end = size - 1;
        } else if (isNaN(end)) {
          end = size - 1;
        }
        if (end > size - 1) {
          end = size - 1;
        }
        if (isNaN(start) || isNaN(end) || start > end || start < 0) {
          continue;
        }
        ranges.push({
          start,
          end
        });
      }
      if (ranges.length < 1) {
        return -1;
      }
      return options && options.combine ? combineRanges(ranges) : ranges;
    }
    function combineRanges(ranges) {
      var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
      for (var j = 0, i = 1; i < ordered.length; i++) {
        var range = ordered[i];
        var current = ordered[j];
        if (range.start > current.end + 1) {
          ordered[++j] = range;
        } else if (range.end > current.end) {
          current.end = range.end;
          current.index = Math.min(current.index, range.index);
        }
      }
      ordered.length = j + 1;
      var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
      combined.type = ranges.type;
      return combined;
    }
    function mapWithIndex(range, index) {
      return {
        start: range.start,
        end: range.end,
        index
      };
    }
    function mapWithoutIndex(range) {
      return {
        start: range.start,
        end: range.end
      };
    }
    function sortByRangeIndex(a, b) {
      return a.index - b.index;
    }
    function sortByRangeStart(a, b) {
      return a.start - b.start;
    }
  }
});

// js-ipfs-fetch/node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "js-ipfs-fetch/node_modules/mime/Mime.js"(exports2, module2) {
    "use strict";
    init_globals();
    function Mime() {
      this._types = /* @__PURE__ */ Object.create(null);
      this._extensions = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      let last15 = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last15.replace(/^.*\./, "").toLowerCase();
      let hasPath = last15.length < path.length;
      let hasDot = ext.length < last15.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module2.exports = Mime;
  }
});

// js-ipfs-fetch/node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "js-ipfs-fetch/node_modules/mime/types/standard.js"(exports2, module2) {
    init_globals();
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// js-ipfs-fetch/node_modules/mime/lite.js
var require_lite = __commonJS({
  "js-ipfs-fetch/node_modules/mime/lite.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Mime = require_Mime();
    module2.exports = new Mime(require_standard());
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/vendor/varint.js
function encode15(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT2) {
    out[offset++] = num & 255 | MSB2;
    num /= 128;
  }
  while (num & MSBALL2) {
    out[offset++] = num & 255 | MSB2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode15.bytes = offset - oldOffset + 1;
  return out;
}
function read2(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$12);
  read2.bytes = counter - offset;
  return res;
}
var encode_12, MSB2, REST2, MSBALL2, INT2, decode15, MSB$12, REST$12, N12, N22, N32, N42, N52, N62, N72, N82, N92, length4, varint6, _brrp_varint2, varint_default2;
var init_varint3 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/vendor/varint.js"() {
    init_globals();
    encode_12 = encode15;
    MSB2 = 128;
    REST2 = 127;
    MSBALL2 = ~REST2;
    INT2 = Math.pow(2, 31);
    decode15 = read2;
    MSB$12 = 128;
    REST$12 = 127;
    N12 = Math.pow(2, 7);
    N22 = Math.pow(2, 14);
    N32 = Math.pow(2, 21);
    N42 = Math.pow(2, 28);
    N52 = Math.pow(2, 35);
    N62 = Math.pow(2, 42);
    N72 = Math.pow(2, 49);
    N82 = Math.pow(2, 56);
    N92 = Math.pow(2, 63);
    length4 = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
    varint6 = {
      encode: encode_12,
      decode: decode15,
      encodingLength: length4
    };
    _brrp_varint2 = varint6;
    varint_default2 = _brrp_varint2;
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/varint.js
var decode16, encodeTo2, encodingLength2;
var init_varint4 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/varint.js"() {
    init_globals();
    init_varint3();
    decode16 = (data) => {
      const code13 = varint_default2.decode(data);
      return [
        code13,
        varint_default2.decode.bytes
      ];
    };
    encodeTo2 = (int, target, offset = 0) => {
      varint_default2.encode(int, target, offset);
      return target;
    };
    encodingLength2 = (int) => {
      return varint_default2.encodingLength(int);
    };
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/bytes.js
var bytes_exports3 = {};
__export(bytes_exports3, {
  coerce: () => coerce2,
  empty: () => empty2,
  equals: () => equals4,
  fromHex: () => fromHex2,
  fromString: () => fromString4,
  isBinary: () => isBinary2,
  toHex: () => toHex2,
  toString: () => toString4
});
var empty2, toHex2, fromHex2, equals4, coerce2, isBinary2, fromString4, toString4;
var init_bytes3 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/bytes.js"() {
    init_globals();
    empty2 = new Uint8Array(0);
    toHex2 = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
    fromHex2 = (hex) => {
      const hexes = hex.match(/../g);
      return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty2;
    };
    equals4 = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce2 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    isBinary2 = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
    fromString4 = (str) => new TextEncoder().encode(str);
    toString4 = (b) => new TextDecoder().decode(b);
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/hashes/digest.js
var create8, decode17, equals5, Digest2;
var init_digest2 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_globals();
    init_bytes3();
    init_varint4();
    create8 = (code13, digest3) => {
      const size = digest3.byteLength;
      const sizeOffset = encodingLength2(code13);
      const digestOffset = sizeOffset + encodingLength2(size);
      const bytes2 = new Uint8Array(digestOffset + size);
      encodeTo2(code13, bytes2, 0);
      encodeTo2(size, bytes2, sizeOffset);
      bytes2.set(digest3, digestOffset);
      return new Digest2(code13, size, digest3, bytes2);
    };
    decode17 = (multihash) => {
      const bytes2 = coerce2(multihash);
      const [code13, sizeOffset] = decode16(bytes2);
      const [size, digestOffset] = decode16(bytes2.subarray(sizeOffset));
      const digest3 = bytes2.subarray(sizeOffset + digestOffset);
      if (digest3.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest2(code13, size, digest3, bytes2);
    };
    equals5 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && equals4(a.bytes, b.bytes);
      }
    };
    Digest2 = class {
      constructor(code13, size, digest3, bytes2) {
        this.code = code13;
        this.size = size;
        this.digest = digest3;
        this.bytes = bytes2;
      }
    };
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/vendor/base-x.js
function base3(ALPHABET, name10) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode19(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length5 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length5) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      pbegin++;
    }
    var it2 = size - length5;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length5 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length5) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length5 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length5;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode22(string3) {
    var buffer3 = decodeUnsafe(string3);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name10} character`);
  }
  return {
    encode: encode19,
    decodeUnsafe,
    decode: decode22
  };
}
var src2, _brrp__multiformats_scope_baseX2, base_x_default2;
var init_base_x2 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/vendor/base-x.js"() {
    init_globals();
    src2 = base3;
    _brrp__multiformats_scope_baseX2 = src2;
    base_x_default2 = _brrp__multiformats_scope_baseX2;
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base.js
var Encoder2, Decoder2, ComposedDecoder2, or2, Codec2, from3, baseX2, decode18, encode16, rfc46482;
var init_base4 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base.js"() {
    init_globals();
    init_base_x2();
    init_bytes3();
    Encoder2 = class {
      constructor(name10, prefix, baseEncode) {
        this.name = name10;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder2 = class {
      constructor(name10, prefix, baseDecode) {
        this.name = name10;
        this.prefix = prefix;
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          switch (text[0]) {
            case this.prefix: {
              return this.baseDecode(text.slice(1));
            }
            default: {
              throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
          }
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or2(this, decoder);
      }
    };
    ComposedDecoder2 = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or2(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    or2 = (left, right) => new ComposedDecoder2({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    Codec2 = class {
      constructor(name10, prefix, baseEncode, baseDecode) {
        this.name = name10;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder2(name10, prefix, baseEncode);
        this.decoder = new Decoder2(name10, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    from3 = ({ name: name10, prefix, encode: encode19, decode: decode22 }) => new Codec2(name10, prefix, encode19, decode22);
    baseX2 = ({ prefix, name: name10, alphabet }) => {
      const { encode: encode19, decode: decode22 } = base_x_default2(alphabet, name10);
      return from3({
        prefix,
        name: name10,
        encode: encode19,
        decode: (text) => coerce2(decode22(text))
      });
    };
    decode18 = (string3, alphabet, bitsPerChar, name10) => {
      const codes = {};
      for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
      }
      let end = string3.length;
      while (string3[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer3 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string3[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name10} character`);
        }
        buffer3 = buffer3 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer3 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer3 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode16 = (data, alphabet, bitsPerChar) => {
      const pad = alphabet[alphabet.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer3 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer3 = buffer3 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask & buffer3 >> bits];
        }
      }
      if (bits) {
        out += alphabet[mask & buffer3 << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc46482 = ({ name: name10, prefix, bitsPerChar, alphabet }) => {
      return from3({
        prefix,
        name: name10,
        encode(input) {
          return encode16(input, alphabet, bitsPerChar);
        },
        decode(input) {
          return decode18(input, alphabet, bitsPerChar, name10);
        }
      });
    };
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base58.js
var base58_exports2 = {};
__export(base58_exports2, {
  base58btc: () => base58btc2,
  base58flickr: () => base58flickr2
});
var base58btc2, base58flickr2;
var init_base582 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base58.js"() {
    init_globals();
    init_base4();
    base58btc2 = baseX2({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr2 = baseX2({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base32.js
var base32_exports2 = {};
__export(base32_exports2, {
  base32: () => base322,
  base32hex: () => base32hex2,
  base32hexpad: () => base32hexpad2,
  base32hexpadupper: () => base32hexpadupper2,
  base32hexupper: () => base32hexupper2,
  base32pad: () => base32pad2,
  base32padupper: () => base32padupper2,
  base32upper: () => base32upper2,
  base32z: () => base32z2
});
var base322, base32upper2, base32pad2, base32padupper2, base32hex2, base32hexupper2, base32hexpad2, base32hexpadupper2, base32z2;
var init_base322 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base32.js"() {
    init_globals();
    init_base4();
    base322 = rfc46482({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper2 = rfc46482({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad2 = rfc46482({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper2 = rfc46482({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex2 = rfc46482({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper2 = rfc46482({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad2 = rfc46482({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper2 = rfc46482({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z2 = rfc46482({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/cid.js
var cid_exports2 = {};
__export(cid_exports2, {
  CID: () => CID2
});
var CID2, parseCIDtoBytes2, toStringV02, toStringV12, DAG_PB_CODE2, SHA_256_CODE2, encodeCID3, cidSymbol2, readonly3, hidden2, version3, deprecate2, IS_CID_DEPRECATION2;
var init_cid2 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/cid.js"() {
    init_globals();
    init_varint4();
    init_digest2();
    init_base582();
    init_base322();
    init_bytes3();
    CID2 = class {
      constructor(version4, code13, multihash, bytes2) {
        this.code = code13;
        this.version = version4;
        this.multihash = multihash;
        this.bytes = bytes2;
        this.byteOffset = bytes2.byteOffset;
        this.byteLength = bytes2.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden2,
          byteLength: hidden2,
          code: readonly3,
          version: readonly3,
          multihash: readonly3,
          bytes: readonly3,
          _baseCache: hidden2,
          asCID: hidden2
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code13, multihash } = this;
            if (code13 !== DAG_PB_CODE2) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE2) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID2.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code13, digest: digest3 } = this.multihash;
            const multihash = create8(code13, digest3);
            return CID2.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals5(this.multihash, other.multihash);
      }
      toString(base4) {
        const { bytes: bytes2, version: version4, _baseCache } = this;
        switch (version4) {
          case 0:
            return toStringV02(bytes2, _baseCache, base4 || base58btc2.encoder);
          default:
            return toStringV12(bytes2, _baseCache, base4 || base322.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate2(/^0\.0/, IS_CID_DEPRECATION2);
        return !!(value && (value[cidSymbol2] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID2) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version4, code: code13, multihash, bytes: bytes2 } = value;
          return new CID2(version4, code13, multihash, bytes2 || encodeCID3(version4, code13, multihash.bytes));
        } else if (value != null && value[cidSymbol2] === true) {
          const { version: version4, multihash, code: code13 } = value;
          const digest3 = decode17(multihash);
          return CID2.create(version4, code13, digest3);
        } else {
          return null;
        }
      }
      static create(version4, code13, digest3) {
        if (typeof code13 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version4) {
          case 0: {
            if (code13 !== DAG_PB_CODE2) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
            } else {
              return new CID2(version4, code13, digest3, digest3.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID3(version4, code13, digest3.bytes);
            return new CID2(version4, code13, digest3, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest3) {
        return CID2.create(0, DAG_PB_CODE2, digest3);
      }
      static createV1(code13, digest3) {
        return CID2.create(1, code13, digest3);
      }
      static decode(bytes2) {
        const [cid, remainder] = CID2.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes2) {
        const specs = CID2.inspectBytes(bytes2);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce2(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest3 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID2.createV0(digest3) : CID2.createV1(specs.codec, digest3);
        return [
          cid,
          bytes2.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length5] = decode16(initialBytes.subarray(offset));
          offset += length5;
          return i;
        };
        let version4 = next();
        let codec = DAG_PB_CODE2;
        if (version4 === 18) {
          version4 = 0;
          offset = 0;
        } else if (version4 === 1) {
          codec = next();
        }
        if (version4 !== 0 && version4 !== 1) {
          throw new RangeError(`Invalid CID version ${version4}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version4,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base4) {
        const [prefix, bytes2] = parseCIDtoBytes2(source, base4);
        const cid = CID2.decode(bytes2);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    parseCIDtoBytes2 = (source, base4) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base4 || base58btc2;
          return [
            base58btc2.prefix,
            decoder.decode(`${base58btc2.prefix}${source}`)
          ];
        }
        case base58btc2.prefix: {
          const decoder = base4 || base58btc2;
          return [
            base58btc2.prefix,
            decoder.decode(source)
          ];
        }
        case base322.prefix: {
          const decoder = base4 || base322;
          return [
            base322.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base4 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base4.decode(source)
          ];
        }
      }
    };
    toStringV02 = (bytes2, cache2, base4) => {
      const { prefix } = base4;
      if (prefix !== base58btc2.prefix) {
        throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
      }
      const cid = cache2.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes2).slice(1);
        cache2.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV12 = (bytes2, cache2, base4) => {
      const { prefix } = base4;
      const cid = cache2.get(prefix);
      if (cid == null) {
        const cid2 = base4.encode(bytes2);
        cache2.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE2 = 112;
    SHA_256_CODE2 = 18;
    encodeCID3 = (version4, code13, multihash) => {
      const codeOffset = encodingLength2(version4);
      const hashOffset = codeOffset + encodingLength2(code13);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo2(version4, bytes2, 0);
      encodeTo2(code13, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
    readonly3 = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden2 = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version3 = "0.0.0-dev";
    deprecate2 = (range, message) => {
      if (range.test(version3)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    IS_CID_DEPRECATION2 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});

// js-ipfs-fetch/node_modules/err-code/index.js
var require_err_code3 = __commonJS({
  "js-ipfs-fetch/node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code13, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code13 === "object") {
        props = code13;
        code13 = "";
      }
      if (code13) {
        props.code = code13;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// js-ipfs-fetch/node_modules/@ipld/dag-pb/esm/src/pb-decode.js
function decodeVarint2(bytes2, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes2[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [
    v,
    offset
  ];
}
function decodeBytes3(bytes2, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint2(bytes2, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes2.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey2(bytes2, index) {
  let wire;
  [wire, index] = decodeVarint2(bytes2, index);
  return [
    wire & 7,
    wire >> 3,
    index
  ];
}
function decodeLink2(bytes2) {
  const link = {};
  const l = bytes2.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey2(bytes2, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      ;
      [link.Hash, index] = decodeBytes3(bytes2, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes3(bytes2, index);
      link.Name = textDecoder4.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      ;
      [link.Tsize, index] = decodeVarint2(bytes2, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode2(bytes2) {
  const l = bytes2.length;
  let index = 0;
  let links3;
  let linksBeforeData = false;
  let data;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey2(bytes2, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      ;
      [data, index] = decodeBytes3(bytes2, index);
      if (links3) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links3) {
        links3 = [];
      }
      let byts;
      [byts, index] = decodeBytes3(bytes2, index);
      links3.push(decodeLink2(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links3 || [];
  return node;
}
var textDecoder4;
var init_pb_decode = __esm({
  "js-ipfs-fetch/node_modules/@ipld/dag-pb/esm/src/pb-decode.js"() {
    init_globals();
    textDecoder4 = new TextDecoder();
  }
});

// js-ipfs-fetch/node_modules/@ipld/dag-pb/esm/src/pb-encode.js
var textEncoder5, maxInt322, maxUInt322;
var init_pb_encode = __esm({
  "js-ipfs-fetch/node_modules/@ipld/dag-pb/esm/src/pb-encode.js"() {
    init_globals();
    textEncoder5 = new TextEncoder();
    maxInt322 = 2 ** 32;
    maxUInt322 = 2 ** 31;
  }
});

// js-ipfs-fetch/node_modules/@ipld/dag-pb/esm/src/util.js
var textEncoder6;
var init_util = __esm({
  "js-ipfs-fetch/node_modules/@ipld/dag-pb/esm/src/util.js"() {
    init_globals();
    init_cid2();
    textEncoder6 = new TextEncoder();
  }
});

// js-ipfs-fetch/node_modules/@ipld/dag-pb/esm/src/index.js
function decode19(bytes2) {
  const pbn = decodeNode2(bytes2);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID2.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}
var code9;
var init_src5 = __esm({
  "js-ipfs-fetch/node_modules/@ipld/dag-pb/esm/src/index.js"() {
    init_globals();
    init_cid2();
    init_pb_decode();
    init_pb_encode();
    init_util();
    code9 = 112;
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/is.js
function is2(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf2 = typeof value;
  if (typeofs2.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer3(value)) {
    return "Buffer";
  }
  const objectType = getObjectType2(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer3(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType2(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames2.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
var typeofs2, objectTypeNames2;
var init_is2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/is.js"() {
    init_globals();
    typeofs2 = [
      "string",
      "number",
      "bigint",
      "symbol"
    ];
    objectTypeNames2 = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/token.js
var Type2, Token2;
var init_token2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/token.js"() {
    init_globals();
    Type2 = class {
      constructor(major, name10, terminal) {
        this.major = major;
        this.majorEncoded = major << 5;
        this.name = name10;
        this.terminal = terminal;
      }
      toString() {
        return `Type[${this.major}].${this.name}`;
      }
      compare(typ) {
        return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
      }
    };
    Type2.uint = new Type2(0, "uint", true);
    Type2.negint = new Type2(1, "negint", true);
    Type2.bytes = new Type2(2, "bytes", true);
    Type2.string = new Type2(3, "string", true);
    Type2.array = new Type2(4, "array", false);
    Type2.map = new Type2(5, "map", false);
    Type2.tag = new Type2(6, "tag", false);
    Type2.float = new Type2(7, "float", true);
    Type2.false = new Type2(7, "false", true);
    Type2.true = new Type2(7, "true", true);
    Type2.null = new Type2(7, "null", true);
    Type2.undefined = new Type2(7, "undefined", true);
    Type2.break = new Type2(7, "break", true);
    Token2 = class {
      constructor(type, value, encodedLength) {
        this.type = type;
        this.value = value;
        this.encodedLength = encodedLength;
        this.encodedBytes = void 0;
        this.byteValue = void 0;
      }
      toString() {
        return `Token[${this.type}].${this.value}`;
      }
    };
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/byte-utils.js
function isBuffer4(buf3) {
  return useBuffer2 && globalThis.Buffer.isBuffer(buf3);
}
function asU8A2(buf3) {
  if (!(buf3 instanceof Uint8Array)) {
    return Uint8Array.from(buf3);
  }
  return isBuffer4(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
}
function compare3(b1, b2) {
  if (isBuffer4(b1) && isBuffer4(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes2(string3, units = Infinity) {
  let codePoint;
  const length5 = string3.length;
  let leadSurrogate = null;
  const bytes2 = [];
  for (let i = 0; i < length5; ++i) {
    codePoint = string3.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i + 1 === length5) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function utf8Slice2(buf3, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf3[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf3[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          fourthByte = buf3[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
function decodeCodePointsArray2(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2));
  }
  return res;
}
var useBuffer2, textDecoder5, textEncoder7, toString5, fromString5, slice2, concat3, alloc2, MAX_ARGUMENTS_LENGTH2;
var init_byte_utils2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/byte-utils.js"() {
    init_globals();
    useBuffer2 = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
    textDecoder5 = new TextDecoder();
    textEncoder7 = new TextEncoder();
    toString5 = useBuffer2 ? (bytes2, start, end) => {
      return end - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end)).toString("utf8") : utf8Slice2(bytes2, start, end);
    } : (bytes2, start, end) => {
      return end - start > 64 ? textDecoder5.decode(bytes2.subarray(start, end)) : utf8Slice2(bytes2, start, end);
    };
    fromString5 = useBuffer2 ? (string3) => {
      return string3.length > 64 ? globalThis.Buffer.from(string3) : utf8ToBytes2(string3);
    } : (string3) => {
      return string3.length > 64 ? textEncoder7.encode(string3) : utf8ToBytes2(string3);
    };
    slice2 = useBuffer2 ? (bytes2, start, end) => {
      if (isBuffer4(bytes2)) {
        return new Uint8Array(bytes2.subarray(start, end));
      }
      return bytes2.slice(start, end);
    } : (bytes2, start, end) => {
      return bytes2.slice(start, end);
    };
    concat3 = useBuffer2 ? (chunks, length5) => {
      chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
      return asU8A2(globalThis.Buffer.concat(chunks, length5));
    } : (chunks, length5) => {
      const out = new Uint8Array(length5);
      let off = 0;
      for (let b of chunks) {
        if (off + b.length > out.length) {
          b = b.subarray(0, out.length - off);
        }
        out.set(b, off);
        off += b.length;
      }
      return out;
    };
    alloc2 = useBuffer2 ? (size) => {
      return globalThis.Buffer.allocUnsafe(size);
    } : (size) => {
      return new Uint8Array(size);
    };
    MAX_ARGUMENTS_LENGTH2 = 4096;
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/bl.js
var defaultChunkSize2, Bl2;
var init_bl2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/bl.js"() {
    init_globals();
    init_byte_utils2();
    defaultChunkSize2 = 256;
    Bl2 = class {
      constructor(chunkSize2 = defaultChunkSize2) {
        this.chunkSize = chunkSize2;
        this.cursor = 0;
        this.maxCursor = -1;
        this.chunks = [];
        this._initReuseChunk = null;
      }
      reset() {
        this.cursor = 0;
        this.maxCursor = -1;
        if (this.chunks.length) {
          this.chunks = [];
        }
        if (this._initReuseChunk !== null) {
          this.chunks.push(this._initReuseChunk);
          this.maxCursor = this._initReuseChunk.length - 1;
        }
      }
      push(bytes2) {
        let topChunk = this.chunks[this.chunks.length - 1];
        const newMax = this.cursor + bytes2.length;
        if (newMax <= this.maxCursor + 1) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          topChunk.set(bytes2, chunkPos);
        } else {
          if (topChunk) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            if (chunkPos < topChunk.length) {
              this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
              this.maxCursor = this.cursor - 1;
            }
          }
          if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
            topChunk = alloc2(this.chunkSize);
            this.chunks.push(topChunk);
            this.maxCursor += topChunk.length;
            if (this._initReuseChunk === null) {
              this._initReuseChunk = topChunk;
            }
            topChunk.set(bytes2, 0);
          } else {
            this.chunks.push(bytes2);
            this.maxCursor += bytes2.length;
          }
        }
        this.cursor += bytes2.length;
      }
      toBytes(reset = false) {
        let byts;
        if (this.chunks.length === 1) {
          const chunk = this.chunks[0];
          if (reset && this.cursor > chunk.length / 2) {
            byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
            this._initReuseChunk = null;
            this.chunks = [];
          } else {
            byts = slice2(chunk, 0, this.cursor);
          }
        } else {
          byts = concat3(this.chunks, this.cursor);
        }
        if (reset) {
          this.reset();
        }
        return byts;
      }
    };
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/common.js
function assertEnoughData2(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix2} not enough data for type`);
  }
}
var decodeErrPrefix2, encodeErrPrefix2, uintMinorPrefixBytes2;
var init_common2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/common.js"() {
    init_globals();
    decodeErrPrefix2 = "CBOR decode error:";
    encodeErrPrefix2 = "CBOR encode error:";
    uintMinorPrefixBytes2 = [];
    uintMinorPrefixBytes2[23] = 1;
    uintMinorPrefixBytes2[24] = 2;
    uintMinorPrefixBytes2[25] = 3;
    uintMinorPrefixBytes2[26] = 5;
    uintMinorPrefixBytes2[27] = 9;
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/0uint.js
function readUint82(data, offset, options) {
  assertEnoughData2(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries2[0]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint162(data, offset, options) {
  assertEnoughData2(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries2[1]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint322(data, offset, options) {
  assertEnoughData2(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries2[2]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint642(data, offset, options) {
  assertEnoughData2(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries2[3]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
}
function decodeUint82(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint82(data, pos + 1, options), 2);
}
function decodeUint162(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint162(data, pos + 1, options), 3);
}
function decodeUint322(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint322(data, pos + 1, options), 5);
}
function decodeUint642(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint642(data, pos + 1, options), 9);
}
function encodeUint2(buf3, token) {
  return encodeUintValue2(buf3, 0, token.value);
}
function encodeUintValue2(buf3, major, uint) {
  if (uint < uintBoundaries2[0]) {
    const nuint = Number(uint);
    buf3.push([major | nuint]);
  } else if (uint < uintBoundaries2[1]) {
    const nuint = Number(uint);
    buf3.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries2[2]) {
    const nuint = Number(uint);
    buf3.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries2[3]) {
    const nuint = Number(uint);
    buf3.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries2[4]) {
      const set2 = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set2[8] = lo & 255;
      lo = lo >> 8;
      set2[7] = lo & 255;
      lo = lo >> 8;
      set2[6] = lo & 255;
      lo = lo >> 8;
      set2[5] = lo & 255;
      set2[4] = hi & 255;
      hi = hi >> 8;
      set2[3] = hi & 255;
      hi = hi >> 8;
      set2[2] = hi & 255;
      hi = hi >> 8;
      set2[1] = hi & 255;
      buf3.push(set2);
    } else {
      throw new Error(`${decodeErrPrefix2} encountered BigInt larger than allowable range`);
    }
  }
}
var uintBoundaries2;
var init_uint2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/0uint.js"() {
    init_globals();
    init_token2();
    init_common2();
    uintBoundaries2 = [
      24,
      256,
      65536,
      4294967296,
      BigInt("18446744073709551616")
    ];
    encodeUint2.encodedSize = function encodedSize9(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
    encodeUintValue2.encodedSize = function encodedSize10(uint) {
      if (uint < uintBoundaries2[0]) {
        return 1;
      }
      if (uint < uintBoundaries2[1]) {
        return 2;
      }
      if (uint < uintBoundaries2[2]) {
        return 3;
      }
      if (uint < uintBoundaries2[3]) {
        return 5;
      }
      return 9;
    };
    encodeUint2.compareTokens = function compareTokens4(tok1, tok2) {
      return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
    };
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/1negint.js
function decodeNegint82(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint82(data, pos + 1, options), 2);
}
function decodeNegint162(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint162(data, pos + 1, options), 3);
}
function decodeNegint322(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint322(data, pos + 1, options), 5);
}
function decodeNegint642(data, pos, _minor, options) {
  const int = readUint642(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token2(Type2.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
  }
  return new Token2(Type2.negint, neg1b2 - BigInt(int), 9);
}
function encodeNegint2(buf3, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
  encodeUintValue2(buf3, token.type.majorEncoded, unsigned);
}
var neg1b2, pos1b2;
var init_negint2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/1negint.js"() {
    init_globals();
    init_token2();
    init_uint2();
    init_common2();
    neg1b2 = BigInt(-1);
    pos1b2 = BigInt(1);
    encodeNegint2.encodedSize = function encodedSize11(token) {
      const negint = token.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
      if (unsigned < uintBoundaries2[0]) {
        return 1;
      }
      if (unsigned < uintBoundaries2[1]) {
        return 2;
      }
      if (unsigned < uintBoundaries2[2]) {
        return 3;
      }
      if (unsigned < uintBoundaries2[3]) {
        return 5;
      }
      return 9;
    };
    encodeNegint2.compareTokens = function compareTokens5(tok1, tok2) {
      return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
    };
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/2bytes.js
function toToken5(data, pos, prefix, length5) {
  assertEnoughData2(data, pos, prefix + length5);
  const buf3 = slice2(data, pos + prefix, pos + prefix + length5);
  return new Token2(Type2.bytes, buf3, prefix + length5);
}
function decodeBytesCompact2(data, pos, minor, _options) {
  return toToken5(data, pos, 1, minor);
}
function decodeBytes82(data, pos, _minor, options) {
  return toToken5(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeBytes162(data, pos, _minor, options) {
  return toToken5(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeBytes322(data, pos, _minor, options) {
  return toToken5(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeBytes642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer bytes lengths not supported`);
  }
  return toToken5(data, pos, 9, l);
}
function tokenBytes2(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type2.string ? fromString5(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes3(buf3, token) {
  const bytes2 = tokenBytes2(token);
  encodeUintValue2(buf3, token.type.majorEncoded, bytes2.length);
  buf3.push(bytes2);
}
function compareBytes2(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare3(b1, b2);
}
var init_bytes4 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/2bytes.js"() {
    init_globals();
    init_token2();
    init_common2();
    init_uint2();
    init_byte_utils2();
    encodeBytes3.encodedSize = function encodedSize12(token) {
      const bytes2 = tokenBytes2(token);
      return encodeUintValue2.encodedSize(bytes2.length) + bytes2.length;
    };
    encodeBytes3.compareTokens = function compareTokens6(tok1, tok2) {
      return compareBytes2(tokenBytes2(tok1), tokenBytes2(tok2));
    };
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/3string.js
function toToken6(data, pos, prefix, length5, options) {
  const totLength = prefix + length5;
  assertEnoughData2(data, pos, totLength);
  const tok = new Token2(Type2.string, toString5(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice2(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact2(data, pos, minor, options) {
  return toToken6(data, pos, 1, minor, options);
}
function decodeString82(data, pos, _minor, options) {
  return toToken6(data, pos, 2, readUint82(data, pos + 1, options), options);
}
function decodeString162(data, pos, _minor, options) {
  return toToken6(data, pos, 3, readUint162(data, pos + 1, options), options);
}
function decodeString322(data, pos, _minor, options) {
  return toToken6(data, pos, 5, readUint322(data, pos + 1, options), options);
}
function decodeString642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer string lengths not supported`);
  }
  return toToken6(data, pos, 9, l, options);
}
var encodeString2;
var init_string2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/3string.js"() {
    init_globals();
    init_token2();
    init_common2();
    init_uint2();
    init_bytes4();
    init_byte_utils2();
    encodeString2 = encodeBytes3;
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/4array.js
function toToken7(_data, _pos, prefix, length5) {
  return new Token2(Type2.array, length5, prefix);
}
function decodeArrayCompact2(data, pos, minor, _options) {
  return toToken7(data, pos, 1, minor);
}
function decodeArray82(data, pos, _minor, options) {
  return toToken7(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeArray162(data, pos, _minor, options) {
  return toToken7(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeArray322(data, pos, _minor, options) {
  return toToken7(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeArray642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer array lengths not supported`);
  }
  return toToken7(data, pos, 9, l);
}
function decodeArrayIndefinite2(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken7(data, pos, 1, Infinity);
}
function encodeArray2(buf3, token) {
  encodeUintValue2(buf3, Type2.array.majorEncoded, token.value);
}
var init_array2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/4array.js"() {
    init_globals();
    init_token2();
    init_uint2();
    init_common2();
    encodeArray2.compareTokens = encodeUint2.compareTokens;
    encodeArray2.encodedSize = function encodedSize13(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/5map.js
function toToken8(_data, _pos, prefix, length5) {
  return new Token2(Type2.map, length5, prefix);
}
function decodeMapCompact2(data, pos, minor, _options) {
  return toToken8(data, pos, 1, minor);
}
function decodeMap82(data, pos, _minor, options) {
  return toToken8(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeMap162(data, pos, _minor, options) {
  return toToken8(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeMap322(data, pos, _minor, options) {
  return toToken8(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeMap642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer map lengths not supported`);
  }
  return toToken8(data, pos, 9, l);
}
function decodeMapIndefinite2(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken8(data, pos, 1, Infinity);
}
function encodeMap2(buf3, token) {
  encodeUintValue2(buf3, Type2.map.majorEncoded, token.value);
}
var init_map2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/5map.js"() {
    init_globals();
    init_token2();
    init_uint2();
    init_common2();
    encodeMap2.compareTokens = encodeUint2.compareTokens;
    encodeMap2.encodedSize = function encodedSize14(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact2(_data, _pos, minor, _options) {
  return new Token2(Type2.tag, minor, 1);
}
function decodeTag82(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint82(data, pos + 1, options), 2);
}
function decodeTag162(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint162(data, pos + 1, options), 3);
}
function decodeTag322(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint322(data, pos + 1, options), 5);
}
function decodeTag642(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint642(data, pos + 1, options), 9);
}
function encodeTag2(buf3, token) {
  encodeUintValue2(buf3, Type2.tag.majorEncoded, token.value);
}
var init_tag2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/6tag.js"() {
    init_globals();
    init_token2();
    init_uint2();
    encodeTag2.compareTokens = encodeUint2.compareTokens;
    encodeTag2.encodedSize = function encodedSize15(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/7float.js
function decodeUndefined2(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix2} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token2(Type2.null, null, 1);
  }
  return new Token2(Type2.undefined, void 0, 1);
}
function decodeBreak2(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return new Token2(Type2.break, void 0, 1);
}
function createToken2(value, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix2} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix2} Infinity values are not supported`);
    }
  }
  return new Token2(Type2.float, value, bytes2);
}
function decodeFloat162(data, pos, _minor, options) {
  return createToken2(readFloat162(data, pos + 1), 3, options);
}
function decodeFloat322(data, pos, _minor, options) {
  return createToken2(readFloat322(data, pos + 1), 5, options);
}
function decodeFloat642(data, pos, _minor, options) {
  return createToken2(readFloat642(data, pos + 1), 9, options);
}
function encodeFloat2(buf3, token, options) {
  const float = token.value;
  if (float === false) {
    buf3.push([Type2.float.majorEncoded | MINOR_FALSE2]);
  } else if (float === true) {
    buf3.push([Type2.float.majorEncoded | MINOR_TRUE2]);
  } else if (float === null) {
    buf3.push([Type2.float.majorEncoded | MINOR_NULL2]);
  } else if (float === void 0) {
    buf3.push([Type2.float.majorEncoded | MINOR_UNDEFINED2]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat162(float);
      decoded = readFloat162(ui8a2, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a2[0] = 249;
        buf3.push(ui8a2.slice(0, 3));
        success = true;
      } else {
        encodeFloat322(float);
        decoded = readFloat322(ui8a2, 1);
        if (float === decoded) {
          ui8a2[0] = 250;
          buf3.push(ui8a2.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat642(float);
      decoded = readFloat642(ui8a2, 1);
      ui8a2[0] = 251;
      buf3.push(ui8a2.slice(0, 9));
    }
  }
}
function encodeFloat162(inp) {
  if (inp === Infinity) {
    dataView2.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView2.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView2.setUint16(0, 32256, false);
  } else {
    dataView2.setFloat32(0, inp);
    const valu32 = dataView2.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView2.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView2.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView2.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat162(ui8a3, pos) {
  if (ui8a3.length - pos < 2) {
    throw new Error(`${decodeErrPrefix2} not enough data for float16`);
  }
  const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat322(inp) {
  dataView2.setFloat32(0, inp, false);
}
function readFloat322(ui8a3, pos) {
  if (ui8a3.length - pos < 4) {
    throw new Error(`${decodeErrPrefix2} not enough data for float32`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat642(inp) {
  dataView2.setFloat64(0, inp, false);
}
function readFloat642(ui8a3, pos) {
  if (ui8a3.length - pos < 8) {
    throw new Error(`${decodeErrPrefix2} not enough data for float64`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 8).getFloat64(0, false);
}
var MINOR_FALSE2, MINOR_TRUE2, MINOR_NULL2, MINOR_UNDEFINED2, buffer2, dataView2, ui8a2;
var init_float2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/7float.js"() {
    init_globals();
    init_token2();
    init_common2();
    init_uint2();
    MINOR_FALSE2 = 20;
    MINOR_TRUE2 = 21;
    MINOR_NULL2 = 22;
    MINOR_UNDEFINED2 = 23;
    encodeFloat2.encodedSize = function encodedSize16(token, options) {
      const float = token.value;
      if (float === false || float === true || float === null || float === void 0) {
        return 1;
      }
      if (!options || options.float64 !== true) {
        encodeFloat162(float);
        let decoded = readFloat162(ui8a2, 1);
        if (float === decoded || Number.isNaN(float)) {
          return 3;
        }
        encodeFloat322(float);
        decoded = readFloat322(ui8a2, 1);
        if (float === decoded) {
          return 5;
        }
      }
      return 9;
    };
    buffer2 = new ArrayBuffer(9);
    dataView2 = new DataView(buffer2, 1);
    ui8a2 = new Uint8Array(buffer2, 0);
    encodeFloat2.compareTokens = encodeUint2.compareTokens;
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/jump.js
function invalidMinor2(data, pos, minor) {
  throw new Error(`${decodeErrPrefix2} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer2(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix2} ${msg}`);
  };
}
var jump2, quick2;
var init_jump2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/jump.js"() {
    init_globals();
    init_token2();
    init_uint2();
    init_negint2();
    init_bytes4();
    init_string2();
    init_array2();
    init_map2();
    init_tag2();
    init_float2();
    init_common2();
    init_byte_utils2();
    jump2 = [];
    for (let i = 0; i <= 23; i++) {
      jump2[i] = invalidMinor2;
    }
    jump2[24] = decodeUint82;
    jump2[25] = decodeUint162;
    jump2[26] = decodeUint322;
    jump2[27] = decodeUint642;
    jump2[28] = invalidMinor2;
    jump2[29] = invalidMinor2;
    jump2[30] = invalidMinor2;
    jump2[31] = invalidMinor2;
    for (let i = 32; i <= 55; i++) {
      jump2[i] = invalidMinor2;
    }
    jump2[56] = decodeNegint82;
    jump2[57] = decodeNegint162;
    jump2[58] = decodeNegint322;
    jump2[59] = decodeNegint642;
    jump2[60] = invalidMinor2;
    jump2[61] = invalidMinor2;
    jump2[62] = invalidMinor2;
    jump2[63] = invalidMinor2;
    for (let i = 64; i <= 87; i++) {
      jump2[i] = decodeBytesCompact2;
    }
    jump2[88] = decodeBytes82;
    jump2[89] = decodeBytes162;
    jump2[90] = decodeBytes322;
    jump2[91] = decodeBytes642;
    jump2[92] = invalidMinor2;
    jump2[93] = invalidMinor2;
    jump2[94] = invalidMinor2;
    jump2[95] = errorer2("indefinite length bytes/strings are not supported");
    for (let i = 96; i <= 119; i++) {
      jump2[i] = decodeStringCompact2;
    }
    jump2[120] = decodeString82;
    jump2[121] = decodeString162;
    jump2[122] = decodeString322;
    jump2[123] = decodeString642;
    jump2[124] = invalidMinor2;
    jump2[125] = invalidMinor2;
    jump2[126] = invalidMinor2;
    jump2[127] = errorer2("indefinite length bytes/strings are not supported");
    for (let i = 128; i <= 151; i++) {
      jump2[i] = decodeArrayCompact2;
    }
    jump2[152] = decodeArray82;
    jump2[153] = decodeArray162;
    jump2[154] = decodeArray322;
    jump2[155] = decodeArray642;
    jump2[156] = invalidMinor2;
    jump2[157] = invalidMinor2;
    jump2[158] = invalidMinor2;
    jump2[159] = decodeArrayIndefinite2;
    for (let i = 160; i <= 183; i++) {
      jump2[i] = decodeMapCompact2;
    }
    jump2[184] = decodeMap82;
    jump2[185] = decodeMap162;
    jump2[186] = decodeMap322;
    jump2[187] = decodeMap642;
    jump2[188] = invalidMinor2;
    jump2[189] = invalidMinor2;
    jump2[190] = invalidMinor2;
    jump2[191] = decodeMapIndefinite2;
    for (let i = 192; i <= 215; i++) {
      jump2[i] = decodeTagCompact2;
    }
    jump2[216] = decodeTag82;
    jump2[217] = decodeTag162;
    jump2[218] = decodeTag322;
    jump2[219] = decodeTag642;
    jump2[220] = invalidMinor2;
    jump2[221] = invalidMinor2;
    jump2[222] = invalidMinor2;
    jump2[223] = invalidMinor2;
    for (let i = 224; i <= 243; i++) {
      jump2[i] = errorer2("simple values are not supported");
    }
    jump2[244] = invalidMinor2;
    jump2[245] = invalidMinor2;
    jump2[246] = invalidMinor2;
    jump2[247] = decodeUndefined2;
    jump2[248] = errorer2("simple values are not supported");
    jump2[249] = decodeFloat162;
    jump2[250] = decodeFloat322;
    jump2[251] = decodeFloat642;
    jump2[252] = invalidMinor2;
    jump2[253] = invalidMinor2;
    jump2[254] = invalidMinor2;
    jump2[255] = decodeBreak2;
    quick2 = [];
    for (let i = 0; i < 24; i++) {
      quick2[i] = new Token2(Type2.uint, i, 1);
    }
    for (let i = -1; i >= -24; i--) {
      quick2[31 - i] = new Token2(Type2.negint, i, 1);
    }
    quick2[64] = new Token2(Type2.bytes, new Uint8Array(0), 1);
    quick2[96] = new Token2(Type2.string, "", 1);
    quick2[128] = new Token2(Type2.array, 0, 1);
    quick2[160] = new Token2(Type2.map, 0, 1);
    quick2[244] = new Token2(Type2.false, false, 1);
    quick2[245] = new Token2(Type2.true, true, 1);
    quick2[246] = new Token2(Type2.null, null, 1);
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/encode.js
function makeCborEncoders2() {
  const encoders = [];
  encoders[Type2.uint.major] = encodeUint2;
  encoders[Type2.negint.major] = encodeNegint2;
  encoders[Type2.bytes.major] = encodeBytes3;
  encoders[Type2.string.major] = encodeString2;
  encoders[Type2.array.major] = encodeArray2;
  encoders[Type2.map.major] = encodeMap2;
  encoders[Type2.tag.major] = encodeTag2;
  encoders[Type2.float.major] = encodeFloat2;
  return encoders;
}
function objectToTokens2(obj, options = {}, refStack) {
  const typ = is2(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders2[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders2[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix2} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries2(entries2, options) {
  if (options.mapSorter) {
    entries2.sort(options.mapSorter);
  }
}
var cborEncoders2, buf2, Ref2, simpleTokens2, typeEncoders2;
var init_encode2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/encode.js"() {
    init_globals();
    init_is2();
    init_token2();
    init_bl2();
    init_common2();
    init_jump2();
    init_byte_utils2();
    init_uint2();
    init_negint2();
    init_bytes4();
    init_string2();
    init_array2();
    init_map2();
    init_tag2();
    init_float2();
    cborEncoders2 = makeCborEncoders2();
    buf2 = new Bl2();
    Ref2 = class {
      constructor(obj, parent2) {
        this.obj = obj;
        this.parent = parent2;
      }
      includes(obj) {
        let p = this;
        do {
          if (p.obj === obj) {
            return true;
          }
        } while (p = p.parent);
        return false;
      }
      static createCheck(stack, obj) {
        if (stack && stack.includes(obj)) {
          throw new Error(`${encodeErrPrefix2} object contains circular references`);
        }
        return new Ref2(obj, stack);
      }
    };
    simpleTokens2 = {
      null: new Token2(Type2.null, null),
      undefined: new Token2(Type2.undefined, void 0),
      true: new Token2(Type2.true, true),
      false: new Token2(Type2.false, false),
      emptyArray: new Token2(Type2.array, 0),
      emptyMap: new Token2(Type2.map, 0)
    };
    typeEncoders2 = {
      number(obj, _typ, _options, _refStack) {
        if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
          return new Token2(Type2.float, obj);
        } else if (obj >= 0) {
          return new Token2(Type2.uint, obj);
        } else {
          return new Token2(Type2.negint, obj);
        }
      },
      bigint(obj, _typ, _options, _refStack) {
        if (obj >= BigInt(0)) {
          return new Token2(Type2.uint, obj);
        } else {
          return new Token2(Type2.negint, obj);
        }
      },
      Uint8Array(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, obj);
      },
      string(obj, _typ, _options, _refStack) {
        return new Token2(Type2.string, obj);
      },
      boolean(obj, _typ, _options, _refStack) {
        return obj ? simpleTokens2.true : simpleTokens2.false;
      },
      null(_obj, _typ, _options, _refStack) {
        return simpleTokens2.null;
      },
      undefined(_obj, _typ, _options, _refStack) {
        return simpleTokens2.undefined;
      },
      ArrayBuffer(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, new Uint8Array(obj));
      },
      DataView(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
      },
      Array(obj, _typ, options, refStack) {
        if (!obj.length) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens2.emptyArray,
              new Token2(Type2.break)
            ];
          }
          return simpleTokens2.emptyArray;
        }
        refStack = Ref2.createCheck(refStack, obj);
        const entries2 = [];
        let i = 0;
        for (const e of obj) {
          entries2[i++] = objectToTokens2(e, options, refStack);
        }
        if (options.addBreakTokens) {
          return [
            new Token2(Type2.array, obj.length),
            entries2,
            new Token2(Type2.break)
          ];
        }
        return [
          new Token2(Type2.array, obj.length),
          entries2
        ];
      },
      Object(obj, typ, options, refStack) {
        const isMap = typ !== "Object";
        const keys2 = isMap ? obj.keys() : Object.keys(obj);
        const length5 = isMap ? obj.size : keys2.length;
        if (!length5) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens2.emptyMap,
              new Token2(Type2.break)
            ];
          }
          return simpleTokens2.emptyMap;
        }
        refStack = Ref2.createCheck(refStack, obj);
        const entries2 = [];
        let i = 0;
        for (const key of keys2) {
          entries2[i++] = [
            objectToTokens2(key, options, refStack),
            objectToTokens2(isMap ? obj.get(key) : obj[key], options, refStack)
          ];
        }
        sortMapEntries2(entries2, options);
        if (options.addBreakTokens) {
          return [
            new Token2(Type2.map, length5),
            entries2,
            new Token2(Type2.break)
          ];
        }
        return [
          new Token2(Type2.map, length5),
          entries2
        ];
      }
    };
    typeEncoders2.Map = typeEncoders2.Object;
    typeEncoders2.Buffer = typeEncoders2.Uint8Array;
    for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
      typeEncoders2[`${typ}Array`] = typeEncoders2.DataView;
    }
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/lib/decode.js
function tokenToArray2(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject2(tokeniser, options);
    if (value === BREAK2) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed array`);
    }
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap2(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject2(tokeniser, options);
    if (key === BREAK2) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed map`);
    }
    if (key === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix2} non-string keys not supported (got ${typeof key})`);
    }
    const value = tokensToObject2(tokeniser, options);
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject2(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE2;
  }
  const token = tokeniser.next();
  if (token.type === Type2.break) {
    return BREAK2;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type2.array) {
    return tokenToArray2(token, tokeniser, options);
  }
  if (token.type === Type2.map) {
    return tokenToMap2(token, tokeniser, options);
  }
  if (token.type === Type2.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject2(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix2} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode20(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix2} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions2, options);
  const tokeniser = options.tokenizer || new Tokeniser2(data, options);
  const decoded = tokensToObject2(tokeniser, options);
  if (decoded === DONE2) {
    throw new Error(`${decodeErrPrefix2} did not find any content to decode`);
  }
  if (decoded === BREAK2) {
    throw new Error(`${decodeErrPrefix2} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix2} too many terminals, data makes no sense`);
  }
  return decoded;
}
var defaultDecodeOptions2, Tokeniser2, DONE2, BREAK2;
var init_decode2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/lib/decode.js"() {
    init_globals();
    init_common2();
    init_token2();
    init_jump2();
    defaultDecodeOptions2 = {
      strict: false,
      allowIndefinite: true,
      allowUndefined: true,
      allowBigInt: true
    };
    Tokeniser2 = class {
      constructor(data, options = {}) {
        this.pos = 0;
        this.data = data;
        this.options = options;
      }
      done() {
        return this.pos >= this.data.length;
      }
      next() {
        const byt = this.data[this.pos];
        let token = quick2[byt];
        if (token === void 0) {
          const decoder = jump2[byt];
          if (!decoder) {
            throw new Error(`${decodeErrPrefix2} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
          }
          const minor = byt & 31;
          token = decoder(this.data, this.pos, minor, this.options);
        }
        this.pos += token.encodedLength;
        return token;
      }
    };
    DONE2 = Symbol.for("DONE");
    BREAK2 = Symbol.for("BREAK");
  }
});

// js-ipfs-fetch/node_modules/cborg/esm/cborg.js
var init_cborg2 = __esm({
  "js-ipfs-fetch/node_modules/cborg/esm/cborg.js"() {
    init_globals();
    init_encode2();
    init_decode2();
    init_token2();
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/node_modules/@ipld/dag-cbor/esm/index.js
function cidDecoder5(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID2.decode(bytes2.subarray(1));
}
var CID_CBOR_TAG5, decodeOptions6, code10, decode21;
var init_esm2 = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/node_modules/@ipld/dag-cbor/esm/index.js"() {
    init_globals();
    init_cborg2();
    init_cid2();
    CID_CBOR_TAG5 = 42;
    decodeOptions6 = {
      allowIndefinite: false,
      allowUndefined: false,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      strict: true,
      useMaps: false,
      tags: []
    };
    decodeOptions6.tags[CID_CBOR_TAG5] = cidDecoder5;
    code10 = 113;
    decode21 = (data) => decode20(data, decodeOptions6);
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/codecs/raw.js
var code11;
var init_raw2 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_globals();
    init_bytes3();
    code11 = 85;
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports3 = {};
__export(identity_exports3, {
  identity: () => identity3
});
var code12, name9, encode18, digest2, identity3;
var init_identity3 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_globals();
    init_bytes3();
    init_digest2();
    code12 = 0;
    name9 = "identity";
    encode18 = coerce2;
    digest2 = (input) => create8(code12, encode18(input));
    identity3 = {
      code: code12,
      name: name9,
      encode: encode18,
      digest: digest2
    };
  }
});

// js-ipfs-fetch/node_modules/@protobufjs/aspromise/index.js
var require_aspromise2 = __commonJS({
  "js-ipfs-fetch/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve11, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve11.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// js-ipfs-fetch/node_modules/@protobufjs/base64/index.js
var require_base642 = __commonJS({
  "js-ipfs-fetch/node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    init_globals();
    var base643 = exports2;
    base643.length = function length5(string3) {
      var p = string3.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string3.charAt(p) === "=")
        ++n;
      return Math.ceil(string3.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base643.encode = function encode19(buffer3, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer3[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base643.decode = function decode22(string3, buffer3, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string3.length; ) {
        var c = string3.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer3[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer3[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer3[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base643.test = function test(string3) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string3);
    };
  }
});

// js-ipfs-fetch/node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter2 = __commonJS({
  "js-ipfs-fetch/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = EventEmitter4;
    function EventEmitter4() {
      this._listeners = {};
    }
    EventEmitter4.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter4.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter4.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// js-ipfs-fetch/node_modules/@protobufjs/float/index.js
var require_float2 = __commonJS({
  "js-ipfs-fetch/node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf3, pos) {
            f32[0] = val;
            buf3[pos] = f8b[0];
            buf3[pos + 1] = f8b[1];
            buf3[pos + 2] = f8b[2];
            buf3[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf3, pos) {
            f32[0] = val;
            buf3[pos] = f8b[3];
            buf3[pos + 1] = f8b[2];
            buf3[pos + 2] = f8b[1];
            buf3[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf3, pos) {
            f8b[0] = buf3[pos];
            f8b[1] = buf3[pos + 1];
            f8b[2] = buf3[pos + 2];
            f8b[3] = buf3[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf3, pos) {
            f8b[3] = buf3[pos];
            f8b[2] = buf3[pos + 1];
            f8b[1] = buf3[pos + 2];
            f8b[0] = buf3[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf3, pos) {
            var sign3 = val < 0 ? 1 : 0;
            if (sign3)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? 0 : 2147483648, buf3, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf3, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign3 << 31 | 2139095040) >>> 0, buf3, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign3 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf3, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign3 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf3, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf3, pos) {
            var uint = readUint(buf3, pos), sign3 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 1401298464324817e-60 * mantissa : sign3 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf3, pos) {
            f64[0] = val;
            buf3[pos] = f8b[0];
            buf3[pos + 1] = f8b[1];
            buf3[pos + 2] = f8b[2];
            buf3[pos + 3] = f8b[3];
            buf3[pos + 4] = f8b[4];
            buf3[pos + 5] = f8b[5];
            buf3[pos + 6] = f8b[6];
            buf3[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf3, pos) {
            f64[0] = val;
            buf3[pos] = f8b[7];
            buf3[pos + 1] = f8b[6];
            buf3[pos + 2] = f8b[5];
            buf3[pos + 3] = f8b[4];
            buf3[pos + 4] = f8b[3];
            buf3[pos + 5] = f8b[2];
            buf3[pos + 6] = f8b[1];
            buf3[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf3, pos) {
            f8b[0] = buf3[pos];
            f8b[1] = buf3[pos + 1];
            f8b[2] = buf3[pos + 2];
            f8b[3] = buf3[pos + 3];
            f8b[4] = buf3[pos + 4];
            f8b[5] = buf3[pos + 5];
            f8b[6] = buf3[pos + 6];
            f8b[7] = buf3[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf3, pos) {
            f8b[7] = buf3[pos];
            f8b[6] = buf3[pos + 1];
            f8b[5] = buf3[pos + 2];
            f8b[4] = buf3[pos + 3];
            f8b[3] = buf3[pos + 4];
            f8b[2] = buf3[pos + 5];
            f8b[1] = buf3[pos + 6];
            f8b[0] = buf3[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf3, pos) {
            var sign3 = val < 0 ? 1 : 0;
            if (sign3)
              val = -val;
            if (val === 0) {
              writeUint(0, buf3, pos + off0);
              writeUint(1 / val > 0 ? 0 : 2147483648, buf3, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf3, pos + off0);
              writeUint(2146959360, buf3, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf3, pos + off0);
              writeUint((sign3 << 31 | 2146435072) >>> 0, buf3, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf3, pos + off0);
                writeUint((sign3 << 31 | mantissa / 4294967296) >>> 0, buf3, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf3, pos + off0);
                writeUint((sign3 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf3, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf3, pos) {
            var lo = readUint(buf3, pos + off0), hi = readUint(buf3, pos + off1);
            var sign3 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 5e-324 * mantissa : sign3 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf3, pos) {
      buf3[pos] = val & 255;
      buf3[pos + 1] = val >>> 8 & 255;
      buf3[pos + 2] = val >>> 16 & 255;
      buf3[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf3, pos) {
      buf3[pos] = val >>> 24;
      buf3[pos + 1] = val >>> 16 & 255;
      buf3[pos + 2] = val >>> 8 & 255;
      buf3[pos + 3] = val & 255;
    }
    function readUintLE(buf3, pos) {
      return (buf3[pos] | buf3[pos + 1] << 8 | buf3[pos + 2] << 16 | buf3[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf3, pos) {
      return (buf3[pos] << 24 | buf3[pos + 1] << 16 | buf3[pos + 2] << 8 | buf3[pos + 3]) >>> 0;
    }
  }
});

// js-ipfs-fetch/node_modules/@protobufjs/inquire/index.js
var require_inquire2 = __commonJS({
  "js-ipfs-fetch/node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    init_globals();
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// js-ipfs-fetch/node_modules/@protobufjs/utf8/index.js
var require_utf82 = __commonJS({
  "js-ipfs-fetch/node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    init_globals();
    var utf8 = exports2;
    utf8.length = function utf8_length(string3) {
      var len = 0, c = 0;
      for (var i = 0; i < string3.length; ++i) {
        c = string3.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string3.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer3, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer3[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer3[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer3[start++] & 63) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer3[start++] & 63) << 6 | buffer3[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string3, buffer3, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string3.length; ++i) {
        c1 = string3.charCodeAt(i);
        if (c1 < 128) {
          buffer3[offset++] = c1;
        } else if (c1 < 2048) {
          buffer3[offset++] = c1 >> 6 | 192;
          buffer3[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string3.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer3[offset++] = c1 >> 18 | 240;
          buffer3[offset++] = c1 >> 12 & 63 | 128;
          buffer3[offset++] = c1 >> 6 & 63 | 128;
          buffer3[offset++] = c1 & 63 | 128;
        } else {
          buffer3[offset++] = c1 >> 12 | 224;
          buffer3[offset++] = c1 >> 6 & 63 | 128;
          buffer3[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// js-ipfs-fetch/node_modules/@protobufjs/pool/index.js
var require_pool2 = __commonJS({
  "js-ipfs-fetch/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = pool;
    function pool(alloc3, slice3, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc3(size2);
        if (offset + size2 > SIZE) {
          slab = alloc3(SIZE);
          offset = 0;
        }
        var buf3 = slice3.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf3;
      };
    }
  }
});

// js-ipfs-fetch/node_modules/protobufjs/src/util/longbits.js
var require_longbits2 = __commonJS({
  "js-ipfs-fetch/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = LongBits;
    var util = require_minimal3();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign3 = value < 0;
      if (sign3)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign3) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from5(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits((charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0, (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0);
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length5() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// js-ipfs-fetch/node_modules/protobufjs/src/util/minimal.js
var require_minimal3 = __commonJS({
  "js-ipfs-fetch/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    init_globals();
    var util = exports2;
    util.asPromise = require_aspromise2();
    util.base64 = require_base642();
    util.EventEmitter = require_eventemitter2();
    util.float = require_float2();
    util.inquire = require_inquire2();
    util.utf8 = require_utf82();
    util.pool = require_pool2();
    util.LongBits = require_longbits2();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util.isInteger = Number.isInteger || function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge5(dst, src3, ifNotSet) {
      for (var keys2 = Object.keys(src3), i = 0; i < keys2.length; ++i)
        if (dst[keys2[i]] === void 0 || !ifNotSet)
          dst[keys2[i]] = src3[keys2[i]];
      return dst;
    }
    util.merge = merge5;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name10) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge5(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name10;
      } });
      CustomError.prototype.toString = function toString6() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys2 = Object.keys(this), i2 = keys2.length - 1; i2 > -1; --i2)
          if (fieldMap[keys2[i2]] === 1 && this[keys2[i2]] !== void 0 && this[keys2[i2]] !== null)
            return keys2[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name10) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name10)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// js-ipfs-fetch/node_modules/protobufjs/src/writer.js
var require_writer2 = __commonJS({
  "js-ipfs-fetch/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = Writer;
    var util = require_minimal3();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base643 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create9 = function create10() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create9();
    Writer.alloc = function alloc3(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf3, pos) {
      buf3[pos] = val & 255;
    }
    function writeVarint32(val, buf3, pos) {
      while (val > 127) {
        buf3[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf3[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf3, pos) {
      while (val.hi) {
        buf3[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf3[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf3[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf3, pos) {
      buf3[pos] = val & 255;
      buf3[pos + 1] = val >>> 8 & 255;
      buf3[pos + 2] = val >>> 16 & 255;
      buf3[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf3, pos) {
      buf3.set(val, pos);
    } : function writeBytes_for(val, buf3, pos) {
      for (var i = 0; i < val.length; ++i)
        buf3[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf3 = Writer.alloc(len = base643.length(value));
        base643.decode(value, buf3, 0);
        value = buf3;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf3 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf3, pos);
        pos += head.len;
        head = head.next;
      }
      return buf3;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create9();
      BufferWriter._configure();
    };
  }
});

// js-ipfs-fetch/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer2 = __commonJS({
  "js-ipfs-fetch/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = BufferWriter;
    var Writer = require_writer2();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal3();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf3, pos) {
        buf3.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf3, pos) {
        if (val.copy)
          val.copy(buf3, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf3[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf3, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf3, pos);
      else if (buf3.utf8Write)
        buf3.utf8Write(val, pos);
      else
        buf3.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// js-ipfs-fetch/node_modules/protobufjs/src/reader.js
var require_reader2 = __commonJS({
  "js-ipfs-fetch/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = Reader;
    var util = require_minimal3();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer3) {
      this.buf = buffer3;
      this.pos = 0;
      this.len = buffer3.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer3) {
      if (buffer3 instanceof Uint8Array || Array.isArray(buffer3))
        return new Reader(buffer3);
      throw Error("illegal buffer");
    } : function create_array2(buffer3) {
      if (Array.isArray(buffer3))
        return new Reader(buffer3);
      throw Error("illegal buffer");
    };
    var create9 = function create10() {
      return util.Buffer ? function create_buffer_setup(buffer3) {
        return (Reader.create = function create_buffer(buffer4) {
          return util.Buffer.isBuffer(buffer4) ? new BufferReader(buffer4) : create_array(buffer4);
        })(buffer3);
      } : create_array;
    };
    Reader.create = create9();
    Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf3, end) {
      return (buf3[end - 4] | buf3[end - 3] << 8 | buf3[end - 2] << 16 | buf3[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length5 = this.uint32(), start = this.pos, end = this.pos + length5;
      if (end > this.len)
        throw indexOutOfRange(this, length5);
      this.pos += length5;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes2 = this.bytes();
      return utf8.read(bytes2, 0, bytes2.length);
    };
    Reader.prototype.skip = function skip(length5) {
      if (typeof length5 === "number") {
        if (this.pos + length5 > this.len)
          throw indexOutOfRange(this, length5);
        this.pos += length5;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create9();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : "toNumber";
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// js-ipfs-fetch/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer2 = __commonJS({
  "js-ipfs-fetch/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = BufferReader;
    var Reader = require_reader2();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal3();
    function BufferReader(buffer3) {
      Reader.call(this, buffer3);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// js-ipfs-fetch/node_modules/protobufjs/src/rpc/service.js
var require_service2 = __commonJS({
  "js-ipfs-fetch/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = Service2;
    var util = require_minimal3();
    (Service2.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service2;
    function Service2(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service2.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
          if (err) {
            self2.emit("error", err, method);
            return callback(err);
          }
          if (response === null) {
            self2.end(true);
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
          }
          self2.emit("data", response, method);
          return callback(null, response);
        });
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service2.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// js-ipfs-fetch/node_modules/protobufjs/src/rpc.js
var require_rpc5 = __commonJS({
  "js-ipfs-fetch/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    init_globals();
    var rpc = exports2;
    rpc.Service = require_service2();
  }
});

// js-ipfs-fetch/node_modules/protobufjs/src/roots.js
var require_roots2 = __commonJS({
  "js-ipfs-fetch/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = {};
  }
});

// js-ipfs-fetch/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal2 = __commonJS({
  "js-ipfs-fetch/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    init_globals();
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer2();
    protobuf.BufferWriter = require_writer_buffer2();
    protobuf.Reader = require_reader2();
    protobuf.BufferReader = require_reader_buffer2();
    protobuf.util = require_minimal3();
    protobuf.rpc = require_rpc5();
    protobuf.roots = require_roots2();
    protobuf.configure = configure2;
    function configure2() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure2();
  }
});

// js-ipfs-fetch/node_modules/protobufjs/minimal.js
var require_minimal4 = __commonJS({
  "js-ipfs-fetch/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    init_globals();
    module2.exports = require_index_minimal2();
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/node_modules/ipfs-unixfs/esm/src/unixfs.js
var import_minimal11, $Reader10, $Writer10, $util10, $root10, Data2, UnixTime2, Metadata3;
var init_unixfs = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/node_modules/ipfs-unixfs/esm/src/unixfs.js"() {
    init_globals();
    import_minimal11 = __toESM(require_minimal4(), 1);
    $Reader10 = import_minimal11.default.Reader;
    $Writer10 = import_minimal11.default.Writer;
    $util10 = import_minimal11.default.util;
    $root10 = import_minimal11.default.roots["ipfs-unixfs"] || (import_minimal11.default.roots["ipfs-unixfs"] = {});
    Data2 = $root10.Data = (() => {
      function Data3(p) {
        this.blocksizes = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Data3.prototype.Type = 0;
      Data3.prototype.Data = $util10.newBuffer([]);
      Data3.prototype.filesize = $util10.Long ? $util10.Long.fromBits(0, 0, true) : 0;
      Data3.prototype.blocksizes = $util10.emptyArray;
      Data3.prototype.hashType = $util10.Long ? $util10.Long.fromBits(0, 0, true) : 0;
      Data3.prototype.fanout = $util10.Long ? $util10.Long.fromBits(0, 0, true) : 0;
      Data3.prototype.mode = 0;
      Data3.prototype.mtime = null;
      Data3.encode = function encode19(m, w) {
        if (!w)
          w = $Writer10.create();
        w.uint32(8).int32(m.Type);
        if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
          w.uint32(18).bytes(m.Data);
        if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
          w.uint32(24).uint64(m.filesize);
        if (m.blocksizes != null && m.blocksizes.length) {
          for (var i = 0; i < m.blocksizes.length; ++i)
            w.uint32(32).uint64(m.blocksizes[i]);
        }
        if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
          w.uint32(40).uint64(m.hashType);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(48).uint64(m.fanout);
        if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
          w.uint32(56).uint32(m.mode);
        if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
          $root10.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
        return w;
      };
      Data3.decode = function decode22(r, l) {
        if (!(r instanceof $Reader10))
          r = $Reader10.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root10.Data();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Type = r.int32();
              break;
            case 2:
              m.Data = r.bytes();
              break;
            case 3:
              m.filesize = r.uint64();
              break;
            case 4:
              if (!(m.blocksizes && m.blocksizes.length))
                m.blocksizes = [];
              if ((t & 7) === 2) {
                var c2 = r.uint32() + r.pos;
                while (r.pos < c2)
                  m.blocksizes.push(r.uint64());
              } else
                m.blocksizes.push(r.uint64());
              break;
            case 5:
              m.hashType = r.uint64();
              break;
            case 6:
              m.fanout = r.uint64();
              break;
            case 7:
              m.mode = r.uint32();
              break;
            case 8:
              m.mtime = $root10.UnixTime.decode(r, r.uint32());
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Type"))
          throw $util10.ProtocolError("missing required 'Type'", { instance: m });
        return m;
      };
      Data3.fromObject = function fromObject(d) {
        if (d instanceof $root10.Data)
          return d;
        var m = new $root10.Data();
        switch (d.Type) {
          case "Raw":
          case 0:
            m.Type = 0;
            break;
          case "Directory":
          case 1:
            m.Type = 1;
            break;
          case "File":
          case 2:
            m.Type = 2;
            break;
          case "Metadata":
          case 3:
            m.Type = 3;
            break;
          case "Symlink":
          case 4:
            m.Type = 4;
            break;
          case "HAMTShard":
          case 5:
            m.Type = 5;
            break;
        }
        if (d.Data != null) {
          if (typeof d.Data === "string")
            $util10.base64.decode(d.Data, m.Data = $util10.newBuffer($util10.base64.length(d.Data)), 0);
          else if (d.Data.length)
            m.Data = d.Data;
        }
        if (d.filesize != null) {
          if ($util10.Long)
            (m.filesize = $util10.Long.fromValue(d.filesize)).unsigned = true;
          else if (typeof d.filesize === "string")
            m.filesize = parseInt(d.filesize, 10);
          else if (typeof d.filesize === "number")
            m.filesize = d.filesize;
          else if (typeof d.filesize === "object")
            m.filesize = new $util10.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
        }
        if (d.blocksizes) {
          if (!Array.isArray(d.blocksizes))
            throw TypeError(".Data.blocksizes: array expected");
          m.blocksizes = [];
          for (var i = 0; i < d.blocksizes.length; ++i) {
            if ($util10.Long)
              (m.blocksizes[i] = $util10.Long.fromValue(d.blocksizes[i])).unsigned = true;
            else if (typeof d.blocksizes[i] === "string")
              m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
            else if (typeof d.blocksizes[i] === "number")
              m.blocksizes[i] = d.blocksizes[i];
            else if (typeof d.blocksizes[i] === "object")
              m.blocksizes[i] = new $util10.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
          }
        }
        if (d.hashType != null) {
          if ($util10.Long)
            (m.hashType = $util10.Long.fromValue(d.hashType)).unsigned = true;
          else if (typeof d.hashType === "string")
            m.hashType = parseInt(d.hashType, 10);
          else if (typeof d.hashType === "number")
            m.hashType = d.hashType;
          else if (typeof d.hashType === "object")
            m.hashType = new $util10.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
        }
        if (d.fanout != null) {
          if ($util10.Long)
            (m.fanout = $util10.Long.fromValue(d.fanout)).unsigned = true;
          else if (typeof d.fanout === "string")
            m.fanout = parseInt(d.fanout, 10);
          else if (typeof d.fanout === "number")
            m.fanout = d.fanout;
          else if (typeof d.fanout === "object")
            m.fanout = new $util10.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
        }
        if (d.mode != null) {
          m.mode = d.mode >>> 0;
        }
        if (d.mtime != null) {
          if (typeof d.mtime !== "object")
            throw TypeError(".Data.mtime: object expected");
          m.mtime = $root10.UnixTime.fromObject(d.mtime);
        }
        return m;
      };
      Data3.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.blocksizes = [];
        }
        if (o.defaults) {
          d.Type = o.enums === String ? "Raw" : 0;
          if (o.bytes === String)
            d.Data = "";
          else {
            d.Data = [];
            if (o.bytes !== Array)
              d.Data = $util10.newBuffer(d.Data);
          }
          if ($util10.Long) {
            var n = new $util10.Long(0, 0, true);
            d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.filesize = o.longs === String ? "0" : 0;
          if ($util10.Long) {
            var n = new $util10.Long(0, 0, true);
            d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.hashType = o.longs === String ? "0" : 0;
          if ($util10.Long) {
            var n = new $util10.Long(0, 0, true);
            d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.fanout = o.longs === String ? "0" : 0;
          d.mode = 0;
          d.mtime = null;
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root10.Data.DataType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util10.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        if (m.filesize != null && m.hasOwnProperty("filesize")) {
          if (typeof m.filesize === "number")
            d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
          else
            d.filesize = o.longs === String ? $util10.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util10.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
        }
        if (m.blocksizes && m.blocksizes.length) {
          d.blocksizes = [];
          for (var j = 0; j < m.blocksizes.length; ++j) {
            if (typeof m.blocksizes[j] === "number")
              d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
            else
              d.blocksizes[j] = o.longs === String ? $util10.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util10.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
          }
        }
        if (m.hashType != null && m.hasOwnProperty("hashType")) {
          if (typeof m.hashType === "number")
            d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
          else
            d.hashType = o.longs === String ? $util10.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util10.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          if (typeof m.fanout === "number")
            d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
          else
            d.fanout = o.longs === String ? $util10.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util10.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
        }
        if (m.mode != null && m.hasOwnProperty("mode")) {
          d.mode = m.mode;
        }
        if (m.mtime != null && m.hasOwnProperty("mtime")) {
          d.mtime = $root10.UnixTime.toObject(m.mtime, o);
        }
        return d;
      };
      Data3.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal11.default.util.toJSONOptions);
      };
      Data3.DataType = function() {
        const valuesById = {}, values2 = Object.create(valuesById);
        values2[valuesById[0] = "Raw"] = 0;
        values2[valuesById[1] = "Directory"] = 1;
        values2[valuesById[2] = "File"] = 2;
        values2[valuesById[3] = "Metadata"] = 3;
        values2[valuesById[4] = "Symlink"] = 4;
        values2[valuesById[5] = "HAMTShard"] = 5;
        return values2;
      }();
      return Data3;
    })();
    UnixTime2 = $root10.UnixTime = (() => {
      function UnixTime3(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      UnixTime3.prototype.Seconds = $util10.Long ? $util10.Long.fromBits(0, 0, false) : 0;
      UnixTime3.prototype.FractionalNanoseconds = 0;
      UnixTime3.encode = function encode19(m, w) {
        if (!w)
          w = $Writer10.create();
        w.uint32(8).int64(m.Seconds);
        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
          w.uint32(21).fixed32(m.FractionalNanoseconds);
        return w;
      };
      UnixTime3.decode = function decode22(r, l) {
        if (!(r instanceof $Reader10))
          r = $Reader10.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root10.UnixTime();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Seconds = r.int64();
              break;
            case 2:
              m.FractionalNanoseconds = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Seconds"))
          throw $util10.ProtocolError("missing required 'Seconds'", { instance: m });
        return m;
      };
      UnixTime3.fromObject = function fromObject(d) {
        if (d instanceof $root10.UnixTime)
          return d;
        var m = new $root10.UnixTime();
        if (d.Seconds != null) {
          if ($util10.Long)
            (m.Seconds = $util10.Long.fromValue(d.Seconds)).unsigned = false;
          else if (typeof d.Seconds === "string")
            m.Seconds = parseInt(d.Seconds, 10);
          else if (typeof d.Seconds === "number")
            m.Seconds = d.Seconds;
          else if (typeof d.Seconds === "object")
            m.Seconds = new $util10.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
        }
        if (d.FractionalNanoseconds != null) {
          m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
        }
        return m;
      };
      UnixTime3.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if ($util10.Long) {
            var n = new $util10.Long(0, 0, false);
            d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.Seconds = o.longs === String ? "0" : 0;
          d.FractionalNanoseconds = 0;
        }
        if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
          if (typeof m.Seconds === "number")
            d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
          else
            d.Seconds = o.longs === String ? $util10.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util10.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
        }
        if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
          d.FractionalNanoseconds = m.FractionalNanoseconds;
        }
        return d;
      };
      UnixTime3.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal11.default.util.toJSONOptions);
      };
      return UnixTime3;
    })();
    Metadata3 = $root10.Metadata = (() => {
      function Metadata4(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Metadata4.prototype.MimeType = "";
      Metadata4.encode = function encode19(m, w) {
        if (!w)
          w = $Writer10.create();
        if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
          w.uint32(10).string(m.MimeType);
        return w;
      };
      Metadata4.decode = function decode22(r, l) {
        if (!(r instanceof $Reader10))
          r = $Reader10.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root10.Metadata();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.MimeType = r.string();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Metadata4.fromObject = function fromObject(d) {
        if (d instanceof $root10.Metadata)
          return d;
        var m = new $root10.Metadata();
        if (d.MimeType != null) {
          m.MimeType = String(d.MimeType);
        }
        return m;
      };
      Metadata4.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.MimeType = "";
        }
        if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
          d.MimeType = m.MimeType;
        }
        return d;
      };
      Metadata4.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal11.default.util.toJSONOptions);
      };
      return Metadata4;
    })();
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/node_modules/ipfs-unixfs/esm/src/index.js
function parseMode2(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime3(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code75.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var import_err_code75, PBData2, types2, dirTypes2, DEFAULT_FILE_MODE2, DEFAULT_DIRECTORY_MODE2, UnixFS2;
var init_src6 = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/node_modules/ipfs-unixfs/esm/src/index.js"() {
    init_globals();
    import_err_code75 = __toESM(require_err_code3(), 1);
    init_unixfs();
    PBData2 = Data2;
    types2 = [
      "raw",
      "directory",
      "file",
      "metadata",
      "symlink",
      "hamt-sharded-directory"
    ];
    dirTypes2 = [
      "directory",
      "hamt-sharded-directory"
    ];
    DEFAULT_FILE_MODE2 = parseInt("0644", 8);
    DEFAULT_DIRECTORY_MODE2 = parseInt("0755", 8);
    UnixFS2 = class {
      static unmarshal(marshaled) {
        const message = PBData2.decode(marshaled);
        const decoded = PBData2.toObject(message, {
          defaults: false,
          arrays: true,
          longs: Number,
          objects: false
        });
        const data = new UnixFS2({
          type: types2[decoded.Type],
          data: decoded.Data,
          blockSizes: decoded.blocksizes,
          mode: decoded.mode,
          mtime: decoded.mtime ? {
            secs: decoded.mtime.Seconds,
            nsecs: decoded.mtime.FractionalNanoseconds
          } : void 0
        });
        data._originalMode = decoded.mode || 0;
        return data;
      }
      constructor(options = { type: "file" }) {
        const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
        if (type && !types2.includes(type)) {
          throw (0, import_err_code75.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
        }
        this.type = type || "file";
        this.data = data;
        this.hashType = hashType;
        this.fanout = fanout;
        this.blockSizes = blockSizes || [];
        this._originalMode = 0;
        this.mode = parseMode2(mode);
        if (mtime) {
          this.mtime = parseMtime3(mtime);
          if (this.mtime && !this.mtime.nsecs) {
            this.mtime.nsecs = 0;
          }
        }
      }
      set mode(mode) {
        this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE2 : DEFAULT_FILE_MODE2;
        const parsedMode = parseMode2(mode);
        if (parsedMode !== void 0) {
          this._mode = parsedMode;
        }
      }
      get mode() {
        return this._mode;
      }
      isDirectory() {
        return Boolean(this.type && dirTypes2.includes(this.type));
      }
      addBlockSize(size) {
        this.blockSizes.push(size);
      }
      removeBlockSize(index) {
        this.blockSizes.splice(index, 1);
      }
      fileSize() {
        if (this.isDirectory()) {
          return 0;
        }
        let sum = 0;
        this.blockSizes.forEach((size) => {
          sum += size;
        });
        if (this.data) {
          sum += this.data.length;
        }
        return sum;
      }
      marshal() {
        let type;
        switch (this.type) {
          case "raw":
            type = PBData2.DataType.Raw;
            break;
          case "directory":
            type = PBData2.DataType.Directory;
            break;
          case "file":
            type = PBData2.DataType.File;
            break;
          case "metadata":
            type = PBData2.DataType.Metadata;
            break;
          case "symlink":
            type = PBData2.DataType.Symlink;
            break;
          case "hamt-sharded-directory":
            type = PBData2.DataType.HAMTShard;
            break;
          default:
            throw (0, import_err_code75.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
        }
        let data = this.data;
        if (!this.data || !this.data.length) {
          data = void 0;
        }
        let mode;
        if (this.mode != null) {
          mode = this._originalMode & 4294963200 | (parseMode2(this.mode) || 0);
          if (mode === DEFAULT_FILE_MODE2 && !this.isDirectory()) {
            mode = void 0;
          }
          if (mode === DEFAULT_DIRECTORY_MODE2 && this.isDirectory()) {
            mode = void 0;
          }
        }
        let mtime;
        if (this.mtime != null) {
          const parsed = parseMtime3(this.mtime);
          if (parsed) {
            mtime = {
              Seconds: parsed.secs,
              FractionalNanoseconds: parsed.nsecs
            };
            if (mtime.FractionalNanoseconds === 0) {
              delete mtime.FractionalNanoseconds;
            }
          }
        }
        const pbData = {
          Type: type,
          Data: data,
          filesize: this.isDirectory() ? void 0 : this.fileSize(),
          blocksizes: this.blockSizes,
          hashType: this.hashType,
          fanout: this.fanout,
          mode,
          mtime
        };
        return PBData2.encode(pbData).finish();
      }
    };
  }
});

// js-ipfs-fetch/node_modules/sparse-array/index.js
var require_sparse_array2 = __commonJS({
  "js-ipfs-fetch/node_modules/sparse-array/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var BITS_PER_BYTE = 7;
    module2.exports = class SparseArray {
      constructor() {
        this._bitArrays = [];
        this._data = [];
        this._length = 0;
        this._changedLength = false;
        this._changedData = false;
      }
      set(index, value) {
        let pos = this._internalPositionFor(index, false);
        if (value === void 0) {
          if (pos !== -1) {
            this._unsetInternalPos(pos);
            this._unsetBit(index);
            this._changedLength = true;
            this._changedData = true;
          }
        } else {
          let needsSort = false;
          if (pos === -1) {
            pos = this._data.length;
            this._setBit(index);
            this._changedData = true;
          } else {
            needsSort = true;
          }
          this._setInternalPos(pos, index, value, needsSort);
          this._changedLength = true;
        }
      }
      unset(index) {
        this.set(index, void 0);
      }
      get(index) {
        this._sortData();
        const pos = this._internalPositionFor(index, true);
        if (pos === -1) {
          return void 0;
        }
        return this._data[pos][1];
      }
      push(value) {
        this.set(this.length, value);
        return this.length;
      }
      get length() {
        this._sortData();
        if (this._changedLength) {
          const last15 = this._data[this._data.length - 1];
          this._length = last15 ? last15[0] + 1 : 0;
          this._changedLength = false;
        }
        return this._length;
      }
      forEach(iterator) {
        let i = 0;
        while (i < this.length) {
          iterator(this.get(i), i, this);
          i++;
        }
      }
      map(iterator) {
        let i = 0;
        let mapped = new Array(this.length);
        while (i < this.length) {
          mapped[i] = iterator(this.get(i), i, this);
          i++;
        }
        return mapped;
      }
      reduce(reducer, initialValue) {
        let i = 0;
        let acc = initialValue;
        while (i < this.length) {
          const value = this.get(i);
          acc = reducer(acc, value, i);
          i++;
        }
        return acc;
      }
      find(finder) {
        let i = 0, found, last15;
        while (i < this.length && !found) {
          last15 = this.get(i);
          found = finder(last15);
          i++;
        }
        return found ? last15 : void 0;
      }
      _internalPositionFor(index, noCreate) {
        const bytePos = this._bytePosFor(index, noCreate);
        if (bytePos >= this._bitArrays.length) {
          return -1;
        }
        const byte = this._bitArrays[bytePos];
        const bitPos = index - bytePos * BITS_PER_BYTE;
        const exists = (byte & 1 << bitPos) > 0;
        if (!exists) {
          return -1;
        }
        const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
        const mask = ~(4294967295 << bitPos + 1);
        const bytePopCount = popCount(byte & mask);
        const arrayPos = previousPopCount + bytePopCount - 1;
        return arrayPos;
      }
      _bytePosFor(index, noCreate) {
        const bytePos = Math.floor(index / BITS_PER_BYTE);
        const targetLength = bytePos + 1;
        while (!noCreate && this._bitArrays.length < targetLength) {
          this._bitArrays.push(0);
        }
        return bytePos;
      }
      _setBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
      }
      _unsetBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
      }
      _setInternalPos(pos, index, value, needsSort) {
        const data = this._data;
        const elem = [index, value];
        if (needsSort) {
          this._sortData();
          data[pos] = elem;
        } else {
          if (data.length) {
            if (data[data.length - 1][0] >= index) {
              data.push(elem);
            } else if (data[0][0] <= index) {
              data.unshift(elem);
            } else {
              const randomIndex = Math.round(data.length / 2);
              this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
            }
          } else {
            this._data.push(elem);
          }
          this._changedData = true;
          this._changedLength = true;
        }
      }
      _unsetInternalPos(pos) {
        this._data.splice(pos, 1);
      }
      _sortData() {
        if (this._changedData) {
          this._data.sort(sortInternal);
        }
        this._changedData = false;
      }
      bitField() {
        const bytes2 = [];
        let pendingBitsForResultingByte = 8;
        let pendingBitsForNewByte = 0;
        let resultingByte = 0;
        let newByte;
        const pending = this._bitArrays.slice();
        while (pending.length || pendingBitsForNewByte) {
          if (pendingBitsForNewByte === 0) {
            newByte = pending.shift();
            pendingBitsForNewByte = 7;
          }
          const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
          const mask = ~(255 << usingBits);
          const masked = newByte & mask;
          resultingByte |= masked << 8 - pendingBitsForResultingByte;
          newByte = newByte >>> usingBits;
          pendingBitsForNewByte -= usingBits;
          pendingBitsForResultingByte -= usingBits;
          if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
            bytes2.push(resultingByte);
            resultingByte = 0;
            pendingBitsForResultingByte = 8;
          }
        }
        for (var i = bytes2.length - 1; i > 0; i--) {
          const value = bytes2[i];
          if (value === 0) {
            bytes2.pop();
          } else {
            break;
          }
        }
        return bytes2;
      }
      compactArray() {
        this._sortData();
        return this._data.map(valueOnly);
      }
    };
    function popCountReduce(count, byte) {
      return count + popCount(byte);
    }
    function popCount(_v) {
      let v = _v;
      v = v - (v >> 1 & 1431655765);
      v = (v & 858993459) + (v >> 2 & 858993459);
      return (v + (v >> 4) & 252645135) * 16843009 >> 24;
    }
    function sortInternal(a, b) {
      return a[0] - b[0];
    }
    function valueOnly(elem) {
      return elem[1];
    }
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/bases/identity.js
var identity_exports4 = {};
__export(identity_exports4, {
  identity: () => identity4
});
var identity4;
var init_identity4 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/bases/identity.js"() {
    init_globals();
    init_base4();
    init_bytes3();
    identity4 = from3({
      prefix: "\0",
      name: "identity",
      encode: (buf3) => toString4(buf3),
      decode: (str) => fromString4(str)
    });
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base2.js
var base2_exports2 = {};
__export(base2_exports2, {
  base2: () => base22
});
var base22;
var init_base22 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base2.js"() {
    init_globals();
    init_base4();
    base22 = rfc46482({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base8.js
var base8_exports2 = {};
__export(base8_exports2, {
  base8: () => base82
});
var base82;
var init_base82 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base8.js"() {
    init_globals();
    init_base4();
    base82 = rfc46482({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base10.js
var base10_exports2 = {};
__export(base10_exports2, {
  base10: () => base102
});
var base102;
var init_base102 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base10.js"() {
    init_globals();
    init_base4();
    base102 = baseX2({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base16.js
var base16_exports2 = {};
__export(base16_exports2, {
  base16: () => base162,
  base16upper: () => base16upper2
});
var base162, base16upper2;
var init_base162 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base16.js"() {
    init_globals();
    init_base4();
    base162 = rfc46482({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper2 = rfc46482({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base36.js
var base36_exports2 = {};
__export(base36_exports2, {
  base36: () => base362,
  base36upper: () => base36upper2
});
var base362, base36upper2;
var init_base362 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base36.js"() {
    init_globals();
    init_base4();
    base362 = baseX2({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper2 = baseX2({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base64.js
var base64_exports2 = {};
__export(base64_exports2, {
  base64: () => base642,
  base64pad: () => base64pad2,
  base64url: () => base64url2,
  base64urlpad: () => base64urlpad2
});
var base642, base64pad2, base64url2, base64urlpad2;
var init_base642 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/bases/base64.js"() {
    init_globals();
    init_base4();
    base642 = rfc46482({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad2 = rfc46482({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url2 = rfc46482({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad2 = rfc46482({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/hashes/hasher.js
var from4, Hasher2;
var init_hasher2 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_globals();
    init_digest2();
    from4 = ({ name: name10, code: code13, encode: encode19 }) => new Hasher2(name10, code13, encode19);
    Hasher2 = class {
      constructor(name10, code13, encode19) {
        this.name = name10;
        this.code = code13;
        this.encode = encode19;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create8(this.code, result) : result.then((digest3) => create8(this.code, digest3));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports2 = {};
__export(sha2_browser_exports2, {
  sha256: () => sha2562,
  sha512: () => sha5122
});
var sha2, sha2562, sha5122;
var init_sha2_browser2 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
    init_globals();
    init_hasher2();
    sha2 = (name10) => async (data) => new Uint8Array(await crypto.subtle.digest(name10, data));
    sha2562 = from4({
      name: "sha2-256",
      code: 18,
      encode: sha2("SHA-256")
    });
    sha5122 = from4({
      name: "sha2-512",
      code: 19,
      encode: sha2("SHA-512")
    });
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/codecs/json.js
var textEncoder8, textDecoder6;
var init_json2 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/codecs/json.js"() {
    init_globals();
    textEncoder8 = new TextEncoder();
    textDecoder6 = new TextDecoder();
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/index.js
var init_src7 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/index.js"() {
    init_globals();
    init_cid2();
    init_varint4();
    init_bytes3();
    init_hasher2();
    init_digest2();
  }
});

// js-ipfs-fetch/node_modules/multiformats/esm/src/basics.js
var bases2, hashes2;
var init_basics2 = __esm({
  "js-ipfs-fetch/node_modules/multiformats/esm/src/basics.js"() {
    init_globals();
    init_identity4();
    init_base22();
    init_base82();
    init_base102();
    init_base162();
    init_base322();
    init_base362();
    init_base582();
    init_base642();
    init_sha2_browser2();
    init_identity3();
    init_raw2();
    init_json2();
    init_src7();
    bases2 = {
      ...identity_exports4,
      ...base2_exports2,
      ...base8_exports2,
      ...base10_exports2,
      ...base16_exports2,
      ...base32_exports2,
      ...base36_exports2,
      ...base58_exports2,
      ...base64_exports2
    };
    hashes2 = {
      ...sha2_browser_exports2,
      ...identity_exports3
    };
  }
});

// js-ipfs-fetch/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec2(name10, prefix, encode19, decode22) {
  return {
    name: name10,
    prefix,
    encoder: {
      name: name10,
      prefix,
      encode: encode19
    },
    decoder: { decode: decode22 }
  };
}
var string2, ascii2, BASES2, bases_default2;
var init_bases2 = __esm({
  "js-ipfs-fetch/node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_globals();
    init_basics2();
    string2 = createCodec2("utf8", "u", (buf3) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf3);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    ascii2 = createCodec2("ascii", "a", (buf3) => {
      let string3 = "a";
      for (let i = 0; i < buf3.length; i++) {
        string3 += String.fromCharCode(buf3[i]);
      }
      return string3;
    }, (str) => {
      str = str.substring(1);
      const buf3 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        buf3[i] = str.charCodeAt(i);
      }
      return buf3;
    });
    BASES2 = {
      utf8: string2,
      "utf-8": string2,
      hex: bases2.base16,
      latin1: ascii2,
      ascii: ascii2,
      binary: ascii2,
      ...bases2
    };
    bases_default2 = BASES2;
  }
});

// js-ipfs-fetch/node_modules/uint8arrays/esm/src/from-string.js
var from_string_exports2 = {};
__export(from_string_exports2, {
  fromString: () => fromString6
});
function fromString6(string3, encoding = "utf8") {
  const base4 = bases_default2[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base4.decoder.decode(`${base4.prefix}${string3}`);
}
var init_from_string2 = __esm({
  "js-ipfs-fetch/node_modules/uint8arrays/esm/src/from-string.js"() {
    init_globals();
    init_bases2();
  }
});

// js-ipfs-fetch/node_modules/hamt-sharding/src/bucket.js
var require_bucket2 = __commonJS({
  "js-ipfs-fetch/node_modules/hamt-sharding/src/bucket.js"(exports2, module2) {
    "use strict";
    init_globals();
    var SparseArray = require_sparse_array2();
    var { fromString: uint8ArrayFromString } = (init_from_string2(), __toCommonJS(from_string_exports2));
    var Bucket6 = class {
      constructor(options, parent2, posAtParent = 0) {
        this._options = options;
        this._popCount = 0;
        this._parent = parent2;
        this._posAtParent = posAtParent;
        this._children = new SparseArray();
        this.key = null;
      }
      async put(key, value) {
        const place = await this._findNewBucketAndPos(key);
        await place.bucket._putAt(place, key, value);
      }
      async get(key) {
        const child = await this._findChild(key);
        if (child) {
          return child.value;
        }
      }
      async del(key) {
        const place = await this._findPlace(key);
        const child = place.bucket._at(place.pos);
        if (child && child.key === key) {
          place.bucket._delAt(place.pos);
        }
      }
      leafCount() {
        const children = this._children.compactArray();
        return children.reduce((acc, child) => {
          if (child instanceof Bucket6) {
            return acc + child.leafCount();
          }
          return acc + 1;
        }, 0);
      }
      childrenCount() {
        return this._children.length;
      }
      onlyChild() {
        return this._children.get(0);
      }
      *eachLeafSeries() {
        const children = this._children.compactArray();
        for (const child of children) {
          if (child instanceof Bucket6) {
            yield* child.eachLeafSeries();
          } else {
            yield child;
          }
        }
        return [];
      }
      serialize(map12, reduce2) {
        const acc = [];
        return reduce2(this._children.reduce((acc2, child, index) => {
          if (child) {
            if (child instanceof Bucket6) {
              acc2.push(child.serialize(map12, reduce2));
            } else {
              acc2.push(map12(child, index));
            }
          }
          return acc2;
        }, acc));
      }
      asyncTransform(asyncMap, asyncReduce) {
        return asyncTransformBucket(this, asyncMap, asyncReduce);
      }
      toJSON() {
        return this.serialize(mapNode, reduceNodes);
      }
      prettyPrint() {
        return JSON.stringify(this.toJSON(), null, "  ");
      }
      tableSize() {
        return Math.pow(2, this._options.bits);
      }
      async _findChild(key) {
        const result = await this._findPlace(key);
        const child = result.bucket._at(result.pos);
        if (child instanceof Bucket6) {
          return void 0;
        }
        if (child && child.key === key) {
          return child;
        }
      }
      async _findPlace(key) {
        const hashValue = this._options.hash(typeof key === "string" ? uint8ArrayFromString(key) : key);
        const index = await hashValue.take(this._options.bits);
        const child = this._children.get(index);
        if (child instanceof Bucket6) {
          return child._findPlace(hashValue);
        }
        return {
          bucket: this,
          pos: index,
          hash: hashValue,
          existingChild: child
        };
      }
      async _findNewBucketAndPos(key) {
        const place = await this._findPlace(key);
        if (place.existingChild && place.existingChild.key !== key) {
          const bucket = new Bucket6(this._options, place.bucket, place.pos);
          place.bucket._putObjectAt(place.pos, bucket);
          const newPlace = await bucket._findPlace(place.existingChild.hash);
          newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
          return bucket._findNewBucketAndPos(place.hash);
        }
        return place;
      }
      _putAt(place, key, value) {
        this._putObjectAt(place.pos, {
          key,
          value,
          hash: place.hash
        });
      }
      _putObjectAt(pos, object) {
        if (!this._children.get(pos)) {
          this._popCount++;
        }
        this._children.set(pos, object);
      }
      _delAt(pos) {
        if (pos === -1) {
          throw new Error("Invalid position");
        }
        if (this._children.get(pos)) {
          this._popCount--;
        }
        this._children.unset(pos);
        this._level();
      }
      _level() {
        if (this._parent && this._popCount <= 1) {
          if (this._popCount === 1) {
            const onlyChild = this._children.find(exists);
            if (onlyChild && !(onlyChild instanceof Bucket6)) {
              const hash2 = onlyChild.hash;
              hash2.untake(this._options.bits);
              const place = {
                pos: this._posAtParent,
                hash: hash2,
                bucket: this._parent
              };
              this._parent._putAt(place, onlyChild.key, onlyChild.value);
            }
          } else {
            this._parent._delAt(this._posAtParent);
          }
        }
      }
      _at(index) {
        return this._children.get(index);
      }
    };
    function exists(o) {
      return Boolean(o);
    }
    function mapNode(node, index) {
      return node.key;
    }
    function reduceNodes(nodes) {
      return nodes;
    }
    async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
      const output = [];
      for (const child of bucket._children.compactArray()) {
        if (child instanceof Bucket6) {
          await asyncTransformBucket(child, asyncMap, asyncReduce);
        } else {
          const mappedChildren = await asyncMap(child);
          output.push({
            bitField: bucket._children.bitField(),
            children: mappedChildren
          });
        }
      }
      return asyncReduce(output);
    }
    module2.exports = Bucket6;
  }
});

// js-ipfs-fetch/node_modules/hamt-sharding/src/consumable-buffer.js
var require_consumable_buffer2 = __commonJS({
  "js-ipfs-fetch/node_modules/hamt-sharding/src/consumable-buffer.js"(exports2, module2) {
    "use strict";
    init_globals();
    var START_MASKS = [
      255,
      254,
      252,
      248,
      240,
      224,
      192,
      128
    ];
    var STOP_MASKS = [
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255
    ];
    module2.exports = class ConsumableBuffer {
      constructor(value) {
        this._value = value;
        this._currentBytePos = value.length - 1;
        this._currentBitPos = 7;
      }
      availableBits() {
        return this._currentBitPos + 1 + this._currentBytePos * 8;
      }
      totalBits() {
        return this._value.length * 8;
      }
      take(bits) {
        let pendingBits = bits;
        let result = 0;
        while (pendingBits && this._haveBits()) {
          const byte = this._value[this._currentBytePos];
          const availableBits = this._currentBitPos + 1;
          const taking = Math.min(availableBits, pendingBits);
          const value = byteBitsToInt(byte, availableBits - taking, taking);
          result = (result << taking) + value;
          pendingBits -= taking;
          this._currentBitPos -= taking;
          if (this._currentBitPos < 0) {
            this._currentBitPos = 7;
            this._currentBytePos--;
          }
        }
        return result;
      }
      untake(bits) {
        this._currentBitPos += bits;
        while (this._currentBitPos > 7) {
          this._currentBitPos -= 8;
          this._currentBytePos += 1;
        }
      }
      _haveBits() {
        return this._currentBytePos >= 0;
      }
    };
    function byteBitsToInt(byte, start, length5) {
      const mask = maskFor(start, length5);
      return (byte & mask) >>> start;
    }
    function maskFor(start, length5) {
      return START_MASKS[start] & STOP_MASKS[Math.min(length5 + start - 1, 7)];
    }
  }
});

// js-ipfs-fetch/node_modules/uint8arrays/esm/src/concat.js
var concat_exports2 = {};
__export(concat_exports2, {
  concat: () => concat4
});
function concat4(arrays, length5) {
  if (!length5) {
    length5 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = new Uint8Array(length5);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return output;
}
var init_concat2 = __esm({
  "js-ipfs-fetch/node_modules/uint8arrays/esm/src/concat.js"() {
    init_globals();
  }
});

// js-ipfs-fetch/node_modules/hamt-sharding/src/consumable-hash.js
var require_consumable_hash2 = __commonJS({
  "js-ipfs-fetch/node_modules/hamt-sharding/src/consumable-hash.js"(exports2, module2) {
    "use strict";
    init_globals();
    var ConsumableBuffer = require_consumable_buffer2();
    var { concat: uint8ArrayConcat } = (init_concat2(), __toCommonJS(concat_exports2));
    function wrapHash(hashFn3) {
      function hashing(value) {
        if (value instanceof InfiniteHash) {
          return value;
        } else {
          return new InfiniteHash(value, hashFn3);
        }
      }
      return hashing;
    }
    var InfiniteHash = class {
      constructor(value, hashFn3) {
        if (!(value instanceof Uint8Array)) {
          throw new Error("can only hash Uint8Arrays");
        }
        this._value = value;
        this._hashFn = hashFn3;
        this._depth = -1;
        this._availableBits = 0;
        this._currentBufferIndex = 0;
        this._buffers = [];
      }
      async take(bits) {
        let pendingBits = bits;
        while (this._availableBits < pendingBits) {
          await this._produceMoreBits();
        }
        let result = 0;
        while (pendingBits > 0) {
          const hash2 = this._buffers[this._currentBufferIndex];
          const available = Math.min(hash2.availableBits(), pendingBits);
          const took = hash2.take(available);
          result = (result << available) + took;
          pendingBits -= available;
          this._availableBits -= available;
          if (hash2.availableBits() === 0) {
            this._currentBufferIndex++;
          }
        }
        return result;
      }
      untake(bits) {
        let pendingBits = bits;
        while (pendingBits > 0) {
          const hash2 = this._buffers[this._currentBufferIndex];
          const availableForUntake = Math.min(hash2.totalBits() - hash2.availableBits(), pendingBits);
          hash2.untake(availableForUntake);
          pendingBits -= availableForUntake;
          this._availableBits += availableForUntake;
          if (this._currentBufferIndex > 0 && hash2.totalBits() === hash2.availableBits()) {
            this._depth--;
            this._currentBufferIndex--;
          }
        }
      }
      async _produceMoreBits() {
        this._depth++;
        const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;
        const hashValue = await this._hashFn(value);
        const buffer3 = new ConsumableBuffer(hashValue);
        this._buffers.push(buffer3);
        this._availableBits += buffer3.availableBits();
      }
    };
    module2.exports = wrapHash;
    module2.exports.InfiniteHash = InfiniteHash;
  }
});

// js-ipfs-fetch/node_modules/hamt-sharding/src/index.js
var require_src29 = __commonJS({
  "js-ipfs-fetch/node_modules/hamt-sharding/src/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var Bucket6 = require_bucket2();
    var wrapHash = require_consumable_hash2();
    function createHAMT6(options) {
      if (!options || !options.hashFn) {
        throw new Error("please define an options.hashFn");
      }
      const bucketOptions = {
        bits: options.bits || 8,
        hash: wrapHash(options.hashFn)
      };
      return new Bucket6(bucketOptions);
    }
    module2.exports = {
      createHAMT: createHAMT6,
      Bucket: Bucket6
    };
  }
});

// js-ipfs-fetch/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js2 = __commonJS({
  "js-ipfs-fetch/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports2, module2) {
    init_globals();
    (function(root, undefined2) {
      "use strict";
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes2) {
        if (!Array.isArray(bytes2) && !ArrayBuffer.isView(bytes2)) {
          return false;
        }
        for (var i = 0; i < bytes2.length; i++) {
          if (!Number.isInteger(bytes2[i]) || bytes2[i] < 0 || bytes2[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m, n) {
        return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
      }
      function _x86Rotl(m, n) {
        return m << n | m >>> 32 - n;
      }
      function _x86Fmix(h) {
        h ^= h >>> 16;
        h = _x86Multiply(h, 2246822507);
        h ^= h >>> 13;
        h = _x86Multiply(h, 3266489909);
        h ^= h >>> 16;
        return h;
      }
      function _x64Add(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] + n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Multiply(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Rotl(m, n) {
        n %= 64;
        if (n === 32) {
          return [m[1], m[0]];
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
        } else {
          n -= 32;
          return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
        }
      }
      function _x64LeftShift(m, n) {
        n %= 64;
        if (n === 0) {
          return m;
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
        } else {
          return [m[1] << n - 32, 0];
        }
      }
      function _x64Xor(m, n) {
        return [m[0] ^ n[0], m[1] ^ n[1]];
      }
      function _x64Fmix(h) {
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [4283543511, 3981806797]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [3301882366, 444984403]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        return h;
      }
      library.x86.hash32 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 4;
        var blocks = bytes2.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i = 0; i < blocks; i = i + 4) {
          k1 = bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes2[i + 2] << 16;
          case 2:
            k1 ^= bytes2[i + 1] << 8;
          case 1:
            k1 ^= bytes2[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24;
          k2 = bytes2[i + 4] | bytes2[i + 5] << 8 | bytes2[i + 6] << 16 | bytes2[i + 7] << 24;
          k3 = bytes2[i + 8] | bytes2[i + 9] << 8 | bytes2[i + 10] << 16 | bytes2[i + 11] << 24;
          k4 = bytes2[i + 12] | bytes2[i + 13] << 8 | bytes2[i + 14] << 16 | bytes2[i + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes2[i + 14] << 16;
          case 14:
            k4 ^= bytes2[i + 13] << 8;
          case 13:
            k4 ^= bytes2[i + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes2[i + 11] << 24;
          case 11:
            k3 ^= bytes2[i + 10] << 16;
          case 10:
            k3 ^= bytes2[i + 9] << 8;
          case 9:
            k3 ^= bytes2[i + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes2[i + 7] << 24;
          case 7:
            k2 ^= bytes2[i + 6] << 16;
          case 6:
            k2 ^= bytes2[i + 5] << 8;
          case 5:
            k2 ^= bytes2[i + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes2[i + 3] << 24;
          case 3:
            k1 ^= bytes2[i + 2] << 16;
          case 2:
            k1 ^= bytes2[i + 1] << 8;
          case 1:
            k1 ^= bytes2[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes2.length;
        h2 ^= bytes2.length;
        h3 ^= bytes2.length;
        h4 ^= bytes2.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes2, seed) {
        if (library.inputValidation && !_validBytes(bytes2)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes2.length % 16;
        var blocks = bytes2.length - remainder;
        var h1 = [0, seed];
        var h2 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = [bytes2[i + 4] | bytes2[i + 5] << 8 | bytes2[i + 6] << 16 | bytes2[i + 7] << 24, bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24];
          k2 = [bytes2[i + 12] | bytes2[i + 13] << 8 | bytes2[i + 14] << 16 | bytes2[i + 15] << 24, bytes2[i + 8] | bytes2[i + 9] << 8 | bytes2[i + 10] << 16 | bytes2[i + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes2[i + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes2[i]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes2.length]);
        h2 = _x64Xor(h2, [0, bytes2.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports2 !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports2 = module2.exports = library;
        }
        exports2.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
          root.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root.murmurHash3 = library;
      }
    })(exports2);
  }
});

// js-ipfs-fetch/node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited2 = __commonJS({
  "js-ipfs-fetch/node_modules/murmurhash3js-revisited/index.js"(exports2, module2) {
    init_globals();
    module2.exports = require_murmurHash3js2();
  }
});

// js-ipfs-fetch/node_modules/@multiformats/murmur3/esm/index.js
function fromNumberTo32BitBuf2(number) {
  const bytes2 = new Array(4);
  for (let i = 0; i < 4; i++) {
    bytes2[i] = number & 255;
    number = number >> 8;
  }
  return new Uint8Array(bytes2);
}
var import_murmurhash3js_revisited2, murmur3322, murmur31282;
var init_esm3 = __esm({
  "js-ipfs-fetch/node_modules/@multiformats/murmur3/esm/index.js"() {
    init_globals();
    init_hasher2();
    init_src7();
    import_murmurhash3js_revisited2 = __toESM(require_murmurhash3js_revisited2(), 1);
    murmur3322 = from4({
      name: "murmur3-32",
      code: 35,
      encode: (input) => fromNumberTo32BitBuf2(import_murmurhash3js_revisited2.default.x86.hash32(input))
    });
    murmur31282 = from4({
      name: "murmur3-128",
      code: 34,
      encode: (input) => bytes_exports3.fromHex(import_murmurhash3js_revisited2.default.x64.hash128(input))
    });
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js
var import_hamt_sharding5, hashFn2, addLinksToHamtBucket3, toPrefix3, toBucketPath3, findShardCid2, find_cid_in_shard_default2;
var init_find_cid_in_shard = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js"() {
    init_globals();
    import_hamt_sharding5 = __toESM(require_src29(), 1);
    init_src5();
    init_esm3();
    hashFn2 = async function(buf3) {
      return (await murmur31282.encode(buf3)).slice(0, 8).reverse();
    };
    addLinksToHamtBucket3 = (links3, bucket, rootBucket) => {
      return Promise.all(links3.map((link) => {
        if (link.Name == null) {
          throw new Error("Unexpected Link without a Name");
        }
        if (link.Name.length === 2) {
          const pos = parseInt(link.Name, 16);
          return bucket._putObjectAt(pos, new import_hamt_sharding5.Bucket({
            hash: rootBucket._options.hash,
            bits: rootBucket._options.bits
          }, bucket, pos));
        }
        return rootBucket.put(link.Name.substring(2), true);
      }));
    };
    toPrefix3 = (position) => {
      return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
    };
    toBucketPath3 = (position) => {
      let bucket = position.bucket;
      const path = [];
      while (bucket._parent) {
        path.push(bucket);
        bucket = bucket._parent;
      }
      path.push(bucket);
      return path.reverse();
    };
    findShardCid2 = async (node, name10, blockstore, context, options) => {
      if (!context) {
        const rootBucket = (0, import_hamt_sharding5.createHAMT)({ hashFn: hashFn2 });
        context = {
          rootBucket,
          hamtDepth: 1,
          lastBucket: rootBucket
        };
      }
      await addLinksToHamtBucket3(node.Links, context.lastBucket, context.rootBucket);
      const position = await context.rootBucket._findNewBucketAndPos(name10);
      let prefix = toPrefix3(position.pos);
      const bucketPath = toBucketPath3(position);
      if (bucketPath.length > context.hamtDepth) {
        context.lastBucket = bucketPath[context.hamtDepth];
        prefix = toPrefix3(context.lastBucket._posAtParent);
      }
      const link = node.Links.find((link2) => {
        if (link2.Name == null) {
          return false;
        }
        const entryPrefix = link2.Name.substring(0, 2);
        const entryName = link2.Name.substring(2);
        if (entryPrefix !== prefix) {
          return false;
        }
        if (entryName && entryName !== name10) {
          return false;
        }
        return true;
      });
      if (!link) {
        return null;
      }
      if (link.Name != null && link.Name.substring(2) === name10) {
        return link.Hash;
      }
      context.hamtDepth++;
      const block = await blockstore.get(link.Hash, options);
      node = decode19(block);
      return findShardCid2(node, name10, blockstore, context, options);
    };
    find_cid_in_shard_default2 = findShardCid2;
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/utils/extract-data-from-block.js
function extractDataFromBlock2(block, blockStart, requestedStart, requestedEnd) {
  const blockLength = block.length;
  const blockEnd = blockStart + blockLength;
  if (requestedStart >= blockEnd || requestedEnd < blockStart) {
    return new Uint8Array(0);
  }
  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
    block = block.slice(0, requestedEnd - blockStart);
  }
  if (requestedStart >= blockStart && requestedStart < blockEnd) {
    block = block.slice(requestedStart - blockStart);
  }
  return block;
}
var extract_data_from_block_default2;
var init_extract_data_from_block = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/utils/extract-data-from-block.js"() {
    init_globals();
    extract_data_from_block_default2 = extractDataFromBlock2;
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/utils/validate-offset-and-length.js
var import_err_code76, validateOffsetAndLength2, validate_offset_and_length_default2;
var init_validate_offset_and_length = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/utils/validate-offset-and-length.js"() {
    init_globals();
    import_err_code76 = __toESM(require_err_code3(), 1);
    validateOffsetAndLength2 = (size, offset, length5) => {
      if (!offset) {
        offset = 0;
      }
      if (offset < 0) {
        throw (0, import_err_code76.default)(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
      }
      if (offset > size) {
        throw (0, import_err_code76.default)(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
      }
      if (!length5 && length5 !== 0) {
        length5 = size - offset;
      }
      if (length5 < 0) {
        throw (0, import_err_code76.default)(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
      }
      if (offset + length5 > size) {
        length5 = size - offset;
      }
      return {
        offset,
        length: length5
      };
    };
    validate_offset_and_length_default2 = validateOffsetAndLength2;
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js
async function* emitBytes2(blockstore, node, start, end, streamPosition = 0, options) {
  if (node instanceof Uint8Array) {
    const buf3 = extract_data_from_block_default2(node, streamPosition, start, end);
    if (buf3.length) {
      yield buf3;
    }
    streamPosition += buf3.length;
    return streamPosition;
  }
  if (node.Data == null) {
    throw (0, import_err_code77.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  let file;
  try {
    file = UnixFS2.unmarshal(node.Data);
  } catch (err) {
    throw (0, import_err_code77.default)(err, "ERR_NOT_UNIXFS");
  }
  if (file.data && file.data.length) {
    const buf3 = extract_data_from_block_default2(file.data, streamPosition, start, end);
    if (buf3.length) {
      yield buf3;
    }
    streamPosition += file.data.length;
  }
  let childStart = streamPosition;
  for (let i = 0; i < node.Links.length; i++) {
    const childLink = node.Links[i];
    const childEnd = streamPosition + file.blockSizes[i];
    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {
      const block = await blockstore.get(childLink.Hash, { signal: options.signal });
      let child;
      switch (childLink.Hash.code) {
        case code9:
          child = await decode19(block);
          break;
        case code11:
          child = block;
          break;
        case code10:
          child = await decode21(block);
          break;
        default:
          throw Error(`Unsupported codec: ${childLink.Hash.code}`);
      }
      for await (const buf3 of emitBytes2(blockstore, child, start, end, streamPosition, options)) {
        streamPosition += buf3.length;
        yield buf3;
      }
    }
    streamPosition = childEnd;
    childStart = childEnd + 1;
  }
}
var import_err_code77, fileContent2, file_default3;
var init_file = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js"() {
    init_globals();
    init_extract_data_from_block();
    init_validate_offset_and_length();
    init_src6();
    import_err_code77 = __toESM(require_err_code3(), 1);
    init_src5();
    init_esm2();
    init_raw2();
    fileContent2 = (cid, node, unixfs, path, resolve11, depth, blockstore) => {
      function yieldFileContent(options = {}) {
        const fileSize = unixfs.fileSize();
        if (fileSize === void 0) {
          throw new Error("File was a directory");
        }
        const { offset, length: length5 } = validate_offset_and_length_default2(fileSize, options.offset, options.length);
        const start = offset;
        const end = offset + length5;
        return emitBytes2(blockstore, node, start, end, 0, options);
      }
      return yieldFileContent;
    };
    file_default3 = fileContent2;
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/directory.js
var directoryContent2, directory_default2;
var init_directory = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/directory.js"() {
    init_globals();
    directoryContent2 = (cid, node, unixfs, path, resolve11, depth, blockstore) => {
      async function* yieldDirectoryContent(options = {}) {
        const offset = options.offset || 0;
        const length5 = options.length || node.Links.length;
        const links3 = node.Links.slice(offset, length5);
        for (const link of links3) {
          const result = await resolve11(link.Hash, link.Name || "", `${path}/${link.Name || ""}`, [], depth + 1, blockstore, options);
          if (result.entry) {
            yield result.entry;
          }
        }
      }
      return yieldDirectoryContent;
    };
    directory_default2 = directoryContent2;
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js
async function* listDirectory2(node, path, resolve11, depth, blockstore, options) {
  const links3 = node.Links;
  for (const link of links3) {
    const name10 = link.Name != null ? link.Name.substring(2) : null;
    if (name10) {
      const result = await resolve11(link.Hash, name10, `${path}/${name10}`, [], depth + 1, blockstore, options);
      yield result.entry;
    } else {
      const block = await blockstore.get(link.Hash);
      node = decode19(block);
      for await (const file of listDirectory2(node, path, resolve11, depth, blockstore, options)) {
        yield file;
      }
    }
  }
}
var hamtShardedDirectoryContent2, hamt_sharded_directory_default2;
var init_hamt_sharded_directory = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js"() {
    init_globals();
    init_src5();
    hamtShardedDirectoryContent2 = (cid, node, unixfs, path, resolve11, depth, blockstore) => {
      function yieldHamtDirectoryContent(options = {}) {
        return listDirectory2(node, path, resolve11, depth, blockstore, options);
      }
      return yieldHamtDirectoryContent;
    };
    hamt_sharded_directory_default2 = hamtShardedDirectoryContent2;
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js
var import_err_code78, findLinkCid2, contentExporters2, unixFsResolver2, unixfs_v1_default2;
var init_unixfs_v1 = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js"() {
    init_globals();
    import_err_code78 = __toESM(require_err_code3(), 1);
    init_src6();
    init_find_cid_in_shard();
    init_src5();
    init_file();
    init_directory();
    init_hamt_sharded_directory();
    findLinkCid2 = (node, name10) => {
      const link = node.Links.find((link2) => link2.Name === name10);
      return link && link.Hash;
    };
    contentExporters2 = {
      raw: file_default3,
      file: file_default3,
      directory: directory_default2,
      "hamt-sharded-directory": hamt_sharded_directory_default2,
      metadata: (cid, node, unixfs, path, resolve11, depth, blockstore) => {
        return () => [];
      },
      symlink: (cid, node, unixfs, path, resolve11, depth, blockstore) => {
        return () => [];
      }
    };
    unixFsResolver2 = async (cid, name10, path, toResolve, resolve11, depth, blockstore, options) => {
      const block = await blockstore.get(cid, options);
      const node = decode19(block);
      let unixfs;
      let next;
      if (!name10) {
        name10 = cid.toString();
      }
      if (node.Data == null) {
        throw (0, import_err_code78.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
      }
      try {
        unixfs = UnixFS2.unmarshal(node.Data);
      } catch (err) {
        throw (0, import_err_code78.default)(err, "ERR_NOT_UNIXFS");
      }
      if (!path) {
        path = name10;
      }
      if (toResolve.length) {
        let linkCid;
        if (unixfs && unixfs.type === "hamt-sharded-directory") {
          linkCid = await find_cid_in_shard_default2(node, toResolve[0], blockstore);
        } else {
          linkCid = findLinkCid2(node, toResolve[0]);
        }
        if (!linkCid) {
          throw (0, import_err_code78.default)(new Error("file does not exist"), "ERR_NOT_FOUND");
        }
        const nextName = toResolve.shift();
        const nextPath = `${path}/${nextName}`;
        next = {
          cid: linkCid,
          toResolve,
          name: nextName || "",
          path: nextPath
        };
      }
      return {
        entry: {
          type: unixfs.isDirectory() ? "directory" : "file",
          name: name10,
          path,
          cid,
          content: contentExporters2[unixfs.type](cid, node, unixfs, path, resolve11, depth, blockstore),
          unixfs,
          depth,
          node,
          size: unixfs.fileSize()
        },
        next
      };
    };
    unixfs_v1_default2 = unixFsResolver2;
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/raw.js
var import_err_code79, rawContent3, resolve7, raw_default2;
var init_raw3 = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/raw.js"() {
    init_globals();
    import_err_code79 = __toESM(require_err_code3(), 1);
    init_extract_data_from_block();
    init_validate_offset_and_length();
    rawContent3 = (node) => {
      async function* contentGenerator(options = {}) {
        const { offset, length: length5 } = validate_offset_and_length_default2(node.length, options.offset, options.length);
        yield extract_data_from_block_default2(node, 0, offset, offset + length5);
      }
      return contentGenerator;
    };
    resolve7 = async (cid, name10, path, toResolve, resolve11, depth, blockstore, options) => {
      if (toResolve.length) {
        throw (0, import_err_code79.default)(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
      }
      const block = await blockstore.get(cid, options);
      return {
        entry: {
          type: "raw",
          name: name10,
          path,
          cid,
          content: rawContent3(block),
          depth,
          size: block.length,
          node: block
        }
      };
    };
    raw_default2 = resolve7;
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/dag-cbor.js
var import_err_code80, resolve8, dag_cbor_default2;
var init_dag_cbor = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/dag-cbor.js"() {
    init_globals();
    init_cid2();
    import_err_code80 = __toESM(require_err_code3(), 1);
    init_esm2();
    resolve8 = async (cid, name10, path, toResolve, resolve11, depth, blockstore, options) => {
      const block = await blockstore.get(cid);
      const object = decode21(block);
      let subObject = object;
      let subPath = path;
      while (toResolve.length) {
        const prop = toResolve[0];
        if (prop in subObject) {
          toResolve.shift();
          subPath = `${subPath}/${prop}`;
          const subObjectCid = CID2.asCID(subObject[prop]);
          if (subObjectCid) {
            return {
              entry: {
                type: "object",
                name: name10,
                path,
                cid,
                node: block,
                depth,
                size: block.length,
                content: async function* () {
                  yield object;
                }
              },
              next: {
                cid: subObjectCid,
                name: prop,
                path: subPath,
                toResolve
              }
            };
          }
          subObject = subObject[prop];
        } else {
          throw (0, import_err_code80.default)(new Error(`No property named ${prop} found in cbor node ${cid}`), "ERR_NO_PROP");
        }
      }
      return {
        entry: {
          type: "object",
          name: name10,
          path,
          cid,
          node: block,
          depth,
          size: block.length,
          content: async function* () {
            yield object;
          }
        }
      };
    };
    dag_cbor_default2 = resolve8;
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/identity.js
var import_err_code81, rawContent4, resolve9, identity_default2;
var init_identity5 = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/identity.js"() {
    init_globals();
    import_err_code81 = __toESM(require_err_code3(), 1);
    init_extract_data_from_block();
    init_validate_offset_and_length();
    init_digest2();
    rawContent4 = (node) => {
      async function* contentGenerator(options = {}) {
        const { offset, length: length5 } = validate_offset_and_length_default2(node.length, options.offset, options.length);
        yield extract_data_from_block_default2(node, 0, offset, offset + length5);
      }
      return contentGenerator;
    };
    resolve9 = async (cid, name10, path, toResolve, resolve11, depth, blockstore, options) => {
      if (toResolve.length) {
        throw (0, import_err_code81.default)(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
      }
      const buf3 = await decode17(cid.multihash.bytes);
      return {
        entry: {
          type: "identity",
          name: name10,
          path,
          cid,
          content: rawContent4(buf3.digest),
          depth,
          size: buf3.digest.length,
          node: buf3.digest
        }
      };
    };
    identity_default2 = resolve9;
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/index.js
function resolve10(cid, name10, path, toResolve, depth, blockstore, options) {
  const resolver = resolvers2[cid.code];
  if (!resolver) {
    throw (0, import_err_code82.default)(new Error(`No resolver for code ${cid.code}`), "ERR_NO_RESOLVER");
  }
  return resolver(cid, name10, path, toResolve, resolve10, depth, blockstore, options);
}
var import_err_code82, resolvers2, resolvers_default2;
var init_resolvers = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/index.js"() {
    init_globals();
    import_err_code82 = __toESM(require_err_code3(), 1);
    init_src5();
    init_esm2();
    init_raw2();
    init_identity3();
    init_unixfs_v1();
    init_raw3();
    init_dag_cbor();
    init_identity5();
    resolvers2 = {
      [code9]: unixfs_v1_default2,
      [code11]: raw_default2,
      [code10]: dag_cbor_default2,
      [identity3.code]: identity_default2
    };
    resolvers_default2 = resolve10;
  }
});

// js-ipfs-fetch/node_modules/it-last/index.js
var require_it_last2 = __commonJS({
  "js-ipfs-fetch/node_modules/it-last/index.js"(exports2, module2) {
    "use strict";
    init_globals();
    var last15 = async (source) => {
      let res;
      for await (const entry of source) {
        res = entry;
      }
      return res;
    };
    module2.exports = last15;
  }
});

// js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/index.js
var src_exports9 = {};
__export(src_exports9, {
  exporter: () => exporter2,
  recursive: () => recursive2,
  walkPath: () => walkPath2
});
async function* walkPath2(path, blockstore, options = {}) {
  let { cid, toResolve } = cidAndRest2(path);
  let name10 = cid.toString();
  let entryPath = name10;
  const startingDepth = toResolve.length;
  while (true) {
    const result = await resolvers_default2(cid, name10, entryPath, toResolve, startingDepth, blockstore, options);
    if (!result.entry && !result.next) {
      throw (0, import_err_code83.default)(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
    }
    if (result.entry) {
      yield result.entry;
    }
    if (!result.next) {
      return;
    }
    toResolve = result.next.toResolve;
    cid = result.next.cid;
    name10 = result.next.name;
    entryPath = result.next.path;
  }
}
async function exporter2(path, blockstore, options = {}) {
  const result = await (0, import_it_last14.default)(walkPath2(path, blockstore, options));
  if (!result) {
    throw (0, import_err_code83.default)(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
  }
  return result;
}
async function* recursive2(path, blockstore, options = {}) {
  const node = await exporter2(path, blockstore, options);
  if (!node) {
    return;
  }
  yield node;
  if (node.type === "directory") {
    for await (const child of recurse(node, options)) {
      yield child;
    }
  }
  async function* recurse(node2, options2) {
    for await (const file of node2.content(options2)) {
      yield file;
      if (file instanceof Uint8Array) {
        continue;
      }
      if (file.type === "directory") {
        yield* recurse(file, options2);
      }
    }
  }
}
var import_err_code83, import_it_last14, toPathComponents4, cidAndRest2;
var init_src8 = __esm({
  "js-ipfs-fetch/node_modules/ipfs-unixfs-exporter/esm/src/index.js"() {
    init_globals();
    import_err_code83 = __toESM(require_err_code3(), 1);
    init_cid2();
    init_resolvers();
    import_it_last14 = __toESM(require_it_last2(), 1);
    toPathComponents4 = (path = "") => {
      return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
    };
    cidAndRest2 = (path) => {
      if (path instanceof Uint8Array) {
        return {
          cid: CID2.decode(path),
          toResolve: []
        };
      }
      const cid = CID2.asCID(path);
      if (cid) {
        return {
          cid,
          toResolve: []
        };
      }
      if (typeof path === "string") {
        if (path.indexOf("/ipfs/") === 0) {
          path = path.substring(6);
        }
        const output = toPathComponents4(path);
        return {
          cid: CID2.parse(output[0]),
          toResolve: output.slice(1)
        };
      }
      throw (0, import_err_code83.default)(new Error(`Unknown path type ${path}`), "ERR_BAD_PATH");
    };
  }
});

// js-ipfs-fetch/index.js
var require_js_ipfs_fetch = __commonJS({
  "js-ipfs-fetch/index.js"(exports2, module2) {
    init_globals();
    var makeFetch = require_make_fetch();
    var parseRange = require_range_parser();
    var mime = require_lite();
    var { CID: CID3 } = (init_cid2(), __toCommonJS(cid_exports2));
    var { base32: base323 } = (init_base322(), __toCommonJS(base32_exports2));
    var { exporter: exporter3 } = (init_src8(), __toCommonJS(src_exports9));
    var ipfsTimeout = 3e4;
    var ipnsTimeout = 12e4;
    var SUPPORTED_METHODS = ["GET", "HEAD", "POST", "PUT"];
    module2.exports = function makeIPFSFetch({ ipfs: ipfs2 }) {
      return makeFetch(async ({ url, headers: reqHeaders, method, signal, body }) => {
        const { hostname, pathname, protocol, searchParams } = new URL(url);
        let ipfsPath2 = hostname ? hostname + pathname : pathname.slice(1);
        const headers = {};
        headers.Allow = SUPPORTED_METHODS.join(", ");
        async function getStat(path) {
          return exporter3(path, ipfs2.block, { signal, preload: false, timeout: ipfsTimeout });
        }
        async function serveFile(path = ipfsPath2) {
          headers["Accept-Ranges"] = "bytes";
          const isRanged = reqHeaders.Range || reqHeaders.range;
          const file = await getStat(path);
          const { size } = file;
          const mimeName = searchParams.get("filename") || path;
          headers["Content-Type"] = getMimeType(mimeName);
          if (isRanged) {
            const ranges = parseRange(size, isRanged);
            if (ranges && ranges.length && ranges.type === "bytes") {
              const [{ start, end }] = ranges;
              const length5 = end - start + 1;
              headers["Content-Length"] = `${length5}`;
              headers["Content-Range"] = `bytes ${start}-${end}/${size}`;
              return {
                statusCode: 206,
                headers,
                data: ipfs2.cat(path, { signal, offset: start, length: length5, timeout: ipfsTimeout })
              };
            } else {
              headers["Content-Length"] = `${size}`;
              return {
                statusCode: 200,
                headers,
                data: ipfs2.cat(path, { signal, timeout: ipfsTimeout })
              };
            }
          } else {
            headers["Content-Length"] = `${size}`;
            return {
              statusCode: 200,
              headers,
              data: ipfs2.cat(path, { signal, timeout: ipfsTimeout })
            };
          }
        }
        async function resolveIPNS(path) {
          const segments = ensureStartingSlash(path).split(/\/+/);
          let mainSegment = segments[1];
          if (!mainSegment.includes(".")) {
            const keys2 = await ipfs2.key.list({ signal, timeout: ipnsTimeout });
            const keyForName = keys2.find(({ name: name10 }) => name10 === mainSegment);
            if (keyForName) {
              mainSegment = keyForName.id + "/";
            }
          }
          const toResolve = `/ipns${ensureEndingSlash(ensureStartingSlash(mainSegment))}`;
          const resolved = await ipfs2.resolve(toResolve, { signal, timeout: ipnsTimeout });
          return [resolved, ...segments.slice(2)].join("/");
        }
        async function updateIPNS(keyName, value) {
          const keys2 = await ipfs2.key.list({ signal, timeout: ipnsTimeout });
          const existing = keys2.find(({ name: name10, id }) => {
            if (name10 === keyName)
              return true;
            try {
              return CID3.parse(id).toV1().toString(base323) === keyName;
            } catch {
              return false;
            }
          });
          if (!existing) {
            await ipfs2.key.gen(keyName, {
              signal,
              type: "rsa",
              size: 2048,
              timeout: ipnsTimeout
            });
          }
          const finalName = existing ? existing.name : keyName;
          const publish = await ipfs2.name.publish(value, {
            allowOffline: true,
            key: finalName,
            signal,
            timeout: ipnsTimeout
          });
          const { name: cid } = publish;
          const ipnsURL = `ipns://${cid}/`;
          return {
            statusCode: 200,
            headers,
            data: intoAsyncIterable(ipnsURL)
          };
        }
        try {
          if (protocol === "ipfs:" && (method === "POST" || method === "PUT")) {
            const contentType = reqHeaders["Content-Type"] || reqHeaders["content-type"];
            const isFormData = contentType && contentType.includes("multipart/form-data");
            const addedURL = await uploadData(ipfsPath2, body, isFormData);
            return {
              statusCode: 200,
              headers,
              data: intoAsyncIterable(addedURL)
            };
          } else if (method === "HEAD") {
            if (protocol === "ipns:") {
              ipfsPath2 = await resolveIPNS(ipfsPath2);
            }
            const stat = await getStat(ipfsPath2);
            if (stat.type === "directory") {
              if (!searchParams.has("noResolve")) {
                const stats = await collect(ipfs2.ls(ipfsPath2, { signal, timeout: ipfsTimeout }));
                const files = stats.map(({ name: name10, type }) => type === "dir" ? `${name10}/` : name10);
                if (files.includes("index.html")) {
                  ipfsPath2 = posixPath.join(ipfsPath2, "index.html");
                } else {
                  return {
                    statusCode: 200,
                    headers,
                    data: intoAsyncIterable("")
                  };
                }
              }
            }
            const finalStat = await getStat(ipfsPath2);
            const { size } = finalStat;
            const mimeName = searchParams.get("filename") || ipfsPath2;
            headers["Accept-Ranges"] = "bytes";
            headers["Content-Type"] = getMimeType(mimeName);
            headers["Content-Length"] = `${size}`;
            return {
              statusCode: 200,
              headers,
              data: intoAsyncIterable("")
            };
          } else if (method === "GET") {
            if (protocol === "ipns:") {
              ipfsPath2 = await resolveIPNS(ipfsPath2);
            }
            const stat = await getStat(ipfsPath2);
            if (stat.type === "directory") {
              let data = null;
              try {
                const stats = await collect(ipfs2.ls(ipfsPath2, { signal, timeout: ipfsTimeout }));
                const files = stats.map(({ name: name10, type }) => type === "dir" ? `${name10}/` : name10);
                if (files.includes("index.html")) {
                  if (!searchParams.has("noResolve")) {
                    return serveFile(posixPath.join(ipfsPath2, "index.html"));
                  }
                }
                const accept = reqHeaders.Accept || reqHeaders.accept;
                if (accept && accept.includes("text/html")) {
                  const page = `
<!DOCTYPE html>
<title>${url}</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<h1>Index of ${pathname}</h1>
<ul>
  <li><a href="../">../</a></li>${files.map((file) => `
  <li><a href="${file}">./${file}</a></li>
`).join("")}
</ul>
`;
                  headers["Content-Type"] = "text/html; charset=utf-8";
                  data = page;
                } else {
                  const json = JSON.stringify(files, null, "	");
                  headers["Content-Type"] = "application/json; charset=utf-8";
                  data = json;
                }
                return {
                  statusCode: 200,
                  headers,
                  data: intoAsyncIterable(data)
                };
              } catch {
                return serveFile();
              }
            } else {
              return serveFile();
            }
          } else if (protocol === "ipns:" && (method === "POST" || method === "PUT")) {
            const contentType = reqHeaders["Content-Type"] || reqHeaders["content-type"];
            const isFormData = contentType && contentType.includes("multipart/form-data");
            const split = ipfsPath2.split("/");
            const keyName = split[0];
            const subpath = split.slice(1).join("/");
            if (isFormData || subpath) {
              try {
                ipfsPath2 = await resolveIPNS(keyName);
                if (ipfsPath2.startsWith("/ipfs/"))
                  ipfsPath2 = ipfsPath2.slice("/ipfs/".length);
                ipfsPath2 += `/${subpath}`;
              } catch (e) {
                ipfsPath2 = subpath;
              }
              const addedURL = await uploadData(ipfsPath2, body, isFormData);
              const cid = addedURL.slice("ipfs://".length).split("/")[0];
              const value = `/ipfs/${cid}/`;
              return updateIPNS(keyName, value);
            } else {
              const rawValue = await collectString(body);
              const value = rawValue.replace(/^ipfs:\/\//, "/ipfs/").replace(/^ipns:\/\//, "/ipns/");
              return updateIPNS(keyName, value);
            }
          } else {
            return {
              statusCode: 405,
              headers,
              data: intoAsyncIterable("")
            };
          }
        } catch (e) {
          const statusCode = (() => {
            if (e.code === "ERR_NOT_FOUND") {
              return 404;
            } else if (e.name === "TimeoutError") {
              return 408;
            } else {
              return 500;
            }
          })(e);
          console.error(e.stack);
          return {
            statusCode,
            headers,
            data: intoAsyncIterable(e.stack)
          };
        }
      });
    };
    async function* intoAsyncIterable(data) {
      yield Buffer.from(data);
    }
    async function collect(iterable) {
      const result = [];
      for await (const item of iterable) {
        result.push(item);
      }
      return result;
    }
    async function collectString(iterable) {
      const items = await collect(iterable);
      return items.map((item) => item.toString()).join("");
    }
    function ensureStartingSlash(path) {
      if (!path.startsWith("/"))
        return "/" + path;
      return path;
    }
    function ensureEndingSlash(path) {
      if (!path.endsWith("/"))
        return path + "/";
      return path;
    }
    function getMimeType(path) {
      let mimeType = mime.getType(path) || "text/plain";
      if (mimeType.startsWith("text/"))
        mimeType = `${mimeType}; charset=utf-8`;
      return mimeType;
    }
  }
});

// index.js
init_globals();

// node_modules/trystero/src/index.js
var src_exports = {};
__export(src_exports, {
  joinRoom: () => joinRoom,
  selfId: () => selfId
});
init_globals();

// node_modules/trystero/src/torrent.js
init_globals();

// node_modules/trystero/src/room.js
init_globals();

// node_modules/trystero/src/utils.js
init_globals();

// node_modules/simple-peer-light/index.js
init_globals();
var MAX_BUFFERED_AMOUNT = 64 * 1024;
var ICECOMPLETE_TIMEOUT = 5 * 1e3;
var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
function randombytes(size) {
  const array = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    array[i] = Math.random() * 256 | 0;
  }
  return array;
}
function getBrowserRTC() {
  if (typeof globalThis === "undefined")
    return null;
  const wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
  };
  if (!wrtc.RTCPeerConnection)
    return null;
  return wrtc;
}
function errCode(err, code13) {
  Object.defineProperty(err, "code", {
    value: code13,
    enumerable: true,
    configurable: true
  });
  return err;
}
function filterTrickle(sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, "");
}
function warn(message) {
  console.warn(message);
}
var Peer = class {
  constructor(opts = {}) {
    this._map = /* @__PURE__ */ new Map();
    this._id = randombytes(4).toString("hex").slice(0, 7);
    this._doDebug = opts.debug;
    this._debug("new peer %o", opts);
    this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString("hex") : null;
    this.initiator = opts.initiator || false;
    this.channelConfig = opts.channelConfig || Peer.channelConfig;
    this.channelNegotiated = this.channelConfig.negotiated;
    this.config = Object.assign({}, Peer.config, opts.config);
    this.offerOptions = opts.offerOptions || {};
    this.answerOptions = opts.answerOptions || {};
    this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
    this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
    this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
    this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
    this.destroyed = false;
    this.destroying = false;
    this._connected = false;
    this.remoteAddress = void 0;
    this.remoteFamily = void 0;
    this.remotePort = void 0;
    this.localAddress = void 0;
    this.localFamily = void 0;
    this.localPort = void 0;
    this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
    if (!this._wrtc) {
      if (typeof window === "undefined") {
        throw errCode(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
      } else {
        throw errCode(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
      }
    }
    this._pcReady = false;
    this._channelReady = false;
    this._iceComplete = false;
    this._iceCompleteTimer = null;
    this._channel = null;
    this._pendingCandidates = [];
    this._isNegotiating = false;
    this._firstNegotiation = true;
    this._batchedNegotiation = false;
    this._queuedNegotiation = false;
    this._sendersAwaitingStable = [];
    this._senderMap = /* @__PURE__ */ new Map();
    this._closingInterval = null;
    this._remoteTracks = [];
    this._remoteStreams = [];
    this._chunk = null;
    this._cb = null;
    this._interval = null;
    try {
      this._pc = new this._wrtc.RTCPeerConnection(this.config);
    } catch (err) {
      this.destroy(errCode(err, "ERR_PC_CONSTRUCTOR"));
      return;
    }
    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
    this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange();
    };
    this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange();
    };
    this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange();
    };
    this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange();
    };
    this._pc.onicecandidate = (event) => {
      this._onIceCandidate(event);
    };
    if (typeof this._pc.peerIdentity === "object") {
      this._pc.peerIdentity.catch((err) => {
        this.destroy(errCode(err, "ERR_PC_PEER_IDENTITY"));
      });
    }
    if (this.initiator || this.channelNegotiated) {
      this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      });
    } else {
      this._pc.ondatachannel = (event) => {
        this._setupData(event);
      };
    }
    if (this.streams) {
      this.streams.forEach((stream) => {
        this.addStream(stream);
      });
    }
    this._pc.ontrack = (event) => {
      this._onTrack(event);
    };
    this._debug("initial negotiation");
    this._needsNegotiation();
  }
  get bufferSize() {
    return this._channel && this._channel.bufferedAmount || 0;
  }
  get connected() {
    return this._connected && this._channel.readyState === "open";
  }
  address() {
    return {
      port: this.localPort,
      family: this.localFamily,
      address: this.localAddress
    };
  }
  signal(data) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
    if (typeof data === "string") {
      try {
        data = JSON.parse(data);
      } catch (err) {
        data = {};
      }
    }
    this._debug("signal()");
    if (data.renegotiate && this.initiator) {
      this._debug("got request to renegotiate");
      this._needsNegotiation();
    }
    if (data.transceiverRequest && this.initiator) {
      this._debug("got request for transceiver");
      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
    }
    if (data.candidate) {
      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
        this._addIceCandidate(data.candidate);
      } else {
        this._pendingCandidates.push(data.candidate);
      }
    }
    if (data.sdp) {
      this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {
        if (this.destroyed)
          return;
        this._pendingCandidates.forEach((candidate) => {
          this._addIceCandidate(candidate);
        });
        this._pendingCandidates = [];
        if (this._pc.remoteDescription.type === "offer")
          this._createAnswer();
      }).catch((err) => {
        this.destroy(errCode(err, "ERR_SET_REMOTE_DESCRIPTION"));
      });
    }
    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
      this.destroy(errCode(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
    }
  }
  _addIceCandidate(candidate) {
    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
    this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
      if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
        warn("Ignoring unsupported ICE candidate.");
      } else {
        this.destroy(errCode(err, "ERR_ADD_ICE_CANDIDATE"));
      }
    });
  }
  send(chunk) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
    this._channel.send(chunk);
  }
  addTransceiver(kind, init) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
    this._debug("addTransceiver()");
    if (this.initiator) {
      try {
        this._pc.addTransceiver(kind, init);
        this._needsNegotiation();
      } catch (err) {
        this.destroy(errCode(err, "ERR_ADD_TRANSCEIVER"));
      }
    } else {
      this.emit("signal", {
        type: "transceiverRequest",
        transceiverRequest: { kind, init }
      });
    }
  }
  addStream(stream) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
    this._debug("addStream()");
    stream.getTracks().forEach((track) => {
      this.addTrack(track, stream);
    });
  }
  addTrack(track, stream) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
    this._debug("addTrack()");
    const submap = this._senderMap.get(track) || /* @__PURE__ */ new Map();
    let sender = submap.get(stream);
    if (!sender) {
      sender = this._pc.addTrack(track, stream);
      submap.set(stream, sender);
      this._senderMap.set(track, submap);
      this._needsNegotiation();
    } else if (sender.removed) {
      throw errCode(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
    } else {
      throw errCode(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
    }
  }
  replaceTrack(oldTrack, newTrack, stream) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
    this._debug("replaceTrack()");
    const submap = this._senderMap.get(oldTrack);
    const sender = submap ? submap.get(stream) : null;
    if (!sender) {
      throw errCode(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
    }
    if (newTrack)
      this._senderMap.set(newTrack, submap);
    if (sender.replaceTrack != null) {
      sender.replaceTrack(newTrack);
    } else {
      this.destroy(errCode(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
    }
  }
  removeTrack(track, stream) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
    this._debug("removeSender()");
    const submap = this._senderMap.get(track);
    const sender = submap ? submap.get(stream) : null;
    if (!sender) {
      throw errCode(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
    }
    try {
      sender.removed = true;
      this._pc.removeTrack(sender);
    } catch (err) {
      if (err.name === "NS_ERROR_UNEXPECTED") {
        this._sendersAwaitingStable.push(sender);
      } else {
        this.destroy(errCode(err, "ERR_REMOVE_TRACK"));
      }
    }
    this._needsNegotiation();
  }
  removeStream(stream) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
    this._debug("removeSenders()");
    stream.getTracks().forEach((track) => {
      this.removeTrack(track, stream);
    });
  }
  _needsNegotiation() {
    this._debug("_needsNegotiation");
    if (this._batchedNegotiation)
      return;
    this._batchedNegotiation = true;
    queueMicrotask(() => {
      this._batchedNegotiation = false;
      if (this.initiator || !this._firstNegotiation) {
        this._debug("starting batched negotiation");
        this.negotiate();
      } else {
        this._debug("non-initiator initial negotiation request discarded");
      }
      this._firstNegotiation = false;
    });
  }
  negotiate() {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
    if (this.initiator) {
      if (this._isNegotiating) {
        this._queuedNegotiation = true;
        this._debug("already negotiating, queueing");
      } else {
        this._debug("start negotiation");
        setTimeout(() => {
          this._createOffer();
        }, 0);
      }
    } else {
      if (this._isNegotiating) {
        this._queuedNegotiation = true;
        this._debug("already negotiating, queueing");
      } else {
        this._debug("requesting negotiation from initiator");
        this.emit("signal", {
          type: "renegotiate",
          renegotiate: true
        });
      }
    }
    this._isNegotiating = true;
  }
  destroy(err) {
    if (this.destroyed || this.destroying)
      return;
    this.destroying = true;
    this._debug("destroying (error: %s)", err && (err.message || err));
    queueMicrotask(() => {
      this.destroyed = true;
      this.destroying = false;
      this._debug("destroy (error: %s)", err && (err.message || err));
      this._connected = false;
      this._pcReady = false;
      this._channelReady = false;
      this._remoteTracks = null;
      this._remoteStreams = null;
      this._senderMap = null;
      clearInterval(this._closingInterval);
      this._closingInterval = null;
      clearInterval(this._interval);
      this._interval = null;
      this._chunk = null;
      this._cb = null;
      if (this._channel) {
        try {
          this._channel.close();
        } catch (err2) {
        }
        this._channel.onmessage = null;
        this._channel.onopen = null;
        this._channel.onclose = null;
        this._channel.onerror = null;
      }
      if (this._pc) {
        try {
          this._pc.close();
        } catch (err2) {
        }
        this._pc.oniceconnectionstatechange = null;
        this._pc.onicegatheringstatechange = null;
        this._pc.onsignalingstatechange = null;
        this._pc.onicecandidate = null;
        this._pc.ontrack = null;
        this._pc.ondatachannel = null;
      }
      this._pc = null;
      this._channel = null;
      if (err)
        this.emit("error", err);
      this.emit("close");
    });
  }
  _setupData(event) {
    if (!event.channel) {
      return this.destroy(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
    }
    this._channel = event.channel;
    this._channel.binaryType = "arraybuffer";
    if (typeof this._channel.bufferedAmountLowThreshold === "number") {
      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
    }
    this.channelName = this._channel.label;
    this._channel.onmessage = (event2) => {
      this._onChannelMessage(event2);
    };
    this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow();
    };
    this._channel.onopen = () => {
      this._onChannelOpen();
    };
    this._channel.onclose = () => {
      this._onChannelClose();
    };
    this._channel.onerror = (err) => {
      this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
    };
    let isClosing = false;
    this._closingInterval = setInterval(() => {
      if (this._channel && this._channel.readyState === "closing") {
        if (isClosing)
          this._onChannelClose();
        isClosing = true;
      } else {
        isClosing = false;
      }
    }, CHANNEL_CLOSING_TIMEOUT);
  }
  _startIceCompleteTimeout() {
    if (this.destroyed)
      return;
    if (this._iceCompleteTimer)
      return;
    this._debug("started iceComplete timeout");
    this._iceCompleteTimer = setTimeout(() => {
      if (!this._iceComplete) {
        this._iceComplete = true;
        this._debug("iceComplete timeout completed");
        this.emit("iceTimeout");
        this.emit("_iceComplete");
      }
    }, this.iceCompleteTimeout);
  }
  _createOffer() {
    if (this.destroyed)
      return;
    this._pc.createOffer(this.offerOptions).then((offer) => {
      if (this.destroyed)
        return;
      if (!this.trickle && !this.allowHalfTrickle) {
        offer.sdp = filterTrickle(offer.sdp);
      }
      offer.sdp = this.sdpTransform(offer.sdp);
      const sendOffer = () => {
        if (this.destroyed)
          return;
        const signal = this._pc.localDescription || offer;
        this._debug("signal");
        this.emit("signal", {
          type: signal.type,
          sdp: signal.sdp
        });
      };
      const onSuccess = () => {
        this._debug("createOffer success");
        if (this.destroyed)
          return;
        if (this.trickle || this._iceComplete)
          sendOffer();
        else
          this.once("_iceComplete", sendOffer);
      };
      const onError = (err) => {
        this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
      };
      this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
    }).catch((err) => {
      this.destroy(errCode(err, "ERR_CREATE_OFFER"));
    });
  }
  _requestMissingTransceivers() {
    if (this._pc.getTransceivers) {
      this._pc.getTransceivers().forEach((transceiver) => {
        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
          transceiver.requested = true;
          this.addTransceiver(transceiver.sender.track.kind);
        }
      });
    }
  }
  _createAnswer() {
    if (this.destroyed)
      return;
    this._pc.createAnswer(this.answerOptions).then((answer) => {
      if (this.destroyed)
        return;
      if (!this.trickle && !this.allowHalfTrickle) {
        answer.sdp = filterTrickle(answer.sdp);
      }
      answer.sdp = this.sdpTransform(answer.sdp);
      const sendAnswer = () => {
        if (this.destroyed)
          return;
        const signal = this._pc.localDescription || answer;
        this._debug("signal");
        this.emit("signal", {
          type: signal.type,
          sdp: signal.sdp
        });
        if (!this.initiator)
          this._requestMissingTransceivers();
      };
      const onSuccess = () => {
        if (this.destroyed)
          return;
        if (this.trickle || this._iceComplete)
          sendAnswer();
        else
          this.once("_iceComplete", sendAnswer);
      };
      const onError = (err) => {
        this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
      };
      this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
    }).catch((err) => {
      this.destroy(errCode(err, "ERR_CREATE_ANSWER"));
    });
  }
  _onConnectionStateChange() {
    if (this.destroyed)
      return;
    if (this._pc.connectionState === "failed") {
      this.destroy(errCode(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
    }
  }
  _onIceStateChange() {
    if (this.destroyed)
      return;
    const iceConnectionState = this._pc.iceConnectionState;
    const iceGatheringState = this._pc.iceGatheringState;
    this._debug("iceStateChange (connection: %s) (gathering: %s)", iceConnectionState, iceGatheringState);
    this.emit("iceStateChange", iceConnectionState, iceGatheringState);
    if (iceConnectionState === "connected" || iceConnectionState === "completed") {
      this._pcReady = true;
      this._maybeReady();
    }
    if (iceConnectionState === "failed") {
      this.destroy(errCode(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
    }
    if (iceConnectionState === "closed") {
      this.destroy(errCode(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
    }
  }
  getStats(cb) {
    const flattenValues = (report) => {
      if (Object.prototype.toString.call(report.values) === "[object Array]") {
        report.values.forEach((value) => {
          Object.assign(report, value);
        });
      }
      return report;
    };
    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
      this._pc.getStats().then((res) => {
        const reports = [];
        res.forEach((report) => {
          reports.push(flattenValues(report));
        });
        cb(null, reports);
      }, (err) => cb(err));
    } else if (this._pc.getStats.length > 0) {
      this._pc.getStats((res) => {
        if (this.destroyed)
          return;
        const reports = [];
        res.result().forEach((result) => {
          const report = {};
          result.names().forEach((name10) => {
            report[name10] = result.stat(name10);
          });
          report.id = result.id;
          report.type = result.type;
          report.timestamp = result.timestamp;
          reports.push(flattenValues(report));
        });
        cb(null, reports);
      }, (err) => cb(err));
    } else {
      cb(null, []);
    }
  }
  _maybeReady() {
    this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) {
      return;
    }
    this._connecting = true;
    const findCandidatePair = () => {
      if (this.destroyed)
        return;
      this.getStats((err, items) => {
        if (this.destroyed)
          return;
        if (err)
          items = [];
        const remoteCandidates = {};
        const localCandidates = {};
        const candidatePairs = {};
        let foundSelectedCandidatePair = false;
        items.forEach((item) => {
          if (item.type === "remotecandidate" || item.type === "remote-candidate") {
            remoteCandidates[item.id] = item;
          }
          if (item.type === "localcandidate" || item.type === "local-candidate") {
            localCandidates[item.id] = item;
          }
          if (item.type === "candidatepair" || item.type === "candidate-pair") {
            candidatePairs[item.id] = item;
          }
        });
        const setSelectedCandidatePair = (selectedCandidatePair) => {
          foundSelectedCandidatePair = true;
          let local = localCandidates[selectedCandidatePair.localCandidateId];
          if (local && (local.ip || local.address)) {
            this.localAddress = local.ip || local.address;
            this.localPort = Number(local.port);
          } else if (local && local.ipAddress) {
            this.localAddress = local.ipAddress;
            this.localPort = Number(local.portNumber);
          } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
            local = selectedCandidatePair.googLocalAddress.split(":");
            this.localAddress = local[0];
            this.localPort = Number(local[1]);
          }
          if (this.localAddress) {
            this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
          }
          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
          if (remote && (remote.ip || remote.address)) {
            this.remoteAddress = remote.ip || remote.address;
            this.remotePort = Number(remote.port);
          } else if (remote && remote.ipAddress) {
            this.remoteAddress = remote.ipAddress;
            this.remotePort = Number(remote.portNumber);
          } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
            remote = selectedCandidatePair.googRemoteAddress.split(":");
            this.remoteAddress = remote[0];
            this.remotePort = Number(remote[1]);
          }
          if (this.remoteAddress) {
            this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
          }
          this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
        };
        items.forEach((item) => {
          if (item.type === "transport" && item.selectedCandidatePairId) {
            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
          }
          if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
            setSelectedCandidatePair(item);
          }
        });
        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
          setTimeout(findCandidatePair, 100);
          return;
        } else {
          this._connecting = false;
          this._connected = true;
        }
        if (this._chunk) {
          try {
            this.send(this._chunk);
          } catch (err2) {
            return this.destroy(errCode(err2, "ERR_DATA_CHANNEL"));
          }
          this._chunk = null;
          this._debug('sent chunk from "write before connect"');
          const cb = this._cb;
          this._cb = null;
          cb(null);
        }
        if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
          this._interval = setInterval(() => this._onInterval(), 150);
          if (this._interval.unref)
            this._interval.unref();
        }
        this._debug("connect");
        this.emit("connect");
      });
    };
    findCandidatePair();
  }
  _onInterval() {
    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      return;
    }
    this._onChannelBufferedAmountLow();
  }
  _onSignalingStateChange() {
    if (this.destroyed)
      return;
    if (this._pc.signalingState === "stable") {
      this._isNegotiating = false;
      this._debug("flushing sender queue", this._sendersAwaitingStable);
      this._sendersAwaitingStable.forEach((sender) => {
        this._pc.removeTrack(sender);
        this._queuedNegotiation = true;
      });
      this._sendersAwaitingStable = [];
      if (this._queuedNegotiation) {
        this._debug("flushing negotiation queue");
        this._queuedNegotiation = false;
        this._needsNegotiation();
      } else {
        this._debug("negotiated");
        this.emit("negotiated");
      }
    }
    this._debug("signalingStateChange %s", this._pc.signalingState);
    this.emit("signalingStateChange", this._pc.signalingState);
  }
  _onIceCandidate(event) {
    if (this.destroyed)
      return;
    if (event.candidate && this.trickle) {
      this.emit("signal", {
        type: "candidate",
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      });
    } else if (!event.candidate && !this._iceComplete) {
      this._iceComplete = true;
      this.emit("_iceComplete");
    }
    if (event.candidate) {
      this._startIceCompleteTimeout();
    }
  }
  _onChannelMessage(event) {
    if (this.destroyed)
      return;
    let data = event.data;
    if (data instanceof ArrayBuffer)
      data = new Uint8Array(data);
    this.emit("data", data);
  }
  _onChannelBufferedAmountLow() {
    if (this.destroyed || !this._cb)
      return;
    this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
    const cb = this._cb;
    this._cb = null;
    cb(null);
  }
  _onChannelOpen() {
    if (this._connected || this.destroyed)
      return;
    this._debug("on channel open");
    this._channelReady = true;
    this._maybeReady();
  }
  _onChannelClose() {
    if (this.destroyed)
      return;
    this._debug("on channel close");
    this.destroy();
  }
  _onTrack(event) {
    if (this.destroyed)
      return;
    event.streams.forEach((eventStream) => {
      this._debug("on track");
      this.emit("track", event.track, eventStream);
      this._remoteTracks.push({
        track: event.track,
        stream: eventStream
      });
      if (this._remoteStreams.some((remoteStream) => {
        return remoteStream.id === eventStream.id;
      })) {
        return;
      }
      this._remoteStreams.push(eventStream);
      queueMicrotask(() => {
        this._debug("on stream");
        this.emit("stream", eventStream);
      });
    });
  }
  _debug(...args) {
    if (!this._doDebug)
      return;
    args[0] = "[" + this._id + "] " + args[0];
    console.log(...args);
  }
  on(key, listener) {
    const map12 = this._map;
    if (!map12.has(key))
      map12.set(key, /* @__PURE__ */ new Set());
    map12.get(key).add(listener);
  }
  off(key, listener) {
    const map12 = this._map;
    const listeners = map12.get(key);
    if (!listeners)
      return;
    listeners.delete(listener);
    if (listeners.size === 0)
      map12.delete(key);
  }
  once(key, listener) {
    const listener_ = (...args) => {
      this.off(key, listener_);
      listener(...args);
    };
    this.on(key, listener_);
  }
  emit(key, ...args) {
    const map12 = this._map;
    if (!map12.has(key))
      return;
    for (const listener of map12.get(key)) {
      try {
        listener(...args);
      } catch (err) {
        console.error(err);
      }
    }
  }
};
Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
Peer.config = {
  iceServers: [
    {
      urls: [
        "stun:stun.l.google.com:19302",
        "stun:global.stun.twilio.com:3478"
      ]
    }
  ],
  sdpSemantics: "unified-plan"
};
Peer.channelConfig = {};
var simple_peer_light_default = Peer;

// node_modules/trystero/src/utils.js
var charSet = "0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz";
var initPeer = (initiator, trickle, config2) => {
  const peer = new simple_peer_light_default({ initiator, trickle, config: config2 });
  const onData = (data) => peer.__earlyDataBuffer.push(data);
  peer.on(events.data, onData);
  peer.__earlyDataBuffer = [];
  peer.__drainEarlyData = (f) => {
    peer.off(events.data, onData);
    peer.__earlyDataBuffer.forEach(f);
    delete peer.__earlyDataBuffer;
    delete peer.__drainEarlyData;
  };
  return peer;
};
var genId = (n) => new Array(n).fill().map(() => charSet[Math.floor(Math.random() * charSet.length)]).join("");
var initGuard = (occupiedRooms2, f) => (config2, ns) => {
  if (occupiedRooms2[ns]) {
    throw mkErr(`already joined room ${ns}`);
  }
  if (!config2) {
    throw mkErr("requires a config map as the first argument");
  }
  if (!config2.appId && !config2.firebaseApp) {
    throw mkErr("config map is missing appId field");
  }
  if (!ns) {
    throw mkErr("namespace argument required");
  }
  return f(config2, ns);
};
var libName = "Trystero";
var selfId = genId(20);
var { keys, values, entries, fromEntries } = Object;
var noOp = () => {
};
var mkErr = (msg) => new Error(`${libName}: ${msg}`);
var encodeBytes = (txt) => new TextEncoder().encode(txt);
var decodeBytes = (txt) => new TextDecoder().decode(txt);
var events = fromEntries(["close", "connect", "data", "error", "signal", "stream", "track"].map((k) => [
  k,
  k
]));
var combineChunks = (chunks) => {
  const full = new Uint8Array(chunks.reduce((a, c) => a + c.byteLength, 0));
  chunks.reduce((a, c) => {
    full.set(c, a);
    return a + c.byteLength;
  }, 0);
  return full;
};

// node_modules/trystero/src/room.js
var TypedArray = Object.getPrototypeOf(Uint8Array);
var typeByteLimit = 12;
var typeIndex = 0;
var nonceIndex = typeIndex + typeByteLimit;
var tagIndex = nonceIndex + 1;
var progressIndex = tagIndex + 1;
var payloadIndex = progressIndex + 1;
var chunkSize = 16 * 2 ** 10 - payloadIndex;
var oneByteMax = 255;
var buffLowEvent = "bufferedamountlow";
var room_default = (onPeer, onSelfLeave) => {
  const peerMap = {};
  const actions = {};
  const pendingTransmissions = {};
  const pendingPongs = {};
  const pendingStreamMetas = {};
  const pendingTrackMetas = {};
  const iterate = (targets, f) => (targets ? Array.isArray(targets) ? targets : [targets] : keys(peerMap)).flatMap((id) => {
    const peer = peerMap[id];
    if (!peer) {
      console.warn(`${libName}: no peer with id ${id} found`);
      return [];
    }
    return f(id, peer);
  });
  const exitPeer = (id) => {
    if (!peerMap[id]) {
      return;
    }
    delete peerMap[id];
    delete pendingTransmissions[id];
    delete pendingPongs[id];
    onPeerLeave(id);
  };
  const makeAction = (type) => {
    if (!type) {
      throw mkErr("action type argument is required");
    }
    const typeEncoded = encodeBytes(type);
    if (typeEncoded.byteLength > typeByteLimit) {
      throw mkErr(`action type string "${type}" (${typeEncoded.byteLength}b) exceeds byte limit (${typeByteLimit}). Hint: choose a shorter name.`);
    }
    const typeBytes = new Uint8Array(typeByteLimit);
    typeBytes.set(typeEncoded);
    const typePadded = decodeBytes(typeBytes);
    if (actions[typePadded]) {
      throw mkErr(`action '${type}' already registered`);
    }
    let nonce = 0;
    actions[typePadded] = { onComplete: noOp, onProgress: noOp };
    return [
      async (data, targets, meta, onProgress) => {
        if (meta && typeof meta !== "object") {
          throw mkErr("action meta argument must be an object");
        }
        if (data === void 0) {
          throw mkErr("action data cannot be undefined");
        }
        const isJson = typeof data !== "string";
        const isBlob2 = data instanceof Blob;
        const isBinary3 = isBlob2 || data instanceof ArrayBuffer || data instanceof TypedArray;
        if (meta && !isBinary3) {
          throw mkErr("action meta argument can only be used with binary data");
        }
        const buffer3 = isBinary3 ? new Uint8Array(isBlob2 ? await data.arrayBuffer() : data) : encodeBytes(isJson ? JSON.stringify(data) : data);
        const metaEncoded = meta ? encodeBytes(JSON.stringify(meta)) : null;
        const chunkTotal = Math.ceil(buffer3.byteLength / chunkSize) + (meta ? 1 : 0);
        const chunks = new Array(chunkTotal).fill().map((_, i) => {
          const isLast = i === chunkTotal - 1;
          const isMeta = meta && i === 0;
          const chunk = new Uint8Array(payloadIndex + (isMeta ? metaEncoded.byteLength : isLast ? buffer3.byteLength - chunkSize * (chunkTotal - (meta ? 2 : 1)) : chunkSize));
          chunk.set(typeBytes);
          chunk.set([nonce], nonceIndex);
          chunk.set([isLast | isMeta << 1 | isBinary3 << 2 | isJson << 3], tagIndex);
          chunk.set([Math.round((i + 1) / chunkTotal * oneByteMax)], progressIndex);
          chunk.set(meta ? isMeta ? metaEncoded : buffer3.subarray((i - 1) * chunkSize, i * chunkSize) : buffer3.subarray(i * chunkSize, (i + 1) * chunkSize), payloadIndex);
          return chunk;
        });
        nonce = nonce + 1 & oneByteMax;
        return Promise.all(iterate(targets, async (id, peer) => {
          const chan = peer._channel;
          let chunkN = 0;
          while (chunkN < chunkTotal) {
            const chunk = chunks[chunkN];
            if (chan.bufferedAmount > chan.bufferedAmountLowThreshold) {
              await new Promise((res) => {
                const next = () => {
                  chan.removeEventListener(buffLowEvent, next);
                  res();
                };
                chan.addEventListener(buffLowEvent, next);
              });
            }
            if (!peerMap[id]) {
              break;
            }
            peer.send(chunk);
            chunkN++;
            if (onProgress) {
              onProgress(chunk[progressIndex] / oneByteMax, id, meta);
            }
          }
        }));
      },
      (onComplete) => actions[typePadded] = { ...actions[typePadded], onComplete },
      (onProgress) => actions[typePadded] = { ...actions[typePadded], onProgress }
    ];
  };
  const handleData = (id, data) => {
    const buffer3 = new Uint8Array(data);
    const type = decodeBytes(buffer3.subarray(typeIndex, nonceIndex));
    const [nonce] = buffer3.subarray(nonceIndex, tagIndex);
    const [tag] = buffer3.subarray(tagIndex, progressIndex);
    const [progress] = buffer3.subarray(progressIndex, payloadIndex);
    const payload = buffer3.subarray(payloadIndex);
    const isLast = !!(tag & 1);
    const isMeta = !!(tag & 1 << 1);
    const isBinary3 = !!(tag & 1 << 2);
    const isJson = !!(tag & 1 << 3);
    if (!actions[type]) {
      throw mkErr(`received message with unregistered type (${type})`);
    }
    if (!pendingTransmissions[id]) {
      pendingTransmissions[id] = {};
    }
    if (!pendingTransmissions[id][type]) {
      pendingTransmissions[id][type] = {};
    }
    let target = pendingTransmissions[id][type][nonce];
    if (!target) {
      target = pendingTransmissions[id][type][nonce] = { chunks: [] };
    }
    if (isMeta) {
      target.meta = JSON.parse(decodeBytes(payload));
    } else {
      target.chunks.push(payload);
    }
    actions[type].onProgress(progress / oneByteMax, id, target.meta);
    if (!isLast) {
      return;
    }
    const full = combineChunks(target.chunks);
    if (isBinary3) {
      actions[type].onComplete(full, id, target.meta);
    } else {
      const text = decodeBytes(full);
      actions[type].onComplete(isJson ? JSON.parse(text) : text, id);
    }
    delete pendingTransmissions[id][type][nonce];
  };
  const [sendPing, getPing] = makeAction("__91n6__");
  const [sendPong, getPong] = makeAction("__90n6__");
  const [sendSignal, getSignal] = makeAction("__516n4L__");
  const [sendStreamMeta, getStreamMeta] = makeAction("__57r34m__");
  const [sendTrackMeta, getTrackMeta] = makeAction("__7r4ck__");
  let onPeerJoin = noOp;
  let onPeerLeave = noOp;
  let onPeerStream = noOp;
  let onPeerTrack = noOp;
  onPeer((peer, id) => {
    if (peerMap[id]) {
      return;
    }
    const onData = handleData.bind(null, id);
    peerMap[id] = peer;
    peer.on(events.signal, (sdp) => sendSignal(sdp, id));
    peer.on(events.close, () => exitPeer(id));
    peer.on(events.data, onData);
    peer.on(events.stream, (stream) => {
      onPeerStream(stream, id, pendingStreamMetas[id]);
      delete pendingStreamMetas[id];
    });
    peer.on(events.track, (track, stream) => {
      onPeerTrack(track, stream, id, pendingTrackMetas[id]);
      delete pendingTrackMetas[id];
    });
    peer.on(events.error, (e) => {
      if (e.code === "ERR_DATA_CHANNEL") {
        return;
      }
      console.error(e);
    });
    onPeerJoin(peer, id);
    peer.__drainEarlyData(onData);
  });
  getPing((_, id) => sendPong(null, id));
  getPong((_, id) => {
    if (pendingPongs[id]) {
      pendingPongs[id]();
      delete pendingPongs[id];
    }
  });
  getSignal((sdp, id) => {
    if (peerMap[id]) {
      peerMap[id].signal(sdp);
    }
  });
  getStreamMeta((meta, id) => pendingStreamMetas[id] = meta);
  getTrackMeta((meta, id) => pendingTrackMetas[id] = meta);
  return {
    makeAction,
    ping: async (id) => {
      if (!id) {
        throw mkErr("ping() must be called with target peer ID");
      }
      const start = Date.now();
      sendPing(null, id);
      await new Promise((res) => pendingPongs[id] = res);
      return Date.now() - start;
    },
    leave: () => {
      entries(peerMap).forEach(([id, peer]) => {
        peer.destroy();
        delete peerMap[id];
      });
      onSelfLeave();
    },
    getPeers: () => keys(peerMap),
    addStream: (stream, targets, meta) => iterate(targets, async (id, peer) => {
      if (meta) {
        await sendStreamMeta(meta, id);
      }
      peer.addStream(stream);
    }),
    removeStream: (stream, targets) => iterate(targets, (_, peer) => peer.removeStream(stream)),
    addTrack: (track, stream, targets, meta) => iterate(targets, async (id, peer) => {
      if (meta) {
        await sendTrackMeta(meta, id);
      }
      peer.addTrack(track, stream);
    }),
    removeTrack: (track, stream, targets) => iterate(targets, (_, peer) => peer.removeTrack(track, stream)),
    replaceTrack: (oldTrack, newTrack, stream, targets, meta) => iterate(targets, async (id, peer) => {
      if (meta) {
        await sendTrackMeta(meta, id);
      }
      peer.replaceTrack(oldTrack, newTrack, stream);
    }),
    onPeerJoin: (f) => onPeerJoin = f,
    onPeerLeave: (f) => onPeerLeave = f,
    onPeerStream: (f) => onPeerStream = f,
    onPeerTrack: (f) => onPeerTrack = f
  };
};

// node_modules/trystero/src/crypto.js
init_globals();
var algo = "AES-CBC";
var ecdsa_params = {
  name: "ECDSA",
  hash: { name: "SHA-384" }
};
var ecdsa_import_params = {
  name: "ECDSA",
  namedCurve: "P-384"
};
var pack = (buff) => window.btoa(String.fromCharCode.apply(null, new Uint8Array(buff)));
var unpack = (packed) => {
  const str = window.atob(packed);
  return new Uint8Array(str.length).map((_, i) => str.charCodeAt(i)).buffer;
};
var genKey = async (secret, ns) => crypto.subtle.importKey("raw", await crypto.subtle.digest({ name: "SHA-256" }, encodeBytes(`${secret}:${ns}`)), { name: algo }, false, ["encrypt", "decrypt"]);
var sign = async (key_pair, sdp) => {
  const encoder = new TextEncoder();
  const encoded_sdp = encoder.encode(sdp);
  const signature = await crypto.subtle.sign(ecdsa_params, key_pair.privateKey, encoded_sdp);
  const exported_key = await crypto.subtle.exportKey("jwk", key_pair.publicKey);
  return JSON.stringify({
    sdp,
    signature: pack(signature),
    key: exported_key
  });
};
var verify = async (string3) => {
  const data = JSON.parse(string3);
  const imported_key = await crypto.subtle.importKey("jwk", data.key, ecdsa_import_params, true, ["verify"]);
  const encoder = new TextEncoder();
  const encoded_sdp = encoder.encode(data.sdp);
  const signature = unpack(data.signature);
  const verified = await window.crypto.subtle.verify(ecdsa_params, imported_key, signature, encoded_sdp);
  return {
    sdp: data.sdp,
    verified,
    key: imported_key
  };
};

// node_modules/trystero/src/torrent.js
var occupiedRooms = {};
var sockets = {};
var socketListeners = {};
var hashLimit = 20;
var offerPoolSize = 10;
var defaultRedundancy = 2;
var defaultAnnounceSecs = 33;
var maxAnnounceSecs = 120;
var trackerAction = "announce";
var defaultTrackerUrls = [
  "wss://tracker.openwebtorrent.com",
  "wss://tracker.btorrent.xyz",
  "wss://tracker.files.fm:7073/announce",
  "wss://spacetradersapi-chatbox.herokuapp.com:443/announce"
];
var joinRoom = initGuard(occupiedRooms, (config2, ns) => {
  const connectedPeers = {};
  const key = config2.password && genKey(config2.password, ns);
  const trackerUrls = (config2.trackerUrls || defaultTrackerUrls).slice(0, config2.trackerUrls ? config2.trackerUrls.length : config2.trackerRedundancy || defaultRedundancy);
  if (!trackerUrls.length) {
    throw mkErr("trackerUrls is empty");
  }
  const infoHashP = crypto.subtle.digest("SHA-1", encodeBytes(`${libName}:${config2.appId}:${ns}`)).then((buffer3) => Array.from(new Uint8Array(buffer3)).map((b) => b.toString(36)).join("").slice(0, hashLimit));
  const makeOffers = () => fromEntries(new Array(offerPoolSize).fill().map(() => {
    const peer = initPeer(true, false, config2.rtcConfig);
    return [
      genId(hashLimit),
      { peer, offerP: new Promise((res) => peer.once(events.signal, res)) }
    ];
  }));
  const onSocketMessage = async (socket, e) => {
    const infoHash = await infoHashP;
    let val;
    try {
      val = JSON.parse(e.data);
    } catch (e2) {
      console.error(`${libName}: received malformed SDP JSON`);
      return;
    }
    if (val.info_hash !== infoHash || val.peer_id && val.peer_id === selfId) {
      return;
    }
    const failure = val["failure reason"];
    if (failure) {
      console.warn(`${libName}: torrent tracker failure (${failure})`);
      return;
    }
    if (val.interval && val.interval > announceSecs && val.interval <= maxAnnounceSecs) {
      clearInterval(announceInterval);
      announceSecs = val.interval;
      announceInterval = setInterval(announceAll, announceSecs * 1e3);
    }
    if (val.offer && val.offer_id) {
      if (connectedPeers[val.peer_id] || handledOffers[val.offer_id]) {
        return;
      }
      handledOffers[val.offer_id] = true;
      const peer = initPeer(false, false, config2.rtcConfig);
      peer.once(events.signal, async (answer) => socket.send(JSON.stringify({
        answer: { ...answer, sdp: await sign(config2.signing_key, answer.sdp) },
        action: trackerAction,
        info_hash: infoHash,
        peer_id: selfId,
        to_peer_id: val.peer_id,
        offer_id: val.offer_id
      })));
      peer.on(events.connect, () => onConnect(peer, val.peer_id));
      peer.on(events.close, () => onDisconnect(val.peer_id));
      const verification_result = await verify(val.offer.sdp);
      if (verification_result.verified) {
        peer.signal({ ...val.offer, sdp: verification_result.sdp });
        console.log(`Verified ${val.peer_id}`);
        peer.key = verification_result.key;
      } else {
        console.warn(`Peer ${val.peer_id} sent a SDP that failed verification.`);
      }
      return;
    }
    if (val.answer) {
      if (connectedPeers[val.peer_id] || handledOffers[val.offer_id]) {
        return;
      }
      const offer = offerPool[val.offer_id];
      if (offer) {
        const { peer } = offer;
        if (peer.destroyed) {
          return;
        }
        handledOffers[val.offer_id] = true;
        peer.on(events.connect, () => onConnect(peer, val.peer_id, val.offer_id));
        peer.on(events.close, () => onDisconnect(val.peer_id));
        const verification_result = await verify(val.answer.sdp);
        if (verification_result.verified) {
          peer.signal({ ...val.answer, sdp: verification_result.sdp });
          console.log(`Verified ${val.peer_id}`);
          peer.key = verification_result.key;
        } else {
          console.warn(`Peer ${val.peer_id} sent a SDP that failed verification.`);
        }
      }
    }
  };
  const announce = async (socket, infoHash) => socket.send(JSON.stringify({
    action: trackerAction,
    info_hash: infoHash,
    numwant: offerPoolSize,
    peer_id: selfId,
    offers: await Promise.all(entries(offerPool).map(async ([id, { offerP }]) => {
      const offer = await offerP;
      return {
        offer_id: id,
        offer: { ...offer, sdp: await sign(config2.signing_key, offer.sdp) }
      };
    }))
  }));
  const makeSocket = (url, infoHash, forced) => {
    if (forced || !sockets[url]) {
      socketListeners[url] = {
        ...socketListeners[url],
        [infoHash]: onSocketMessage
      };
      sockets[url] = new Promise((res) => {
        const socket = new WebSocket(url);
        socket.onopen = res.bind(null, socket);
        socket.onmessage = (e) => values(socketListeners[url]).forEach((f) => f(socket, e));
      });
    } else {
      socketListeners[url][infoHash] = onSocketMessage;
    }
    return sockets[url];
  };
  const announceAll = async () => {
    const infoHash = await infoHashP;
    if (offerPool) {
      cleanPool();
    }
    offerPool = makeOffers();
    trackerUrls.forEach(async (url) => {
      const socket = await makeSocket(url, infoHash);
      if (socket.readyState === WebSocket.OPEN) {
        announce(socket, infoHash);
      } else if (socket.readyState !== WebSocket.CONNECTING) {
        announce(await makeSocket(url, infoHash, true), infoHash);
      }
    });
  };
  const cleanPool = () => {
    entries(offerPool).forEach(([id, { peer }]) => {
      if (!handledOffers[id] && !connectedPeers[id]) {
        peer.destroy();
      }
    });
    handledOffers = {};
  };
  const onConnect = (peer, id, offerId) => {
    onPeerConnect(peer, id);
    connectedPeers[id] = true;
    if (offerId) {
      connectedPeers[offerId] = true;
    }
  };
  const onDisconnect = (id) => delete connectedPeers[id];
  let announceSecs = defaultAnnounceSecs;
  let announceInterval = setInterval(announceAll, announceSecs * 1e3);
  let onPeerConnect = noOp;
  let handledOffers = {};
  let offerPool;
  occupiedRooms[ns] = true;
  announceAll();
  return room_default((f) => onPeerConnect = f, async () => {
    const infoHash = await infoHashP;
    trackerUrls.forEach((url) => delete socketListeners[url][infoHash]);
    delete occupiedRooms[ns];
    clearInterval(announceInterval);
    cleanPool();
  });
});

// node_modules/ipfs-core/esm/src/index.js
var src_exports7 = {};
__export(src_exports7, {
  CID: () => CID,
  PeerId: () => PeerId13,
  create: () => create7,
  crypto: () => crypto5,
  globSource: () => globSource,
  isIPFS: () => isIPFS2,
  multiaddr: () => import_multiaddr21.Multiaddr,
  urlSource: () => urlSource
});
init_globals();

// node_modules/ipfs-core/esm/src/components/index.js
init_globals();

// node_modules/merge-options/index.mjs
init_globals();
var import_index = __toESM(require_merge_options(), 1);
var merge_options_default = import_index.default;

// node_modules/ipfs-core/esm/src/components/index.js
var import_env2 = __toESM(require_env(), 1);
var import_debug49 = __toESM(require_browser2(), 1);
var import_err_code74 = __toESM(require_err_code(), 1);

// node_modules/ipfs-unixfs/esm/src/index.js
init_globals();
var import_err_code = __toESM(require_err_code(), 1);

// node_modules/ipfs-unixfs/esm/src/unixfs.js
init_globals();
var import_minimal = __toESM(require_minimal2(), 1);
var $Reader = import_minimal.default.Reader;
var $Writer = import_minimal.default.Writer;
var $util = import_minimal.default.util;
var $root = import_minimal.default.roots["ipfs-unixfs"] || (import_minimal.default.roots["ipfs-unixfs"] = {});
var Data = $root.Data = (() => {
  function Data3(p) {
    this.blocksizes = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Data3.prototype.Type = 0;
  Data3.prototype.Data = $util.newBuffer([]);
  Data3.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data3.prototype.blocksizes = $util.emptyArray;
  Data3.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data3.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  Data3.prototype.mode = 0;
  Data3.prototype.mtime = null;
  Data3.encode = function encode19(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int32(m.Type);
    if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
      w.uint32(18).bytes(m.Data);
    if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
      w.uint32(24).uint64(m.filesize);
    if (m.blocksizes != null && m.blocksizes.length) {
      for (var i = 0; i < m.blocksizes.length; ++i)
        w.uint32(32).uint64(m.blocksizes[i]);
    }
    if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
      w.uint32(40).uint64(m.hashType);
    if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
      w.uint32(48).uint64(m.fanout);
    if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
      w.uint32(56).uint32(m.mode);
    if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
      $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
    return w;
  };
  Data3.decode = function decode22(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Data();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Type = r.int32();
          break;
        case 2:
          m.Data = r.bytes();
          break;
        case 3:
          m.filesize = r.uint64();
          break;
        case 4:
          if (!(m.blocksizes && m.blocksizes.length))
            m.blocksizes = [];
          if ((t & 7) === 2) {
            var c2 = r.uint32() + r.pos;
            while (r.pos < c2)
              m.blocksizes.push(r.uint64());
          } else
            m.blocksizes.push(r.uint64());
          break;
        case 5:
          m.hashType = r.uint64();
          break;
        case 6:
          m.fanout = r.uint64();
          break;
        case 7:
          m.mode = r.uint32();
          break;
        case 8:
          m.mtime = $root.UnixTime.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Type"))
      throw $util.ProtocolError("missing required 'Type'", { instance: m });
    return m;
  };
  Data3.fromObject = function fromObject(d) {
    if (d instanceof $root.Data)
      return d;
    var m = new $root.Data();
    switch (d.Type) {
      case "Raw":
      case 0:
        m.Type = 0;
        break;
      case "Directory":
      case 1:
        m.Type = 1;
        break;
      case "File":
      case 2:
        m.Type = 2;
        break;
      case "Metadata":
      case 3:
        m.Type = 3;
        break;
      case "Symlink":
      case 4:
        m.Type = 4;
        break;
      case "HAMTShard":
      case 5:
        m.Type = 5;
        break;
    }
    if (d.Data != null) {
      if (typeof d.Data === "string")
        $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
      else if (d.Data.length)
        m.Data = d.Data;
    }
    if (d.filesize != null) {
      if ($util.Long)
        (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
      else if (typeof d.filesize === "string")
        m.filesize = parseInt(d.filesize, 10);
      else if (typeof d.filesize === "number")
        m.filesize = d.filesize;
      else if (typeof d.filesize === "object")
        m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
    }
    if (d.blocksizes) {
      if (!Array.isArray(d.blocksizes))
        throw TypeError(".Data.blocksizes: array expected");
      m.blocksizes = [];
      for (var i = 0; i < d.blocksizes.length; ++i) {
        if ($util.Long)
          (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
        else if (typeof d.blocksizes[i] === "string")
          m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
        else if (typeof d.blocksizes[i] === "number")
          m.blocksizes[i] = d.blocksizes[i];
        else if (typeof d.blocksizes[i] === "object")
          m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
      }
    }
    if (d.hashType != null) {
      if ($util.Long)
        (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
      else if (typeof d.hashType === "string")
        m.hashType = parseInt(d.hashType, 10);
      else if (typeof d.hashType === "number")
        m.hashType = d.hashType;
      else if (typeof d.hashType === "object")
        m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
    }
    if (d.fanout != null) {
      if ($util.Long)
        (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
      else if (typeof d.fanout === "string")
        m.fanout = parseInt(d.fanout, 10);
      else if (typeof d.fanout === "number")
        m.fanout = d.fanout;
      else if (typeof d.fanout === "object")
        m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
    }
    if (d.mode != null) {
      m.mode = d.mode >>> 0;
    }
    if (d.mtime != null) {
      if (typeof d.mtime !== "object")
        throw TypeError(".Data.mtime: object expected");
      m.mtime = $root.UnixTime.fromObject(d.mtime);
    }
    return m;
  };
  Data3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocksizes = [];
    }
    if (o.defaults) {
      d.Type = o.enums === String ? "Raw" : 0;
      if (o.bytes === String)
        d.Data = "";
      else {
        d.Data = [];
        if (o.bytes !== Array)
          d.Data = $util.newBuffer(d.Data);
      }
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.filesize = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.hashType = o.longs === String ? "0" : 0;
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.fanout = o.longs === String ? "0" : 0;
      d.mode = 0;
      d.mtime = null;
    }
    if (m.Type != null && m.hasOwnProperty("Type")) {
      d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
    }
    if (m.Data != null && m.hasOwnProperty("Data")) {
      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
    }
    if (m.filesize != null && m.hasOwnProperty("filesize")) {
      if (typeof m.filesize === "number")
        d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
      else
        d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
    }
    if (m.blocksizes && m.blocksizes.length) {
      d.blocksizes = [];
      for (var j = 0; j < m.blocksizes.length; ++j) {
        if (typeof m.blocksizes[j] === "number")
          d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
        else
          d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
      }
    }
    if (m.hashType != null && m.hasOwnProperty("hashType")) {
      if (typeof m.hashType === "number")
        d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
      else
        d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
    }
    if (m.fanout != null && m.hasOwnProperty("fanout")) {
      if (typeof m.fanout === "number")
        d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
      else
        d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
    }
    if (m.mode != null && m.hasOwnProperty("mode")) {
      d.mode = m.mode;
    }
    if (m.mtime != null && m.hasOwnProperty("mtime")) {
      d.mtime = $root.UnixTime.toObject(m.mtime, o);
    }
    return d;
  };
  Data3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  Data3.DataType = function() {
    const valuesById = {}, values2 = Object.create(valuesById);
    values2[valuesById[0] = "Raw"] = 0;
    values2[valuesById[1] = "Directory"] = 1;
    values2[valuesById[2] = "File"] = 2;
    values2[valuesById[3] = "Metadata"] = 3;
    values2[valuesById[4] = "Symlink"] = 4;
    values2[valuesById[5] = "HAMTShard"] = 5;
    return values2;
  }();
  return Data3;
})();
var UnixTime = $root.UnixTime = (() => {
  function UnixTime3(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  UnixTime3.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
  UnixTime3.prototype.FractionalNanoseconds = 0;
  UnixTime3.encode = function encode19(m, w) {
    if (!w)
      w = $Writer.create();
    w.uint32(8).int64(m.Seconds);
    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
      w.uint32(21).fixed32(m.FractionalNanoseconds);
    return w;
  };
  UnixTime3.decode = function decode22(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.UnixTime();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.Seconds = r.int64();
          break;
        case 2:
          m.FractionalNanoseconds = r.fixed32();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    if (!m.hasOwnProperty("Seconds"))
      throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
    return m;
  };
  UnixTime3.fromObject = function fromObject(d) {
    if (d instanceof $root.UnixTime)
      return d;
    var m = new $root.UnixTime();
    if (d.Seconds != null) {
      if ($util.Long)
        (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
      else if (typeof d.Seconds === "string")
        m.Seconds = parseInt(d.Seconds, 10);
      else if (typeof d.Seconds === "number")
        m.Seconds = d.Seconds;
      else if (typeof d.Seconds === "object")
        m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
    }
    if (d.FractionalNanoseconds != null) {
      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
    }
    return m;
  };
  UnixTime3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if ($util.Long) {
        var n = new $util.Long(0, 0, false);
        d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.Seconds = o.longs === String ? "0" : 0;
      d.FractionalNanoseconds = 0;
    }
    if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
      if (typeof m.Seconds === "number")
        d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
      else
        d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
    }
    if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
      d.FractionalNanoseconds = m.FractionalNanoseconds;
    }
    return d;
  };
  UnixTime3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return UnixTime3;
})();
var Metadata = $root.Metadata = (() => {
  function Metadata4(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Metadata4.prototype.MimeType = "";
  Metadata4.encode = function encode19(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
      w.uint32(10).string(m.MimeType);
    return w;
  };
  Metadata4.decode = function decode22(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.MimeType = r.string();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata4.fromObject = function fromObject(d) {
    if (d instanceof $root.Metadata)
      return d;
    var m = new $root.Metadata();
    if (d.MimeType != null) {
      m.MimeType = String(d.MimeType);
    }
    return m;
  };
  Metadata4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.MimeType = "";
    }
    if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
      d.MimeType = m.MimeType;
    }
    return d;
  };
  Metadata4.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
  };
  return Metadata4;
})();

// node_modules/ipfs-unixfs/esm/src/index.js
var PBData = Data;
var types = [
  "raw",
  "directory",
  "file",
  "metadata",
  "symlink",
  "hamt-sharded-directory"
];
var dirTypes = [
  "directory",
  "hamt-sharded-directory"
];
var DEFAULT_FILE_MODE = parseInt("0644", 8);
var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var UnixFS = class {
  static unmarshal(marshaled) {
    const message = PBData.decode(marshaled);
    const decoded = PBData.toObject(message, {
      defaults: false,
      arrays: true,
      longs: Number,
      objects: false
    });
    const data = new UnixFS({
      type: types[decoded.Type],
      data: decoded.Data,
      blockSizes: decoded.blocksizes,
      mode: decoded.mode,
      mtime: decoded.mtime ? {
        secs: decoded.mtime.Seconds,
        nsecs: decoded.mtime.FractionalNanoseconds
      } : void 0
    });
    data._originalMode = decoded.mode || 0;
    return data;
  }
  constructor(options = { type: "file" }) {
    const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
    if (type && !types.includes(type)) {
      throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type || "file";
    this.data = data;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes || [];
    this._originalMode = 0;
    this.mode = parseMode(mode);
    if (mtime) {
      this.mtime = parseMtime(mtime);
      if (this.mtime && !this.mtime.nsecs) {
        this.mtime.nsecs = 0;
      }
    }
  }
  set mode(mode) {
    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    const parsedMode = parseMode(mode);
    if (parsedMode !== void 0) {
      this._mode = parsedMode;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return Boolean(this.type && dirTypes.includes(this.type));
  }
  addBlockSize(size) {
    this.blockSizes.push(size);
  }
  removeBlockSize(index) {
    this.blockSizes.splice(index, 1);
  }
  fileSize() {
    if (this.isDirectory()) {
      return 0;
    }
    let sum = 0;
    this.blockSizes.forEach((size) => {
      sum += size;
    });
    if (this.data) {
      sum += this.data.length;
    }
    return sum;
  }
  marshal() {
    let type;
    switch (this.type) {
      case "raw":
        type = PBData.DataType.Raw;
        break;
      case "directory":
        type = PBData.DataType.Directory;
        break;
      case "file":
        type = PBData.DataType.File;
        break;
      case "metadata":
        type = PBData.DataType.Metadata;
        break;
      case "symlink":
        type = PBData.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type = PBData.DataType.HAMTShard;
        break;
      default:
        throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    let data = this.data;
    if (!this.data || !this.data.length) {
      data = void 0;
    }
    let mode;
    if (this.mode != null) {
      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode = void 0;
      }
      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      const parsed = parseMtime(this.mtime);
      if (parsed) {
        mtime = {
          Seconds: parsed.secs,
          FractionalNanoseconds: parsed.nsecs
        };
        if (mtime.FractionalNanoseconds === 0) {
          delete mtime.FractionalNanoseconds;
        }
      }
    }
    const pbData = {
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    };
    return PBData.encode(pbData).finish();
  }
};

// node_modules/@ipld/dag-pb/esm/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  code: () => code,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode5,
  encode: () => encode3,
  name: () => name,
  prepare: () => prepare,
  validate: () => validate
});
init_globals();
init_cid();

// node_modules/@ipld/dag-pb/esm/src/pb-decode.js
init_globals();
var textDecoder = new TextDecoder();
function decodeVarint(bytes2, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes2[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [
    v,
    offset
  ];
}
function decodeBytes2(bytes2, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes2, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes2.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey(bytes2, index) {
  let wire;
  [wire, index] = decodeVarint(bytes2, index);
  return [
    wire & 7,
    wire >> 3,
    index
  ];
}
function decodeLink(bytes2) {
  const link = {};
  const l = bytes2.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes2, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      ;
      [link.Hash, index] = decodeBytes2(bytes2, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes2(bytes2, index);
      link.Name = textDecoder.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      ;
      [link.Tsize, index] = decodeVarint(bytes2, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes2) {
  const l = bytes2.length;
  let index = 0;
  let links3;
  let linksBeforeData = false;
  let data;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes2, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      ;
      [data, index] = decodeBytes2(bytes2, index);
      if (links3) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links3) {
        links3 = [];
      }
      let byts;
      [byts, index] = decodeBytes2(bytes2, index);
      links3.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links3 || [];
  return node;
}

// node_modules/@ipld/dag-pb/esm/src/pb-encode.js
init_globals();
var textEncoder = new TextEncoder();
var maxInt32 = 2 ** 32;
var maxUInt32 = 2 ** 31;
function encodeLink(link, bytes2) {
  let i = bytes2.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint(bytes2, i, link.Tsize) - 1;
    bytes2[i] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder.encode(link.Name);
    i -= nameBytes.length;
    bytes2.set(nameBytes, i);
    i = encodeVarint(bytes2, i, nameBytes.length) - 1;
    bytes2[i] = 18;
  }
  if (link.Hash) {
    i -= link.Hash.length;
    bytes2.set(link.Hash, i);
    i = encodeVarint(bytes2, i, link.Hash.length) - 1;
    bytes2[i] = 10;
  }
  return bytes2.length - i;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes2 = new Uint8Array(size);
  let i = size;
  if (node.Data) {
    i -= node.Data.length;
    bytes2.set(node.Data, i);
    i = encodeVarint(bytes2, i, node.Data.length) - 1;
    bytes2[i] = 10;
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size2 = encodeLink(node.Links[index], bytes2.subarray(0, i));
      i -= size2;
      i = encodeVarint(bytes2, i, size2) - 1;
      bytes2[i] = 18;
    }
  }
  return bytes2;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes2, offset, v) {
  offset -= sov(v);
  const base4 = offset;
  while (v >= maxUInt32) {
    bytes2[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes2[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes2[offset] = v;
  return base4;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
var len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];

// node_modules/@ipld/dag-pb/esm/src/util.js
init_globals();
init_cid();
var pbNodeProperties = [
  "Data",
  "Links"
];
var pbLinkProperties = [
  "Hash",
  "Name",
  "Tsize"
];
var textEncoder2 = new TextEncoder();
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder2.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder2.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash = CID.asCID(link);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder2.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link = node.Links[i];
    if (!link || typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links3 = []) {
  return prepare({
    Data: data,
    Links: links3
  });
}
function createLink(name10, size, cid) {
  return asLink({
    Hash: cid,
    Name: name10,
    Tsize: size
  });
}

// node_modules/@ipld/dag-pb/esm/src/index.js
var name = "dag-pb";
var code = 112;
function encode3(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode5(bytes2) {
  const pbn = decodeNode(bytes2);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}

// node_modules/ipfs-core/node_modules/@ipld/dag-cbor/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  code: () => code2,
  decode: () => decode7,
  encode: () => encode5,
  name: () => name2
});
init_globals();
init_cborg();
init_cid();
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes2)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var name2 = "dag-cbor";
var code2 = 113;
var encode5 = (node) => encode4(node, encodeOptions);
var decode7 = (data) => decode6(data, decodeOptions);

// node_modules/@ipld/dag-json/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  code: () => code3,
  decode: () => decode9,
  encode: () => encode7,
  name: () => name3
});
init_globals();
init_src();
init_base64();
init_cborg();

// node_modules/cborg/esm/lib/json/json.js
init_globals();

// node_modules/cborg/esm/lib/json/encode.js
init_globals();
init_token();
init_encode();
init_common();
init_byte_utils();
var JSONEncoder = class extends Array {
  constructor() {
    super();
    this.inRecursive = [];
  }
  prefix(buf3) {
    const recurs = this.inRecursive[this.inRecursive.length - 1];
    if (recurs) {
      if (recurs.type === Type.array) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          buf3.push([44]);
        }
      }
      if (recurs.type === Type.map) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          if (recurs.elements % 2 === 1) {
            buf3.push([44]);
          } else {
            buf3.push([58]);
          }
        }
      }
    }
  }
  [Type.uint.major](buf3, token) {
    this.prefix(buf3);
    const is3 = String(token.value);
    const isa = [];
    for (let i = 0; i < is3.length; i++) {
      isa[i] = is3.charCodeAt(i);
    }
    buf3.push(isa);
  }
  [Type.negint.major](buf3, token) {
    this[Type.uint.major](buf3, token);
  }
  [Type.bytes.major](_buf, _token) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  [Type.string.major](buf3, token) {
    this.prefix(buf3);
    const byts = fromString2(JSON.stringify(token.value));
    buf3.push(byts.length > 32 ? asU8A(byts) : byts);
  }
  [Type.array.major](buf3, _token) {
    this.prefix(buf3);
    this.inRecursive.push({
      type: Type.array,
      elements: 0
    });
    buf3.push([91]);
  }
  [Type.map.major](buf3, _token) {
    this.prefix(buf3);
    this.inRecursive.push({
      type: Type.map,
      elements: 0
    });
    buf3.push([123]);
  }
  [Type.tag.major](_buf, _token) {
  }
  [Type.float.major](buf3, token) {
    if (token.type.name === "break") {
      const recurs = this.inRecursive.pop();
      if (recurs) {
        if (recurs.type === Type.array) {
          buf3.push([93]);
        } else if (recurs.type === Type.map) {
          buf3.push([125]);
        } else {
          throw new Error("Unexpected recursive type; this should not happen!");
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (token.value === void 0) {
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    }
    this.prefix(buf3);
    if (token.type.name === "true") {
      buf3.push([
        116,
        114,
        117,
        101
      ]);
      return;
    } else if (token.type.name === "false") {
      buf3.push([
        102,
        97,
        108,
        115,
        101
      ]);
      return;
    } else if (token.type.name === "null") {
      buf3.push([
        110,
        117,
        108,
        108
      ]);
      return;
    }
    const is3 = String(token.value);
    const isa = [];
    let dp = false;
    for (let i = 0; i < is3.length; i++) {
      isa[i] = is3.charCodeAt(i);
      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
        dp = true;
      }
    }
    if (!dp) {
      isa.push(46);
      isa.push(48);
    }
    buf3.push(isa);
  }
};
function mapSorter2(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {
    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
}
var defaultEncodeOptions2 = {
  addBreakTokens: true,
  mapSorter: mapSorter2
};
function encode6(data, options) {
  options = Object.assign({}, defaultEncodeOptions2, options);
  return encodeCustom(data, new JSONEncoder(), options);
}

// node_modules/cborg/esm/lib/json/decode.js
init_globals();
init_decode();
init_token();
init_byte_utils();
init_common();
var Tokenizer = class {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
    this.modeStack = ["value"];
    this.lastToken = "";
  }
  done() {
    return this.pos >= this.data.length;
  }
  ch() {
    return this.data[this.pos];
  }
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let c = this.ch();
    while (c === 32 || c === 9 || c === 13 || c === 10) {
      c = this.data[++this.pos];
    }
  }
  expect(str) {
    if (this.data.length - this.pos < str.length) {
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);
    }
    for (let i = 0; i < str.length; i++) {
      if (this.data[this.pos++] !== str[i]) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...str)}'`);
      }
    }
  }
  parseNumber() {
    const startPos = this.pos;
    let negative = false;
    let float = false;
    const swallow = (chars) => {
      while (!this.done()) {
        const ch = this.ch();
        if (chars.includes(ch)) {
          this.pos++;
        } else {
          break;
        }
      }
    };
    if (this.ch() === 45) {
      negative = true;
      this.pos++;
    }
    if (this.ch() === 48) {
      this.pos++;
      if (this.ch() === 46) {
        this.pos++;
        float = true;
      } else {
        return new Token(Type.uint, 0, this.pos - startPos);
      }
    }
    swallow([
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57
    ]);
    if (negative && this.pos === startPos + 1) {
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
    }
    if (!this.done() && this.ch() === 46) {
      if (float) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
      }
      float = true;
      this.pos++;
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
      float = true;
      this.pos++;
      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
        this.pos++;
      }
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this.pos));
    const num = parseFloat(numStr);
    if (float) {
      return new Token(Type.float, num, this.pos - startPos);
    }
    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
      return new Token(num >= 0 ? Type.uint : Type.negint, num, this.pos - startPos);
    }
    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this.pos - startPos);
  }
  parseString() {
    if (this.ch() !== 34) {
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);
    }
    this.pos++;
    for (let i = this.pos, l = 0; i < this.data.length && l < 65536; i++, l++) {
      const ch = this.data[i];
      if (ch === 92 || ch < 32 || ch >= 128) {
        break;
      }
      if (ch === 34) {
        const str = String.fromCharCode.apply(null, this.data.subarray(this.pos, i));
        this.pos = i + 1;
        return new Token(Type.string, str, l);
      }
    }
    const startPos = this.pos;
    const chars = [];
    const readu4 = () => {
      if (this.pos + 4 >= this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);
      }
      let u4 = 0;
      for (let i = 0; i < 4; i++) {
        let ch = this.ch();
        if (ch >= 48 && ch <= 57) {
          ch -= 48;
        } else if (ch >= 97 && ch <= 102) {
          ch = ch - 97 + 10;
        } else if (ch >= 65 && ch <= 70) {
          ch = ch - 65 + 10;
        } else {
          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);
        }
        u4 = u4 * 16 + ch;
        this.pos++;
      }
      return u4;
    };
    const readUtf8Char = () => {
      const firstByte = this.ch();
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (this.pos + bytesPerSequence > this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);
      }
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = this.data[this.pos + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          fourthByte = this.data[this.pos + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        chars.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      chars.push(codePoint);
      this.pos += bytesPerSequence;
    };
    while (!this.done()) {
      const ch = this.ch();
      let ch1;
      switch (ch) {
        case 92:
          this.pos++;
          if (this.done()) {
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);
          }
          ch1 = this.ch();
          this.pos++;
          switch (ch1) {
            case 34:
            case 39:
            case 92:
            case 47:
              chars.push(ch1);
              break;
            case 98:
              chars.push(8);
              break;
            case 116:
              chars.push(9);
              break;
            case 110:
              chars.push(10);
              break;
            case 102:
              chars.push(12);
              break;
            case 114:
              chars.push(13);
              break;
            case 117:
              chars.push(readu4());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`);
          }
          break;
        case 34:
          this.pos++;
          return new Token(Type.string, decodeCodePointsArray(chars), this.pos - startPos);
        default:
          if (ch < 32) {
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);
          } else if (ch < 128) {
            chars.push(ch);
            this.pos++;
          } else {
            readUtf8Char();
          }
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`);
  }
  parseValue() {
    switch (this.ch()) {
      case 123:
        this.modeStack.push("obj-start");
        this.pos++;
        return new Token(Type.map, Infinity, 1);
      case 91:
        this.modeStack.push("array-start");
        this.pos++;
        return new Token(Type.array, Infinity, 1);
      case 34: {
        return this.parseString();
      }
      case 110:
        this.expect([
          110,
          117,
          108,
          108
        ]);
        return new Token(Type.null, null, 4);
      case 102:
        this.expect([
          102,
          97,
          108,
          115,
          101
        ]);
        return new Token(Type.false, false, 5);
      case 116:
        this.expect([
          116,
          114,
          117,
          101
        ]);
        return new Token(Type.true, true, 4);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`);
    }
  }
  next() {
    this.skipWhitespace();
    switch (this.currentMode()) {
      case "value":
        this.modeStack.pop();
        return this.parseValue();
      case "array-value": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "array-start": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "obj-key":
        if (this.ch() === 125) {
          this.modeStack.pop();
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.skipWhitespace();
      case "obj-start": {
        this.modeStack.pop();
        if (this.ch() === 125) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        const token = this.parseString();
        this.skipWhitespace();
        if (this.ch() !== 58) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("obj-value");
        return token;
      }
      case "obj-value": {
        this.modeStack.pop();
        this.modeStack.push("obj-key");
        this.skipWhitespace();
        return this.parseValue();
      }
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`);
    }
  }
};
function decode8(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode6(data, options);
}

// node_modules/@ipld/dag-json/esm/index.js
function cidEncoder2(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.string, cidString, cidString.length),
    new Token(Type.break, void 0, 1)
  ];
}
function bytesEncoder(bytes2) {
  const bytesString = base64.encode(bytes2).slice(1);
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "bytes", 5),
    new Token(Type.string, bytesString, bytesString.length),
    new Token(Type.break, void 0, 1),
    new Token(Type.break, void 0, 1)
  ];
}
function undefinedEncoder2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions2 = {
  typeEncoders: {
    Object: cidEncoder2,
    Uint8Array: bytesEncoder,
    Buffer: bytesEncoder,
    undefined: undefinedEncoder2,
    number: numberEncoder2
  }
};
var DagJsonTokenizer = class extends Tokenizer {
  constructor(data, options) {
    super(data, options);
    this.tokenBuffer = [];
  }
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  next() {
    const token = this._next();
    if (token.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i = 0; i < 2; i++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes2 = base64.decode(`m${innerValueToken.value}`);
              return new Token(Type.bytes, bytes2, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token;
  }
};
var decodeOptions2 = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions2.tags[42] = CID.parse;
var name3 = "dag-json";
var code3 = 297;
var encode7 = (node) => encode6(node, encodeOptions2);
var decode9 = (data) => {
  const options = Object.assign(decodeOptions2, { tokenizer: new DagJsonTokenizer(data, decodeOptions2) });
  return decode8(data, options);
};

// node_modules/ipfs-core/esm/src/components/index.js
var dagJOSE2 = __toESM(require_lib(), 1);
init_identity();
init_basics();

// node_modules/ipfs-core-config/esm/src/init-assets.browser.js
init_globals();
function initAssets() {
}

// node_modules/ipfs-core/esm/src/errors.js
init_globals();
var NotInitializedError = class extends Error {
  constructor(message = "not initialized") {
    super(message);
    this.name = "NotInitializedError";
    this.code = NotInitializedError.code;
  }
};
NotInitializedError.code = "ERR_NOT_INITIALIZED";
var AlreadyInitializingError = class extends Error {
  constructor(message = "cannot initialize an initializing node") {
    super(message);
    this.name = "AlreadyInitializingError";
    this.code = AlreadyInitializedError.code;
  }
};
AlreadyInitializingError.code = "ERR_ALREADY_INITIALIZING";
var AlreadyInitializedError = class extends Error {
  constructor(message = "cannot re-initialize an initialized node") {
    super(message);
    this.name = "AlreadyInitializedError";
    this.code = AlreadyInitializedError.code;
  }
};
AlreadyInitializedError.code = "ERR_ALREADY_INITIALIZED";
var NotStartedError = class extends Error {
  constructor(message = "not started") {
    super(message);
    this.name = "NotStartedError";
    this.code = NotStartedError.code;
  }
};
NotStartedError.code = "ERR_NOT_STARTED";
var AlreadyStartingError = class extends Error {
  constructor(message = "cannot start, already startin") {
    super(message);
    this.name = "AlreadyStartingError";
    this.code = AlreadyStartingError.code;
  }
};
AlreadyStartingError.code = "ERR_ALREADY_STARTING";
var AlreadyStartedError = class extends Error {
  constructor(message = "cannot start, already started") {
    super(message);
    this.name = "AlreadyStartedError";
    this.code = AlreadyStartedError.code;
  }
};
AlreadyStartedError.code = "ERR_ALREADY_STARTED";
var NotEnabledError = class extends Error {
  constructor(message = "not enabled") {
    super(message);
    this.name = "NotEnabledError";
    this.code = NotEnabledError.code;
  }
};
NotEnabledError.code = "ERR_NOT_ENABLED";

// node_modules/ipfs-core/esm/src/components/index.js
init_from_string();

// node_modules/ipfs-core/esm/src/components/start.js
init_globals();

// node_modules/ipfs-core/esm/src/utils/service.js
init_globals();

// node_modules/ipfs-core/esm/src/utils.js
init_globals();
var import_is_ipfs = __toESM(require_src3(), 1);
init_cid();
init_key();
var import_err_code3 = __toESM(require_err_code(), 1);

// node_modules/ipfs-core-utils/esm/src/with-timeout-option.js
init_globals();
var import_timeout_abort_controller = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal = __toESM(require_any_signal(), 1);

// node_modules/parse-duration/index.mjs
init_globals();
var durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
parse.nanosecond = parse.ns = 1 / 1e6;
parse["\xB5s"] = parse["\u03BCs"] = parse.us = parse.microsecond = 1 / 1e3;
parse.millisecond = parse.ms = parse[""] = 1;
parse.second = parse.sec = parse.s = parse.ms * 1e3;
parse.minute = parse.min = parse.m = parse.s * 60;
parse.hour = parse.hr = parse.h = parse.m * 60;
parse.day = parse.d = parse.h * 24;
parse.week = parse.wk = parse.w = parse.d * 7;
parse.month = parse.b = parse.d * (365.25 / 12);
parse.year = parse.yr = parse.y = parse.d * 365.25;
function parse(str = "", format = "ms") {
  var result = null;
  str = (str + "").replace(/(\d)[,_](\d)/g, "$1$2");
  str.replace(durationRE, function(_, n, units) {
    units = unitRatio(units);
    if (units)
      result = (result || 0) + parseFloat(n, 10) * units;
  });
  return result && result / (unitRatio(format) || 1);
}
function unitRatio(str) {
  return parse[str] || parse[str.toLowerCase().replace(/s$/, "")];
}
var parse_duration_default = parse;

// node_modules/ipfs-core-utils/esm/src/errors.js
init_globals();
var TimeoutError = class extends Error {
  constructor(message = "request timed out") {
    super(message);
    this.name = "TimeoutError";
    this.code = TimeoutError.code;
  }
};
TimeoutError.code = "ERR_TIMEOUT";

// node_modules/ipfs-core-utils/esm/src/with-timeout-option.js
function withTimeoutOption(fn, optionsArgIndex) {
  return (...args) => {
    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];
    if (!options || !options.timeout)
      return fn(...args);
    const timeout = typeof options.timeout === "string" ? parse_duration_default(options.timeout) : options.timeout;
    const controller = new import_timeout_abort_controller.TimeoutController(timeout);
    options.signal = (0, import_any_signal.anySignal)([
      options.signal,
      controller.signal
    ]);
    const fnRes = fn(...args);
    const timeoutPromise = new Promise((_resolve, reject) => {
      controller.signal.addEventListener("abort", () => {
        reject(new TimeoutError());
      });
    });
    const start = Date.now();
    const maybeThrowTimeoutError = () => {
      if (controller.signal.aborted) {
        throw new TimeoutError();
      }
      const timeTaken = Date.now() - start;
      if (timeTaken > timeout) {
        controller.abort();
        throw new TimeoutError();
      }
    };
    if (fnRes[Symbol.asyncIterator]) {
      return async function* () {
        const it = fnRes[Symbol.asyncIterator]();
        try {
          while (true) {
            const { value, done } = await Promise.race([
              it.next(),
              timeoutPromise
            ]);
            if (done) {
              break;
            }
            maybeThrowTimeoutError();
            yield value;
          }
        } catch (err) {
          maybeThrowTimeoutError();
          throw err;
        } finally {
          controller.clear();
          if (it.return) {
            it.return();
          }
        }
      }();
    }
    return (async () => {
      try {
        const res = await Promise.race([
          fnRes,
          timeoutPromise
        ]);
        maybeThrowTimeoutError();
        return res;
      } catch (err) {
        maybeThrowTimeoutError();
        throw err;
      } finally {
        controller.clear();
      }
    })();
  };
}

// node_modules/ipfs-core-utils/esm/src/to-cid-and-path.js
init_globals();
init_cid();
var import_err_code2 = __toESM(require_err_code(), 1);
var IPFS_PREFIX = "/ipfs/";
function toCidAndPath(string3) {
  if (string3 instanceof Uint8Array) {
    try {
      string3 = CID.decode(string3);
    } catch (err) {
      throw (0, import_err_code2.default)(err, "ERR_INVALID_CID");
    }
  }
  let cid = CID.asCID(string3);
  if (cid) {
    return {
      cid,
      path: void 0
    };
  }
  string3 = string3.toString();
  if (string3.startsWith(IPFS_PREFIX)) {
    string3 = string3.substring(IPFS_PREFIX.length);
  }
  const parts = string3.split("/");
  let path;
  try {
    cid = CID.parse(parts.shift() || "");
  } catch (err) {
    throw (0, import_err_code2.default)(err, "ERR_INVALID_CID");
  }
  if (parts.length) {
    path = `/${parts.join("/")}`;
  }
  return {
    cid,
    path
  };
}

// node_modules/ipfs-core/esm/src/utils.js
var ERR_BAD_PATH = "ERR_BAD_PATH";
var OFFLINE_ERROR = "This command must be run in online mode. Try running 'ipfs daemon' first.";
var MFS_ROOT_KEY = new Key("/local/filesroot");
var MFS_MAX_CHUNK_SIZE = 262144;
var normalizePath = (pathStr) => {
  const cid = CID.asCID(pathStr);
  if (cid) {
    return `/ipfs/${pathStr}`;
  }
  const str = pathStr.toString();
  try {
    return `/ipfs/${CID.parse(str)}`;
  } catch {
  }
  if (import_is_ipfs.default.path(str)) {
    return str;
  } else {
    throw (0, import_err_code3.default)(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);
  }
};
var normalizeCidPath = (path) => {
  if (path instanceof Uint8Array) {
    return CID.decode(path).toString();
  }
  path = path.toString();
  if (path.indexOf("/ipfs/") === 0) {
    path = path.substring("/ipfs/".length);
  }
  if (path.charAt(path.length - 1) === "/") {
    path = path.substring(0, path.length - 1);
  }
  return path;
};
var resolvePath = async function(repo, codecs2, ipfsPath2, options = {}) {
  const { cid, path } = toCidAndPath(ipfsPath2);
  if (path) {
    options.path = path;
  }
  let lastCid = cid;
  let lastRemainderPath = options.path || "";
  if (lastRemainderPath.startsWith("/")) {
    lastRemainderPath = lastRemainderPath.substring(1);
  }
  if (options.path) {
    try {
      for await (const { value, remainderPath } of resolve(cid, options.path, codecs2, repo, { signal: options.signal })) {
        if (!CID.asCID(value)) {
          break;
        }
        lastRemainderPath = remainderPath;
        lastCid = value;
      }
    } catch (err) {
      if (err.message.startsWith("Object has no property")) {
        err.message = `no link named "${lastRemainderPath.split("/")[0]}" under ${lastCid}`;
        err.code = "ERR_NO_LINK";
      }
      throw err;
    }
  }
  return {
    cid: lastCid,
    remainderPath: lastRemainderPath || ""
  };
};
var mapFile = (file) => {
  if (file.type !== "file" && file.type !== "directory" && file.type !== "raw") {
    throw new Error(`Unknown node type '${file.type}'`);
  }
  const output = {
    cid: file.cid,
    path: file.path,
    name: file.name,
    size: file.size,
    type: "file"
  };
  if (file.type === "directory") {
    output.type = "dir";
  }
  if (file.type === "file") {
    output.size = file.unixfs.fileSize();
  }
  if (file.type === "file" || file.type === "directory") {
    output.mode = file.unixfs.mode;
    if (file.unixfs.mtime !== void 0) {
      output.mtime = file.unixfs.mtime;
    }
  }
  return output;
};
var withTimeout = withTimeoutOption(async (promise, _options) => await promise);
var resolve = async function* (cid, path, codecs2, repo, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await repo.blocks.get(cid2, options);
    return codec.decode(block);
  };
  const parts = path.split("/").filter(Boolean);
  let value = await load(cid);
  let lastCid = cid;
  while (parts.length) {
    const key = parts.shift();
    if (!key) {
      throw (0, import_err_code3.default)(new Error(`Could not resolve path "${path}"`), "ERR_INVALID_PATH");
    }
    if (cid.code === code && Array.isArray(value.Links)) {
      const link = value.Links.find((l) => l.Name === key);
      if (link) {
        yield {
          value: link.Hash,
          remainderPath: parts.join("/")
        };
        value = await load(link.Hash);
        lastCid = link.Hash;
        continue;
      }
    }
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      value = value[key];
      yield {
        value,
        remainderPath: parts.join("/")
      };
    } else {
      throw (0, import_err_code3.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    if (CID.asCID(value)) {
      lastCid = value;
      value = await load(value);
    }
  }
  yield {
    value,
    remainderPath: ""
  };
};

// node_modules/ipfs-core/esm/src/utils/service.js
var Service = class {
  static create({ start, stop }) {
    return new Service(start, stop);
  }
  static async start(service, options) {
    const { state, activate } = service;
    switch (state.status) {
      case "stopped": {
        try {
          const promise = activate(options);
          service.state = {
            status: "starting",
            ready: promise
          };
          const result = await promise;
          service.state = {
            status: "started",
            value: result
          };
          return result;
        } catch (error) {
          service.state = { status: "stopped" };
          throw error;
        }
      }
      case "starting": {
        throw new AlreadyStartingError();
      }
      case "started": {
        throw new AlreadyStartedError();
      }
      case "stopping": {
        await state.ready;
        return await Service.start(service, options);
      }
      default: {
        return Service.panic(service);
      }
    }
  }
  static async stop(service) {
    const { state, deactivate } = service;
    switch (state.status) {
      case "stopped": {
        break;
      }
      case "starting": {
        try {
          await state.ready;
        } catch (_) {
        }
        return await Service.stop(service);
      }
      case "stopping": {
        return await state.ready;
      }
      case "started": {
        if (deactivate) {
          await deactivate(state.value);
        }
        service.state = { status: "stopped" };
        break;
      }
      default: {
        Service.panic(state);
      }
    }
  }
  static try({ state }) {
    switch (state.status) {
      case "started":
        return state.value;
      default:
        return null;
    }
  }
  static async use({ state }, options) {
    switch (state.status) {
      case "started":
        return state.value;
      case "starting":
        return await withTimeout(state.ready, options);
      default:
        throw new NotStartedError();
    }
  }
  static panic({ state }) {
    const status = JSON.stringify({ status: state.status });
    throw RangeError(`Service in invalid state ${status}, should never happen if you see this please report a bug`);
  }
  constructor(activate, deactivate) {
    this.activate = activate;
    this.deactivate = deactivate;
    this.state = { status: "stopped" };
  }
  async use(options) {
    return await Service.use(this, options);
  }
  try() {
    return Service.try(this);
  }
};

// node_modules/ipfs-core/esm/src/components/start.js
function createStart({ network, preload: preload2, peerId, keychain, repo, ipns, mfsPreload, print, hashers, options }) {
  const start = async () => {
    const { libp2p } = await Service.start(network, {
      peerId,
      repo,
      print,
      hashers,
      options
    });
    await Promise.all([
      ipns.startOnline({
        keychain,
        libp2p,
        peerId,
        repo
      }),
      preload2.start(),
      mfsPreload.start()
    ]);
  };
  return start;
}

// node_modules/ipfs-core/esm/src/components/stop.js
init_globals();
function createStop({ network, preload: preload2, ipns, repo, mfsPreload }) {
  const stop = async () => {
    await Promise.all([
      preload2.stop(),
      ipns.stop(),
      mfsPreload.stop()
    ]);
    await Service.stop(network);
    await repo.close();
  };
  return stop;
}

// node_modules/ipfs-core/esm/src/components/dns.js
init_globals();

// node_modules/ipfs-core-config/esm/src/dns.browser.js
init_globals();

// node_modules/ipfs-core-config/esm/src/utils/tlru.js
init_globals();
var import_hashlru = __toESM(require_hashlru(), 1);
var TLRU = class {
  constructor(maxSize) {
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  get(key) {
    const value = this.lru.get(key);
    if (value) {
      if (value.expire && value.expire < Date.now()) {
        this.lru.remove(key);
        return void 0;
      }
      return value.value;
    }
    return void 0;
  }
  set(key, value, ttl2) {
    this.lru.set(key, {
      value,
      expire: Date.now() + ttl2
    });
  }
  has(key) {
    const value = this.get(key);
    if (value) {
      return true;
    }
    return false;
  }
  remove(key) {
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};

// node_modules/ipfs-core-config/esm/src/dns.browser.js
var import_p_queue = __toESM(require_dist(), 1);
var import_http = __toESM(require_http(), 1);
var cache = new TLRU(1e3);
var ttl = 60 * 1e3;
var Queue = import_p_queue.default.default ? import_p_queue.default.default : import_p_queue.default;
var httpQueue = new Queue({ concurrency: 4 });
var ipfsPath = (response) => {
  if (response.Path)
    return response.Path;
  throw new Error(response.Message);
};
async function resolveDnslink(fqdn, opts) {
  const resolve11 = async (fqdn2, opts2 = {}) => {
    const searchParams = new URLSearchParams(opts2);
    searchParams.set("arg", fqdn2);
    const query = searchParams.toString();
    if (!opts2.nocache && cache.has(query)) {
      const response2 = cache.get(query);
      return ipfsPath(response2);
    }
    const response = await httpQueue.add(async () => {
      const res = await import_http.default.get("https://ipfs.io/api/v0/dns", { searchParams });
      const query2 = new URL(res.url).search.slice(1);
      const json = await res.json();
      cache.set(query2, json, ttl);
      return json;
    });
    return ipfsPath(response);
  };
  return resolve11(fqdn, opts);
}

// node_modules/ipfs-core/esm/src/components/dns.js
function fqdnFixups(domain) {
  if (domain.endsWith(".eth")) {
    domain = domain.replace(/.eth$/, ".eth.link");
  }
  return domain;
}
function createDns() {
  const resolveDNS = async (domain, options = { recursive: true }) => {
    if (typeof domain !== "string") {
      throw new Error("Invalid arguments, domain must be a string");
    }
    domain = fqdnFixups(domain);
    return resolveDnslink(domain, options);
  };
  return withTimeoutOption(resolveDNS);
}

// node_modules/ipfs-core/esm/src/components/is-online.js
init_globals();
function createIsOnline({ network }) {
  return () => {
    const net = network.try();
    return net != null && Boolean(net.libp2p.isStarted());
  };
}

// node_modules/ipfs-core/esm/src/components/resolve.js
init_globals();
var import_is_ipfs2 = __toESM(require_src3(), 1);
init_cid();
var import_peer_id = __toESM(require_src5(), 1);
function createResolve({ repo, codecs: codecs2, bases: bases3, name: name10 }) {
  async function resolve11(path, opts = {}) {
    if (!import_is_ipfs2.default.path(path)) {
      throw new Error("invalid argument " + path);
    }
    if (import_is_ipfs2.default.ipnsPath(path)) {
      for await (const resolvedPath of name10.resolve(path, opts)) {
        path = resolvedPath;
      }
    }
    const [, schema, hash2, ...rest] = path.split("/");
    const base4 = opts.cidBase ? await bases3.getBase(opts.cidBase) : void 0;
    const bytes2 = parseBytes(hash2);
    if (rest.length === 0) {
      const str = base4 ? base4.encoder.encode(bytes2) : hash2;
      return `/${schema}/${str}`;
    }
    const cid = CID.decode(bytes2);
    path = rest.join("/");
    const results = resolve(cid, path, codecs2, repo, opts);
    let value = cid;
    let remainderPath = path;
    for await (const result of results) {
      if (CID.asCID(result.value)) {
        value = result.value;
        remainderPath = result.remainderPath;
      }
    }
    return `/ipfs/${value.toString(base4 && base4.encoder)}${remainderPath ? "/" + remainderPath : ""}`;
  }
  return withTimeoutOption(resolve11);
}
function parseBytes(str) {
  try {
    return import_peer_id.default.parse(str).toBytes();
  } catch {
    return CID.parse(str).bytes;
  }
}

// node_modules/ipfs-core/esm/src/components/pin/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/pin/add.js
init_globals();
var import_it_last = __toESM(require_it_last(), 1);
init_cid();
function createAdd({ addAll }) {
  return (path, options = {}) => {
    let iter;
    const cid = CID.asCID(path);
    if (cid) {
      iter = addAll([{
        cid,
        ...options
      }], options);
    } else {
      iter = addAll([{
        path: path.toString(),
        ...options
      }], options);
    }
    return (0, import_it_last.default)(iter);
  };
}

// node_modules/ipfs-core/esm/src/components/pin/add-all.js
init_globals();

// node_modules/ipfs-core-utils/esm/src/pins/normalise-input.js
init_globals();
var import_err_code4 = __toESM(require_err_code(), 1);
init_cid();
async function* normaliseInput(input) {
  if (input === null || input === void 0) {
    throw (0, import_err_code4.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  const cid = CID.asCID(input);
  if (cid) {
    yield toPin({ cid });
    return;
  }
  if (input instanceof String || typeof input === "string") {
    yield toPin({ path: input });
    return;
  }
  if (input.cid != null || input.path != null) {
    return yield toPin(input);
  }
  if (Symbol.iterator in input) {
    const iterator = input[Symbol.iterator]();
    const first4 = iterator.next();
    if (first4.done)
      return iterator;
    if (CID.asCID(first4.value) || first4.value instanceof String || typeof first4.value === "string") {
      yield toPin({ cid: first4.value });
      for (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first4.value.cid != null || first4.value.path != null) {
      yield toPin(first4.value);
      for (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code4.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  if (Symbol.asyncIterator in input) {
    const iterator = input[Symbol.asyncIterator]();
    const first4 = await iterator.next();
    if (first4.done)
      return iterator;
    if (CID.asCID(first4.value) || first4.value instanceof String || typeof first4.value === "string") {
      yield toPin({ cid: first4.value });
      for await (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first4.value.cid != null || first4.value.path != null) {
      yield toPin(first4.value);
      for await (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code4.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code4.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
function toPin(input) {
  const path = input.cid || `${input.path}`;
  if (!path) {
    throw (0, import_err_code4.default)(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
  }
  const pin = {
    path,
    recursive: input.recursive !== false
  };
  if (input.metadata != null) {
    pin.metadata = input.metadata;
  }
  return pin;
}

// node_modules/ipfs-repo/esm/src/pin-types.js
init_globals();
var PinTypes = {
  direct: "direct",
  recursive: "recursive",
  indirect: "indirect",
  all: "all"
};

// node_modules/ipfs-core/esm/src/components/pin/add-all.js
function createAddAll({ repo, codecs: codecs2 }) {
  async function* addAll(source, options = {}) {
    const pinAdd = async function* () {
      for await (const { path, recursive: recursive3, metadata } of normaliseInput(source)) {
        const { cid } = await resolvePath(repo, codecs2, path);
        const { reason } = await repo.pins.isPinnedWithType(cid, [
          PinTypes.recursive,
          PinTypes.direct
        ]);
        if (reason === "recursive" && !recursive3) {
          throw new Error(`${cid} already pinned recursively`);
        }
        if (recursive3) {
          await repo.pins.pinRecursively(cid, { metadata });
        } else {
          await repo.pins.pinDirectly(cid, { metadata });
        }
        yield cid;
      }
    };
    const lock3 = Boolean(options.lock);
    if (!lock3) {
      yield* pinAdd();
      return;
    }
    const release = await repo.gcLock.readLock();
    try {
      yield* pinAdd();
    } finally {
      release();
    }
  }
  return withTimeoutOption(addAll);
}

// node_modules/ipfs-core/esm/src/components/pin/ls.js
init_globals();
var import_err_code5 = __toESM(require_err_code(), 1);
function toPin2(type, cid, metadata) {
  const output = {
    type,
    cid
  };
  if (metadata) {
    output.metadata = metadata;
  }
  return output;
}
function createLs({ repo, codecs: codecs2 }) {
  async function* ls(options = {}) {
    let type = PinTypes.all;
    if (options.type) {
      type = options.type;
      if (!Object.keys(PinTypes).includes(type)) {
        throw (0, import_err_code5.default)(new Error("Invalid pin type"), "ERR_INVALID_PIN_TYPE");
      }
    }
    if (options.paths) {
      let matched = false;
      for await (const { path } of normaliseInput(options.paths)) {
        const { cid } = await resolvePath(repo, codecs2, path);
        const { reason, pinned, parent: parent2, metadata } = await repo.pins.isPinnedWithType(cid, type);
        if (!pinned) {
          throw (0, import_err_code5.default)(new Error(`path '${path}' is not pinned`), "ERR_NOT_PINNED");
        }
        switch (reason) {
          case PinTypes.direct:
          case PinTypes.recursive:
            matched = true;
            yield toPin2(reason, cid, metadata);
            break;
          default:
            matched = true;
            yield toPin2(`${PinTypes.indirect} through ${parent2}`, cid, metadata);
        }
      }
      if (!matched) {
        throw new Error("No match found");
      }
      return;
    }
    if (type === PinTypes.recursive || type === PinTypes.all) {
      for await (const { cid, metadata } of repo.pins.recursiveKeys()) {
        yield toPin2(PinTypes.recursive, cid, metadata);
      }
    }
    if (type === PinTypes.indirect || type === PinTypes.all) {
      for await (const cid of repo.pins.indirectKeys(options)) {
        yield toPin2(PinTypes.indirect, cid);
      }
    }
    if (type === PinTypes.direct || type === PinTypes.all) {
      for await (const { cid, metadata } of repo.pins.directKeys()) {
        yield toPin2(PinTypes.direct, cid, metadata);
      }
    }
  }
  return withTimeoutOption(ls);
}

// node_modules/ipfs-core/esm/src/components/pin/rm.js
init_globals();
var import_it_last2 = __toESM(require_it_last(), 1);
function createRm({ rmAll }) {
  async function rm(path, options = {}) {
    const cid = await (0, import_it_last2.default)(rmAll([{
      path,
      ...options
    }], options));
    if (!cid) {
      throw new Error("CID expected");
    }
    return cid;
  }
  return rm;
}

// node_modules/ipfs-core/esm/src/components/pin/rm-all.js
init_globals();
function createRmAll({ repo, codecs: codecs2 }) {
  async function* rmAll(source, _options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      for await (const { path, recursive: recursive3 } of normaliseInput(source)) {
        const { cid } = await resolvePath(repo, codecs2, path);
        const { pinned, reason } = await repo.pins.isPinnedWithType(cid, PinTypes.all);
        if (!pinned) {
          throw new Error(`${cid} is not pinned`);
        }
        switch (reason) {
          case PinTypes.recursive:
            if (!recursive3) {
              throw new Error(`${cid} is pinned recursively`);
            }
            await repo.pins.unpin(cid);
            yield cid;
            break;
          case PinTypes.direct:
            await repo.pins.unpin(cid);
            yield cid;
            break;
          default:
            throw new Error(`${cid} is pinned indirectly under ${reason}`);
        }
      }
    } finally {
      release();
    }
  }
  return withTimeoutOption(rmAll);
}

// node_modules/ipfs-core/esm/src/components/pin/index.js
var PinAPI = class {
  constructor({ codecs: codecs2, repo }) {
    const addAll = createAddAll({
      codecs: codecs2,
      repo
    });
    this.addAll = addAll;
    this.add = createAdd({ addAll });
    const rmAll = createRmAll({
      codecs: codecs2,
      repo
    });
    this.rmAll = rmAll;
    this.rm = createRm({ rmAll });
    this.ls = createLs({
      codecs: codecs2,
      repo
    });
    this.remote = {
      add: (cid, options = {}) => Promise.reject(new Error("Not implemented")),
      ls: async function* (query, options = {}) {
        return Promise.reject(new Error("Not implemented"));
      },
      rm: (query, options = {}) => Promise.reject(new Error("Not implemented")),
      rmAll: (query, options = {}) => Promise.reject(new Error("Not implemented")),
      service: {
        add: (name10, credentials) => Promise.reject(new Error("Not implemented")),
        rm: (name10, options = {}) => Promise.reject(new Error("Not implemented")),
        ls: (options = {}) => Promise.reject(new Error("Not implemented"))
      }
    };
  }
};

// node_modules/ipfs-core/esm/src/components/ipns.js
init_globals();

// node_modules/ipfs-core/esm/src/ipns/index.js
init_globals();
var import_peer_id6 = __toESM(require_src5(), 1);
var import_err_code11 = __toESM(require_err_code(), 1);
var import_debug5 = __toESM(require_browser2(), 1);

// node_modules/ipfs-core/esm/src/ipns/publisher.js
init_globals();
var import_peer_id3 = __toESM(require_src5(), 1);
init_key();
init_errors();
var import_err_code8 = __toESM(require_err_code(), 1);
var import_debug2 = __toESM(require_browser2(), 1);
init_to_string();
init_equals();

// node_modules/ipns/esm/src/index.js
init_globals();
var import_timestamp_nano = __toESM(require_timestamp(), 1);
init_key();
var import_libp2p_crypto = __toESM(require_src6(), 1);
var import_peer_id2 = __toESM(require_src5(), 1);
init_digest();
init_identity();
var import_err_code7 = __toESM(require_err_code(), 1);
init_base32();
init_from_string();
init_to_string();
init_concat();
init_equals();
init_cborg();
var import_long = __toESM(require_long(), 1);
var import_debug = __toESM(require_browser2(), 1);

// node_modules/ipns/esm/src/pb/ipns.js
init_globals();
var import_minimal2 = __toESM(require_minimal2(), 1);
var $Reader2 = import_minimal2.default.Reader;
var $Writer2 = import_minimal2.default.Writer;
var $util2 = import_minimal2.default.util;
var $root2 = import_minimal2.default.roots["ipfs-ipns"] || (import_minimal2.default.roots["ipfs-ipns"] = {});
var IpnsEntry = $root2.IpnsEntry = (() => {
  function IpnsEntry2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  IpnsEntry2.prototype.value = $util2.newBuffer([]);
  IpnsEntry2.prototype.signature = $util2.newBuffer([]);
  IpnsEntry2.prototype.validityType = 0;
  IpnsEntry2.prototype.validity = $util2.newBuffer([]);
  IpnsEntry2.prototype.sequence = $util2.Long ? $util2.Long.fromBits(0, 0, true) : 0;
  IpnsEntry2.prototype.ttl = $util2.Long ? $util2.Long.fromBits(0, 0, true) : 0;
  IpnsEntry2.prototype.pubKey = $util2.newBuffer([]);
  IpnsEntry2.prototype.signatureV2 = $util2.newBuffer([]);
  IpnsEntry2.prototype.data = $util2.newBuffer([]);
  IpnsEntry2.encode = function encode19(m, w) {
    if (!w)
      w = $Writer2.create();
    if (m.value != null && Object.hasOwnProperty.call(m, "value"))
      w.uint32(10).bytes(m.value);
    if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
      w.uint32(18).bytes(m.signature);
    if (m.validityType != null && Object.hasOwnProperty.call(m, "validityType"))
      w.uint32(24).int32(m.validityType);
    if (m.validity != null && Object.hasOwnProperty.call(m, "validity"))
      w.uint32(34).bytes(m.validity);
    if (m.sequence != null && Object.hasOwnProperty.call(m, "sequence"))
      w.uint32(40).uint64(m.sequence);
    if (m.ttl != null && Object.hasOwnProperty.call(m, "ttl"))
      w.uint32(48).uint64(m.ttl);
    if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
      w.uint32(58).bytes(m.pubKey);
    if (m.signatureV2 != null && Object.hasOwnProperty.call(m, "signatureV2"))
      w.uint32(66).bytes(m.signatureV2);
    if (m.data != null && Object.hasOwnProperty.call(m, "data"))
      w.uint32(74).bytes(m.data);
    return w;
  };
  IpnsEntry2.decode = function decode22(r, l) {
    if (!(r instanceof $Reader2))
      r = $Reader2.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root2.IpnsEntry();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.value = r.bytes();
          break;
        case 2:
          m.signature = r.bytes();
          break;
        case 3:
          m.validityType = r.int32();
          break;
        case 4:
          m.validity = r.bytes();
          break;
        case 5:
          m.sequence = r.uint64();
          break;
        case 6:
          m.ttl = r.uint64();
          break;
        case 7:
          m.pubKey = r.bytes();
          break;
        case 8:
          m.signatureV2 = r.bytes();
          break;
        case 9:
          m.data = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  IpnsEntry2.fromObject = function fromObject(d) {
    if (d instanceof $root2.IpnsEntry)
      return d;
    var m = new $root2.IpnsEntry();
    if (d.value != null) {
      if (typeof d.value === "string")
        $util2.base64.decode(d.value, m.value = $util2.newBuffer($util2.base64.length(d.value)), 0);
      else if (d.value.length)
        m.value = d.value;
    }
    if (d.signature != null) {
      if (typeof d.signature === "string")
        $util2.base64.decode(d.signature, m.signature = $util2.newBuffer($util2.base64.length(d.signature)), 0);
      else if (d.signature.length)
        m.signature = d.signature;
    }
    switch (d.validityType) {
      case "EOL":
      case 0:
        m.validityType = 0;
        break;
    }
    if (d.validity != null) {
      if (typeof d.validity === "string")
        $util2.base64.decode(d.validity, m.validity = $util2.newBuffer($util2.base64.length(d.validity)), 0);
      else if (d.validity.length)
        m.validity = d.validity;
    }
    if (d.sequence != null) {
      if ($util2.Long)
        (m.sequence = $util2.Long.fromValue(d.sequence)).unsigned = true;
      else if (typeof d.sequence === "string")
        m.sequence = parseInt(d.sequence, 10);
      else if (typeof d.sequence === "number")
        m.sequence = d.sequence;
      else if (typeof d.sequence === "object")
        m.sequence = new $util2.LongBits(d.sequence.low >>> 0, d.sequence.high >>> 0).toNumber(true);
    }
    if (d.ttl != null) {
      if ($util2.Long)
        (m.ttl = $util2.Long.fromValue(d.ttl)).unsigned = true;
      else if (typeof d.ttl === "string")
        m.ttl = parseInt(d.ttl, 10);
      else if (typeof d.ttl === "number")
        m.ttl = d.ttl;
      else if (typeof d.ttl === "object")
        m.ttl = new $util2.LongBits(d.ttl.low >>> 0, d.ttl.high >>> 0).toNumber(true);
    }
    if (d.pubKey != null) {
      if (typeof d.pubKey === "string")
        $util2.base64.decode(d.pubKey, m.pubKey = $util2.newBuffer($util2.base64.length(d.pubKey)), 0);
      else if (d.pubKey.length)
        m.pubKey = d.pubKey;
    }
    if (d.signatureV2 != null) {
      if (typeof d.signatureV2 === "string")
        $util2.base64.decode(d.signatureV2, m.signatureV2 = $util2.newBuffer($util2.base64.length(d.signatureV2)), 0);
      else if (d.signatureV2.length)
        m.signatureV2 = d.signatureV2;
    }
    if (d.data != null) {
      if (typeof d.data === "string")
        $util2.base64.decode(d.data, m.data = $util2.newBuffer($util2.base64.length(d.data)), 0);
      else if (d.data.length)
        m.data = d.data;
    }
    return m;
  };
  IpnsEntry2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.value = "";
      else {
        d.value = [];
        if (o.bytes !== Array)
          d.value = $util2.newBuffer(d.value);
      }
      if (o.bytes === String)
        d.signature = "";
      else {
        d.signature = [];
        if (o.bytes !== Array)
          d.signature = $util2.newBuffer(d.signature);
      }
      d.validityType = o.enums === String ? "EOL" : 0;
      if (o.bytes === String)
        d.validity = "";
      else {
        d.validity = [];
        if (o.bytes !== Array)
          d.validity = $util2.newBuffer(d.validity);
      }
      if ($util2.Long) {
        var n = new $util2.Long(0, 0, true);
        d.sequence = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.sequence = o.longs === String ? "0" : 0;
      if ($util2.Long) {
        var n = new $util2.Long(0, 0, true);
        d.ttl = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.ttl = o.longs === String ? "0" : 0;
      if (o.bytes === String)
        d.pubKey = "";
      else {
        d.pubKey = [];
        if (o.bytes !== Array)
          d.pubKey = $util2.newBuffer(d.pubKey);
      }
      if (o.bytes === String)
        d.signatureV2 = "";
      else {
        d.signatureV2 = [];
        if (o.bytes !== Array)
          d.signatureV2 = $util2.newBuffer(d.signatureV2);
      }
      if (o.bytes === String)
        d.data = "";
      else {
        d.data = [];
        if (o.bytes !== Array)
          d.data = $util2.newBuffer(d.data);
      }
    }
    if (m.value != null && m.hasOwnProperty("value")) {
      d.value = o.bytes === String ? $util2.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
    }
    if (m.signature != null && m.hasOwnProperty("signature")) {
      d.signature = o.bytes === String ? $util2.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
    }
    if (m.validityType != null && m.hasOwnProperty("validityType")) {
      d.validityType = o.enums === String ? $root2.IpnsEntry.ValidityType[m.validityType] : m.validityType;
    }
    if (m.validity != null && m.hasOwnProperty("validity")) {
      d.validity = o.bytes === String ? $util2.base64.encode(m.validity, 0, m.validity.length) : o.bytes === Array ? Array.prototype.slice.call(m.validity) : m.validity;
    }
    if (m.sequence != null && m.hasOwnProperty("sequence")) {
      if (typeof m.sequence === "number")
        d.sequence = o.longs === String ? String(m.sequence) : m.sequence;
      else
        d.sequence = o.longs === String ? $util2.Long.prototype.toString.call(m.sequence) : o.longs === Number ? new $util2.LongBits(m.sequence.low >>> 0, m.sequence.high >>> 0).toNumber(true) : m.sequence;
    }
    if (m.ttl != null && m.hasOwnProperty("ttl")) {
      if (typeof m.ttl === "number")
        d.ttl = o.longs === String ? String(m.ttl) : m.ttl;
      else
        d.ttl = o.longs === String ? $util2.Long.prototype.toString.call(m.ttl) : o.longs === Number ? new $util2.LongBits(m.ttl.low >>> 0, m.ttl.high >>> 0).toNumber(true) : m.ttl;
    }
    if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
      d.pubKey = o.bytes === String ? $util2.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
    }
    if (m.signatureV2 != null && m.hasOwnProperty("signatureV2")) {
      d.signatureV2 = o.bytes === String ? $util2.base64.encode(m.signatureV2, 0, m.signatureV2.length) : o.bytes === Array ? Array.prototype.slice.call(m.signatureV2) : m.signatureV2;
    }
    if (m.data != null && m.hasOwnProperty("data")) {
      d.data = o.bytes === String ? $util2.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
    }
    return d;
  };
  IpnsEntry2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
  };
  IpnsEntry2.ValidityType = function() {
    const valuesById = {}, values2 = Object.create(valuesById);
    values2[valuesById[0] = "EOL"] = 0;
    return values2;
  }();
  return IpnsEntry2;
})();

// node_modules/ipns/esm/src/utils.js
init_globals();
function parseRFC3339(time) {
  const rfc3339Matcher = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z");
  const m = String(time).trim().match(rfc3339Matcher);
  if (!m) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour2 = parseInt(m[4], 10);
  const minute2 = parseInt(m[5], 10);
  const second = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour2, minute2, second, millisecond));
}

// node_modules/ipns/esm/src/errors.js
init_globals();
var ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD";
var ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY";
var ERR_SIGNATURE_CREATION = "ERR_SIGNATURE_CREATION";
var ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION";
var ERR_UNRECOGNIZED_FORMAT = "ERR_UNRECOGNIZED_FORMAT";
var ERR_PEER_ID_FROM_PUBLIC_KEY = "ERR_PEER_ID_FROM_PUBLIC_KEY";
var ERR_PUBLIC_KEY_FROM_ID = "ERR_PUBLIC_KEY_FROM_ID";
var ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER";
var ERR_INVALID_RECORD_DATA = "ERR_INVALID_RECORD_DATA";
var ERR_INVALID_EMBEDDED_KEY = "ERR_INVALID_EMBEDDED_KEY";

// node_modules/ipns/esm/src/index.js
var log = Object.assign((0, import_debug.default)("jsipns"), { error: (0, import_debug.default)("jsipns:error") });
var ID_MULTIHASH_CODE = identity.code;
var IPNS_PREFIX = fromString3("/ipns/");
var namespace = "/ipns/";
var namespaceLength = namespace.length;
var create2 = (privateKey, value, seq, lifetime) => {
  const expirationDate = new import_timestamp_nano.default(Date.now() + Number(lifetime));
  const validityType = IpnsEntry.ValidityType.EOL;
  const [ms, ns] = lifetime.toString().split(".");
  const lifetimeNs = BigInt(ms) * BigInt(1e5) + BigInt(ns || 0);
  return _create(privateKey, value, seq, validityType, expirationDate, lifetimeNs);
};
var _create = async (privateKey, value, seq, validityType, expirationDate, ttl2) => {
  seq = BigInt(seq);
  const isoValidity = fromString3(expirationDate.toString());
  const signatureV1 = await sign2(privateKey, value, validityType, isoValidity);
  const data = createCborData(value, isoValidity, validityType, seq, ttl2);
  const sigData = ipnsEntryDataForV2Sig(data);
  const signatureV2 = await privateKey.sign(sigData);
  const entry = {
    value,
    signature: signatureV1,
    validityType,
    validity: isoValidity,
    sequence: seq,
    ttl: ttl2,
    signatureV2,
    data
  };
  log(`ipns entry for ${value} created`);
  return entry;
};
var createCborData = (value, validity, validityType, sequence, ttl2) => {
  const data = {
    Value: value,
    Validity: validity,
    ValidityType: validityType,
    Sequence: sequence,
    TTL: ttl2
  };
  return encode4(data);
};
var validate2 = async (publicKey, entry) => {
  const { value, validityType, validity } = entry;
  let dataForSignature;
  let signature;
  if (entry.signatureV2 && entry.data) {
    signature = entry.signatureV2;
    dataForSignature = ipnsEntryDataForV2Sig(entry.data);
    validateCborDataMatchesPbData(entry);
  } else {
    signature = entry.signature;
    dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);
  }
  let isValid;
  try {
    isValid = await publicKey.verify(dataForSignature, signature);
  } catch (err) {
    isValid = false;
  }
  if (!isValid) {
    log.error("record signature verification failed");
    throw (0, import_err_code7.default)(new Error("record signature verification failed"), ERR_SIGNATURE_VERIFICATION);
  }
  if (validityType === IpnsEntry.ValidityType.EOL) {
    let validityDate;
    try {
      validityDate = parseRFC3339(toString3(validity));
    } catch (e) {
      log.error("unrecognized validity format (not an rfc3339 format)");
      throw (0, import_err_code7.default)(new Error("unrecognized validity format (not an rfc3339 format)"), ERR_UNRECOGNIZED_FORMAT);
    }
    if (validityDate.getTime() < Date.now()) {
      log.error("record has expired");
      throw (0, import_err_code7.default)(new Error("record has expired"), ERR_IPNS_EXPIRED_RECORD);
    }
  } else if (validityType) {
    log.error("unrecognized validity type");
    throw (0, import_err_code7.default)(new Error("unrecognized validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  log(`ipns entry for ${value} is valid`);
};
var validateCborDataMatchesPbData = (entry) => {
  if (!entry.data) {
    throw (0, import_err_code7.default)(new Error("Record data is missing"), ERR_INVALID_RECORD_DATA);
  }
  const data = decode6(entry.data);
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  if (!equals3(data.Value, entry.value)) {
    throw (0, import_err_code7.default)(new Error('Field "value" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (!equals3(data.Validity, entry.validity)) {
    throw (0, import_err_code7.default)(new Error('Field "validity" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.ValidityType !== entry.validityType) {
    throw (0, import_err_code7.default)(new Error('Field "validityType" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.Sequence !== entry.sequence) {
    throw (0, import_err_code7.default)(new Error('Field "sequence" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.TTL !== entry.ttl) {
    throw (0, import_err_code7.default)(new Error('Field "ttl" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
};
var embedPublicKey = async (publicKey, entry) => {
  if (!publicKey || !publicKey.bytes || !entry) {
    const error = new Error("one or more of the provided parameters are not defined");
    log.error(error);
    throw (0, import_err_code7.default)(error, ERR_UNDEFINED_PARAMETER);
  }
  let peerId;
  try {
    peerId = await import_peer_id2.default.createFromPubKey(publicKey.bytes);
  } catch (err) {
    throw (0, import_err_code7.default)(err, ERR_PEER_ID_FROM_PUBLIC_KEY);
  }
  let extractedPublicKey;
  try {
    extractedPublicKey = extractPublicKeyFromId(peerId);
  } catch (err) {
    log.error(err);
    throw (0, import_err_code7.default)(err, ERR_PUBLIC_KEY_FROM_ID);
  }
  if (extractedPublicKey) {
    return null;
  }
  try {
    entry.pubKey = import_libp2p_crypto.default.keys.marshalPublicKey(publicKey);
  } catch (err) {
    log.error(err);
    throw err;
  }
  return entry;
};
var extractPublicKey = async (peerId, entry) => {
  if (!entry || !peerId) {
    const error = new Error("one or more of the provided parameters are not defined");
    log.error(error);
    throw (0, import_err_code7.default)(error, ERR_UNDEFINED_PARAMETER);
  }
  let pubKey;
  if (entry.pubKey) {
    try {
      pubKey = import_libp2p_crypto.default.keys.unmarshalPublicKey(entry.pubKey);
    } catch (err) {
      log.error(err);
      throw err;
    }
    const otherId = await import_peer_id2.default.createFromPubKey(entry.pubKey);
    if (!otherId.equals(peerId)) {
      throw (0, import_err_code7.default)(new Error("Embedded public key did not match PeerID"), ERR_INVALID_EMBEDDED_KEY);
    }
  } else if (peerId.pubKey) {
    pubKey = peerId.pubKey;
  }
  if (pubKey) {
    return pubKey;
  }
  throw (0, import_err_code7.default)(new Error("no public key is available"), ERR_UNDEFINED_PARAMETER);
};
var rawStdEncoding = (key) => base32upper.encode(key).slice(1);
var getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`);
var getIdKeys = (pid) => {
  const pkBuffer = fromString3("/pk/");
  const ipnsBuffer = fromString3("/ipns/");
  return {
    routingPubKey: new Key(concat2([
      pkBuffer,
      pid
    ]), false),
    pkKey: new Key(rawStdEncoding(concat2([
      pkBuffer,
      pid
    ]))),
    routingKey: new Key(concat2([
      ipnsBuffer,
      pid
    ]), false),
    ipnsKey: new Key(rawStdEncoding(concat2([
      ipnsBuffer,
      pid
    ])))
  };
};
var sign2 = (privateKey, value, validityType, validity) => {
  try {
    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);
    return privateKey.sign(dataForSignature);
  } catch (error) {
    log.error("record signature creation failed");
    throw (0, import_err_code7.default)(new Error("record signature creation failed: " + error.message), ERR_SIGNATURE_CREATION);
  }
};
var getValidityType = (validityType) => {
  if (validityType.toString() === "0") {
    return "EOL";
  }
  const error = new Error(`unrecognized validity type ${validityType.toString()}`);
  log.error(error);
  throw (0, import_err_code7.default)(error, ERR_UNRECOGNIZED_VALIDITY);
};
var ipnsEntryDataForV1Sig = (value, validityType, validity) => {
  const validityTypeBuffer = fromString3(getValidityType(validityType));
  return concat2([
    value,
    validity,
    validityTypeBuffer
  ]);
};
var ipnsEntryDataForV2Sig = (data) => {
  const entryData = fromString3("ipns-signature:");
  return concat2([
    entryData,
    data
  ]);
};
var extractPublicKeyFromId = (peerId) => {
  const digest3 = decode3(peerId.id);
  if (digest3.code !== ID_MULTIHASH_CODE) {
    return null;
  }
  return import_libp2p_crypto.default.keys.unmarshalPublicKey(digest3.digest);
};
var marshal = (obj) => {
  return IpnsEntry.encode({
    ...obj,
    sequence: import_long.default.fromString(obj.sequence.toString()),
    ttl: obj.ttl == null ? void 0 : import_long.default.fromString(obj.ttl.toString())
  }).finish();
};
var unmarshal = (buf3) => {
  const message = IpnsEntry.decode(buf3);
  const object = IpnsEntry.toObject(message, {
    defaults: false,
    arrays: true,
    objects: false
  });
  return {
    value: object.value,
    signature: object.signature,
    validityType: object.validityType,
    validity: object.validity,
    sequence: Object.hasOwnProperty.call(object, "sequence") ? BigInt(`${object.sequence}`) : 0,
    pubKey: object.pubKey,
    ttl: Object.hasOwnProperty.call(object, "ttl") ? BigInt(`${object.ttl}`) : void 0,
    signatureV2: object.signatureV2,
    data: object.data
  };
};
var validator = {
  validate: async (marshalledData, key) => {
    const receivedEntry = unmarshal(marshalledData);
    const bufferId = key.slice(IPNS_PREFIX.length);
    const peerId = import_peer_id2.default.createFromBytes(bufferId);
    const pubKey = await extractPublicKey(peerId, receivedEntry);
    await validate2(pubKey, receivedEntry);
  },
  select: (dataA, dataB) => {
    const entryA = unmarshal(dataA);
    const entryB = unmarshal(dataB);
    if (entryA.signatureV2 && !entryB.signatureV2) {
      return 0;
    } else if (entryB.signatureV2 && !entryA.signatureV2) {
      return 1;
    }
    if (entryA.sequence > entryB.sequence) {
      return 0;
    } else if (entryA.sequence < entryB.sequence) {
      return 1;
    }
    const entryAValidityDate = parseRFC3339(toString3(entryA.validity));
    const entryBValidityDate = parseRFC3339(toString3(entryB.validity));
    return entryBValidityDate.getTime() > entryAValidityDate.getTime() ? 1 : 0;
  }
};

// node_modules/ipfs-core/esm/src/ipns/publisher.js
var log2 = Object.assign((0, import_debug2.default)("ipfs:ipns:publisher"), { error: (0, import_debug2.default)("ipfs:ipns:publisher:error") });
var ERR_NOT_FOUND = notFoundError().code;
var defaultRecordLifetime = 60 * 60 * 1e3;
var IpnsPublisher = class {
  constructor(routing, datastore) {
    this._routing = routing;
    this._datastore = datastore;
  }
  async publishWithEOL(privKey, value, lifetime) {
    if (!privKey || !privKey.bytes) {
      throw (0, import_err_code8.default)(new Error("invalid private key"), "ERR_INVALID_PRIVATE_KEY");
    }
    const peerId = await import_peer_id3.default.createFromPrivKey(privKey.bytes);
    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId);
    return this._putRecordToRouting(record, peerId);
  }
  publish(privKey, value) {
    return this.publishWithEOL(privKey, value, defaultRecordLifetime);
  }
  async _putRecordToRouting(record, peerId) {
    if (!import_peer_id3.default.isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log2.error(errMsg);
      throw (0, import_err_code8.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    const publicKey = peerId.pubKey;
    const embedPublicKeyRecord = await embedPublicKey(publicKey, record);
    const keys2 = getIdKeys(peerId.toBytes());
    await this._publishEntry(keys2.routingKey, embedPublicKeyRecord || record);
    return embedPublicKeyRecord || record;
  }
  async _publishEntry(key, entry) {
    const k = Key.asKey(key);
    if (!k) {
      const errMsg = "datastore key does not have a valid format";
      log2.error(errMsg);
      throw (0, import_err_code8.default)(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
    }
    let entryData;
    try {
      entryData = marshal(entry);
    } catch (err) {
      log2.error(err);
      throw err;
    }
    try {
      const res = await this._routing.put(k.uint8Array(), entryData);
      log2(`ipns record for ${toString3(k.uint8Array(), "base32")} was stored in the routing`);
      return res;
    } catch (err) {
      const errMsg = `ipns record for ${toString3(k.uint8Array(), "base32")} could not be stored in the routing - ${err.stack}`;
      log2.error(errMsg);
      log2.error(err);
      throw (0, import_err_code8.default)(new Error(errMsg), "ERR_PUTTING_TO_ROUTING");
    }
  }
  async _getPublished(peerId, options = {}) {
    if (!import_peer_id3.default.isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log2.error(errMsg);
      throw (0, import_err_code8.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    const checkRouting = options.checkRouting !== false;
    try {
      const dsVal = await this._datastore.get(getLocalKey(peerId.id));
      return this._unmarshalData(dsVal);
    } catch (err) {
      if (err.code !== ERR_NOT_FOUND) {
        const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`;
        log2.error(errMsg);
        throw (0, import_err_code8.default)(new Error(errMsg), "ERR_UNEXPECTED_DATASTORE_RESPONSE");
      }
      if (!checkRouting) {
        throw (0, import_err_code8.default)(err, "ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");
      }
      try {
        const keys2 = getIdKeys(peerId.toBytes());
        const res = await this._routing.get(keys2.routingKey.uint8Array());
        return this._unmarshalData(res);
      } catch (err2) {
        log2.error(err2);
        throw err2;
      }
    }
  }
  _unmarshalData(data) {
    try {
      return unmarshal(data);
    } catch (err) {
      throw (0, import_err_code8.default)(err, "ERR_INVALID_RECORD_DATA");
    }
  }
  async _updateOrCreateRecord(privKey, value, lifetime, peerId) {
    if (!import_peer_id3.default.isPeerId(peerId)) {
      const errMsg = "peerId received is not valid";
      log2.error(errMsg);
      throw (0, import_err_code8.default)(new Error(errMsg), "ERR_INVALID_PEER_ID");
    }
    const getPublishedOptions = { checkRouting: true };
    let record;
    try {
      record = await this._getPublished(peerId, getPublishedOptions);
    } catch (err) {
      if (err.code !== ERR_NOT_FOUND) {
        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`;
        log2.error(errMsg);
        throw (0, import_err_code8.default)(new Error(errMsg), "ERR_DETERMINING_PUBLISHED_RECORD");
      }
    }
    let seqNumber = 0;
    if (record && record.sequence !== void 0) {
      seqNumber = !equals3(record.value, value) ? BigInt(record.sequence) + BigInt(1) : BigInt(record.sequence);
    }
    let entryData;
    try {
      entryData = await create2(privKey, value, seqNumber, lifetime);
    } catch (err) {
      const errMsg = `ipns record for ${value} could not be created`;
      log2.error(err);
      throw (0, import_err_code8.default)(new Error(errMsg), "ERR_CREATING_IPNS_RECORD");
    }
    try {
      const data = marshal(entryData);
      await this._datastore.put(getLocalKey(peerId.id), data);
      log2(`ipns record for ${toString3(value, "base32")} was stored in the datastore`);
      return entryData;
    } catch (err) {
      const errMsg = `ipns record for ${value} could not be stored in the datastore`;
      log2.error(errMsg);
      throw (0, import_err_code8.default)(new Error(errMsg), "ERR_STORING_IN_DATASTORE");
    }
  }
};
IpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;

// node_modules/ipfs-core/esm/src/ipns/republisher.js
init_globals();
var import_libp2p_crypto2 = __toESM(require_src6(), 1);
var import_peer_id4 = __toESM(require_src5(), 1);
var import_err_code9 = __toESM(require_err_code(), 1);
var import_debug3 = __toESM(require_browser2(), 1);
var log3 = Object.assign((0, import_debug3.default)("ipfs:ipns:republisher"), { error: (0, import_debug3.default)("ipfs:ipns:republisher:error") });
var minute = 60 * 1e3;
var hour = 60 * minute;
var defaultBroadcastInterval = 4 * hour;
var defaultRecordLifetime2 = 24 * hour;
var IpnsRepublisher = class {
  constructor(publisher, datastore, peerId, keychain, options = { pass: "" }) {
    this._publisher = publisher;
    this._datastore = datastore;
    this._peerId = peerId;
    this._keychain = keychain;
    this._options = options;
    this._republishHandle = null;
  }
  async start() {
    if (this._republishHandle) {
      throw (0, import_err_code9.default)(new Error("republisher is already running"), "ERR_REPUBLISH_ALREADY_RUNNING");
    }
    const republishHandle = {
      _task: null,
      _inflightTask: null,
      _timeoutId: null,
      runPeriodically: (period) => {
        republishHandle._timeoutId = setTimeout(async () => {
          republishHandle._timeoutId = null;
          try {
            republishHandle._inflightTask = republishHandle._task();
            await republishHandle._inflightTask;
            if (republishHandle._task) {
              republishHandle.runPeriodically(period);
            }
          } catch (err) {
            log3.error(err);
          }
        }, period());
      },
      cancel: async () => {
        if (republishHandle._timeoutId != null) {
          clearTimeout(republishHandle._timeoutId);
        }
        republishHandle._task = null;
        await republishHandle._inflightTask;
      }
    };
    const { privKey } = this._peerId;
    const { pass } = this._options;
    let firstRun = true;
    republishHandle._task = () => this._republishEntries(privKey, pass);
    republishHandle.runPeriodically(() => {
      if (firstRun) {
        firstRun = false;
        return this._options.initialBroadcastInterval || minute;
      }
      return this._options.broadcastInterval || defaultBroadcastInterval;
    });
    this._republishHandle = republishHandle;
  }
  async stop() {
    const republishHandle = this._republishHandle;
    if (!republishHandle) {
      throw (0, import_err_code9.default)(new Error("republisher is not running"), "ERR_REPUBLISH_NOT_RUNNING");
    }
    this._republishHandle = null;
    await republishHandle.cancel();
  }
  async _republishEntries(privateKey, pass) {
    try {
      await this._republishEntry(privateKey);
    } catch (err) {
      const errMsg = "cannot republish entry for the node's private key";
      log3.error(errMsg);
      return;
    }
    if (pass) {
      try {
        const keys2 = await this._keychain.listKeys();
        for (const key of keys2) {
          if (key.name === "self") {
            continue;
          }
          const pem = await this._keychain.exportKey(key.name, pass);
          const privKey = await import_libp2p_crypto2.default.keys.import(pem, pass);
          await this._republishEntry(privKey);
        }
      } catch (err) {
        log3.error(err);
      }
    }
  }
  async _republishEntry(privateKey) {
    if (!privateKey || !privateKey.bytes) {
      throw (0, import_err_code9.default)(new Error("invalid private key"), "ERR_INVALID_PRIVATE_KEY");
    }
    try {
      const peerId = await import_peer_id4.default.createFromPrivKey(privateKey.bytes);
      const value = await this._getPreviousValue(peerId);
      await this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime2);
    } catch (err) {
      if (err.code === "ERR_NO_ENTRY_FOUND") {
        return;
      }
      throw err;
    }
  }
  async _getPreviousValue(peerId) {
    if (!import_peer_id4.default.isPeerId(peerId)) {
      throw (0, import_err_code9.default)(new Error("invalid peer ID"), "ERR_INVALID_PEER_ID");
    }
    try {
      const dsVal = await this._datastore.get(getLocalKey(peerId.id));
      if (!(dsVal instanceof Uint8Array)) {
        throw (0, import_err_code9.default)(new Error("found ipns record that we couldn't process"), "ERR_INVALID_IPNS_RECORD");
      }
      try {
        const record = unmarshal(dsVal);
        return record.value;
      } catch (err) {
        log3.error(err);
        throw (0, import_err_code9.default)(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_IPNS_RECORD");
      }
    } catch (err) {
      if (err && err.notFound) {
        throw (0, import_err_code9.default)(new Error(`no previous entry for record with id: ${peerId.id}`), "ERR_NO_ENTRY_FOUND");
      }
      throw err;
    }
  }
};

// node_modules/ipfs-core/esm/src/ipns/resolver.js
init_globals();
var import_peer_id5 = __toESM(require_src5(), 1);
var import_err_code10 = __toESM(require_err_code(), 1);
var import_debug4 = __toESM(require_browser2(), 1);
init_to_string();
init_errors();
var log4 = Object.assign((0, import_debug4.default)("ipfs:ipns:resolver"), { error: (0, import_debug4.default)("ipfs:ipns:resolver:error") });
var ERR_NOT_FOUND2 = notFoundError().code;
var defaultMaximumRecursiveDepth = 32;
var IpnsResolver = class {
  constructor(routing) {
    this._routing = routing;
  }
  async resolve(name10, options = {}) {
    if (typeof name10 !== "string") {
      throw (0, import_err_code10.default)(new Error("invalid name"), "ERR_INVALID_NAME");
    }
    const recursive3 = options.recursive && options.recursive.toString() === "true";
    const nameSegments = name10.split("/");
    if (nameSegments.length !== 3 || nameSegments[0] !== "") {
      throw (0, import_err_code10.default)(new Error("invalid name"), "ERR_INVALID_NAME");
    }
    const key = nameSegments[2];
    let depth = Infinity;
    if (recursive3) {
      depth = defaultMaximumRecursiveDepth;
    }
    const res = await this.resolver(key, depth);
    log4(`${name10} was locally resolved correctly`);
    return res;
  }
  async resolver(name10, depth) {
    if (depth === 0) {
      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;
      log4.error(errMsg);
      throw (0, import_err_code10.default)(new Error(errMsg), "ERR_RESOLVE_RECURSION_LIMIT");
    }
    const res = await this._resolveName(name10);
    const nameSegments = res.split("/");
    if (nameSegments[1] === "ipfs" || !depth) {
      return res;
    }
    return this.resolver(nameSegments[2], depth - 1);
  }
  async _resolveName(name10) {
    const peerId = import_peer_id5.default.parse(name10);
    const { routingKey } = getIdKeys(peerId.toBytes());
    let record;
    try {
      record = await this._routing.get(routingKey.uint8Array());
    } catch (err) {
      log4.error("could not get record from routing", err);
      if (err.code === ERR_NOT_FOUND2) {
        throw (0, import_err_code10.default)(new Error(`record requested for ${name10} was not found in the network`), "ERR_NO_RECORD_FOUND");
      }
      throw (0, import_err_code10.default)(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
    }
    let ipnsEntry;
    try {
      ipnsEntry = unmarshal(record);
    } catch (err) {
      log4.error("could not unmarshal record", err);
      throw (0, import_err_code10.default)(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_RECORD_RECEIVED");
    }
    return this._validateRecord(peerId, ipnsEntry);
  }
  async _validateRecord(peerId, ipnsEntry) {
    const pubKey = await extractPublicKey(peerId, ipnsEntry);
    await validate2(pubKey, ipnsEntry);
    return toString3(ipnsEntry.value);
  }
};

// node_modules/ipfs-core/esm/src/utils/tlru.js
init_globals();
var import_hashlru2 = __toESM(require_hashlru(), 1);
var TLRU2 = class {
  constructor(maxSize) {
    this.lru = (0, import_hashlru2.default)(maxSize);
  }
  get(key) {
    const value = this.lru.get(key);
    if (value) {
      if (value.expire && value.expire < Date.now()) {
        this.lru.remove(key);
        return void 0;
      }
      return value.value;
    }
    return void 0;
  }
  set(key, value, ttl2) {
    this.lru.set(key, {
      value,
      expire: Date.now() + ttl2
    });
  }
  has(key) {
    const value = this.get(key);
    if (value) {
      return true;
    }
    return false;
  }
  remove(key) {
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};

// node_modules/ipfs-core/esm/src/ipns/index.js
init_to_string();
var log5 = Object.assign((0, import_debug5.default)("ipfs:ipns"), { error: (0, import_debug5.default)("ipfs:ipns:error") });
var defaultRecordTtl = 60 * 1e3;
var IPNS = class {
  constructor(routing, datastore, peerId, keychain, options) {
    this.publisher = new IpnsPublisher(routing, datastore);
    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);
    this.resolver = new IpnsResolver(routing);
    this.cache = new TLRU2(1e3);
    this.routing = routing;
  }
  async publish(privKey, value, lifetime = IpnsPublisher.defaultRecordLifetime) {
    try {
      const peerId = await (0, import_peer_id6.createFromPrivKey)(privKey.bytes);
      await this.publisher.publishWithEOL(privKey, value, lifetime);
      log5(`IPNS value ${toString3(value, "base32")} was published correctly`);
      const id = peerId.toB58String();
      const ttEol = parseFloat(lifetime);
      const ttl2 = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;
      this.cache.set(id, value, ttl2);
      log5(`IPNS value ${toString3(value, "base32")} was cached correctly`);
      return {
        name: id,
        value
      };
    } catch (err) {
      log5.error(err);
      throw err;
    }
  }
  async resolve(name10, options = {}) {
    if (typeof name10 !== "string") {
      throw (0, import_err_code11.default)(new Error("name received is not valid"), "ERR_INVALID_NAME");
    }
    if (!options.nocache && !options.recursive) {
      const id = name10.split("/")[2];
      const result = this.cache.get(id);
      if (result) {
        return result;
      }
    }
    try {
      const result = await this.resolver.resolve(name10, options);
      log5(`IPNS record from ${name10} was resolved correctly`);
      return result;
    } catch (err) {
      log5.error(err);
      throw err;
    }
  }
  async initializeKeyspace(privKey, value) {
    return this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime);
  }
};

// node_modules/ipfs-core/esm/src/ipns/routing/config.js
init_globals();
init_tiered();
var import_dlv = __toESM(require_dlv_umd(), 1);

// node_modules/ipfs-core/esm/src/ipns/routing/pubsub-datastore.js
init_globals();
init_base58();

// node_modules/datastore-pubsub/esm/src/index.js
init_globals();
init_src2();
init_src3();

// node_modules/datastore-pubsub/esm/src/utils.js
init_globals();
var import_err_code12 = __toESM(require_err_code(), 1);
init_to_string();
init_from_string();
var namespace2 = "/record/";
function encodeBase32(buf3) {
  return toString3(buf3, "base32");
}
function keyToTopic(key) {
  if (typeof key === "string" || key instanceof String) {
    key = fromString3(key.toString());
  }
  const b64url = toString3(key, "base64url");
  return `${namespace2}${b64url}`;
}
function topicToKey(topic) {
  if (topic.substring(0, namespace2.length) !== namespace2) {
    throw (0, import_err_code12.default)(new Error("topic received is not from a record"), "ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");
  }
  const key = topic.substring(namespace2.length);
  return fromString3(key, "base64url");
}

// node_modules/datastore-pubsub/esm/src/index.js
init_equals();
var import_err_code13 = __toESM(require_err_code(), 1);
var import_debug7 = __toESM(require_browser2(), 1);
var log7 = Object.assign((0, import_debug7.default)("datastore-pubsub:publisher"), { error: (0, import_debug7.default)("datastore-pubsub:publisher:error") });
var PubsubDatastore = class extends BaseDatastore {
  constructor(pubsub, datastore, peerId, validator3, subscriptionKeyFn) {
    super();
    if (!validator3) {
      throw (0, import_err_code13.default)(new TypeError("missing validator"), "ERR_INVALID_PARAMETERS");
    }
    if (typeof validator3.validate !== "function") {
      throw (0, import_err_code13.default)(new TypeError("missing validate function"), "ERR_INVALID_PARAMETERS");
    }
    if (typeof validator3.select !== "function") {
      throw (0, import_err_code13.default)(new TypeError("missing select function"), "ERR_INVALID_PARAMETERS");
    }
    if (subscriptionKeyFn && typeof subscriptionKeyFn !== "function") {
      throw (0, import_err_code13.default)(new TypeError("invalid subscriptionKeyFn received"), "ERR_INVALID_PARAMETERS");
    }
    this._pubsub = pubsub;
    this._datastore = datastore;
    this._peerId = peerId;
    this._validator = validator3;
    this._handleSubscriptionKeyFn = subscriptionKeyFn;
    this._onMessage = this._onMessage.bind(this);
  }
  async put(key, val) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = "datastore key does not have a valid format";
      log7.error(errMsg);
      throw (0, import_err_code13.default)(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
    }
    if (!(val instanceof Uint8Array)) {
      const errMsg = "received value is not a Uint8Array";
      log7.error(errMsg);
      throw (0, import_err_code13.default)(new Error(errMsg), "ERR_INVALID_VALUE_RECEIVED");
    }
    const stringifiedTopic = keyToTopic(key);
    log7(`publish value for topic ${stringifiedTopic}`);
    await this._pubsub.publish(stringifiedTopic, val);
  }
  async get(key) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = "datastore key does not have a valid format";
      log7.error(errMsg);
      throw (0, import_err_code13.default)(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
    }
    const stringifiedTopic = keyToTopic(key);
    const subscriptions = await this._pubsub.getTopics();
    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {
      return this._getLocal(key);
    }
    try {
      this._pubsub.on(stringifiedTopic, this._onMessage);
      await this._pubsub.subscribe(stringifiedTopic);
    } catch (err) {
      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;
      log7.error(errMsg);
      throw (0, import_err_code13.default)(new Error(errMsg), "ERR_SUBSCRIBING_TOPIC");
    }
    log7(`subscribed values for key ${stringifiedTopic}`);
    return this._getLocal(key);
  }
  unsubscribe(key) {
    const stringifiedTopic = keyToTopic(key);
    this._pubsub.removeListener(stringifiedTopic, this._onMessage);
    return this._pubsub.unsubscribe(stringifiedTopic);
  }
  async _getLocal(key) {
    const routingKey = new Key("/" + encodeBase32(key), false);
    let dsVal;
    try {
      dsVal = await this._datastore.get(routingKey);
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        const errMsg2 = `unexpected error getting the ipns record for ${routingKey.toString()}`;
        log7.error(errMsg2);
        throw (0, import_err_code13.default)(new Error(errMsg2), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
      }
      const errMsg = `local record requested was not found for ${routingKey.toString()}`;
      log7.error(errMsg);
      throw (0, import_err_code13.default)(new Error(errMsg), "ERR_NOT_FOUND");
    }
    if (!(dsVal instanceof Uint8Array)) {
      const errMsg = "found record that we couldn't convert to a value";
      log7.error(errMsg);
      throw (0, import_err_code13.default)(new Error(errMsg), "ERR_INVALID_RECORD_RECEIVED");
    }
    return dsVal;
  }
  async _onMessage(msg) {
    const { data, from: from5, topicIDs } = msg;
    let key;
    try {
      key = topicToKey(topicIDs[0]);
    } catch (err) {
      log7.error(err);
      return;
    }
    log7(`message received for topic ${topicIDs[0]}`);
    if (from5 === this._peerId.toB58String()) {
      log7("message discarded as it is from the same peer");
      return;
    }
    if (this._handleSubscriptionKeyFn) {
      let res;
      try {
        res = await this._handleSubscriptionKeyFn(key);
      } catch (err) {
        log7.error("message discarded by the subscriptionKeyFn");
        return;
      }
      key = res;
    }
    try {
      await this._storeIfSubscriptionIsBetter(key, data);
    } catch (err) {
      log7.error(err);
    }
  }
  async _storeIfSubscriptionIsBetter(key, data) {
    let isBetter = false;
    try {
      isBetter = await this._isBetter(key, data);
    } catch (err) {
      if (err.code !== "ERR_NOT_VALID_RECORD") {
        throw err;
      }
    }
    if (isBetter) {
      await this._storeRecord(key, data);
    }
  }
  async _validateRecord(value, peerId) {
    return this._validator.validate(value, peerId);
  }
  async _selectRecord(key, records) {
    const res = await this._validator.select(key, records);
    return res === 0;
  }
  async _isBetter(key, val) {
    try {
      await this._validateRecord(val, key);
    } catch (err) {
      const errMsg = "record received through pubsub is not valid";
      log7.error(errMsg);
      throw (0, import_err_code13.default)(new Error(errMsg), "ERR_NOT_VALID_RECORD");
    }
    const dsKey = new Key(key);
    let currentRecord;
    try {
      currentRecord = await this._getLocal(dsKey.uint8Array());
    } catch (err) {
      return true;
    }
    if (equals3(currentRecord, val)) {
      return false;
    }
    return this._selectRecord(key, [
      currentRecord,
      val
    ]);
  }
  async _storeRecord(key, data) {
    const routingKey = new Key("/" + encodeBase32(key), false);
    await this._datastore.put(routingKey, data);
    log7(`record for ${keyToTopic(key)} was stored in the datastore`);
  }
};

// node_modules/ipfs-core/esm/src/ipns/routing/pubsub-datastore.js
init_from_string();
init_to_string();
var import_err_code14 = __toESM(require_err_code(), 1);
var import_debug8 = __toESM(require_browser2(), 1);
var log8 = Object.assign((0, import_debug8.default)("ipfs:ipns:pubsub"), { error: (0, import_debug8.default)("ipfs:ipns:pubsub:error") });
var IpnsPubsubDatastore = class {
  constructor(pubsub, localDatastore, peerId) {
    this._subscriptions = {};
    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);
    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, validator, this._handleSubscriptionKey);
  }
  async put(key, value) {
    try {
      await this._pubsubDs.put(key, value);
    } catch (err) {
      log8.error(err);
      throw err;
    }
  }
  async get(key) {
    let res;
    let err;
    try {
      res = await this._pubsubDs.get(key);
    } catch (e) {
      err = e;
    }
    const ns = key.slice(0, namespaceLength);
    if (toString3(ns) === namespace) {
      const stringifiedTopic = base58btc.encode(key).substring(1);
      const id = base58btc.encode(key.slice(namespaceLength)).substring(1);
      this._subscriptions[stringifiedTopic] = id;
      log8(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);
    }
    if (err) {
      throw err;
    }
    return res;
  }
  _handleSubscriptionKey(key) {
    if (key instanceof Uint8Array) {
      key = toString3(key, "base58btc");
    }
    const subscriber = this._subscriptions[key];
    if (!subscriber) {
      throw (0, import_err_code14.default)(new Error(`key ${key} does not correspond to a subscription`), "ERR_INVALID_KEY");
    }
    let keys2;
    try {
      keys2 = getIdKeys(fromString3(subscriber, "base58btc"));
    } catch (err) {
      log8.error(err);
      throw err;
    }
    return keys2.routingKey.uint8Array();
  }
  getSubscriptions() {
    const subscriptions = Object.values(this._subscriptions).filter(Boolean);
    return subscriptions.map((sub) => `${namespace}${sub}`);
  }
  async cancel(name10) {
    if (typeof name10 !== "string") {
      throw (0, import_err_code14.default)(new Error("invalid subscription name"), "ERR_INVALID_SUBSCRIPTION_NAME");
    }
    if (name10.startsWith(namespace)) {
      name10 = name10.substring(namespaceLength);
    }
    const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name10);
    if (!stringifiedTopic) {
      return { canceled: false };
    }
    const bufTopic = fromString3(stringifiedTopic);
    this._pubsubDs.unsubscribe(bufTopic);
    delete this._subscriptions[stringifiedTopic];
    log8(`unsubscribed pubsub ${stringifiedTopic}: ${name10}`);
    return { canceled: true };
  }
};

// node_modules/ipfs-core/esm/src/ipns/routing/offline-datastore.js
init_globals();
init_key();
var import_libp2p_record = __toESM(require_src7(), 1);
var import_err_code15 = __toESM(require_err_code(), 1);
var import_debug9 = __toESM(require_browser2(), 1);
init_to_string();
var log9 = Object.assign((0, import_debug9.default)("ipfs:ipns:offline-datastore"), { error: (0, import_debug9.default)("ipfs:ipns:offline-datastore:error") });
var OfflineDatastore = class {
  constructor(repo) {
    this._repo = repo;
    this.stores = [];
  }
  async put(key, value) {
    if (!(key instanceof Uint8Array)) {
      throw (0, import_err_code15.default)(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
    }
    if (!(value instanceof Uint8Array)) {
      throw (0, import_err_code15.default)(new Error("Offline datastore value must be a Uint8Array"), "ERR_INVALID_VALUE");
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err) {
      log9.error(err);
      throw (0, import_err_code15.default)(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
    }
    const record = new import_libp2p_record.Record(key, value);
    return this._repo.datastore.put(routingKey, record.serialize());
  }
  async get(key) {
    if (!(key instanceof Uint8Array)) {
      throw (0, import_err_code15.default)(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err) {
      log9.error(err);
      throw (0, import_err_code15.default)(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
    }
    const res = await this._repo.datastore.get(routingKey);
    let record;
    try {
      record = import_libp2p_record.Record.deserialize(res);
    } catch (err) {
      log9.error(err);
      throw err;
    }
    return record.value;
  }
  _routingKey(key) {
    return new Key("/dht/record/" + toString3(key, "base32"), false);
  }
};

// node_modules/ipfs-core/esm/src/ipns/routing/dht-datastore.js
init_globals();
var import_it_drain3 = __toESM(require_it_drain(), 1);
init_errors();
var import_debug10 = __toESM(require_browser2(), 1);
var log10 = Object.assign((0, import_debug10.default)("ipfs:ipns:dht-datastore"), { error: (0, import_debug10.default)("ipfs:ipns:dht-datastore:error") });
var DHTDatastore = class {
  constructor(dht) {
    this._dht = dht;
  }
  async put(key, value) {
    try {
      await (0, import_it_drain3.default)(this._dht.put(key, value));
    } catch (err) {
      log10.error(err);
      throw err;
    }
  }
  async get(key) {
    for await (const event of this._dht.get(key)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw notFoundError();
  }
};

// node_modules/ipfs-core/esm/src/ipns/routing/config.js
function createRouting({ libp2p, repo, peerId, options }) {
  const ipnsStores = [];
  let pubsubDs;
  if ((0, import_dlv.default)(options, "EXPERIMENTAL.ipnsPubsub", false)) {
    const pubsub = libp2p.pubsub;
    const localDatastore = repo.datastore;
    pubsubDs = new IpnsPubsubDatastore(pubsub, localDatastore, peerId);
    ipnsStores.push(pubsubDs);
  }
  if (!(0, import_dlv.default)(options, "offline", false) && libp2p._config && libp2p._config.dht && libp2p._config.dht.enabled) {
    ipnsStores.push(new DHTDatastore(libp2p._dht));
  }
  if ((0, import_dlv.default)(options, "offline", false) || ipnsStores.length === 0) {
    const offlineDatastore = new OfflineDatastore(repo);
    ipnsStores.push(offlineDatastore);
  }
  return new TieredDatastore(ipnsStores);
}

// node_modules/ipfs-core/esm/src/components/ipns.js
var import_debug11 = __toESM(require_browser2(), 1);
var log11 = (0, import_debug11.default)("ipfs:components:ipns");
var IPNSAPI = class {
  constructor(options = { pass: "" }) {
    this.options = options;
    this.offline = null;
    this.online = null;
  }
  getIPNS() {
    const ipns = this.online || this.offline;
    if (ipns) {
      return ipns;
    } else {
      throw new NotInitializedError();
    }
  }
  get routing() {
    return this.getIPNS().routing;
  }
  startOffline({ repo, peerId, keychain }) {
    if (this.offline != null) {
      throw new AlreadyInitializedError();
    }
    log11("initializing IPNS keyspace");
    const routing = new OfflineDatastore(repo);
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    this.offline = ipns;
  }
  async startOnline({ libp2p, repo, peerId, keychain }) {
    if (this.online != null) {
      throw new AlreadyInitializedError();
    }
    const routing = createRouting({
      libp2p,
      repo,
      peerId,
      options: this.options
    });
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    await ipns.republisher.start();
    this.online = ipns;
  }
  async stop() {
    const ipns = this.online;
    if (ipns) {
      await ipns.republisher.stop();
      this.online = null;
    }
  }
  publish(privKey, value, lifetime) {
    return this.getIPNS().publish(privKey, value, lifetime);
  }
  resolve(name10, options) {
    return this.getIPNS().resolve(name10, options);
  }
  initializeKeyspace(privKey, value) {
    return this.getIPNS().initializeKeyspace(privKey, value);
  }
};

// node_modules/ipfs-core/esm/src/components/name/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/name/publish.js
init_globals();
var import_debug12 = __toESM(require_browser2(), 1);
var import_libp2p_crypto3 = __toESM(require_src6(), 1);
var import_err_code16 = __toESM(require_err_code(), 1);
init_from_string();
init_to_string();

// node_modules/ipfs-core/esm/src/components/name/utils.js
init_globals();
var import_is_ipfs3 = __toESM(require_src3(), 1);
var import_it_drain4 = __toESM(require_it_drain(), 1);
async function resolvePath2({ ipns, repo, codecs: codecs2 }, name10, options) {
  if (import_is_ipfs3.default.ipnsPath(name10)) {
    return ipns.resolve(name10);
  }
  const { cid, path } = toCidAndPath(name10);
  await (0, import_it_drain4.default)(resolve(cid, path || "", codecs2, repo, options));
}

// node_modules/ipfs-core/esm/src/components/name/publish.js
var log12 = Object.assign((0, import_debug12.default)("ipfs:name:publish"), { error: (0, import_debug12.default)("ipfs:name:publish:error") });
function createPublish({ ipns, repo, codecs: codecs2, peerId, isOnline, keychain }) {
  const lookupKey = async (keyName) => {
    if (keyName === "self") {
      return peerId.privKey;
    }
    try {
      const pem = await keychain.exportKey(keyName, "temp");
      const privateKey = await import_libp2p_crypto3.default.keys.import(pem, "temp");
      return privateKey;
    } catch (err) {
      log12.error(err);
      throw (0, import_err_code16.default)(err, "ERR_CANNOT_GET_KEY");
    }
  };
  async function publish(value, options = {}) {
    const resolve11 = !(options.resolve === false);
    const lifetime = options.lifetime || "24h";
    const key = options.key || "self";
    if (!isOnline()) {
      throw (0, import_err_code16.default)(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
    }
    try {
      value = normalizePath(value);
    } catch (err) {
      log12.error(err);
      throw err;
    }
    let pubLifetime = 0;
    try {
      pubLifetime = parse_duration_default(lifetime) || 0;
      pubLifetime = parseFloat(pubLifetime.toFixed(6));
    } catch (err) {
      log12.error(err);
      throw err;
    }
    const results = await Promise.all([
      lookupKey(key),
      resolve11 ? resolvePath2({
        ipns,
        repo,
        codecs: codecs2
      }, value) : Promise.resolve()
    ]);
    const bytes2 = fromString3(value);
    const result = await ipns.publish(results[0], bytes2, pubLifetime);
    return {
      name: result.name,
      value: toString3(result.value)
    };
  }
  return withTimeoutOption(publish);
}

// node_modules/ipfs-core/esm/src/components/name/resolve.js
init_globals();
var import_debug13 = __toESM(require_browser2(), 1);
var import_err_code17 = __toESM(require_err_code(), 1);
init_cid();
init_digest();
init_base36();
var import_peer_id7 = __toESM(require_src5(), 1);
var import_is_domain_name = __toESM(require_is_domain_name(), 1);
init_to_string();
var mergeOptions2 = merge_options_default.bind({ ignoreUndefined: true });
var log13 = Object.assign((0, import_debug13.default)("ipfs:name:resolve"), { error: (0, import_debug13.default)("ipfs:name:resolve:error") });
var appendRemainder = (result, remainder) => remainder.length > 0 ? result + "/" + remainder.join("/") : result;
function createResolve2({
  dns,
  ipns,
  peerId,
  isOnline,
  options: { offline }
}) {
  async function* resolve11(name10, options = {}) {
    options = mergeOptions2({
      nocache: false,
      recursive: true
    }, options);
    if (offline && options && options.nocache) {
      throw (0, import_err_code17.default)(new Error("cannot specify both offline and nocache"), "ERR_NOCACHE_AND_OFFLINE");
    }
    if (!isOnline() && !offline) {
      throw (0, import_err_code17.default)(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
    }
    if (!name10) {
      name10 = peerId.toB58String();
    }
    if (!name10.startsWith("/ipns/")) {
      name10 = `/ipns/${name10}`;
    }
    let [namespace3, hash2, ...remainder] = name10.slice(1).split("/");
    try {
      if (hash2.substring(0, 1) === "1") {
        const id = import_peer_id7.default.parse(hash2);
        const digest3 = decode3(id.toBytes());
        const libp2pKey = CID.createV1(114, digest3);
        hash2 = libp2pKey.toString(base36);
      } else {
        const cid = CID.parse(hash2);
        if (cid.version === 1) {
          hash2 = cid.toString(base36);
        }
      }
    } catch (err) {
      if ((0, import_is_domain_name.default)(hash2)) {
        yield appendRemainder(await dns(hash2, options), remainder);
        return;
      }
      log13.error(err);
      throw (0, import_err_code17.default)(new Error("Invalid IPNS name"), "ERR_IPNS_INVALID_NAME");
    }
    const value = await ipns.resolve(`/${namespace3}/${hash2}`, options);
    yield appendRemainder(value instanceof Uint8Array ? toString3(value) : value, remainder);
  }
  return withTimeoutOption(resolve11);
}

// node_modules/ipfs-core/esm/src/components/name/pubsub/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/name/pubsub/cancel.js
init_globals();

// node_modules/ipfs-core/esm/src/components/name/pubsub/utils.js
init_globals();
var import_err_code18 = __toESM(require_err_code(), 1);
function getPubsubRouting(ipns, options) {
  if (!ipns || !(options && options.ipnsPubsub)) {
    throw (0, import_err_code18.default)(new Error("IPNS pubsub subsystem is not enabled"), "ERR_IPNS_PUBSUB_NOT_ENABLED");
  }
  if (ipns.routing instanceof IpnsPubsubDatastore) {
    return ipns.routing;
  }
  const pubsub = (ipns.routing.stores || []).find((s) => s instanceof IpnsPubsubDatastore);
  if (!pubsub) {
    throw (0, import_err_code18.default)(new Error("IPNS pubsub datastore not found"), "ERR_PUBSUB_DATASTORE_NOT_FOUND");
  }
  return pubsub;
}

// node_modules/ipfs-core/esm/src/components/name/pubsub/cancel.js
function createCancel({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function cancel(name10, options2 = {}) {
    const pubsub = getPubsubRouting(ipns, experimental);
    return pubsub.cancel(name10, options2);
  }
  return withTimeoutOption(cancel);
}

// node_modules/ipfs-core/esm/src/components/name/pubsub/state.js
init_globals();
function createState({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function state(_options = {}) {
    try {
      return { enabled: Boolean(getPubsubRouting(ipns, experimental)) };
    } catch (err) {
      return { enabled: false };
    }
  }
  return withTimeoutOption(state);
}

// node_modules/ipfs-core/esm/src/components/name/pubsub/subs.js
init_globals();
function createSubs({ ipns, options }) {
  const experimental = options.EXPERIMENTAL;
  async function subs(options2 = {}) {
    const pubsub = getPubsubRouting(ipns, experimental);
    return pubsub.getSubscriptions(options2);
  }
  return withTimeoutOption(subs);
}

// node_modules/ipfs-core/esm/src/components/name/pubsub/index.js
var PubSubAPI = class {
  constructor({ ipns, options }) {
    this.cancel = createCancel({
      ipns,
      options
    });
    this.state = createState({
      ipns,
      options
    });
    this.subs = createSubs({
      ipns,
      options
    });
  }
};

// node_modules/ipfs-core/esm/src/components/name/index.js
var NameAPI = class {
  constructor({ dns, ipns, repo, codecs: codecs2, peerId, isOnline, keychain, options }) {
    this.publish = createPublish({
      ipns,
      repo,
      codecs: codecs2,
      peerId,
      isOnline,
      keychain
    });
    this.resolve = createResolve2({
      dns,
      ipns,
      peerId,
      isOnline,
      options
    });
    this.pubsub = new PubSubAPI({
      ipns,
      options
    });
  }
};

// node_modules/ipfs-core/esm/src/components/refs/index.js
init_globals();
init_errors();
init_cid();
var import_timeout_abort_controller2 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal2 = __toESM(require_any_signal(), 1);
var ERR_NOT_FOUND3 = notFoundError().code;
var Format = {
  default: "<dst>",
  edges: "<src> -> <dst>"
};
function createRefs({ repo, codecs: codecs2, resolve: resolve11, preload: preload2 }) {
  async function* refs(ipfsPath2, options = {}) {
    if (options.maxDepth === 0) {
      return;
    }
    if (options.edges && options.format && options.format !== Format.default) {
      throw new Error("Cannot set edges to true and also specify format");
    }
    options.format = options.edges ? Format.edges : options.format;
    if (typeof options.maxDepth !== "number") {
      options.maxDepth = options.recursive ? Infinity : 1;
    }
    if (options.timeout) {
      const controller = new import_timeout_abort_controller2.TimeoutController(options.timeout);
      const signals = [controller.signal];
      if (options.signal) {
        signals.push(options.signal);
      }
      options.signal = (0, import_any_signal2.anySignal)(signals);
    }
    const rawPaths = Array.isArray(ipfsPath2) ? ipfsPath2 : [ipfsPath2];
    const paths = rawPaths.map((p) => getFullPath(preload2, p, options));
    for (const path of paths) {
      try {
        yield* refsStream(resolve11, repo, codecs2, path, options);
      } catch (err) {
        yield {
          ref: "",
          err: err.message
        };
      }
    }
  }
  return refs;
}
function getFullPath(preload2, ipfsPath2, options) {
  const { cid, path } = toCidAndPath(ipfsPath2);
  if (options.preload !== false) {
    preload2(cid);
  }
  return `/ipfs/${cid}${path || ""}`;
}
async function* refsStream(resolve11, repo, codecs2, path, options) {
  const resPath = await resolve11(path, options);
  const { cid } = toCidAndPath(resPath);
  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;
  const unique = options.unique || false;
  for await (const obj of objectStream(repo, codecs2, cid, maxDepth, unique, options)) {
    if (!obj.parent) {
      continue;
    }
    if (obj.isDuplicate) {
      continue;
    }
    yield { ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format) };
  }
}
function formatLink(srcCid, dstCid, linkName = "", format = Format.default) {
  let out = format.replace(/<src>/g, srcCid.toString());
  out = out.replace(/<dst>/g, dstCid.toString());
  out = out.replace(/<linkname>/g, linkName);
  return out;
}
async function* objectStream(repo, codecs2, rootCid, maxDepth, uniqueOnly, options) {
  const seen = /* @__PURE__ */ new Set();
  async function* traverseLevel(parent2, depth) {
    const nextLevelDepth = depth + 1;
    if (nextLevelDepth > maxDepth) {
      return;
    }
    try {
      for await (const link of getLinks(repo, codecs2, parent2.cid, options)) {
        yield {
          parent: parent2,
          node: link,
          isDuplicate: uniqueOnly && seen.has(link.cid.toString())
        };
        if (uniqueOnly) {
          seen.add(link.cid.toString());
        }
        yield* traverseLevel(link, nextLevelDepth);
      }
    } catch (err) {
      if (err.code === ERR_NOT_FOUND3) {
        err.message = `Could not find object with CID: ${parent2.cid}`;
      }
      throw err;
    }
  }
  yield* traverseLevel({ cid: rootCid }, 0);
}
async function* getLinks(repo, codecs2, cid, options) {
  const block = await repo.blocks.get(cid, options);
  const codec = await codecs2.getCodec(cid.code);
  const value = codec.decode(block);
  const isDagPb = cid.code === code;
  const base4 = [];
  for (const [name10, cid2] of links(value, base4)) {
    if (isDagPb) {
      const match = name10.match(/^Links\/(\d+)\/Hash$/);
      if (match) {
        const index = Number(match[1]);
        if (index < value.Links.length) {
          yield {
            name: value.Links[index].Name,
            cid: cid2
          };
          continue;
        }
      }
    }
    yield {
      name: name10,
      cid: cid2
    };
  }
}
var links = function* (source, base4) {
  if (source == null) {
    return;
  }
  if (source instanceof Uint8Array) {
    return;
  }
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base4,
      key
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          const cid = CID.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid) {
          yield [
            path.join("/"),
            cid
          ];
        } else {
          yield* links(value, path);
        }
      }
    }
  }
  return [];
};

// node_modules/ipfs-core/esm/src/components/refs/local.js
init_globals();
function createLocal({ repo }) {
  async function* refsLocal(options = {}) {
    for await (const cid of repo.blocks.queryKeys({}, { signal: options.signal })) {
      yield { ref: cid.toString() };
    }
  }
  return withTimeoutOption(refsLocal);
}

// node_modules/ipfs-core/esm/src/components/bitswap/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/bitswap/wantlist.js
init_globals();
function createWantlist({ network }) {
  async function wantlist(options = {}) {
    const { bitswap } = await network.use(options);
    const list = bitswap.getWantlist();
    return Array.from(list).map((e) => e[1].cid);
  }
  return withTimeoutOption(wantlist);
}

// node_modules/ipfs-core/esm/src/components/bitswap/wantlist-for-peer.js
init_globals();
var import_peer_id8 = __toESM(require_src5(), 1);
function createWantlistForPeer({ network }) {
  async function wantlistForPeer(peerId, options = {}) {
    const { bitswap } = await network.use(options);
    const list = bitswap.wantlistForPeer(import_peer_id8.default.createFromB58String(peerId));
    return Array.from(list).map((e) => e[1].cid);
  }
  return withTimeoutOption(wantlistForPeer);
}

// node_modules/ipfs-core/esm/src/components/bitswap/unwant.js
init_globals();
function createUnwant({ network }) {
  async function unwant(cids, options = {}) {
    const { bitswap } = await network.use(options);
    if (!Array.isArray(cids)) {
      cids = [cids];
    }
    return bitswap.unwant(cids);
  }
  return withTimeoutOption(unwant);
}

// node_modules/ipfs-core/esm/src/components/bitswap/stat.js
init_globals();
function createStat({ network }) {
  async function stat(options = {}) {
    const bitswap = (await network.use(options)).bitswap;
    const snapshot = bitswap.stat().snapshot;
    return {
      provideBufLen: parseInt(snapshot.providesBufferLength.toString()),
      blocksReceived: BigInt(snapshot.blocksReceived.toString()),
      wantlist: Array.from(bitswap.getWantlist()).map((e) => e[1].cid),
      peers: bitswap.peers().map((id) => id.toB58String()),
      dupBlksReceived: BigInt(snapshot.dupBlksReceived.toString()),
      dupDataReceived: BigInt(snapshot.dupDataReceived.toString()),
      dataReceived: BigInt(snapshot.dataReceived.toString()),
      blocksSent: BigInt(snapshot.blocksSent.toString()),
      dataSent: BigInt(snapshot.dataSent.toString())
    };
  }
  return withTimeoutOption(stat);
}

// node_modules/ipfs-core/esm/src/components/bitswap/index.js
var BitswapAPI = class {
  constructor({ network }) {
    this.wantlist = createWantlist({ network });
    this.wantlistForPeer = createWantlistForPeer({ network });
    this.unwant = createUnwant({ network });
    this.stat = createStat({ network });
  }
};

// node_modules/ipfs-core/esm/src/components/bootstrap/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/bootstrap/add.js
init_globals();

// node_modules/ipfs-core/esm/src/components/bootstrap/utils.js
init_globals();
var import_mafmt = __toESM(require_src2(), 1);
function isValidMultiaddr(ma) {
  try {
    return import_mafmt.default.IPFS.matches(ma);
  } catch (err) {
    return false;
  }
}

// node_modules/ipfs-core/esm/src/components/bootstrap/add.js
function createAdd2({ repo }) {
  async function add(multiaddr, options = {}) {
    if (!isValidMultiaddr(multiaddr)) {
      throw new Error(`${multiaddr} is not a valid Multiaddr`);
    }
    const config2 = await repo.config.getAll(options);
    const boostrappers = config2.Bootstrap || [];
    boostrappers.push(multiaddr.toString());
    config2.Bootstrap = Array.from(new Set(boostrappers)).sort((a, b) => a.localeCompare(b));
    await repo.config.replace(config2);
    return { Peers: [multiaddr] };
  }
  return withTimeoutOption(add);
}

// node_modules/ipfs-core/esm/src/components/bootstrap/clear.js
init_globals();
var import_multiaddr = __toESM(require_src(), 1);
function createClear({ repo }) {
  async function clear(options = {}) {
    const config2 = await repo.config.getAll(options);
    const removed = config2.Bootstrap || [];
    config2.Bootstrap = [];
    await repo.config.replace(config2);
    return { Peers: removed.map((ma) => new import_multiaddr.Multiaddr(ma)) };
  }
  return withTimeoutOption(clear);
}

// node_modules/ipfs-core/esm/src/components/bootstrap/list.js
init_globals();
var import_multiaddr2 = __toESM(require_src(), 1);
function createList({ repo }) {
  async function list(options = {}) {
    const peers = await repo.config.get("Bootstrap", options);
    return { Peers: (peers || []).map((ma) => new import_multiaddr2.Multiaddr(ma)) };
  }
  return withTimeoutOption(list);
}

// node_modules/ipfs-core/esm/src/components/bootstrap/reset.js
init_globals();

// node_modules/ipfs-core-config/esm/src/config.browser.js
init_globals();
var config_browser_default = () => ({
  Addresses: {
    Swarm: [],
    Announce: [],
    NoAnnounce: [],
    API: "",
    Gateway: "",
    RPC: "",
    Delegates: [
      "/dns4/node0.delegate.ipfs.io/tcp/443/https",
      "/dns4/node1.delegate.ipfs.io/tcp/443/https",
      "/dns4/node2.delegate.ipfs.io/tcp/443/https",
      "/dns4/node3.delegate.ipfs.io/tcp/443/https"
    ]
  },
  Discovery: {
    MDNS: {
      Enabled: false,
      Interval: 10
    },
    webRTCStar: { Enabled: true }
  },
  Bootstrap: [
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
    "/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic",
    "/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6",
    "/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS",
    "/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"
  ],
  Pubsub: { Enabled: true },
  Swarm: {
    ConnMgr: {
      LowWater: 5,
      HighWater: 20
    },
    DisableNatPortMap: true
  },
  Routing: { Type: "dhtclient" }
});

// node_modules/ipfs-core/esm/src/components/bootstrap/reset.js
var import_multiaddr3 = __toESM(require_src(), 1);
function createReset({ repo }) {
  async function reset(options = {}) {
    const config2 = await repo.config.getAll(options);
    config2.Bootstrap = config_browser_default().Bootstrap;
    await repo.config.replace(config2);
    return { Peers: config_browser_default().Bootstrap.map((ma) => new import_multiaddr3.Multiaddr(ma)) };
  }
  return withTimeoutOption(reset);
}

// node_modules/ipfs-core/esm/src/components/bootstrap/rm.js
init_globals();
function createRm2({ repo }) {
  async function rm(multiaddr, options = {}) {
    if (!isValidMultiaddr(multiaddr)) {
      throw new Error(`${multiaddr} is not a valid Multiaddr`);
    }
    const config2 = await repo.config.getAll(options);
    config2.Bootstrap = (config2.Bootstrap || []).filter((ma) => ma.toString() !== multiaddr.toString());
    await repo.config.replace(config2);
    return { Peers: [multiaddr] };
  }
  return withTimeoutOption(rm);
}

// node_modules/ipfs-core/esm/src/components/bootstrap/index.js
var BootstrapAPI = class {
  constructor({ repo }) {
    this.add = createAdd2({ repo });
    this.list = createList({ repo });
    this.rm = createRm2({ repo });
    this.clear = createClear({ repo });
    this.reset = createReset({ repo });
  }
};

// node_modules/ipfs-core/esm/src/components/block/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/block/get.js
init_globals();
function createGet({ preload: preload2, repo }) {
  async function get6(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    return repo.blocks.get(cid, options);
  }
  return withTimeoutOption(get6);
}

// node_modules/ipfs-core/esm/src/components/block/put.js
init_globals();
init_cid();
function createPut({ codecs: codecs2, hashers, repo, preload: preload2 }) {
  async function put(block, options = {}) {
    const release = options.pin ? await repo.gcLock.readLock() : null;
    try {
      const cidVersion = options.version != null ? options.version : 0;
      const codecName = options.format || (cidVersion === 0 ? "dag-pb" : "raw");
      const hasher = await hashers.getHasher(options.mhtype || "sha2-256");
      const hash2 = await hasher.digest(block);
      const codec = await codecs2.getCodec(codecName);
      const cid = CID.create(cidVersion, codec.code, hash2);
      await repo.blocks.put(cid, block, { signal: options.signal });
      if (options.preload !== false) {
        preload2(cid);
      }
      if (options.pin === true) {
        await repo.pins.pinRecursively(cid, { signal: options.signal });
      }
      return cid;
    } finally {
      if (release) {
        release();
      }
    }
  }
  return withTimeoutOption(put);
}

// node_modules/ipfs-core/esm/src/components/block/rm.js
init_globals();
var import_err_code19 = __toESM(require_err_code(), 1);
var import_it_parallel = __toESM(require_it_parallel(), 1);
var import_it_map2 = __toESM(require_it_map(), 1);
var import_it_filter3 = __toESM(require_it_filter(), 1);
var import_it_pipe2 = __toESM(require_it_pipe(), 1);

// node_modules/ipfs-core/esm/src/components/block/utils.js
init_globals();
init_cid();
function cleanCid(cid) {
  if (cid instanceof Uint8Array) {
    return CID.decode(cid);
  }
  return CID.parse(cid.toString());
}

// node_modules/ipfs-core/esm/src/components/block/rm.js
var BLOCK_RM_CONCURRENCY = 8;
function createRm3({ repo }) {
  async function* rm(cids, options = {}) {
    if (!Array.isArray(cids)) {
      cids = [cids];
    }
    const release = await repo.gcLock.writeLock();
    try {
      yield* (0, import_it_pipe2.pipe)(cids, (source) => (0, import_it_map2.default)(source, (cid) => {
        return async () => {
          cid = cleanCid(cid);
          const result = { cid };
          try {
            const has = await repo.blocks.has(cid);
            if (!has) {
              throw (0, import_err_code19.default)(new Error("block not found"), "ERR_BLOCK_NOT_FOUND");
            }
            await repo.blocks.delete(cid);
          } catch (err) {
            if (!options.force) {
              err.message = `cannot remove ${cid}: ${err.message}`;
              result.error = err;
            }
          }
          return result;
        };
      }), (source) => (0, import_it_parallel.default)(source, { concurrency: BLOCK_RM_CONCURRENCY }), (source) => (0, import_it_filter3.default)(source, () => !options.quiet));
    } finally {
      release();
    }
  }
  return withTimeoutOption(rm);
}

// node_modules/ipfs-core/esm/src/components/block/stat.js
init_globals();
function createStat2({ repo, preload: preload2 }) {
  async function stat(cid, options = {}) {
    cid = cleanCid(cid);
    if (options.preload !== false) {
      preload2(cid);
    }
    const block = await repo.blocks.get(cid);
    return {
      cid,
      size: block.length
    };
  }
  return withTimeoutOption(stat);
}

// node_modules/ipfs-core/esm/src/components/block/index.js
var BlockAPI = class {
  constructor({ codecs: codecs2, hashers, preload: preload2, repo }) {
    this.get = createGet({
      preload: preload2,
      repo
    });
    this.put = createPut({
      codecs: codecs2,
      hashers,
      preload: preload2,
      repo
    });
    this.rm = createRm3({ repo });
    this.stat = createStat2({
      preload: preload2,
      repo
    });
  }
};

// node_modules/ipfs-core/esm/src/components/root.js
init_globals();

// node_modules/ipfs-core/esm/src/components/add.js
init_globals();
var import_it_last3 = __toESM(require_it_last(), 1);

// node_modules/ipfs-core-utils/esm/src/files/normalise-input-single.js
init_globals();

// node_modules/ipfs-core-utils/esm/src/files/normalise-content.js
init_globals();
var import_err_code20 = __toESM(require_err_code(), 1);
init_from_string();
var import_browser_readablestream_to_it = __toESM(require_browser_readablestream_to_it(), 1);
var import_blob_to_it = __toESM(require_blob_to_it(), 1);
var import_it_peekable = __toESM(require_it_peekable(), 1);
var import_it_all2 = __toESM(require_it_all(), 1);
var import_it_map3 = __toESM(require_it_map(), 1);

// node_modules/ipfs-core-utils/esm/src/files/utils.js
init_globals();
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
var isReadableStream = (value) => value && typeof value.getReader === "function";

// node_modules/ipfs-core-utils/esm/src/files/normalise-content.js
async function* toAsyncIterable(thing) {
  yield thing;
}
async function normaliseContent(input) {
  if (isBytes(input)) {
    return toAsyncIterable(toBytes(input));
  }
  if (typeof input === "string" || input instanceof String) {
    return toAsyncIterable(toBytes(input.toString()));
  }
  if (isBlob(input)) {
    return (0, import_blob_to_it.default)(input);
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable.default)(input);
    const { value, done } = await peekable.peek();
    if (done) {
      return toAsyncIterable(new Uint8Array(0));
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return toAsyncIterable(Uint8Array.from(await (0, import_it_all2.default)(peekable)));
    }
    if (isBytes(value) || typeof value === "string" || value instanceof String) {
      return (0, import_it_map3.default)(peekable, toBytes);
    }
  }
  throw (0, import_err_code20.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
function toBytes(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString3(chunk.toString());
}

// node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-single.js
init_globals();
var import_err_code21 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it2 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_peekable2 = __toESM(require_it_peekable(), 1);
async function* normaliseCandidateSingle(input, normaliseContent3) {
  if (input === null || input === void 0) {
    throw (0, import_err_code21.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input === "string" || input instanceof String) {
    yield toFileObject(input.toString(), normaliseContent3);
    return;
  }
  if (isBytes(input) || isBlob(input)) {
    yield toFileObject(input, normaliseContent3);
    return;
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it2.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable2.default)(input);
    const { value, done } = await peekable.peek();
    if (done) {
      yield { content: [] };
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value) || isBytes(value) || typeof value === "string" || value instanceof String) {
      yield toFileObject(peekable, normaliseContent3);
      return;
    }
    throw (0, import_err_code21.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isFileObject(input)) {
    yield toFileObject(input, normaliseContent3);
    return;
  }
  throw (0, import_err_code21.default)(new Error('Unexpected input: cannot convert "' + typeof input + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input, normaliseContent3) {
  const { path, mode, mtime, content } = input;
  const file = {
    path: path || "",
    mode: parseMode(mode),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path) {
    file.content = await normaliseContent3(input);
  }
  return file;
}

// node_modules/ipfs-core-utils/esm/src/files/normalise-input-single.js
function normaliseInput2(input) {
  return normaliseCandidateSingle(input, normaliseContent);
}

// node_modules/ipfs-core/esm/src/components/add.js
function createAdd3({ addAll }) {
  async function add(entry, options = {}) {
    const result = await (0, import_it_last3.default)(addAll(normaliseInput2(entry), options));
    if (result == null) {
      throw Error("Failed to add a file, if you see this please report a bug");
    }
    return result;
  }
  return add;
}

// node_modules/ipfs-core/esm/src/components/add-all/index.js
init_globals();

// node_modules/ipfs-unixfs-importer/esm/src/index.js
init_globals();
var import_it_parallel_batch2 = __toESM(require_it_parallel_batch(), 1);

// node_modules/ipfs-unixfs-importer/esm/src/options.js
init_globals();
init_sha2_browser();

// node_modules/@multiformats/murmur3/esm/index.js
init_globals();
init_hasher();
init_src();
var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited(), 1);
function fromNumberTo32BitBuf(number) {
  const bytes2 = new Array(4);
  for (let i = 0; i < 4; i++) {
    bytes2[i] = number & 255;
    number = number >> 8;
  }
  return new Uint8Array(bytes2);
}
var murmur332 = from2({
  name: "murmur3-32",
  code: 35,
  encode: (input) => fromNumberTo32BitBuf(import_murmurhash3js_revisited.default.x86.hash32(input))
});
var murmur3128 = from2({
  name: "murmur3-128",
  code: 34,
  encode: (input) => bytes_exports.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input))
});

// node_modules/ipfs-unixfs-importer/esm/src/options.js
async function hamtHashFn(buf3) {
  return (await murmur3128.encode(buf3)).slice(0, 8).reverse();
}
var defaultOptions = {
  chunker: "fixed",
  strategy: "balanced",
  rawLeaves: false,
  onlyHash: false,
  reduceSingleLeafToSelf: true,
  hasher: sha256,
  leafType: "file",
  cidVersion: 0,
  progress: () => () => {
  },
  shardSplitThreshold: 1e3,
  fileImportConcurrency: 50,
  blockWriteConcurrency: 10,
  minChunkSize: 262144,
  maxChunkSize: 262144,
  avgChunkSize: 262144,
  window: 16,
  polynomial: 17437180132763652,
  maxChildrenPerNode: 174,
  layerRepeat: 4,
  wrapWithDirectory: false,
  recursive: false,
  hidden: false,
  timeout: void 0,
  hamtHashFn,
  hamtHashCode: 34,
  hamtBucketBits: 8
};
var options_default = (options = {}) => {
  const defaults = merge_options_default.bind({ ignoreUndefined: true });
  return defaults(defaultOptions, options);
};

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js
init_globals();

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/dir.js
init_globals();

// node_modules/ipfs-unixfs-importer/esm/src/utils/persist.js
init_globals();
init_cid();
init_sha2_browser();
var persist = async (buffer3, blockstore, options) => {
  if (!options.codec) {
    options.codec = src_exports2;
  }
  if (!options.hasher) {
    options.hasher = sha256;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === src_exports2 && options.hasher !== sha256) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer3);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer3, { signal: options.signal });
  }
  return cid;
};
var persist_default = persist;

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/dir.js
var dirBuilder = async (item, blockstore, options) => {
  const unixfs = new UnixFS({
    type: "directory",
    mtime: item.mtime,
    mode: item.mode
  });
  const buffer3 = encode3(prepare({ Data: unixfs.marshal() }));
  const cid = await persist_default(buffer3, blockstore, options);
  const path = item.path;
  return {
    cid,
    path,
    unixfs,
    size: buffer3.length
  };
};
var dir_default = dirBuilder;

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js
init_globals();
var import_err_code22 = __toESM(require_err_code(), 1);
var import_it_parallel_batch = __toESM(require_it_parallel_batch(), 1);
init_raw();

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/flat.js
init_globals();
var import_it_all3 = __toESM(require_it_all(), 1);
async function flat(source, reduce2) {
  return reduce2(await (0, import_it_all3.default)(source));
}
var flat_default = flat;

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/balanced.js
init_globals();
var import_it_batch = __toESM(require_it_batch(), 1);
function balanced(source, reduce2, options) {
  return reduceToParents(source, reduce2, options);
}
async function reduceToParents(source, reduce2, options) {
  const roots = [];
  for await (const chunked of (0, import_it_batch.default)(source, options.maxChildrenPerNode)) {
    roots.push(await reduce2(chunked));
  }
  if (roots.length > 1) {
    return reduceToParents(roots, reduce2, options);
  }
  return roots[0];
}
var balanced_default = balanced;

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/trickle.js
init_globals();
var import_it_batch2 = __toESM(require_it_batch(), 1);
async function trickleStream(source, reduce2, options) {
  const root = new Root(options.layerRepeat);
  let iteration = 0;
  let maxDepth = 1;
  let subTree = root;
  for await (const layer of (0, import_it_batch2.default)(source, options.maxChildrenPerNode)) {
    if (subTree.isFull()) {
      if (subTree !== root) {
        root.addChild(await subTree.reduce(reduce2));
      }
      if (iteration && iteration % options.layerRepeat === 0) {
        maxDepth++;
      }
      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
      iteration++;
    }
    subTree.append(layer);
  }
  if (subTree && subTree !== root) {
    root.addChild(await subTree.reduce(reduce2));
  }
  return root.reduce(reduce2);
}
var trickle_default = trickleStream;
var SubTree = class {
  constructor(maxDepth, layerRepeat, iteration = 0) {
    this.maxDepth = maxDepth;
    this.layerRepeat = layerRepeat;
    this.currentDepth = 1;
    this.iteration = iteration;
    this.root = this.node = this.parent = {
      children: [],
      depth: this.currentDepth,
      maxDepth,
      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
    };
  }
  isFull() {
    if (!this.root.data) {
      return false;
    }
    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
      this._addNextNodeToParent(this.node);
      return false;
    }
    const distantRelative = this._findParent(this.node, this.currentDepth);
    if (distantRelative) {
      this._addNextNodeToParent(distantRelative);
      return false;
    }
    return true;
  }
  _addNextNodeToParent(parent2) {
    this.parent = parent2;
    const nextNode = {
      children: [],
      depth: parent2.depth + 1,
      parent: parent2,
      maxDepth: this.maxDepth,
      maxChildren: Math.floor(parent2.children.length / this.layerRepeat) * this.layerRepeat
    };
    parent2.children.push(nextNode);
    this.currentDepth = nextNode.depth;
    this.node = nextNode;
  }
  append(layer) {
    this.node.data = layer;
  }
  reduce(reduce2) {
    return this._reduce(this.root, reduce2);
  }
  async _reduce(node, reduce2) {
    let children = [];
    if (node.children.length) {
      children = await Promise.all(node.children.filter((child) => child.data).map((child) => this._reduce(child, reduce2)));
    }
    return reduce2((node.data || []).concat(children));
  }
  _findParent(node, depth) {
    const parent2 = node.parent;
    if (!parent2 || parent2.depth === 0) {
      return;
    }
    if (parent2.children.length === parent2.maxChildren || !parent2.maxChildren) {
      return this._findParent(parent2, depth);
    }
    return parent2;
  }
};
var Root = class extends SubTree {
  constructor(layerRepeat) {
    super(0, layerRepeat);
    this.root.depth = 0;
    this.currentDepth = 1;
  }
  addChild(child) {
    this.root.children.push(child);
  }
  reduce(reduce2) {
    return reduce2((this.root.data || []).concat(this.root.children));
  }
};

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/buffer-importer.js
init_globals();
init_raw();
async function* bufferImporter(file, block, options) {
  for await (let buffer3 of file.content) {
    yield async () => {
      options.progress(buffer3.length, file.path);
      let unixfs;
      const opts = {
        codec: src_exports2,
        cidVersion: options.cidVersion,
        hasher: options.hasher,
        onlyHash: options.onlyHash
      };
      if (options.rawLeaves) {
        opts.codec = raw_exports;
        opts.cidVersion = 1;
      } else {
        unixfs = new UnixFS({
          type: options.leafType,
          data: buffer3
        });
        buffer3 = encode3({
          Data: unixfs.marshal(),
          Links: []
        });
      }
      return {
        cid: await persist_default(buffer3, block, opts),
        unixfs,
        size: buffer3.length
      };
    };
  }
}
var buffer_importer_default = bufferImporter;

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js
var dagBuilders = {
  flat: flat_default,
  balanced: balanced_default,
  trickle: trickle_default
};
async function* buildFileBatch(file, blockstore, options) {
  let count = -1;
  let previous;
  let bufferImporter2;
  if (typeof options.bufferImporter === "function") {
    bufferImporter2 = options.bufferImporter;
  } else {
    bufferImporter2 = buffer_importer_default;
  }
  for await (const entry of (0, import_it_parallel_batch.default)(bufferImporter2(file, blockstore, options), options.blockWriteConcurrency)) {
    count++;
    if (count === 0) {
      previous = entry;
      continue;
    } else if (count === 1 && previous) {
      yield previous;
      previous = null;
    }
    yield entry;
  }
  if (previous) {
    previous.single = true;
    yield previous;
  }
}
var reduce = (file, blockstore, options) => {
  async function reducer(leaves) {
    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
      const leaf = leaves[0];
      if (file.mtime !== void 0 || file.mode !== void 0) {
        let buffer4 = await blockstore.get(leaf.cid);
        leaf.unixfs = new UnixFS({
          type: "file",
          mtime: file.mtime,
          mode: file.mode,
          data: buffer4
        });
        buffer4 = encode3(prepare({ Data: leaf.unixfs.marshal() }));
        leaf.cid = await persist_default(buffer4, blockstore, {
          ...options,
          codec: src_exports2,
          hasher: options.hasher,
          cidVersion: options.cidVersion
        });
        leaf.size = buffer4.length;
      }
      return {
        cid: leaf.cid,
        path: file.path,
        unixfs: leaf.unixfs,
        size: leaf.size
      };
    }
    const f = new UnixFS({
      type: "file",
      mtime: file.mtime,
      mode: file.mode
    });
    const links3 = leaves.filter((leaf) => {
      if (leaf.cid.code === code6 && leaf.size) {
        return true;
      }
      if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
        return true;
      }
      return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
    }).map((leaf) => {
      if (leaf.cid.code === code6) {
        f.addBlockSize(leaf.size);
        return {
          Name: "",
          Tsize: leaf.size,
          Hash: leaf.cid
        };
      }
      if (!leaf.unixfs || !leaf.unixfs.data) {
        f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
      } else {
        f.addBlockSize(leaf.unixfs.data.length);
      }
      return {
        Name: "",
        Tsize: leaf.size,
        Hash: leaf.cid
      };
    });
    const node = {
      Data: f.marshal(),
      Links: links3
    };
    const buffer3 = encode3(prepare(node));
    const cid = await persist_default(buffer3, blockstore, options);
    return {
      cid,
      path: file.path,
      unixfs: f,
      size: buffer3.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
    };
  }
  return reducer;
};
function fileBuilder(file, block, options) {
  const dagBuilder2 = dagBuilders[options.strategy];
  if (!dagBuilder2) {
    throw (0, import_err_code22.default)(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
  }
  return dagBuilder2(buildFileBatch(file, block, options), reduce(file, block, options), options);
}
var file_default = fileBuilder;

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js
var import_err_code25 = __toESM(require_err_code(), 1);

// node_modules/ipfs-unixfs-importer/esm/src/chunker/rabin.js
init_globals();
var import_BufferList = __toESM(require_BufferList(), 1);
var import_rabin_wasm = __toESM(require_src8(), 1);
var import_err_code23 = __toESM(require_err_code(), 1);
async function* rabinChunker(source, options) {
  let min, max, avg;
  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
    avg = options.avgChunkSize;
    min = options.minChunkSize;
    max = options.maxChunkSize;
  } else if (!options.avgChunkSize) {
    throw (0, import_err_code23.default)(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
  } else {
    avg = options.avgChunkSize;
    min = avg / 3;
    max = avg + avg / 2;
  }
  if (min < 16) {
    throw (0, import_err_code23.default)(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
  }
  if (max < min) {
    max = min;
  }
  if (avg < min) {
    avg = min;
  }
  const sizepow = Math.floor(Math.log2(avg));
  for await (const chunk of rabin(source, {
    min,
    max,
    bits: sizepow,
    window: options.window,
    polynomial: options.polynomial
  })) {
    yield chunk;
  }
}
var rabin_default = rabinChunker;
async function* rabin(source, options) {
  const r = await (0, import_rabin_wasm.create)(options.bits, options.min, options.max, options.window);
  const buffers = new import_BufferList.default();
  for await (const chunk of source) {
    buffers.append(chunk);
    const sizes = r.fingerprint(chunk);
    for (let i = 0; i < sizes.length; i++) {
      const size = sizes[i];
      const buf3 = buffers.slice(0, size);
      buffers.consume(size);
      yield buf3;
    }
  }
  if (buffers.length) {
    yield buffers.slice(0);
  }
}

// node_modules/ipfs-unixfs-importer/esm/src/chunker/fixed-size.js
init_globals();
var import_BufferList2 = __toESM(require_BufferList(), 1);
async function* fixedSizeChunker(source, options) {
  let bl = new import_BufferList2.default();
  let currentLength = 0;
  let emitted = false;
  const maxChunkSize = options.maxChunkSize;
  for await (const buffer3 of source) {
    bl.append(buffer3);
    currentLength += buffer3.length;
    while (currentLength >= maxChunkSize) {
      yield bl.slice(0, maxChunkSize);
      emitted = true;
      if (maxChunkSize === bl.length) {
        bl = new import_BufferList2.default();
        currentLength = 0;
      } else {
        const newBl = new import_BufferList2.default();
        newBl.append(bl.shallowSlice(maxChunkSize));
        bl = newBl;
        currentLength -= maxChunkSize;
      }
    }
  }
  if (!emitted || currentLength) {
    yield bl.slice(0, currentLength);
  }
}
var fixed_size_default = fixedSizeChunker;

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/validate-chunks.js
init_globals();
var import_err_code24 = __toESM(require_err_code(), 1);
init_from_string();
async function* validateChunks(source) {
  for await (const content of source) {
    if (content.length === void 0) {
      throw (0, import_err_code24.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
    if (typeof content === "string" || content instanceof String) {
      yield fromString3(content.toString());
    } else if (Array.isArray(content)) {
      yield Uint8Array.from(content);
    } else if (content instanceof Uint8Array) {
      yield content;
    } else {
      throw (0, import_err_code24.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
  }
}
var validate_chunks_default = validateChunks;

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return async function* () {
        yield content;
      }();
    } else if (isIterable(content)) {
      return async function* () {
        yield* content;
      }();
    } else if (isAsyncIterable(content)) {
      return content;
    }
  } catch {
    throw (0, import_err_code25.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw (0, import_err_code25.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
async function* dagBuilder(source, blockstore, options) {
  for await (const entry of source) {
    if (entry.path) {
      if (entry.path.substring(0, 2) === "./") {
        options.wrapWithDirectory = true;
      }
      entry.path = entry.path.split("/").filter((path) => path && path !== ".").join("/");
    }
    if (entry.content) {
      let chunker;
      if (typeof options.chunker === "function") {
        chunker = options.chunker;
      } else if (options.chunker === "rabin") {
        chunker = rabin_default;
      } else {
        chunker = fixed_size_default;
      }
      let chunkValidator;
      if (typeof options.chunkValidator === "function") {
        chunkValidator = options.chunkValidator;
      } else {
        chunkValidator = validate_chunks_default;
      }
      const file = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode,
        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
      };
      yield () => file_default(file, blockstore, options);
    } else if (entry.path) {
      const dir = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode
      };
      yield () => dir_default(dir, blockstore, options);
    } else {
      throw new Error("Import candidate must have content or path or both");
    }
  }
}
var dag_builder_default = dagBuilder;

// node_modules/ipfs-unixfs-importer/esm/src/tree-builder.js
init_globals();

// node_modules/ipfs-unixfs-importer/esm/src/dir-flat.js
init_globals();

// node_modules/ipfs-unixfs-importer/esm/src/dir.js
init_globals();
var Dir = class {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  async put(name10, value) {
  }
  get(name10) {
    return Promise.resolve(this);
  }
  async *eachChildSeries() {
  }
  async *flush(blockstore) {
  }
};
var dir_default2 = Dir;

// node_modules/ipfs-unixfs-importer/esm/src/dir-flat.js
var DirFlat = class extends dir_default2 {
  constructor(props, options) {
    super(props, options);
    this._children = {};
  }
  async put(name10, value) {
    this.cid = void 0;
    this.size = void 0;
    this._children[name10] = value;
  }
  get(name10) {
    return Promise.resolve(this._children[name10]);
  }
  childCount() {
    return Object.keys(this._children).length;
  }
  directChildrenCount() {
    return this.childCount();
  }
  onlyChild() {
    return this._children[Object.keys(this._children)[0]];
  }
  async *eachChildSeries() {
    const keys2 = Object.keys(this._children);
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      yield {
        key,
        child: this._children[key]
      };
    }
  }
  async *flush(block) {
    const children = Object.keys(this._children);
    const links3 = [];
    for (let i = 0; i < children.length; i++) {
      let child = this._children[children[i]];
      if (child instanceof dir_default2) {
        for await (const entry of child.flush(block)) {
          child = entry;
          yield child;
        }
      }
      if (child.size != null && child.cid) {
        links3.push({
          Name: children[i],
          Tsize: child.size,
          Hash: child.cid
        });
      }
    }
    const unixfs = new UnixFS({
      type: "directory",
      mtime: this.mtime,
      mode: this.mode
    });
    const node = {
      Data: unixfs.marshal(),
      Links: links3
    };
    const buffer3 = encode3(prepare(node));
    const cid = await persist_default(buffer3, block, this.options);
    const size = buffer3.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);
    this.cid = cid;
    this.size = size;
    yield {
      cid,
      unixfs,
      path: this.path,
      size
    };
  }
};
var dir_flat_default = DirFlat;

// node_modules/ipfs-unixfs-importer/esm/src/flat-to-shard.js
init_globals();

// node_modules/ipfs-unixfs-importer/esm/src/dir-sharded.js
init_globals();
var import_hamt_sharding = __toESM(require_src9(), 1);
var DirSharded = class extends dir_default2 {
  constructor(props, options) {
    super(props, options);
    this._bucket = (0, import_hamt_sharding.createHAMT)({
      hashFn: options.hamtHashFn,
      bits: options.hamtBucketBits
    });
  }
  async put(name10, value) {
    await this._bucket.put(name10, value);
  }
  get(name10) {
    return this._bucket.get(name10);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value
      };
    }
  }
  async *flush(blockstore) {
    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {
      yield {
        ...entry,
        path: this.path
      };
    }
  }
};
var dir_sharded_default = DirSharded;
async function* flush(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links3 = [];
  let childrenSize = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children.get(i);
    if (!child) {
      continue;
    }
    const labelPrefix = i.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof import_hamt_sharding.Bucket) {
      let shard2;
      for await (const subShard of await flush(child, blockstore, null, options)) {
        shard2 = subShard;
      }
      if (!shard2) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links3.push({
        Name: labelPrefix,
        Tsize: shard2.size,
        Hash: shard2.cid
      });
      childrenSize += shard2.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links3.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value = child.value;
      if (!value.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value.size;
      links3.push({
        Name: label,
        Tsize: size2,
        Hash: value.cid
      });
      childrenSize += size2;
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: options.hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links3
  };
  const buffer3 = encode3(prepare(node));
  const cid = await persist_default(buffer3, blockstore, options);
  const size = buffer3.length + childrenSize;
  yield {
    cid,
    unixfs: dir,
    size
  };
}

// node_modules/ipfs-unixfs-importer/esm/src/flat-to-shard.js
async function flatToShard(child, dir, threshold, options) {
  let newDir = dir;
  if (dir instanceof dir_flat_default && dir.directChildrenCount() >= threshold) {
    newDir = await convertToShard(dir, options);
  }
  const parent2 = newDir.parent;
  if (parent2) {
    if (newDir !== dir) {
      if (child) {
        child.parent = newDir;
      }
      if (!newDir.parentKey) {
        throw new Error("No parent key found");
      }
      await parent2.put(newDir.parentKey, newDir);
    }
    return flatToShard(newDir, parent2, threshold, options);
  }
  return newDir;
}
async function convertToShard(oldDir, options) {
  const newDir = new dir_sharded_default({
    root: oldDir.root,
    dir: true,
    parent: oldDir.parent,
    parentKey: oldDir.parentKey,
    path: oldDir.path,
    dirty: oldDir.dirty,
    flat: false,
    mtime: oldDir.mtime,
    mode: oldDir.mode
  }, options);
  for await (const { key, child } of oldDir.eachChildSeries()) {
    await newDir.put(key, child);
  }
  return newDir;
}
var flat_to_shard_default = flatToShard;

// node_modules/ipfs-unixfs-importer/esm/src/utils/to-path-components.js
init_globals();
var toPathComponents = (path = "") => {
  return (path.trim().match(/([^\\/]|\\\/)+/g) || []).filter(Boolean);
};
var to_path_components_default = toPathComponents;

// node_modules/ipfs-unixfs-importer/esm/src/tree-builder.js
async function addToTree(elem, tree2, options) {
  const pathElems = to_path_components_default(elem.path || "");
  const lastIndex = pathElems.length - 1;
  let parent2 = tree2;
  let currentPath = "";
  for (let i = 0; i < pathElems.length; i++) {
    const pathElem = pathElems[i];
    currentPath += `${currentPath ? "/" : ""}${pathElem}`;
    const last15 = i === lastIndex;
    parent2.dirty = true;
    parent2.cid = void 0;
    parent2.size = void 0;
    if (last15) {
      await parent2.put(pathElem, elem);
      tree2 = await flat_to_shard_default(null, parent2, options.shardSplitThreshold, options);
    } else {
      let dir = await parent2.get(pathElem);
      if (!dir || !(dir instanceof dir_default2)) {
        dir = new dir_flat_default({
          root: false,
          dir: true,
          parent: parent2,
          parentKey: pathElem,
          path: currentPath,
          dirty: true,
          flat: true,
          mtime: dir && dir.unixfs && dir.unixfs.mtime,
          mode: dir && dir.unixfs && dir.unixfs.mode
        }, options);
      }
      await parent2.put(pathElem, dir);
      parent2 = dir;
    }
  }
  return tree2;
}
async function* flushAndYield(tree2, blockstore) {
  if (!(tree2 instanceof dir_default2)) {
    if (tree2 && tree2.unixfs && tree2.unixfs.isDirectory()) {
      yield tree2;
    }
    return;
  }
  yield* tree2.flush(blockstore);
}
async function* treeBuilder(source, block, options) {
  let tree2 = new dir_flat_default({
    root: true,
    dir: true,
    path: "",
    dirty: true,
    flat: true
  }, options);
  for await (const entry of source) {
    if (!entry) {
      continue;
    }
    tree2 = await addToTree(entry, tree2, options);
    if (!entry.unixfs || !entry.unixfs.isDirectory()) {
      yield entry;
    }
  }
  if (options.wrapWithDirectory) {
    yield* flushAndYield(tree2, block);
  } else {
    for await (const unwrapped of tree2.eachChildSeries()) {
      if (!unwrapped) {
        continue;
      }
      yield* flushAndYield(unwrapped.child, block);
    }
  }
}
var tree_builder_default = treeBuilder;

// node_modules/ipfs-unixfs-importer/esm/src/index.js
async function* importer(source, blockstore, options = {}) {
  const opts = options_default(options);
  let dagBuilder2;
  if (typeof options.dagBuilder === "function") {
    dagBuilder2 = options.dagBuilder;
  } else {
    dagBuilder2 = dag_builder_default;
  }
  let treeBuilder2;
  if (typeof options.treeBuilder === "function") {
    treeBuilder2 = options.treeBuilder;
  } else {
    treeBuilder2 = tree_builder_default;
  }
  let candidates;
  if (Symbol.asyncIterator in source || Symbol.iterator in source) {
    candidates = source;
  } else {
    candidates = [source];
  }
  for await (const entry of treeBuilder2((0, import_it_parallel_batch2.default)(dagBuilder2(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}

// node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.js
init_globals();

// node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-multiple.js
init_globals();
var import_err_code26 = __toESM(require_err_code(), 1);
var import_browser_readablestream_to_it3 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_peekable3 = __toESM(require_it_peekable(), 1);
var import_it_map4 = __toESM(require_it_map(), 1);
async function* normaliseCandidateMultiple(input, normaliseContent3) {
  if (typeof input === "string" || input instanceof String || isBytes(input) || isBlob(input) || input._readableState) {
    throw (0, import_err_code26.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it3.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable3.default)(input);
    const { value, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      throw (0, import_err_code26.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
    }
    if (value._readableState) {
      yield* (0, import_it_map4.default)(peekable, (value2) => toFileObject2({ content: value2 }, normaliseContent3));
      return;
    }
    if (isBytes(value)) {
      yield toFileObject2({ content: peekable }, normaliseContent3);
      return;
    }
    if (isFileObject(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value) || isBlob(value)) {
      yield* (0, import_it_map4.default)(peekable, (value2) => toFileObject2(value2, normaliseContent3));
      return;
    }
  }
  if (isFileObject(input)) {
    throw (0, import_err_code26.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code26.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject2(input, normaliseContent3) {
  const { path, mode, mtime, content } = input;
  const file = {
    path: path || "",
    mode: parseMode(mode),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path) {
    file.content = await normaliseContent3(input);
  }
  return file;
}

// node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.js
function normaliseInput3(input) {
  return normaliseCandidateMultiple(input, normaliseContent);
}

// node_modules/ipfs-core/esm/src/components/add-all/utils.js
init_globals();
var parseChunkerString = (chunker) => {
  if (!chunker) {
    return { chunker: "fixed" };
  } else if (chunker.startsWith("size-")) {
    const sizeStr = chunker.split("-")[1];
    const size = parseInt(sizeStr);
    if (isNaN(size)) {
      throw new Error("Chunker parameter size must be an integer");
    }
    return {
      chunker: "fixed",
      maxChunkSize: size
    };
  } else if (chunker.startsWith("rabin")) {
    return {
      chunker: "rabin",
      ...parseRabinString(chunker)
    };
  } else {
    throw new Error(`Unrecognized chunker option: ${chunker}`);
  }
};
var parseRabinString = (chunker) => {
  const options = {};
  const parts = chunker.split("-");
  switch (parts.length) {
    case 1:
      options.avgChunkSize = 262144;
      break;
    case 2:
      options.avgChunkSize = parseChunkSize(parts[1], "avg");
      break;
    case 4:
      options.minChunkSize = parseChunkSize(parts[1], "min");
      options.avgChunkSize = parseChunkSize(parts[2], "avg");
      options.maxChunkSize = parseChunkSize(parts[3], "max");
      break;
    default:
      throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"');
  }
  return options;
};
var parseChunkSize = (str, name10) => {
  const size = parseInt(str);
  if (isNaN(size)) {
    throw new Error(`Chunker parameter ${name10} must be an integer`);
  }
  return size;
};

// node_modules/ipfs-core/esm/src/components/add-all/index.js
var import_it_pipe3 = __toESM(require_it_pipe(), 1);
var mergeOptions3 = merge_options_default.bind({ ignoreUndefined: true });
function createAddAll2({ repo, preload: preload2, hashers, options }) {
  const isShardingEnabled = options && options.sharding;
  async function* addAll(source, options2 = {}) {
    const opts = mergeOptions3({
      shardSplitThreshold: isShardingEnabled ? 1e3 : Infinity,
      strategy: "balanced"
    }, options2, { ...parseChunkerString(options2.chunker) });
    if (opts.hashAlg && opts.hashAlg !== "sha2-256" && opts.cidVersion !== 1) {
      opts.cidVersion = 1;
    }
    if (opts.trickle) {
      opts.strategy = "trickle";
    }
    if (opts.strategy === "trickle") {
      opts.leafType = "raw";
      opts.reduceSingleLeafToSelf = false;
    }
    if (opts.cidVersion > 0 && opts.rawLeaves === void 0) {
      opts.rawLeaves = true;
    }
    if (opts.hashAlg !== void 0 && opts.rawLeaves === void 0) {
      opts.rawLeaves = true;
    }
    delete opts.trickle;
    const totals = {};
    if (opts.progress) {
      const prog = opts.progress;
      opts.progress = (bytes2, path) => {
        if (!totals[path]) {
          totals[path] = 0;
        }
        totals[path] += bytes2;
        prog(totals[path], path);
      };
    }
    let hasher;
    if (opts.hashAlg != null) {
      hasher = await hashers.getHasher(opts.hashAlg);
    }
    const iterator = (0, import_it_pipe3.pipe)(normaliseInput3(source), (source2) => importer(source2, repo.blocks, {
      ...opts,
      hasher,
      pin: false
    }), transformFile(opts), preloadFile(preload2, opts), pinFile(repo, opts));
    const releaseLock = await repo.gcLock.readLock();
    try {
      for await (const added of iterator) {
        delete totals[added.path];
        yield added;
      }
    } finally {
      releaseLock();
    }
  }
  return withTimeoutOption(addAll);
}
function transformFile(opts) {
  async function* transformFile2(source) {
    for await (const file of source) {
      let cid = file.cid;
      if (opts.cidVersion === 1) {
        cid = cid.toV1();
      }
      let path = file.path ? file.path : cid.toString();
      if (opts.wrapWithDirectory && !file.path) {
        path = "";
      }
      yield {
        path,
        cid,
        size: file.size,
        mode: file.unixfs && file.unixfs.mode,
        mtime: file.unixfs && file.unixfs.mtime
      };
    }
  }
  return transformFile2;
}
function preloadFile(preload2, opts) {
  async function* maybePreloadFile(source) {
    for await (const file of source) {
      const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === "" : !file.path.includes("/");
      const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;
      if (shouldPreload) {
        preload2(file.cid);
      }
      yield file;
    }
  }
  return maybePreloadFile;
}
function pinFile(repo, opts) {
  async function* maybePinFile(source) {
    for await (const file of source) {
      const isRootDir = !(file.path && file.path.includes("/"));
      const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;
      if (shouldPin) {
        await repo.pins.pinRecursively(file.cid);
      }
      yield file;
    }
  }
  return maybePinFile;
}

// node_modules/ipfs-core/esm/src/components/cat.js
init_globals();

// node_modules/ipfs-unixfs-exporter/esm/src/index.js
init_globals();
var import_err_code34 = __toESM(require_err_code(), 1);
init_cid();

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/index.js
init_globals();
var import_err_code33 = __toESM(require_err_code(), 1);
init_esm();
init_raw();
init_identity();

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js
init_globals();
var import_err_code29 = __toESM(require_err_code(), 1);

// node_modules/ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js
init_globals();
var import_hamt_sharding2 = __toESM(require_src9(), 1);
var hashFn = async function(buf3) {
  return (await murmur3128.encode(buf3)).slice(0, 8).reverse();
};
var addLinksToHamtBucket = (links3, bucket, rootBucket) => {
  return Promise.all(links3.map((link) => {
    if (link.Name == null) {
      throw new Error("Unexpected Link without a Name");
    }
    if (link.Name.length === 2) {
      const pos = parseInt(link.Name, 16);
      return bucket._putObjectAt(pos, new import_hamt_sharding2.Bucket({
        hash: rootBucket._options.hash,
        bits: rootBucket._options.bits
      }, bucket, pos));
    }
    return rootBucket.put(link.Name.substring(2), true);
  }));
};
var toPrefix = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
var toBucketPath = (position) => {
  let bucket = position.bucket;
  const path = [];
  while (bucket._parent) {
    path.push(bucket);
    bucket = bucket._parent;
  }
  path.push(bucket);
  return path.reverse();
};
var findShardCid = async (node, name10, blockstore, context, options) => {
  if (!context) {
    const rootBucket = (0, import_hamt_sharding2.createHAMT)({ hashFn });
    context = {
      rootBucket,
      hamtDepth: 1,
      lastBucket: rootBucket
    };
  }
  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);
  const position = await context.rootBucket._findNewBucketAndPos(name10);
  let prefix = toPrefix(position.pos);
  const bucketPath = toBucketPath(position);
  if (bucketPath.length > context.hamtDepth) {
    context.lastBucket = bucketPath[context.hamtDepth];
    prefix = toPrefix(context.lastBucket._posAtParent);
  }
  const link = node.Links.find((link2) => {
    if (link2.Name == null) {
      return false;
    }
    const entryPrefix = link2.Name.substring(0, 2);
    const entryName = link2.Name.substring(2);
    if (entryPrefix !== prefix) {
      return false;
    }
    if (entryName && entryName !== name10) {
      return false;
    }
    return true;
  });
  if (!link) {
    return null;
  }
  if (link.Name != null && link.Name.substring(2) === name10) {
    return link.Hash;
  }
  context.hamtDepth++;
  const block = await blockstore.get(link.Hash, options);
  node = decode5(block);
  return findShardCid(node, name10, blockstore, context, options);
};
var find_cid_in_shard_default = findShardCid;

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js
init_globals();

// node_modules/ipfs-unixfs-exporter/esm/src/utils/extract-data-from-block.js
init_globals();
function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
  const blockLength = block.length;
  const blockEnd = blockStart + blockLength;
  if (requestedStart >= blockEnd || requestedEnd < blockStart) {
    return new Uint8Array(0);
  }
  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
    block = block.slice(0, requestedEnd - blockStart);
  }
  if (requestedStart >= blockStart && requestedStart < blockEnd) {
    block = block.slice(requestedStart - blockStart);
  }
  return block;
}
var extract_data_from_block_default = extractDataFromBlock;

// node_modules/ipfs-unixfs-exporter/esm/src/utils/validate-offset-and-length.js
init_globals();
var import_err_code27 = __toESM(require_err_code(), 1);
var validateOffsetAndLength = (size, offset, length5) => {
  if (!offset) {
    offset = 0;
  }
  if (offset < 0) {
    throw (0, import_err_code27.default)(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset > size) {
    throw (0, import_err_code27.default)(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
  }
  if (!length5 && length5 !== 0) {
    length5 = size - offset;
  }
  if (length5 < 0) {
    throw (0, import_err_code27.default)(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (offset + length5 > size) {
    length5 = size - offset;
  }
  return {
    offset,
    length: length5
  };
};
var validate_offset_and_length_default = validateOffsetAndLength;

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js
var import_err_code28 = __toESM(require_err_code(), 1);
init_esm();
init_raw();
async function* emitBytes(blockstore, node, start, end, streamPosition = 0, options) {
  if (node instanceof Uint8Array) {
    const buf3 = extract_data_from_block_default(node, streamPosition, start, end);
    if (buf3.length) {
      yield buf3;
    }
    streamPosition += buf3.length;
    return streamPosition;
  }
  if (node.Data == null) {
    throw (0, import_err_code28.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  let file;
  try {
    file = UnixFS.unmarshal(node.Data);
  } catch (err) {
    throw (0, import_err_code28.default)(err, "ERR_NOT_UNIXFS");
  }
  if (file.data && file.data.length) {
    const buf3 = extract_data_from_block_default(file.data, streamPosition, start, end);
    if (buf3.length) {
      yield buf3;
    }
    streamPosition += file.data.length;
  }
  let childStart = streamPosition;
  for (let i = 0; i < node.Links.length; i++) {
    const childLink = node.Links[i];
    const childEnd = streamPosition + file.blockSizes[i];
    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {
      const block = await blockstore.get(childLink.Hash, { signal: options.signal });
      let child;
      switch (childLink.Hash.code) {
        case code:
          child = await decode5(block);
          break;
        case code6:
          child = block;
          break;
        case code4:
          child = await decode10(block);
          break;
        default:
          throw Error(`Unsupported codec: ${childLink.Hash.code}`);
      }
      for await (const buf3 of emitBytes(blockstore, child, start, end, streamPosition, options)) {
        streamPosition += buf3.length;
        yield buf3;
      }
    }
    streamPosition = childEnd;
    childStart = childEnd + 1;
  }
}
var fileContent = (cid, node, unixfs, path, resolve11, depth, blockstore) => {
  function yieldFileContent(options = {}) {
    const fileSize = unixfs.fileSize();
    if (fileSize === void 0) {
      throw new Error("File was a directory");
    }
    const { offset, length: length5 } = validate_offset_and_length_default(fileSize, options.offset, options.length);
    const start = offset;
    const end = offset + length5;
    return emitBytes(blockstore, node, start, end, 0, options);
  }
  return yieldFileContent;
};
var file_default2 = fileContent;

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/directory.js
init_globals();
var directoryContent = (cid, node, unixfs, path, resolve11, depth, blockstore) => {
  async function* yieldDirectoryContent(options = {}) {
    const offset = options.offset || 0;
    const length5 = options.length || node.Links.length;
    const links3 = node.Links.slice(offset, length5);
    for (const link of links3) {
      const result = await resolve11(link.Hash, link.Name || "", `${path}/${link.Name || ""}`, [], depth + 1, blockstore, options);
      if (result.entry) {
        yield result.entry;
      }
    }
  }
  return yieldDirectoryContent;
};
var directory_default = directoryContent;

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js
init_globals();
var hamtShardedDirectoryContent = (cid, node, unixfs, path, resolve11, depth, blockstore) => {
  function yieldHamtDirectoryContent(options = {}) {
    return listDirectory(node, path, resolve11, depth, blockstore, options);
  }
  return yieldHamtDirectoryContent;
};
async function* listDirectory(node, path, resolve11, depth, blockstore, options) {
  const links3 = node.Links;
  for (const link of links3) {
    const name10 = link.Name != null ? link.Name.substring(2) : null;
    if (name10) {
      const result = await resolve11(link.Hash, name10, `${path}/${name10}`, [], depth + 1, blockstore, options);
      yield result.entry;
    } else {
      const block = await blockstore.get(link.Hash);
      node = decode5(block);
      for await (const file of listDirectory(node, path, resolve11, depth, blockstore, options)) {
        yield file;
      }
    }
  }
}
var hamt_sharded_directory_default = hamtShardedDirectoryContent;

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js
var findLinkCid = (node, name10) => {
  const link = node.Links.find((link2) => link2.Name === name10);
  return link && link.Hash;
};
var contentExporters = {
  raw: file_default2,
  file: file_default2,
  directory: directory_default,
  "hamt-sharded-directory": hamt_sharded_directory_default,
  metadata: (cid, node, unixfs, path, resolve11, depth, blockstore) => {
    return () => [];
  },
  symlink: (cid, node, unixfs, path, resolve11, depth, blockstore) => {
    return () => [];
  }
};
var unixFsResolver = async (cid, name10, path, toResolve, resolve11, depth, blockstore, options) => {
  const block = await blockstore.get(cid, options);
  const node = decode5(block);
  let unixfs;
  let next;
  if (!name10) {
    name10 = cid.toString();
  }
  if (node.Data == null) {
    throw (0, import_err_code29.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  try {
    unixfs = UnixFS.unmarshal(node.Data);
  } catch (err) {
    throw (0, import_err_code29.default)(err, "ERR_NOT_UNIXFS");
  }
  if (!path) {
    path = name10;
  }
  if (toResolve.length) {
    let linkCid;
    if (unixfs && unixfs.type === "hamt-sharded-directory") {
      linkCid = await find_cid_in_shard_default(node, toResolve[0], blockstore);
    } else {
      linkCid = findLinkCid(node, toResolve[0]);
    }
    if (!linkCid) {
      throw (0, import_err_code29.default)(new Error("file does not exist"), "ERR_NOT_FOUND");
    }
    const nextName = toResolve.shift();
    const nextPath = `${path}/${nextName}`;
    next = {
      cid: linkCid,
      toResolve,
      name: nextName || "",
      path: nextPath
    };
  }
  return {
    entry: {
      type: unixfs.isDirectory() ? "directory" : "file",
      name: name10,
      path,
      cid,
      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve11, depth, blockstore),
      unixfs,
      depth,
      node,
      size: unixfs.fileSize()
    },
    next
  };
};
var unixfs_v1_default = unixFsResolver;

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/raw.js
init_globals();
var import_err_code30 = __toESM(require_err_code(), 1);
var rawContent = (node) => {
  async function* contentGenerator(options = {}) {
    const { offset, length: length5 } = validate_offset_and_length_default(node.length, options.offset, options.length);
    yield extract_data_from_block_default(node, 0, offset, offset + length5);
  }
  return contentGenerator;
};
var resolve2 = async (cid, name10, path, toResolve, resolve11, depth, blockstore, options) => {
  if (toResolve.length) {
    throw (0, import_err_code30.default)(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const block = await blockstore.get(cid, options);
  return {
    entry: {
      type: "raw",
      name: name10,
      path,
      cid,
      content: rawContent(block),
      depth,
      size: block.length,
      node: block
    }
  };
};
var raw_default = resolve2;

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/dag-cbor.js
init_globals();
init_cid();
var import_err_code31 = __toESM(require_err_code(), 1);
init_esm();
var resolve3 = async (cid, name10, path, toResolve, resolve11, depth, blockstore, options) => {
  const block = await blockstore.get(cid);
  const object = decode10(block);
  let subObject = object;
  let subPath = path;
  while (toResolve.length) {
    const prop = toResolve[0];
    if (prop in subObject) {
      toResolve.shift();
      subPath = `${subPath}/${prop}`;
      const subObjectCid = CID.asCID(subObject[prop]);
      if (subObjectCid) {
        return {
          entry: {
            type: "object",
            name: name10,
            path,
            cid,
            node: block,
            depth,
            size: block.length,
            content: async function* () {
              yield object;
            }
          },
          next: {
            cid: subObjectCid,
            name: prop,
            path: subPath,
            toResolve
          }
        };
      }
      subObject = subObject[prop];
    } else {
      throw (0, import_err_code31.default)(new Error(`No property named ${prop} found in cbor node ${cid}`), "ERR_NO_PROP");
    }
  }
  return {
    entry: {
      type: "object",
      name: name10,
      path,
      cid,
      node: block,
      depth,
      size: block.length,
      content: async function* () {
        yield object;
      }
    }
  };
};
var dag_cbor_default = resolve3;

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/identity.js
init_globals();
var import_err_code32 = __toESM(require_err_code(), 1);
init_digest();
var rawContent2 = (node) => {
  async function* contentGenerator(options = {}) {
    const { offset, length: length5 } = validate_offset_and_length_default(node.length, options.offset, options.length);
    yield extract_data_from_block_default(node, 0, offset, offset + length5);
  }
  return contentGenerator;
};
var resolve4 = async (cid, name10, path, toResolve, resolve11, depth, blockstore, options) => {
  if (toResolve.length) {
    throw (0, import_err_code32.default)(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const buf3 = await decode3(cid.multihash.bytes);
  return {
    entry: {
      type: "identity",
      name: name10,
      path,
      cid,
      content: rawContent2(buf3.digest),
      depth,
      size: buf3.digest.length,
      node: buf3.digest
    }
  };
};
var identity_default = resolve4;

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/index.js
var resolvers = {
  [code]: unixfs_v1_default,
  [code6]: raw_default,
  [code4]: dag_cbor_default,
  [identity.code]: identity_default
};
function resolve5(cid, name10, path, toResolve, depth, blockstore, options) {
  const resolver = resolvers[cid.code];
  if (!resolver) {
    throw (0, import_err_code33.default)(new Error(`No resolver for code ${cid.code}`), "ERR_NO_RESOLVER");
  }
  return resolver(cid, name10, path, toResolve, resolve5, depth, blockstore, options);
}
var resolvers_default = resolve5;

// node_modules/ipfs-unixfs-exporter/esm/src/index.js
var import_it_last4 = __toESM(require_it_last(), 1);
var toPathComponents2 = (path = "") => {
  return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
};
var cidAndRest = (path) => {
  if (path instanceof Uint8Array) {
    return {
      cid: CID.decode(path),
      toResolve: []
    };
  }
  const cid = CID.asCID(path);
  if (cid) {
    return {
      cid,
      toResolve: []
    };
  }
  if (typeof path === "string") {
    if (path.indexOf("/ipfs/") === 0) {
      path = path.substring(6);
    }
    const output = toPathComponents2(path);
    return {
      cid: CID.parse(output[0]),
      toResolve: output.slice(1)
    };
  }
  throw (0, import_err_code34.default)(new Error(`Unknown path type ${path}`), "ERR_BAD_PATH");
};
async function* walkPath(path, blockstore, options = {}) {
  let { cid, toResolve } = cidAndRest(path);
  let name10 = cid.toString();
  let entryPath = name10;
  const startingDepth = toResolve.length;
  while (true) {
    const result = await resolvers_default(cid, name10, entryPath, toResolve, startingDepth, blockstore, options);
    if (!result.entry && !result.next) {
      throw (0, import_err_code34.default)(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
    }
    if (result.entry) {
      yield result.entry;
    }
    if (!result.next) {
      return;
    }
    toResolve = result.next.toResolve;
    cid = result.next.cid;
    name10 = result.next.name;
    entryPath = result.next.path;
  }
}
async function exporter(path, blockstore, options = {}) {
  const result = await (0, import_it_last4.default)(walkPath(path, blockstore, options));
  if (!result) {
    throw (0, import_err_code34.default)(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
  }
  return result;
}
async function* recursive(path, blockstore, options = {}) {
  const node = await exporter(path, blockstore, options);
  if (!node) {
    return;
  }
  yield node;
  if (node.type === "directory") {
    for await (const child of recurse(node, options)) {
      yield child;
    }
  }
  async function* recurse(node2, options2) {
    for await (const file of node2.content(options2)) {
      yield file;
      if (file instanceof Uint8Array) {
        continue;
      }
      if (file.type === "directory") {
        yield* recurse(file, options2);
      }
    }
  }
}

// node_modules/ipfs-core/esm/src/components/cat.js
init_cid();
function createCat({ repo, preload: preload2 }) {
  async function* cat(ipfsPath2, options = {}) {
    ipfsPath2 = normalizeCidPath(ipfsPath2);
    if (options.preload !== false) {
      const pathComponents = ipfsPath2.split("/");
      preload2(CID.parse(pathComponents[0]));
    }
    const file = await exporter(ipfsPath2, repo.blocks, options);
    if (file.type === "directory") {
      throw new Error("this dag node is a directory");
    }
    if (!file.content) {
      throw new Error("this dag node has no content");
    }
    yield* file.content(options);
  }
  return withTimeoutOption(cat);
}

// node_modules/ipfs-core/esm/src/components/get.js
init_globals();
var import_err_code35 = __toESM(require_err_code(), 1);
init_cid();
var import_it_tar = __toESM(require_it_tar(), 1);
var import_it_pipe4 = __toESM(require_it_pipe(), 1);
var import_pako = __toESM(require_pako(), 1);
var import_it_map5 = __toESM(require_it_map(), 1);
var import_it_to_buffer = __toESM(require_it_to_buffer(), 1);
var DEFAULT_COMPRESSION_LEVEL = 6;
function createGet2({ repo, preload: preload2 }) {
  async function* get6(ipfsPath2, options = {}) {
    if (options.compressionLevel != null && (options.compressionLevel < -1 || options.compressionLevel > 9)) {
      throw (0, import_err_code35.default)(new Error("Compression level must be between -1 and 9"), "ERR_INVALID_PARAMS");
    }
    if (options.preload !== false) {
      let pathComponents;
      try {
        pathComponents = normalizeCidPath(ipfsPath2).split("/");
      } catch (err) {
        throw (0, import_err_code35.default)(err, "ERR_INVALID_PATH");
      }
      preload2(CID.parse(pathComponents[0]));
    }
    const ipfsPathOrCid = CID.asCID(ipfsPath2) || ipfsPath2;
    const file = await exporter(ipfsPathOrCid, repo.blocks, options);
    if (file.type === "file" || file.type === "raw") {
      const args = [];
      if (!options.compress || options.archive === true) {
        args.push([{
          header: {
            name: file.path,
            mode: file.type === "file" && file.unixfs.mode,
            mtime: file.type === "file" && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1e3) : void 0,
            size: file.size,
            type: "file"
          },
          body: file.content()
        }], (0, import_it_tar.pack)(), (source) => (0, import_it_map5.default)(source, (buf3) => buf3.slice()));
      } else {
        args.push(file.content);
      }
      if (options.compress) {
        args.push(async function* (source) {
          const buf3 = await (0, import_it_to_buffer.default)(source);
          yield import_pako.default.gzip(buf3, { level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL });
        });
      }
      yield* (0, import_it_pipe4.pipe)(...args);
      return;
    }
    if (file.type === "directory") {
      const args = [
        recursive(ipfsPathOrCid, repo.blocks, options),
        async function* (source) {
          for await (const entry of source) {
            const output = {
              header: {
                name: entry.path,
                size: entry.size
              }
            };
            if (entry.type === "file") {
              output.header.type = "file";
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
              output.body = entry.content();
            } else if (entry.type === "raw") {
              output.header.type = "file";
              output.body = entry.content();
            } else if (entry.type === "directory") {
              output.header.type = "directory";
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
            } else {
              throw (0, import_err_code35.default)(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
            }
            yield output;
          }
        },
        (0, import_it_tar.pack)(),
        (source) => (0, import_it_map5.default)(source, (buf3) => buf3.slice())
      ];
      if (options.compress) {
        if (!options.archive) {
          throw (0, import_err_code35.default)(new Error("file is not regular"), "ERR_INVALID_PATH");
        }
        if (options.compress) {
          args.push(async function* (source) {
            const buf3 = await (0, import_it_to_buffer.default)(source);
            yield import_pako.default.gzip(buf3, { level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL });
          });
        }
      }
      yield* (0, import_it_pipe4.pipe)(...args);
      return;
    }
    throw (0, import_err_code35.default)(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
  }
  return withTimeoutOption(get6);
}

// node_modules/ipfs-core/esm/src/components/ls.js
init_globals();
var import_err_code36 = __toESM(require_err_code(), 1);
init_cid();
function createLs2({ repo, preload: preload2 }) {
  async function* ls(ipfsPath2, options = {}) {
    const legacyPath = normalizeCidPath(ipfsPath2);
    const pathComponents = legacyPath.split("/");
    if (options.preload !== false) {
      preload2(CID.parse(pathComponents[0]));
    }
    const ipfsPathOrCid = CID.asCID(legacyPath) || legacyPath;
    const file = await exporter(ipfsPathOrCid, repo.blocks, options);
    if (file.type === "file") {
      yield mapFile(file);
      return;
    }
    if (file.type === "directory") {
      for await (const child of file.content()) {
        yield mapFile(child);
      }
      return;
    }
    throw (0, import_err_code36.default)(new Error(`Unknown UnixFS type ${file.type}`), "ERR_UNKNOWN_UNIXFS_TYPE");
  }
  return withTimeoutOption(ls);
}

// node_modules/ipfs-core/esm/src/components/root.js
var RootAPI = class {
  constructor({ preload: preload2, repo, hashers, options }) {
    const addAll = createAddAll2({
      preload: preload2,
      repo,
      options,
      hashers
    });
    this.addAll = addAll;
    this.add = createAdd3({ addAll });
    this.cat = createCat({
      repo,
      preload: preload2
    });
    this.get = createGet2({
      repo,
      preload: preload2
    });
    this.ls = createLs2({
      repo,
      preload: preload2
    });
  }
};

// node_modules/ipfs-core/esm/src/components/version.js
init_globals();

// node_modules/ipfs-core/esm/src/version.js
init_globals();
var ipfsCore = "0.14.3";
var commit = "";
var interfaceIpfsCore = "^0.154.3";

// node_modules/ipfs-core/esm/src/components/version.js
function createVersion({ repo }) {
  async function version4(_options = {}) {
    const repoVersion2 = await repo.version.get();
    return {
      version: ipfsCore,
      commit,
      repo: `${repoVersion2}`,
      "ipfs-core": ipfsCore,
      "interface-ipfs-core": interfaceIpfsCore
    };
  }
  return withTimeoutOption(version4);
}

// node_modules/ipfs-core/esm/src/components/id.js
init_globals();
var import_multiaddr4 = __toESM(require_src(), 1);
init_to_string();
var import_peer_id9 = __toESM(require_src5(), 1);
var import_err_code37 = __toESM(require_err_code(), 1);
var import_debug14 = __toESM(require_browser2(), 1);
var log14 = Object.assign((0, import_debug14.default)("ipfs:components:id"), { error: (0, import_debug14.default)("ipfs:components:id:error") });
function createId({ peerId, network }) {
  async function id(options = {}) {
    const net = network.try();
    if (!net) {
      if (options.peerId) {
        throw new NotStartedError();
      }
      const idStr2 = peerId.toB58String();
      return {
        id: idStr2,
        publicKey: toString3(peerId.pubKey.bytes, "base64pad"),
        addresses: [],
        agentVersion: `js-ipfs/${ipfsCore}`,
        protocolVersion: "9000",
        protocols: []
      };
    }
    const { libp2p } = net;
    const peerIdToId = options.peerId ? import_peer_id9.default.parse(options.peerId) : peerId;
    const peer = await findPeer(peerIdToId, libp2p, options);
    const agentVersion = toString3(peer.metadata.get("AgentVersion") || new Uint8Array());
    const protocolVersion = toString3(peer.metadata.get("ProtocolVersion") || new Uint8Array());
    const idStr = peer.id.toB58String();
    const publicKeyStr = peer.publicKey ? toString3(peer.publicKey.bytes, "base64pad") : "";
    return {
      id: idStr,
      publicKey: publicKeyStr,
      addresses: (peer.addresses || []).map((ma) => {
        const str = ma.toString();
        if (str.endsWith(`/p2p/${idStr}`)) {
          return str;
        }
        return `${str}/p2p/${idStr}`;
      }).sort().map((ma) => new import_multiaddr4.Multiaddr(ma)),
      agentVersion,
      protocolVersion,
      protocols: (peer.protocols || []).sort()
    };
  }
  return withTimeoutOption(id);
}
async function findPeer(peerId, libp2p, options) {
  let peer = await libp2p.peerStore.get(peerId);
  if (!peer) {
    peer = await findPeerOnDht(peerId, libp2p, options);
  }
  let publicKey = peerId.pubKey ? peerId.pubKey : await libp2p.peerStore.keyBook.get(peerId);
  if (!publicKey) {
    try {
      publicKey = await libp2p._dht.getPublicKey(peerId, options);
    } catch (err) {
      log14.error("Could not load public key for", peerId.toB58String(), err);
    }
  }
  return {
    ...peer,
    publicKey,
    metadata: peer.metadata || /* @__PURE__ */ new Map(),
    addresses: peer.addresses.map((addr) => addr.multiaddr)
  };
}
async function findPeerOnDht(peerId, libp2p, options) {
  for await (const event of libp2p._dht.findPeer(peerId, options)) {
    if (event.name === "FINAL_PEER") {
      break;
    }
  }
  const peer = await libp2p.peerStore.get(peerId);
  if (!peer) {
    throw (0, import_err_code37.default)(new Error("Could not find peer"), "ERR_NOT_FOUND");
  }
  return peer;
}

// node_modules/ipfs-core/esm/src/components/config/index.js
init_globals();
var import_debug15 = __toESM(require_browser2(), 1);

// node_modules/ipfs-core/esm/src/components/config/profiles.js
init_globals();
var import_just_safe_set = __toESM(require_just_safe_set(), 1);
var profiles = {
  server: {
    description: "Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",
    transform: (config2) => {
      (0, import_just_safe_set.default)(config2, "Discovery.MDNS.Enabled", false);
      (0, import_just_safe_set.default)(config2, "Discovery.webRTCStar.Enabled", false);
      config2.Swarm = {
        ...config2.Swarm || {},
        DisableNatPortMap: true
      };
      return config2;
    }
  },
  "local-discovery": {
    description: "Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",
    transform: (config2) => {
      (0, import_just_safe_set.default)(config2, "Discovery.MDNS.Enabled", true);
      (0, import_just_safe_set.default)(config2, "Discovery.webRTCStar.Enabled", true);
      (0, import_just_safe_set.default)(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: false
      });
      return config2;
    }
  },
  test: {
    description: "Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      (0, import_just_safe_set.default)(config2, "Addresses.API", defaultConfig.Addresses.API ? "/ip4/127.0.0.1/tcp/0" : "");
      (0, import_just_safe_set.default)(config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway ? "/ip4/127.0.0.1/tcp/0" : "");
      (0, import_just_safe_set.default)(config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm.length ? ["/ip4/127.0.0.1/tcp/0"] : []);
      (0, import_just_safe_set.default)(config2, "Addresses.Delegates", []);
      (0, import_just_safe_set.default)(config2, "Bootstrap", []);
      (0, import_just_safe_set.default)(config2, "Discovery.MDNS.Enabled", false);
      (0, import_just_safe_set.default)(config2, "Discovery.webRTCStar.Enabled", false);
      (0, import_just_safe_set.default)(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: true
      });
      return config2;
    }
  },
  "default-networking": {
    description: "Restores default network settings. Inverse profile of the `test` profile.",
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      (0, import_just_safe_set.default)(config2, "Addresses.API", defaultConfig.Addresses.API);
      (0, import_just_safe_set.default)(config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway);
      (0, import_just_safe_set.default)(config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm);
      (0, import_just_safe_set.default)(config2, "Addresses.Delegates", defaultConfig.Addresses.Delegates);
      (0, import_just_safe_set.default)(config2, "Bootstrap", defaultConfig.Bootstrap);
      (0, import_just_safe_set.default)(config2, "Discovery.MDNS.Enabled", defaultConfig.Discovery.MDNS.Enabled);
      (0, import_just_safe_set.default)(config2, "Discovery.webRTCStar.Enabled", defaultConfig.Discovery.webRTCStar.Enabled);
      (0, import_just_safe_set.default)(config2, "Swarm", {
        ...config2.Swarm || {},
        DisableNatPortMap: false
      });
      return config2;
    }
  },
  lowpower: {
    description: "Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",
    transform: (config2) => {
      const Swarm = config2.Swarm || {};
      const ConnMgr = Swarm.ConnMgr || {};
      ConnMgr.LowWater = 20;
      ConnMgr.HighWater = 40;
      Swarm.ConnMgr = ConnMgr;
      config2.Swarm = Swarm;
      return config2;
    }
  },
  "default-power": {
    description: 'Inverse of "lowpower" profile.',
    transform: (config2) => {
      const defaultConfig = config_browser_default();
      config2.Swarm = defaultConfig.Swarm;
      return config2;
    }
  }
};

// node_modules/ipfs-core/esm/src/components/config/index.js
var log15 = (0, import_debug15.default)("ipfs:core:config");
function createConfig({ repo }) {
  return {
    getAll: withTimeoutOption(getAll),
    get: withTimeoutOption(get6),
    set: withTimeoutOption(set2),
    replace: withTimeoutOption(replace),
    profiles: {
      apply: withTimeoutOption(applyProfile),
      list: withTimeoutOption(listProfiles)
    }
  };
  async function getAll(options = {}) {
    return repo.config.getAll(options);
  }
  async function get6(key, options) {
    if (!key) {
      return Promise.reject(new Error("key argument is required"));
    }
    return repo.config.get(key, options);
  }
  async function set2(key, value, options) {
    return repo.config.set(key, value, options);
  }
  async function replace(value, options) {
    return repo.config.replace(value, options);
  }
  async function applyProfile(profileName, options = { dryRun: false }) {
    const { dryRun } = options;
    const profile = profiles[profileName];
    if (!profile) {
      throw new Error(`No profile with name '${profileName}' exists`);
    }
    try {
      const oldCfg = await repo.config.getAll(options);
      let newCfg = JSON.parse(JSON.stringify(oldCfg));
      newCfg = profile.transform(newCfg);
      if (!dryRun) {
        await repo.config.replace(newCfg, options);
      }
      delete oldCfg.Identity.PrivKey;
      delete newCfg.Identity.PrivKey;
      return {
        original: oldCfg,
        updated: newCfg
      };
    } catch (err) {
      log15(err);
      throw new Error(`Could not apply profile '${profileName}' to config: ${err.message}`);
    }
  }
}
async function listProfiles(_options) {
  return Object.keys(profiles).map((name10) => ({
    name: name10,
    description: profiles[name10].description
  }));
}

// node_modules/ipfs-core/esm/src/components/dag/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/dag/export.js
init_globals();
init_cid();

// node_modules/multiformats/esm/src/block.js
init_globals();
init_src();
var readonly2 = ({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
});
var links2 = function* (source, base4) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base4,
      key
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          const cid = CID.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* links2(element, elementPath);
          }
        }
      } else {
        const cid = CID.asCID(value);
        if (cid) {
          yield [
            path.join("/"),
            cid
          ];
        } else {
          yield* links2(value, path);
        }
      }
    }
  }
};
var tree = function* (source, base4) {
  if (source == null)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base4,
      key
    ];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID.asCID(element)) {
            yield* tree(element, elementPath);
          }
        }
      } else {
        yield* tree(value, path);
      }
    }
  }
};
var get2 = (source, path) => {
  let node = source;
  for (const [index, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid) {
      return {
        value: cid,
        remaining: path.slice(index + 1).join("/")
      };
    }
  }
  return { value: node };
};
var Block = class {
  constructor({ cid, bytes: bytes2, value }) {
    if (!cid || !bytes2 || typeof value === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid;
    this.bytes = bytes2;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly2(),
      bytes: readonly2(),
      value: readonly2(),
      asBlock: readonly2()
    });
  }
  links() {
    return links2(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path = "/") {
    return get2(this.value, path.split("/").filter(Boolean));
  }
};
var createUnsafe = ({
  bytes: bytes2,
  cid,
  value: maybeValue,
  codec
}) => {
  const value = maybeValue !== void 0 ? maybeValue : codec && codec.decode(bytes2);
  if (value === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new Block({
    cid,
    bytes: bytes2,
    value
  });
};

// node_modules/@ipld/car/esm/lib/writer-browser.js
init_globals();
init_cid();

// node_modules/@ipld/car/esm/lib/encoder.js
init_globals();
var import_varint2 = __toESM(require_varint(), 1);

// node_modules/@ipld/car/node_modules/@ipld/dag-cbor/esm/index.js
init_globals();
init_cborg();
init_cid();
var CID_CBOR_TAG3 = 42;
function cidEncoder4(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG3),
    new Token(Type.bytes, bytes2)
  ];
}
function undefinedEncoder4() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder4(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions4 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder4,
    undefined: undefinedEncoder4,
    number: numberEncoder4
  }
};
function cidDecoder3(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
var decodeOptions4 = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions4.tags[CID_CBOR_TAG3] = cidDecoder3;
var encode12 = (node) => encode4(node, encodeOptions4);
var decode13 = (data) => decode6(data, decodeOptions4);

// node_modules/@ipld/car/esm/lib/encoder.js
function createHeader(roots) {
  const headerBytes = encode12({
    version: 1,
    roots
  });
  const varintBytes = import_varint2.default.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer) {
  return {
    async setRoots(roots) {
      const bytes2 = createHeader(roots);
      await writer.write(bytes2);
    },
    async writeBlock(block) {
      const { cid, bytes: bytes2 } = block;
      await writer.write(new Uint8Array(import_varint2.default.encode(cid.bytes.length + bytes2.length)));
      await writer.write(cid.bytes);
      if (bytes2.length) {
        await writer.write(bytes2);
      }
    },
    async close() {
      await writer.end();
    }
  };
}

// node_modules/@ipld/car/esm/lib/iterator-channel.js
init_globals();
function noop() {
}
function create4() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve11) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop;
          resolve11();
        };
      });
    }
    return drainer;
  };
  const writer = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      await drainer2;
    }
  };
  const iterator = {
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return {
          done: false,
          value: chunk
        };
      }
      if (ended) {
        drainerResolver();
        return {
          done: true,
          value: void 0
        };
      }
      if (!outWait) {
        outWait = new Promise((resolve11) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop;
            return resolve11(iterator.next());
          };
        });
      }
      return outWait;
    }
  };
  return {
    writer,
    iterator
  };
}

// node_modules/@ipld/car/esm/lib/decoder.js
init_globals();
var import_varint3 = __toESM(require_varint(), 1);
init_cid();
init_digest();

// node_modules/@ipld/car/esm/lib/header-validator.js
init_globals();
var Kinds = {
  Null: (obj) => obj === null,
  Int: (obj) => Number.isInteger(obj),
  Float: (obj) => typeof obj === "number" && Number.isFinite(obj),
  String: (obj) => typeof obj === "string",
  Bool: (obj) => typeof obj === "boolean",
  Bytes: (obj) => obj instanceof Uint8Array,
  Link: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID === obj,
  List: (obj) => Array.isArray(obj),
  Map: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID !== obj && !Kinds.List(obj) && !Kinds.Bytes(obj)
};
var Types = {
  Int: Kinds.Int,
  "CarHeader > version": (obj) => Types.Int(obj),
  "CarHeader > roots (anon) > valueType (anon)": Kinds.Link,
  "CarHeader > roots (anon)": (obj) => Kinds.List(obj) && Array.prototype.every.call(obj, Types["CarHeader > roots (anon) > valueType (anon)"]),
  "CarHeader > roots": (obj) => Types["CarHeader > roots (anon)"](obj),
  CarHeader: (obj) => {
    const keys2 = obj && Object.keys(obj);
    return Kinds.Map(obj) && ["version"].every((k) => keys2.includes(k)) && Object.entries(obj).every(([name10, value]) => Types["CarHeader > " + name10] && Types["CarHeader > " + name10](value));
  }
};
var CarHeader = Types.CarHeader;

// node_modules/@ipld/car/esm/lib/decoder.js
var CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
var V2_HEADER_LENGTH = 16 + 8 + 8 + 8;
async function readVarint(reader) {
  const bytes2 = await reader.upTo(8);
  if (!bytes2.length) {
    throw new Error("Unexpected end of data");
  }
  const i = import_varint3.default.decode(bytes2);
  reader.seek(import_varint3.default.decode.bytes);
  return i;
}
async function readV2Header(reader) {
  const bytes2 = await reader.exactly(V2_HEADER_LENGTH);
  const dv = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  let offset = 0;
  const header = {
    version: 2,
    characteristics: [
      dv.getBigUint64(offset, true),
      dv.getBigUint64(offset += 8, true)
    ],
    dataOffset: Number(dv.getBigUint64(offset += 8, true)),
    dataSize: Number(dv.getBigUint64(offset += 8, true)),
    indexOffset: Number(dv.getBigUint64(offset += 8, true))
  };
  reader.seek(V2_HEADER_LENGTH);
  return header;
}
async function readHeader(reader, strictVersion) {
  const length5 = await readVarint(reader);
  if (length5 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader.exactly(length5);
  reader.seek(length5);
  const block = decode13(header);
  if (!CarHeader(block)) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  const hasRoots = Array.isArray(block.roots);
  if (block.version === 1 && !hasRoots || block.version === 2 && hasRoots) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version === 1) {
    return block;
  }
  const v2Header = await readV2Header(reader);
  reader.seek(v2Header.dataOffset - reader.pos);
  const v1Header = await readHeader(reader, 1);
  return Object.assign(v1Header, v2Header);
}
async function readMultihash(reader) {
  const bytes2 = await reader.upTo(8);
  import_varint3.default.decode(bytes2);
  const codeLength = import_varint3.default.decode.bytes;
  const length5 = import_varint3.default.decode(bytes2.subarray(import_varint3.default.decode.bytes));
  const lengthLength = import_varint3.default.decode.bytes;
  const mhLength = codeLength + lengthLength + length5;
  const multihash = await reader.exactly(mhLength);
  reader.seek(mhLength);
  return multihash;
}
async function readCid(reader) {
  const first4 = await reader.exactly(2);
  if (first4[0] === CIDV0_BYTES.SHA2_256 && first4[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = await reader.exactly(34);
    reader.seek(34);
    const multihash2 = decode3(bytes3);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version4 = await readVarint(reader);
  if (version4 !== 1) {
    throw new Error(`Unexpected CID version (${version4})`);
  }
  const codec = await readVarint(reader);
  const bytes2 = await readMultihash(reader);
  const multihash = decode3(bytes2);
  return CID.create(version4, codec, multihash);
}
async function readBlockHead(reader) {
  const start = reader.pos;
  let length5 = await readVarint(reader);
  if (length5 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length5 += reader.pos - start;
  const cid = await readCid(reader);
  const blockLength = length5 - Number(reader.pos - start);
  return {
    cid,
    length: length5,
    blockLength
  };
}
async function readBlock(reader) {
  const { cid, blockLength } = await readBlockHead(reader);
  const bytes2 = await reader.exactly(blockLength);
  reader.seek(blockLength);
  return {
    bytes: bytes2,
    cid
  };
}
async function readBlockIndex(reader) {
  const offset = reader.pos;
  const { cid, length: length5, blockLength } = await readBlockHead(reader);
  const index = {
    cid,
    length: length5,
    blockLength,
    offset,
    blockOffset: reader.pos
  };
  reader.seek(index.blockLength);
  return index;
}
function createDecoder(reader) {
  const headerPromise = (async () => {
    const header = await readHeader(reader);
    if (header.version === 2) {
      const v1length = reader.pos - header.dataOffset;
      reader = limitReader(reader, header.dataSize - v1length);
    }
    return header;
  })();
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlock(reader);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlockIndex(reader);
      }
    }
  };
}
function bytesReader(bytes2) {
  let pos = 0;
  return {
    async upTo(length5) {
      return bytes2.subarray(pos, pos + Math.min(length5, bytes2.length - pos));
    },
    async exactly(length5) {
      if (length5 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes2.subarray(pos, pos + length5);
    },
    seek(length5) {
      pos += length5;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read3 = async (length5) => {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length5) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset = 0;
  };
  return {
    async upTo(length5) {
      if (currentChunk.length - offset < length5) {
        await read3(length5);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length5));
    },
    async exactly(length5) {
      if (currentChunk.length - offset < length5) {
        await read3(length5);
      }
      if (currentChunk.length - offset < length5) {
        throw new Error("Unexpected end of data");
      }
      return currentChunk.subarray(offset, offset + length5);
    },
    seek(length5) {
      pos += length5;
      offset += length5;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
function limitReader(reader, byteLimit) {
  let bytesRead = 0;
  return {
    async upTo(length5) {
      let bytes2 = await reader.upTo(length5);
      if (bytes2.length + bytesRead > byteLimit) {
        bytes2 = bytes2.subarray(0, byteLimit - bytesRead);
      }
      return bytes2;
    },
    async exactly(length5) {
      const bytes2 = await reader.exactly(length5);
      if (bytes2.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      return bytes2;
    },
    seek(length5) {
      bytesRead += length5;
      reader.seek(length5);
    },
    get pos() {
      return reader.pos;
    }
  };
}

// node_modules/@ipld/car/esm/lib/writer-browser.js
var CarWriter = class {
  constructor(roots, encoder) {
    this._encoder = encoder;
    this._mutex = encoder.setRoots(roots);
    this._ended = false;
  }
  async put(block) {
    if (!(block.bytes instanceof Uint8Array) || !block.cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    if (this._ended) {
      throw new Error("Already closed");
    }
    const cid = CID.asCID(block.cid);
    if (!cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    this._mutex = this._mutex.then(() => this._encoder.writeBlock({
      cid,
      bytes: block.bytes
    }));
    return this._mutex;
  }
  async close() {
    if (this._ended) {
      throw new Error("Already closed");
    }
    await this._mutex;
    this._ended = true;
    return this._encoder.close();
  }
  static create(roots) {
    roots = toRoots(roots);
    const { encoder, iterator } = encodeWriter();
    const writer = new CarWriter(roots, encoder);
    const out = new CarWriterOut(iterator);
    return {
      writer,
      out
    };
  }
  static createAppender() {
    const { encoder, iterator } = encodeWriter();
    encoder.setRoots = () => Promise.resolve();
    const writer = new CarWriter([], encoder);
    const out = new CarWriterOut(iterator);
    return {
      writer,
      out
    };
  }
  static async updateRootsInBytes(bytes2, roots) {
    const reader = bytesReader(bytes2);
    await readHeader(reader);
    const newHeader = createHeader(roots);
    if (Number(reader.pos) !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    bytes2.set(newHeader, 0);
    return bytes2;
  }
};
var CarWriterOut = class {
  constructor(iterator) {
    this._iterator = iterator;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
};
function encodeWriter() {
  const iw = create4();
  const { writer, iterator } = iw;
  const encoder = createEncoder(writer);
  return {
    encoder,
    iterator
  };
}
function toRoots(roots) {
  if (roots === void 0) {
    return [];
  }
  if (!Array.isArray(roots)) {
    const cid = CID.asCID(roots);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root of roots) {
    const _root = CID.asCID(root);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}

// node_modules/ipfs-core/esm/src/components/dag/export.js
var import_debug16 = __toESM(require_browser2(), 1);
init_raw();
init_json();

// node_modules/multiformats/esm/src/traversal.js
init_globals();
init_base58();
var walk = async ({ cid, load, seen }) => {
  seen = seen || /* @__PURE__ */ new Set();
  const b58Cid = cid.toString(base58btc);
  if (seen.has(b58Cid)) {
    return;
  }
  const block = await load(cid);
  seen.add(b58Cid);
  if (block === null) {
    return;
  }
  for (const [, cid2] of block.links()) {
    await walk({
      cid: cid2,
      load,
      seen
    });
  }
};

// node_modules/ipfs-core/esm/src/components/dag/export.js
var log16 = (0, import_debug16.default)("ipfs:components:dag:import");
var NO_LINKS_CODECS = [
  code6,
  code7
];
function createExport({ repo, preload: preload2, codecs: codecs2 }) {
  async function* dagExport(root, options = {}) {
    if (options.preload !== false) {
      preload2(root);
    }
    const cid = CID.asCID(root);
    if (!cid) {
      throw new Error(`Unexpected error converting CID type: ${root}`);
    }
    log16(`Exporting ${cid} as car`);
    const { writer, out } = await CarWriter.create([cid]);
    let err = null;
    (async () => {
      try {
        const load = makeLoader(repo, writer, {
          signal: options.signal,
          timeout: options.timeout
        }, codecs2);
        await walk({
          cid,
          load
        });
      } catch (e) {
        err = e;
      } finally {
        writer.close();
      }
    })();
    for await (const chunk of out) {
      if (err) {
        break;
      }
      yield chunk;
    }
    if (err) {
      throw err;
    }
  }
  return withTimeoutOption(dagExport);
}
function makeLoader(repo, writer, options, codecs2) {
  return async (cid) => {
    const codec = await codecs2.getCodec(cid.code);
    if (!codec) {
      throw new Error(`Can't decode links in block with codec 0x${cid.code.toString(16)} to form complete DAG`);
    }
    const bytes2 = await repo.blocks.get(cid, options);
    log16(`Adding block ${cid} to car`);
    await writer.put({
      cid,
      bytes: bytes2
    });
    if (NO_LINKS_CODECS.includes(cid.code)) {
      return null;
    }
    return createUnsafe({
      bytes: bytes2,
      cid,
      codec
    });
  };
}

// node_modules/ipfs-core/esm/src/components/dag/get.js
init_globals();
var import_it_first = __toESM(require_it_first(), 1);
var import_it_last5 = __toESM(require_it_last(), 1);
var import_err_code38 = __toESM(require_err_code(), 1);
function createGet3({ codecs: codecs2, repo, preload: preload2 }) {
  const get6 = async function get7(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    if (options.path) {
      const entry = options.localResolve ? await (0, import_it_first.default)(resolve(cid, options.path, codecs2, repo, options)) : await (0, import_it_last5.default)(resolve(cid, options.path, codecs2, repo, options));
      const result = entry;
      if (!result) {
        throw (0, import_err_code38.default)(new Error("Not found"), "ERR_NOT_FOUND");
      }
      return result;
    }
    const codec = await codecs2.getCodec(cid.code);
    const block = await repo.blocks.get(cid, options);
    const node = codec.decode(block);
    return {
      value: node,
      remainderPath: ""
    };
  };
  return withTimeoutOption(get6);
}

// node_modules/ipfs-core/esm/src/components/dag/import.js
init_globals();

// node_modules/@ipld/car/esm/lib/iterator.js
init_globals();
var CarIteratorBase = class {
  constructor(version4, roots, iterable) {
    this._version = version4;
    this._roots = roots;
    this._iterable = iterable;
    this._decoded = false;
  }
  get version() {
    return this._version;
  }
  async getRoots() {
    return this._roots;
  }
};
var CarBlockIterator = class extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    return this._iterable[Symbol.asyncIterator]();
  }
  static async fromBytes(bytes2) {
    const { version: version4, roots, iterator } = await fromBytes(bytes2);
    return new CarBlockIterator(version4, roots, iterator);
  }
  static async fromIterable(asyncIterable) {
    const { version: version4, roots, iterator } = await fromIterable(asyncIterable);
    return new CarBlockIterator(version4, roots, iterator);
  }
};
var CarCIDIterator = class extends CarIteratorBase {
  [Symbol.asyncIterator]() {
    if (this._decoded) {
      throw new Error("Cannot decode more than once");
    }
    if (!this._iterable) {
      throw new Error("Block iterable not found");
    }
    this._decoded = true;
    const iterable = this._iterable[Symbol.asyncIterator]();
    return {
      async next() {
        const next = await iterable.next();
        if (next.done) {
          return next;
        }
        return {
          done: false,
          value: next.value.cid
        };
      }
    };
  }
  static async fromBytes(bytes2) {
    const { version: version4, roots, iterator } = await fromBytes(bytes2);
    return new CarCIDIterator(version4, roots, iterator);
  }
  static async fromIterable(asyncIterable) {
    const { version: version4, roots, iterator } = await fromIterable(asyncIterable);
    return new CarCIDIterator(version4, roots, iterator);
  }
};
async function fromBytes(bytes2) {
  if (!(bytes2 instanceof Uint8Array)) {
    throw new TypeError("fromBytes() requires a Uint8Array");
  }
  return decodeIterator(bytesReader(bytes2));
}
async function fromIterable(asyncIterable) {
  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
    throw new TypeError("fromIterable() requires an async iterable");
  }
  return decodeIterator(asyncIterableReader(asyncIterable));
}
async function decodeIterator(reader) {
  const decoder = createDecoder(reader);
  const { version: version4, roots } = await decoder.header();
  return {
    version: version4,
    roots,
    iterator: decoder.blocks()
  };
}

// node_modules/ipfs-core/esm/src/components/dag/import.js
var import_it_peekable4 = __toESM(require_it_peekable(), 1);
var import_it_drain5 = __toESM(require_it_drain(), 1);
var import_it_map6 = __toESM(require_it_map(), 1);
var import_debug17 = __toESM(require_browser2(), 1);
var log17 = (0, import_debug17.default)("ipfs:components:dag:import");
function createImport({ repo }) {
  async function* dagImport(sources, options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      const abortOptions = {
        signal: options.signal,
        timeout: options.timeout
      };
      const peekable = (0, import_it_peekable4.default)(sources);
      const { value, done } = await peekable.peek();
      if (done) {
        return;
      }
      if (value) {
        peekable.push(value);
      }
      let cars;
      if (value instanceof Uint8Array) {
        cars = [peekable];
      } else {
        cars = peekable;
      }
      for await (const car of cars) {
        const roots = await importCar(repo, abortOptions, car);
        if (options.pinRoots !== false) {
          for (const cid of roots) {
            let pinErrorMsg = "";
            try {
              if (await repo.blocks.has(cid)) {
                log17(`Pinning root ${cid}`);
                await repo.pins.pinRecursively(cid);
              } else {
                pinErrorMsg = "blockstore: block not found";
              }
            } catch (err) {
              pinErrorMsg = err.message;
            }
            yield {
              root: {
                cid,
                pinErrorMsg
              }
            };
          }
        }
      }
    } finally {
      release();
    }
  }
  return withTimeoutOption(dagImport);
}
async function importCar(repo, options, source) {
  const reader = await CarBlockIterator.fromIterable(source);
  const roots = await reader.getRoots();
  await (0, import_it_drain5.default)(repo.blocks.putMany((0, import_it_map6.default)(reader, ({
    cid: key,
    bytes: value
  }) => {
    log17(`Import block ${key}`);
    return {
      key,
      value
    };
  }), { signal: options.signal }));
  return roots;
}

// node_modules/ipfs-core/esm/src/components/dag/put.js
init_globals();
init_cid();
function createPut2({ repo, codecs: codecs2, hashers, preload: preload2 }) {
  async function put(dagNode, options = {}) {
    const release = options.pin ? await repo.gcLock.readLock() : null;
    try {
      const storeCodec = await codecs2.getCodec(options.storeCodec || "dag-cbor");
      if (!storeCodec) {
        throw new Error(`Unknown storeCodec ${options.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);
      }
      if (options.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        const inputCodec = await codecs2.getCodec(options.inputCodec);
        if (!inputCodec) {
          throw new Error(`Unknown inputCodec ${options.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);
        }
        dagNode = inputCodec.decode(dagNode);
      }
      const cidVersion = options.version != null ? options.version : 1;
      const hasher = await hashers.getHasher(options.hashAlg || "sha2-256");
      if (!hasher) {
        throw new Error(`Unknown hash algorithm ${options.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);
      }
      const buf3 = storeCodec.encode(dagNode);
      const hash2 = await hasher.digest(buf3);
      const cid = CID.create(cidVersion, storeCodec.code, hash2);
      await repo.blocks.put(cid, buf3, { signal: options.signal });
      if (options.pin) {
        await repo.pins.pinRecursively(cid);
      }
      if (options.preload !== false) {
        preload2(cid);
      }
      return cid;
    } finally {
      if (release) {
        release();
      }
    }
  }
  return withTimeoutOption(put);
}

// node_modules/ipfs-core/esm/src/components/dag/resolve.js
init_globals();
function createResolve3({ repo, codecs: codecs2, preload: preload2 }) {
  async function dagResolve(ipfsPath2, options = {}) {
    const { cid } = toCidAndPath(ipfsPath2);
    if (options.preload !== false) {
      preload2(cid);
    }
    return resolvePath(repo, codecs2, ipfsPath2, options);
  }
  return withTimeoutOption(dagResolve);
}

// node_modules/ipfs-core/esm/src/components/dag/index.js
var DagAPI = class {
  constructor({ repo, codecs: codecs2, hashers, preload: preload2 }) {
    this.export = createExport({
      repo,
      preload: preload2,
      codecs: codecs2
    });
    this.get = createGet3({
      codecs: codecs2,
      repo,
      preload: preload2
    });
    this.import = createImport({ repo });
    this.resolve = createResolve3({
      repo,
      codecs: codecs2,
      preload: preload2
    });
    this.put = createPut2({
      repo,
      codecs: codecs2,
      hashers,
      preload: preload2
    });
  }
};

// node_modules/ipfs-core/esm/src/preload.js
init_globals();
var import_multiaddr_to_uri = __toESM(require_multiaddr_to_uri(), 1);
var import_debug19 = __toESM(require_browser2(), 1);
var import_array_shuffle = __toESM(require_array_shuffle(), 1);

// node_modules/ipfs-core-config/esm/src/preload.browser.js
init_globals();
var import_http2 = __toESM(require_http(), 1);
var import_debug18 = __toESM(require_browser2(), 1);
var import_p_queue2 = __toESM(require_dist(), 1);
var log18 = Object.assign((0, import_debug18.default)("ipfs:preload"), { error: (0, import_debug18.default)("ipfs:preload:error") });
var Queue2 = import_p_queue2.default.default ? import_p_queue2.default.default : import_p_queue2.default;
var httpQueue2 = new Queue2({ concurrency: 4 });
function preload(url, options = {}) {
  log18(url);
  return httpQueue2.add(async () => {
    const res = await import_http2.default.post(url, { signal: options.signal });
    const reader = res.body.getReader();
    try {
      while (true) {
        const { done } = await reader.read();
        if (done)
          return;
      }
    } finally {
      reader.releaseLock();
    }
  });
}

// node_modules/ipfs-core/esm/src/preload.js
var import_hashlru3 = __toESM(require_hashlru(), 1);
var log19 = Object.assign((0, import_debug19.default)("ipfs:preload"), { error: (0, import_debug19.default)("ipfs:preload:error") });
function createPreloader(options = {}) {
  options.enabled = Boolean(options.enabled);
  options.addresses = options.addresses || [];
  options.cache = options.cache || 1e3;
  if (!options.enabled || !options.addresses.length) {
    log19("preload disabled");
    const api2 = () => {
    };
    return Object.assign(api2, {
      start: () => {
      },
      stop: () => {
      }
    });
  }
  let stopped = true;
  let requests = [];
  const apiUris = options.addresses.map(import_multiaddr_to_uri.default);
  const cache2 = (0, import_hashlru3.default)(options.cache);
  const api = async (cid) => {
    try {
      if (stopped) {
        throw new Error(`preload ${cid} but preloader is not started`);
      }
      const path = cid.toString();
      if (cache2.has(path)) {
        return;
      }
      cache2.set(path, true);
      const fallbackApiUris = (0, import_array_shuffle.default)(apiUris);
      let success = false;
      const now = Date.now();
      for (const uri of fallbackApiUris) {
        if (stopped)
          throw new Error(`preload aborted for ${path}`);
        let controller;
        try {
          controller = new AbortController();
          requests = requests.concat(controller);
          await preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path)}`, { signal: controller.signal });
          success = true;
        } catch (err) {
          if (err.type !== "aborted")
            log19.error(err);
        } finally {
          requests = requests.filter((r) => r !== controller);
        }
        if (success)
          break;
      }
      log19(`${success ? "" : "un"}successfully preloaded ${path} in ${Date.now() - now}ms`);
    } catch (err) {
      log19.error(err);
    }
  };
  api.start = () => {
    stopped = false;
  };
  api.stop = () => {
    stopped = true;
    log19(`aborting ${requests.length} pending preload request(s)`);
    requests.forEach((r) => r.abort());
    requests = [];
  };
  return api;
}

// node_modules/ipfs-core/esm/src/mfs-preload.js
init_globals();
var import_debug20 = __toESM(require_browser2(), 1);
var log20 = Object.assign((0, import_debug20.default)("ipfs:mfs-preload"), { error: (0, import_debug20.default)("ipfs:mfs-preload:error") });
function createMfsPreloader({ preload: preload2, files, options = {} }) {
  options.interval = options.interval || 30 * 1e3;
  if (!options.enabled) {
    log20("MFS preload disabled");
    const noop2 = async () => {
    };
    return {
      start: noop2,
      stop: noop2
    };
  }
  let rootCid = "";
  let timeoutId;
  const preloadMfs = async () => {
    try {
      const stats = await files.stat("/");
      const nextRootCid = stats.cid.toString();
      if (rootCid !== nextRootCid) {
        log20(`preloading updated MFS root ${rootCid} -> ${stats.cid}`);
        await preload2(stats.cid);
        rootCid = nextRootCid;
      }
    } catch (err) {
      log20.error("failed to preload MFS root", err);
    } finally {
      timeoutId = setTimeout(preloadMfs, options.interval);
    }
  };
  return {
    async start() {
      const stats = await files.stat("/");
      rootCid = stats.cid.toString();
      log20(`monitoring MFS root ${stats.cid}`);
      timeoutId = setTimeout(preloadMfs, options.interval);
    },
    stop() {
      clearTimeout(timeoutId);
    }
  };
}

// node_modules/ipfs-core/esm/src/components/files/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/files/utils/create-lock.js
init_globals();
var import_mortice = __toESM(require_lib6(), 1);
var lock;
function createLock(repoOwner = false) {
  if (lock) {
    return lock;
  }
  const mutex = (0, import_mortice.default)({ singleProcess: repoOwner });
  lock = {
    readLock: (func) => {
      return async (...args) => {
        const releaseLock = await mutex.readLock();
        try {
          return await func.apply(null, args);
        } finally {
          releaseLock();
        }
      };
    },
    writeLock: (func) => {
      return async (...args) => {
        const releaseLock = await mutex.writeLock();
        try {
          return await func.apply(null, args);
        } finally {
          releaseLock();
        }
      };
    }
  };
  return lock;
}

// node_modules/ipfs-core/esm/src/components/files/index.js
var import_is_ipfs4 = __toESM(require_src3(), 1);

// node_modules/ipfs-core/esm/src/components/files/stat.js
init_globals();

// node_modules/ipfs-core/esm/src/components/files/utils/to-mfs-path.js
init_globals();

// node_modules/ipfs-core/esm/src/components/files/utils/with-mfs-root.js
init_globals();
init_cid();
init_sha2_browser();
var import_debug21 = __toESM(require_browser2(), 1);
var import_err_code39 = __toESM(require_err_code(), 1);
var log21 = (0, import_debug21.default)("ipfs:mfs:utils:with-mfs-root");
async function loadMfsRoot(context, options) {
  if (options && options.signal && options.signal.aborted) {
    throw (0, import_err_code39.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
  }
  await context.repo.datastore.open();
  let cid;
  try {
    const buf3 = await context.repo.datastore.get(MFS_ROOT_KEY);
    cid = CID.decode(buf3);
  } catch (err) {
    if (err.code !== "ERR_NOT_FOUND") {
      throw err;
    }
    log21("Creating new MFS root");
    const buf3 = encode3({
      Data: new UnixFS({ type: "directory" }).marshal(),
      Links: []
    });
    const hash2 = await sha256.digest(buf3);
    cid = CID.createV0(hash2);
    await context.repo.blocks.put(cid, buf3);
    if (options && options.signal && options.signal.aborted) {
      throw (0, import_err_code39.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
    }
    await context.repo.datastore.put(MFS_ROOT_KEY, cid.bytes);
  }
  log21(`Loaded MFS root /ipfs/${cid}`);
  return cid;
}

// node_modules/ipfs-core/esm/src/components/files/utils/to-path-components.js
init_globals();
function toPathComponents3(path = "") {
  return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
}

// node_modules/ipfs-core/esm/src/components/files/utils/to-mfs-path.js
var import_err_code40 = __toESM(require_err_code(), 1);
init_cid();
var IPFS_PREFIX2 = "ipfs";
var toMfsPath = async (context, path, options) => {
  const root = await loadMfsRoot(context, options);
  let output = { entryType: "file" };
  let ipfsPath2 = "";
  if (CID.asCID(path)) {
    ipfsPath2 = `/ipfs/${path}`;
  } else {
    ipfsPath2 = path.toString();
  }
  ipfsPath2 = ipfsPath2.trim();
  ipfsPath2 = ipfsPath2.replace(/(\/\/+)/g, "/");
  if (ipfsPath2.endsWith("/") && ipfsPath2.length > 1) {
    ipfsPath2 = ipfsPath2.substring(0, ipfsPath2.length - 1);
  }
  if (!ipfsPath2) {
    throw (0, import_err_code40.default)(new Error("paths must not be empty"), "ERR_NO_PATH");
  }
  if (ipfsPath2.substring(0, 1) !== "/") {
    throw (0, import_err_code40.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
  }
  if (ipfsPath2.substring(ipfsPath2.length - 1) === "/") {
    ipfsPath2 = ipfsPath2.substring(0, ipfsPath2.length - 1);
  }
  const pathComponents = toPathComponents3(ipfsPath2);
  if (pathComponents[0] === IPFS_PREFIX2) {
    let mfsDirectory;
    if (pathComponents.length === 2) {
      mfsDirectory = `/${pathComponents.join("/")}`;
    } else {
      mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
    }
    output = {
      type: "ipfs",
      depth: pathComponents.length - 2,
      entryType: "file",
      mfsPath: `/${pathComponents.join("/")}`,
      mfsDirectory,
      parts: pathComponents,
      path: `/${pathComponents.join("/")}`,
      name: pathComponents[pathComponents.length - 1]
    };
  } else {
    const mfsPath = `/${IPFS_PREFIX2}/${root}${pathComponents.length ? "/" + pathComponents.join("/") : ""}`;
    const mfsDirectory = `/${IPFS_PREFIX2}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
    output = {
      type: "mfs",
      depth: pathComponents.length,
      entryType: "file",
      mfsDirectory,
      mfsPath,
      parts: pathComponents,
      path: `/${pathComponents.join("/")}`,
      name: pathComponents[pathComponents.length - 1]
    };
  }
  const cidPath = output.type === "mfs" ? output.mfsPath : output.path;
  try {
    const res = await exporter(cidPath, context.repo.blocks, options);
    output.cid = res.cid;
    output.mfsPath = `/ipfs/${res.path}`;
    output.entryType = res.type;
    output.content = res.content;
    if ((output.entryType === "file" || output.entryType === "directory") && (res.type === "file" || res.type === "directory")) {
      output.unixfs = res.unixfs;
    }
  } catch (err) {
    if (err.code !== "ERR_NOT_FOUND") {
      throw err;
    }
  }
  output.exists = Boolean(output.cid);
  return output;
};

// node_modules/ipfs-core/esm/src/components/files/stat.js
var import_debug22 = __toESM(require_browser2(), 1);
var import_err_code41 = __toESM(require_err_code(), 1);
var mergeOptions4 = merge_options_default.bind({ ignoreUndefined: true });
var log22 = (0, import_debug22.default)("ipfs:mfs:stat");
var defaultOptions2 = { withLocal: false };
function createStat3(context) {
  async function mfsStat(path, options = {}) {
    options = mergeOptions4(defaultOptions2, options);
    log22(`Fetching stats for ${path}`);
    const { type, cid, mfsPath } = await toMfsPath(context, path, options);
    const exportPath = type === "ipfs" && cid ? cid : mfsPath;
    let file;
    try {
      file = await exporter(exportPath, context.repo.blocks);
    } catch (err) {
      if (err.code === "ERR_NOT_FOUND") {
        throw (0, import_err_code41.default)(new Error(`${path} does not exist`), "ERR_NOT_FOUND");
      }
      throw err;
    }
    if (!statters[file.type]) {
      throw new Error(`Cannot stat codec ${file.cid.code}`);
    }
    return statters[file.type](file);
  }
  return withTimeoutOption(mfsStat);
}
var statters = {
  raw: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: "file",
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  },
  file: (file) => {
    const stat = {
      cid: file.cid,
      type: "file",
      size: file.unixfs.fileSize(),
      cumulativeSize: encode3(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.unixfs.blockSizes.length,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  directory: (file) => {
    const stat = {
      cid: file.cid,
      type: "directory",
      size: 0,
      cumulativeSize: encode3(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.node.Links.length,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  object: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      type: "file",
      blocks: 0,
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  },
  identity: (file) => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: "file",
      local: void 0,
      sizeLocal: void 0,
      withLocality: false
    };
  }
};

// node_modules/ipfs-core/esm/src/components/files/chmod.js
init_globals();
var import_debug31 = __toESM(require_browser2(), 1);
var import_err_code48 = __toESM(require_err_code(), 1);

// node_modules/ipfs-core/esm/src/components/files/utils/to-trail.js
init_globals();
var import_debug23 = __toESM(require_browser2(), 1);
var log23 = (0, import_debug23.default)("ipfs:mfs:utils:to-trail");
async function toTrail(context, path) {
  log23(`Creating trail for path ${path}`);
  const output = [];
  for await (const fsEntry of walkPath(path, context.repo.blocks)) {
    output.push({
      name: fsEntry.name,
      cid: fsEntry.cid,
      size: fsEntry.size,
      type: fsEntry.type
    });
  }
  return output;
}

// node_modules/ipfs-core/esm/src/components/files/utils/add-link.js
init_globals();
init_cid();
var import_debug25 = __toESM(require_browser2(), 1);

// node_modules/ipfs-core/esm/src/components/files/utils/dir-sharded.js
init_globals();

// node_modules/ipfs-core/esm/src/components/files/utils/persist.js
init_globals();
init_cid();
init_sha2_browser();
var persist2 = async (buffer3, blockstore, options) => {
  if (!options.codec) {
    options.codec = src_exports2;
  }
  if (!options.hasher) {
    options.hasher = sha256;
  }
  if (options.cidVersion === void 0) {
    options.cidVersion = 1;
  }
  if (options.codec === src_exports2 && options.hasher !== sha256) {
    options.cidVersion = 1;
  }
  const multihash = await options.hasher.digest(buffer3);
  const cid = CID.create(options.cidVersion, options.codec.code, multihash);
  if (!options.onlyHash) {
    await blockstore.put(cid, buffer3, { signal: options.signal });
  }
  return cid;
};

// node_modules/ipfs-core/esm/src/components/files/utils/dir-sharded.js
var import_hamt_sharding3 = __toESM(require_src9(), 1);

// node_modules/ipfs-core/esm/src/components/files/utils/hamt-constants.js
init_globals();
var hamtHashCode = murmur3128.code;
var hamtBucketBits = 8;
async function hamtHashFn2(buf3) {
  return (await murmur3128.encode(buf3)).slice(0, 8).reverse();
}

// node_modules/ipfs-core/esm/src/components/files/utils/dir-sharded.js
var Dir2 = class {
  constructor(props, options) {
    this.options = options || {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
    this.cid = void 0;
    this.size = void 0;
  }
  async put(name10, value) {
  }
  get(name10) {
    return Promise.resolve(this);
  }
  async *eachChildSeries() {
  }
  async *flush(blockstore) {
  }
};
var DirSharded2 = class extends Dir2 {
  constructor(props, options) {
    super(props, options);
    this._bucket = (0, import_hamt_sharding3.createHAMT)({
      hashFn: hamtHashFn2,
      bits: hamtBucketBits
    });
  }
  async put(name10, value) {
    await this._bucket.put(name10, value);
  }
  get(name10) {
    return this._bucket.get(name10);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value
      };
    }
  }
  async *flush(blockstore) {
    yield* flush2(this._bucket, blockstore, this, this.options);
  }
};
async function* flush2(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links3 = [];
  let childrenSize = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children.get(i);
    if (!child) {
      continue;
    }
    const labelPrefix = i.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof import_hamt_sharding3.Bucket) {
      let shard2;
      for await (const subShard of await flush2(child, blockstore, null, options)) {
        shard2 = subShard;
      }
      if (!shard2) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links3.push({
        Name: labelPrefix,
        Tsize: shard2.size,
        Hash: shard2.cid
      });
      childrenSize += shard2.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links3.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value = child.value;
      if (!value.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value.size;
      links3.push({
        Name: label,
        Tsize: size2,
        Hash: value.cid
      });
      childrenSize += size2;
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links3
  };
  const buffer3 = encode3(prepare(node));
  const cid = await persist2(buffer3, blockstore, options);
  const size = buffer3.length + childrenSize;
  yield {
    cid,
    node,
    size
  };
}

// node_modules/ipfs-core/esm/src/components/files/utils/hamt-utils.js
init_globals();
var import_hamt_sharding4 = __toESM(require_src9(), 1);
var import_debug24 = __toESM(require_browser2(), 1);
var import_it_last6 = __toESM(require_it_last(), 1);
init_cid();
var log24 = (0, import_debug24.default)("ipfs:mfs:core:utils:hamt-utils");
var updateHamtDirectory = async (context, links3, bucket, options) => {
  if (!options.parent.Data) {
    throw new Error("Could not update HAMT directory because parent had no data");
  }
  const data = Uint8Array.from(bucket._children.bitField().reverse());
  const node = UnixFS.unmarshal(options.parent.Data);
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: hamtHashCode,
    mode: node.mode,
    mtime: node.mtime
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const parent2 = {
    Data: dir.marshal(),
    Links: links3.sort((a, b) => (a.Name || "").localeCompare(b.Name || ""))
  };
  const buf3 = encode3(parent2);
  const hash2 = await hasher.digest(buf3);
  const cid = CID.create(options.cidVersion, code, hash2);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf3);
  }
  return {
    node: parent2,
    cid,
    size: links3.reduce((sum, link) => sum + (link.Tsize || 0), buf3.length)
  };
};
var recreateHamtLevel = async (context, links3, rootBucket, parentBucket, positionAtParent) => {
  const bucket = new import_hamt_sharding4.Bucket({
    hash: rootBucket._options.hash,
    bits: rootBucket._options.bits
  }, parentBucket, positionAtParent);
  parentBucket._putObjectAt(positionAtParent, bucket);
  await addLinksToHamtBucket2(context, links3, bucket, rootBucket);
  return bucket;
};
var recreateInitialHamtLevel = async (links3) => {
  const bucket = (0, import_hamt_sharding4.createHAMT)({
    hashFn: hamtHashFn2,
    bits: hamtBucketBits
  });
  await Promise.all(links3.map(async (link) => {
    const linkName = link.Name || "";
    if (linkName.length === 2) {
      const pos = parseInt(linkName, 16);
      const subBucket = new import_hamt_sharding4.Bucket({
        hash: bucket._options.hash,
        bits: bucket._options.bits
      }, bucket, pos);
      bucket._putObjectAt(pos, subBucket);
      return Promise.resolve();
    }
    return bucket.put(linkName.substring(2), {
      size: link.Tsize,
      cid: link.Hash
    });
  }));
  return bucket;
};
var addLinksToHamtBucket2 = async (context, links3, bucket, rootBucket) => {
  await Promise.all(links3.map(async (link) => {
    const linkName = link.Name || "";
    if (linkName.length === 2) {
      log24("Populating sub bucket", linkName);
      const pos = parseInt(linkName, 16);
      const block = await context.repo.blocks.get(link.Hash);
      const node = decode5(block);
      const subBucket = new import_hamt_sharding4.Bucket({
        hash: rootBucket._options.hash,
        bits: rootBucket._options.bits
      }, bucket, pos);
      bucket._putObjectAt(pos, subBucket);
      await addLinksToHamtBucket2(context, node.Links, subBucket, rootBucket);
      return Promise.resolve();
    }
    return rootBucket.put(linkName.substring(2), {
      size: link.Tsize,
      cid: link.Hash
    });
  }));
};
var toPrefix2 = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
var generatePath = async (context, fileName, rootNode) => {
  const rootBucket = await recreateInitialHamtLevel(rootNode.Links);
  const position = await rootBucket._findNewBucketAndPos(fileName);
  const path = [{
    bucket: position.bucket,
    prefix: toPrefix2(position.pos)
  }];
  let currentBucket = position.bucket;
  while (currentBucket !== rootBucket) {
    path.push({
      bucket: currentBucket,
      prefix: toPrefix2(currentBucket._posAtParent)
    });
    currentBucket = currentBucket._parent;
  }
  path.reverse();
  path[0].node = rootNode;
  for (let i = 0; i < path.length; i++) {
    const segment = path[i];
    if (!segment.node) {
      throw new Error("Could not generate HAMT path");
    }
    const link = segment.node.Links.filter((link2) => (link2.Name || "").substring(0, 2) === segment.prefix).pop();
    if (!link) {
      log24(`Link ${segment.prefix}${fileName} will be added`);
      continue;
    }
    if (link.Name === `${segment.prefix}${fileName}`) {
      log24(`Link ${segment.prefix}${fileName} will be replaced`);
      continue;
    }
    log24(`Found subshard ${segment.prefix}`);
    const block = await context.repo.blocks.get(link.Hash);
    const node = decode5(block);
    if (!path[i + 1]) {
      log24(`Loaded new subshard ${segment.prefix}`);
      await recreateHamtLevel(context, node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
      const position2 = await rootBucket._findNewBucketAndPos(fileName);
      path.push({
        bucket: position2.bucket,
        prefix: toPrefix2(position2.pos),
        node
      });
      continue;
    }
    const nextSegment = path[i + 1];
    await addLinksToHamtBucket2(context, node.Links, nextSegment.bucket, rootBucket);
    nextSegment.node = node;
  }
  await rootBucket.put(fileName, true);
  path.reverse();
  return {
    rootBucket,
    path
  };
};
var createShard = async (context, contents, options = {}) => {
  const shard2 = new DirSharded2({
    root: true,
    dir: true,
    parent: void 0,
    parentKey: void 0,
    path: "",
    dirty: true,
    flat: false,
    mtime: options.mtime,
    mode: options.mode
  }, options);
  for (let i = 0; i < contents.length; i++) {
    await shard2._bucket.put(contents[i].name, {
      size: contents[i].size,
      cid: contents[i].cid
    });
  }
  const res = await (0, import_it_last6.default)(shard2.flush(context.repo.blocks));
  if (!res) {
    throw new Error("Flushing shard yielded no result");
  }
  return res;
};

// node_modules/ipfs-core/esm/src/components/files/utils/add-link.js
var import_err_code42 = __toESM(require_err_code(), 1);
var import_it_last7 = __toESM(require_it_last(), 1);
var log25 = (0, import_debug25.default)("ipfs:mfs:core:utils:add-link");
async function addLink(context, options) {
  let parent2 = options.parent;
  if (options.parentCid) {
    const parentCid = CID.asCID(options.parentCid);
    if (parentCid === null) {
      throw (0, import_err_code42.default)(new Error("Invalid CID passed to addLink"), "EINVALIDPARENTCID");
    }
    if (parentCid.code !== code) {
      throw (0, import_err_code42.default)(new Error("Unsupported codec. Only DAG-PB is supported"), "EINVALIDPARENTCID");
    }
    log25(`Loading parent node ${parentCid}`);
    const block = await context.repo.blocks.get(parentCid);
    parent2 = decode5(block);
  }
  if (!parent2) {
    throw (0, import_err_code42.default)(new Error("No parent node or CID passed to addLink"), "EINVALIDPARENT");
  }
  if (!options.cid) {
    throw (0, import_err_code42.default)(new Error("No child cid passed to addLink"), "EINVALIDCHILDCID");
  }
  if (!options.name) {
    throw (0, import_err_code42.default)(new Error("No child name passed to addLink"), "EINVALIDCHILDNAME");
  }
  if (!options.size && options.size !== 0) {
    throw (0, import_err_code42.default)(new Error("No child size passed to addLink"), "EINVALIDCHILDSIZE");
  }
  if (!parent2.Data) {
    throw (0, import_err_code42.default)(new Error("Parent node with no data passed to addLink"), "ERR_INVALID_PARENT");
  }
  const meta = UnixFS.unmarshal(parent2.Data);
  if (meta.type === "hamt-sharded-directory") {
    log25("Adding link to sharded directory");
    return addToShardedDirectory(context, {
      ...options,
      parent: parent2
    });
  }
  if (parent2.Links.length >= options.shardSplitThreshold) {
    log25("Converting directory to sharded directory");
    return convertToShardedDirectory(context, {
      ...options,
      parent: parent2,
      mtime: meta.mtime,
      mode: meta.mode
    });
  }
  log25(`Adding ${options.name} (${options.cid}) to regular directory`);
  return addToDirectory(context, {
    ...options,
    parent: parent2
  });
}
var convertToShardedDirectory = async (context, options) => {
  const result = await createShard(context, options.parent.Links.map((link) => ({
    name: link.Name || "",
    size: link.Tsize || 0,
    cid: link.Hash
  })).concat({
    name: options.name,
    size: options.size,
    cid: options.cid
  }), options);
  log25(`Converted directory to sharded directory ${result.cid}`);
  return result;
};
var addToDirectory = async (context, options) => {
  const parentLinks = options.parent.Links.filter((link) => {
    return link.Name !== options.name;
  });
  parentLinks.push({
    Name: options.name,
    Tsize: options.size,
    Hash: options.cid
  });
  if (!options.parent.Data) {
    throw (0, import_err_code42.default)(new Error("Parent node with no data passed to addToDirectory"), "ERR_INVALID_PARENT");
  }
  const node = UnixFS.unmarshal(options.parent.Data);
  let data;
  if (node.mtime) {
    const ms = Date.now();
    const secs = Math.floor(ms / 1e3);
    node.mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
    data = node.marshal();
  } else {
    data = options.parent.Data;
  }
  options.parent = prepare({
    Data: data,
    Links: parentLinks
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const buf3 = encode3(options.parent);
  const hash2 = await hasher.digest(buf3);
  const cid = CID.create(options.cidVersion, code, hash2);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf3);
  }
  return {
    node: options.parent,
    cid,
    size: buf3.length
  };
};
var addToShardedDirectory = async (context, options) => {
  const { shard: shard2, path } = await addFileToShardedDirectory(context, options);
  const result = await (0, import_it_last7.default)(shard2.flush(context.repo.blocks));
  if (!result) {
    throw new Error("No result from flushing shard");
  }
  const block = await context.repo.blocks.get(result.cid);
  const node = decode5(block);
  const parentLinks = options.parent.Links.filter((link) => {
    return (link.Name || "").substring(0, 2) !== path[0].prefix;
  });
  const newLink = node.Links.find((link) => (link.Name || "").substring(0, 2) === path[0].prefix);
  if (!newLink) {
    throw new Error(`No link found with prefix ${path[0].prefix}`);
  }
  parentLinks.push(newLink);
  return updateHamtDirectory(context, parentLinks, path[0].bucket, options);
};
var addFileToShardedDirectory = async (context, options) => {
  const file = {
    name: options.name,
    cid: options.cid,
    size: options.size
  };
  if (!options.parent.Data) {
    throw (0, import_err_code42.default)(new Error("Parent node with no data passed to addFileToShardedDirectory"), "ERR_INVALID_PARENT");
  }
  const rootBucket = await recreateInitialHamtLevel(options.parent.Links);
  const node = UnixFS.unmarshal(options.parent.Data);
  const shard2 = new DirSharded2({
    root: true,
    dir: true,
    parent: void 0,
    parentKey: void 0,
    path: "",
    dirty: true,
    flat: false,
    mode: node.mode
  }, options);
  shard2._bucket = rootBucket;
  if (node.mtime) {
    shard2.mtime = { secs: Math.round(Date.now() / 1e3) };
  }
  const position = await rootBucket._findNewBucketAndPos(file.name);
  const path = toBucketPath2(position);
  path[0].node = options.parent;
  let index = 0;
  while (index < path.length) {
    const segment = path[index];
    index++;
    const node2 = segment.node;
    if (!node2) {
      throw new Error("Segment had no node");
    }
    const link = node2.Links.find((link2) => (link2.Name || "").substring(0, 2) === segment.prefix);
    if (!link) {
      log25(`Link ${segment.prefix}${file.name} will be added`);
      index = path.length;
      break;
    }
    if (link.Name === `${segment.prefix}${file.name}`) {
      log25(`Link ${segment.prefix}${file.name} will be replaced`);
      index = path.length;
      break;
    }
    if ((link.Name || "").length > 2) {
      log25(`Link ${link.Name} ${link.Hash} will be replaced with a subshard`);
      index = path.length;
      break;
    }
    log25(`Found subshard ${segment.prefix}`);
    const block = await context.repo.blocks.get(link.Hash);
    const subShard = decode5(block);
    if (!path[index]) {
      log25(`Loaded new subshard ${segment.prefix}`);
      await recreateHamtLevel(context, subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
      const position2 = await rootBucket._findNewBucketAndPos(file.name);
      path.push({
        bucket: position2.bucket,
        prefix: toPrefix2(position2.pos),
        node: subShard
      });
      break;
    }
    const nextSegment = path[index];
    await addLinksToHamtBucket2(context, subShard.Links, nextSegment.bucket, rootBucket);
    nextSegment.node = subShard;
  }
  await shard2._bucket.put(file.name, {
    size: file.size,
    cid: file.cid
  });
  return {
    shard: shard2,
    path
  };
};
var toBucketPath2 = (position) => {
  const path = [{
    bucket: position.bucket,
    prefix: toPrefix2(position.pos)
  }];
  let bucket = position.bucket._parent;
  let positionInBucket = position.bucket._posAtParent;
  while (bucket) {
    path.push({
      bucket,
      prefix: toPrefix2(positionInBucket)
    });
    positionInBucket = bucket._posAtParent;
    bucket = bucket._parent;
  }
  path.reverse();
  return path;
};

// node_modules/ipfs-core/esm/src/components/files/utils/update-tree.js
init_globals();
var import_debug26 = __toESM(require_browser2(), 1);
var log26 = (0, import_debug26.default)("ipfs:mfs:utils:update-tree");
var defaultOptions3 = { shardSplitThreshold: 1e3 };
async function updateTree(context, trail, options) {
  options = Object.assign({}, defaultOptions3, options);
  log26("Trail", trail);
  trail = trail.slice().reverse();
  let index = 0;
  let child;
  for await (const block of context.repo.blocks.getMany(trail.map((node) => node.cid))) {
    const node = decode5(block);
    const cid2 = trail[index].cid;
    const name10 = trail[index].name;
    index++;
    if (!child) {
      child = {
        cid: cid2,
        name: name10,
        size: block.length
      };
      continue;
    }
    const result = await addLink(context, {
      parent: node,
      name: child.name,
      cid: child.cid,
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    });
    child = {
      cid: result.cid,
      name: name10,
      size: result.size
    };
  }
  const { cid } = child;
  log26(`Final CID ${cid}`);
  return cid;
}

// node_modules/ipfs-core/esm/src/components/files/utils/update-mfs-root.js
init_globals();
var import_debug27 = __toESM(require_browser2(), 1);
var import_err_code43 = __toESM(require_err_code(), 1);
var log27 = (0, import_debug27.default)("ipfs:mfs:utils:update-mfs-root");
async function updateMfsRoot(context, cid, options) {
  if (options && options.signal && options.signal.aborted) {
    throw (0, import_err_code43.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
  }
  log27(`New MFS root will be ${cid}`);
  await context.repo.datastore.put(MFS_ROOT_KEY, cid.bytes);
  return cid;
}

// node_modules/ipfs-core/esm/src/components/files/chmod.js
init_cid();
var import_it_pipe5 = __toESM(require_it_pipe(), 1);
var import_it_last8 = __toESM(require_it_last(), 1);

// node_modules/ipfs-core/esm/src/components/files/cp.js
init_globals();

// node_modules/ipfs-core/esm/src/components/files/mkdir.js
init_globals();
var import_err_code44 = __toESM(require_err_code(), 1);
var import_debug28 = __toESM(require_browser2(), 1);

// node_modules/ipfs-core/esm/src/components/files/utils/create-node.js
init_globals();
init_cid();
async function createNode2(context, type, options) {
  const metadata = new UnixFS({
    type,
    mode: options.mode,
    mtime: options.mtime
  });
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const node = {
    Data: metadata.marshal(),
    Links: []
  };
  const buf3 = encode3(node);
  const hash2 = await hasher.digest(buf3);
  const cid = CID.create(options.cidVersion, code, hash2);
  if (options.flush) {
    await context.repo.blocks.put(cid, buf3);
  }
  return {
    cid,
    node
  };
}

// node_modules/ipfs-core/esm/src/components/files/mkdir.js
var mergeOptions5 = merge_options_default.bind({ ignoreUndefined: true });
var log28 = (0, import_debug28.default)("ipfs:mfs:mkdir");
var defaultOptions4 = {
  parents: false,
  hashAlg: "sha2-256",
  cidVersion: 0,
  shardSplitThreshold: 1e3,
  flush: true
};
function createMkdir(context) {
  async function mfsMkdir(path, options = {}) {
    const opts = mergeOptions5(defaultOptions4, options);
    if (!path) {
      throw new Error("no path given to Mkdir");
    }
    path = path.trim();
    if (path === "/") {
      if (opts.parents) {
        return;
      }
      throw (0, import_err_code44.default)(new Error("cannot create directory '/': Already exists"), "ERR_INVALID_PATH");
    }
    if (path.substring(0, 1) !== "/") {
      throw (0, import_err_code44.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
    }
    log28(`Creating ${path}`);
    const pathComponents = toPathComponents3(path);
    if (pathComponents[0] === "ipfs") {
      throw (0, import_err_code44.default)(new Error("path cannot have the prefix 'ipfs'"), "ERR_INVALID_PATH");
    }
    const root = await loadMfsRoot(context, opts);
    let parent2;
    const trail = [];
    const emptyDir = await createNode2(context, "directory", opts);
    for (let i = 0; i <= pathComponents.length; i++) {
      const subPathComponents = pathComponents.slice(0, i);
      const subPath = `/ipfs/${root}/${subPathComponents.join("/")}`;
      try {
        parent2 = await exporter(subPath, context.repo.blocks);
        if (parent2.type !== "file" && parent2.type !== "directory") {
          throw (0, import_err_code44.default)(new Error(`${path} was not a UnixFS node`), "ERR_NOT_UNIXFS");
        }
        if (i === pathComponents.length) {
          if (opts.parents) {
            return;
          }
          throw (0, import_err_code44.default)(new Error("file already exists"), "ERR_ALREADY_EXISTS");
        }
        trail.push({
          name: parent2.name,
          cid: parent2.cid
        });
      } catch (err) {
        if (err.code === "ERR_NOT_FOUND") {
          if (i < pathComponents.length && !opts.parents) {
            throw (0, import_err_code44.default)(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), "ERR_NOT_FOUND");
          }
          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);
        } else {
          throw err;
        }
      }
    }
    const newRootCid = await updateTree(context, trail, opts);
    await updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption(mfsMkdir);
}
var addEmptyDir = async (context, childName, emptyDir, parent2, trail, options) => {
  log28(`Adding empty dir called ${childName} to ${parent2.cid}`);
  const result = await addLink(context, {
    parent: parent2.node,
    parentCid: parent2.cid,
    size: 0,
    cid: emptyDir.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  trail[trail.length - 1].cid = result.cid;
  trail.push({
    name: childName,
    cid: emptyDir.cid
  });
};

// node_modules/ipfs-core/esm/src/components/files/cp.js
var import_debug29 = __toESM(require_browser2(), 1);
var import_err_code45 = __toESM(require_err_code(), 1);
var mergeOptions6 = merge_options_default.bind({ ignoreUndefined: true });
var log29 = (0, import_debug29.default)("ipfs:mfs:cp");
var defaultOptions5 = {
  parents: false,
  flush: true,
  hashAlg: "sha2-256",
  cidVersion: 0,
  shardSplitThreshold: 1e3
};
function createCp(context) {
  async function mfsCp(from5, to, opts = {}) {
    const options = mergeOptions6(defaultOptions5, opts);
    if (!Array.isArray(from5)) {
      from5 = [from5];
    }
    const sources = await Promise.all(from5.map((path) => toMfsPath(context, path, options)));
    let destination = await toMfsPath(context, to, options);
    if (!sources.length || !destination) {
      throw (0, import_err_code45.default)(new Error("Please supply at least one source"), "ERR_INVALID_PARAMS");
    }
    const missing = sources.find((source) => !source.exists);
    if (missing) {
      throw (0, import_err_code45.default)(new Error(`${missing.path} does not exist`), "ERR_INVALID_PARAMS");
    }
    const destinationIsDirectory = isDirectory(destination);
    if (destination.exists) {
      log29("Destination exists");
      if (sources.length === 1 && !destinationIsDirectory) {
        throw (0, import_err_code45.default)(new Error("directory already has entry by that name"), "ERR_ALREADY_EXISTS");
      }
    } else {
      log29("Destination does not exist");
      if (sources.length > 1) {
        if (!options.parents) {
          throw (0, import_err_code45.default)(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
        }
        await createMkdir(context)(destination.path, options);
        destination = await toMfsPath(context, destination.path, options);
      } else if (destination.parts.length > 1) {
        const parentFolder = `/${destination.parts.slice(0, -1).join("/")}`;
        try {
          await createStat3(context)(parentFolder, options);
        } catch (err) {
          if (err.code !== "ERR_NOT_FOUND") {
            throw err;
          }
          if (!options.parents) {
            throw (0, import_err_code45.default)(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
          }
          await createMkdir(context)(parentFolder, options);
          destination = await toMfsPath(context, destination.path, options);
        }
      }
    }
    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;
    const trail = await toTrail(context, destinationPath);
    if (sources.length === 1) {
      const source = sources.pop();
      if (!source) {
        throw (0, import_err_code45.default)(new Error("could not find source"), "ERR_INVALID_PARAMS");
      }
      const destinationName = destinationIsDirectory ? source.name : destination.name;
      log29(`Only one source, copying to destination ${destinationIsDirectory ? "directory" : "file"} ${destinationName}`);
      return copyToFile(context, source, destinationName, trail, options);
    }
    log29("Multiple sources, wrapping in a directory");
    return copyToDirectory(context, sources, destination, trail, options);
  }
  return withTimeoutOption(mfsCp);
}
var isDirectory = (destination) => {
  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes("directory");
};
var copyToFile = async (context, source, destination, destinationTrail, options) => {
  let parent2 = destinationTrail.pop();
  if (!parent2) {
    throw (0, import_err_code45.default)(new Error("destination had no parent"), "ERR_INVALID_PARAMS");
  }
  parent2 = await addSourceToParent(context, source, destination, parent2, options);
  destinationTrail.push(parent2);
  const newRootCid = await updateTree(context, destinationTrail, options);
  await updateMfsRoot(context, newRootCid, options);
};
var copyToDirectory = async (context, sources, destination, destinationTrail, options) => {
  for (let i = 0; i < sources.length; i++) {
    const source = sources[i];
    destination = await addSourceToParent(context, source, source.name, destination, options);
  }
  destinationTrail[destinationTrail.length - 1] = destination;
  const newRootCid = await updateTree(context, destinationTrail, options);
  await updateMfsRoot(context, newRootCid, options);
};
var addSourceToParent = async (context, source, childName, parent2, options) => {
  const sourceBlock = await context.repo.blocks.get(source.cid);
  const { node, cid, size } = await addLink(context, {
    parentCid: parent2.cid,
    size: sourceBlock.length,
    cid: source.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent2.node = node;
  parent2.cid = cid;
  parent2.size = size;
  return parent2;
};

// node_modules/ipfs-core/esm/src/components/files/rm.js
init_globals();
var import_err_code47 = __toESM(require_err_code(), 1);

// node_modules/ipfs-core/esm/src/components/files/utils/remove-link.js
init_globals();
init_cid();
var import_debug30 = __toESM(require_browser2(), 1);
var import_err_code46 = __toESM(require_err_code(), 1);
var log30 = (0, import_debug30.default)("ipfs:mfs:core:utils:remove-link");
async function removeLink(context, options) {
  let parent2 = options.parent;
  if (options.parentCid) {
    const parentCid = CID.asCID(options.parentCid);
    if (parentCid === null) {
      throw (0, import_err_code46.default)(new Error("Invalid CID passed to removeLink"), "EINVALIDPARENTCID");
    }
    log30(`Loading parent node ${parentCid}`);
    const block = await context.repo.blocks.get(parentCid);
    parent2 = decode5(block);
  }
  if (!parent2) {
    throw (0, import_err_code46.default)(new Error("No parent node or CID passed to removeLink"), "EINVALIDPARENT");
  }
  if (!options.name) {
    throw (0, import_err_code46.default)(new Error("No child name passed to removeLink"), "EINVALIDCHILDNAME");
  }
  if (!parent2.Data) {
    throw (0, import_err_code46.default)(new Error("Parent node had no data"), "ERR_INVALID_NODE");
  }
  const meta = UnixFS.unmarshal(parent2.Data);
  if (meta.type === "hamt-sharded-directory") {
    log30(`Removing ${options.name} from sharded directory`);
    return removeFromShardedDirectory(context, {
      ...options,
      parent: parent2
    });
  }
  log30(`Removing link ${options.name} regular directory`);
  return removeFromDirectory(context, {
    ...options,
    parent: parent2
  });
}
var removeFromDirectory = async (context, options) => {
  options.parent.Links = options.parent.Links.filter((link) => {
    return link.Name !== options.name;
  });
  const parentBlock = await encode3(options.parent);
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const hash2 = await hasher.digest(parentBlock);
  const parentCid = CID.create(options.cidVersion, code, hash2);
  await context.repo.blocks.put(parentCid, parentBlock);
  log30(`Updated regular directory ${parentCid}`);
  return {
    node: options.parent,
    cid: parentCid
  };
};
var removeFromShardedDirectory = async (context, options) => {
  const { rootBucket, path } = await generatePath(context, options.name, options.parent);
  await rootBucket.del(options.name);
  const { node } = await updateShard(context, path, options.name, options);
  return updateHamtDirectory(context, node.Links, rootBucket, options);
};
var updateShard = async (context, positions, name10, options) => {
  const last15 = positions.pop();
  if (!last15) {
    throw (0, import_err_code46.default)(new Error("Could not find parent"), "EINVALIDPARENT");
  }
  const { bucket, prefix, node } = last15;
  if (!node) {
    throw (0, import_err_code46.default)(new Error("Could not find parent"), "EINVALIDPARENT");
  }
  const link = node.Links.find((link2) => (link2.Name || "").substring(0, 2) === prefix);
  if (!link) {
    throw (0, import_err_code46.default)(new Error(`No link found with prefix ${prefix} for file ${name10}`), "ERR_NOT_FOUND");
  }
  if (link.Name === `${prefix}${name10}`) {
    log30(`Removing existing link ${link.Name}`);
    const links3 = node.Links.filter((nodeLink) => {
      return nodeLink.Name !== link.Name;
    });
    await bucket.del(name10);
    return updateHamtDirectory(context, links3, bucket, options);
  }
  log30(`Descending into sub-shard ${link.Name} for ${prefix}${name10}`);
  const result = await updateShard(context, positions, name10, options);
  let cid = result.cid;
  let size = result.size;
  let newName = prefix;
  if (result.node.Links.length === 1) {
    log30(`Removing subshard for ${prefix}`);
    const link2 = result.node.Links[0];
    newName = `${prefix}${(link2.Name || "").substring(2)}`;
    cid = link2.Hash;
    size = link2.Tsize || 0;
  }
  log30(`Updating shard ${prefix} with name ${newName}`);
  return updateShardParent(context, bucket, node, prefix, newName, size, cid, options);
};
var updateShardParent = (context, bucket, parent2, oldName, newName, size, cid, options) => {
  const parentLinks = parent2.Links.filter((link) => {
    return link.Name !== oldName;
  });
  parentLinks.push({
    Name: newName,
    Tsize: size,
    Hash: cid
  });
  return updateHamtDirectory(context, parentLinks, bucket, options);
};

// node_modules/ipfs-core/esm/src/components/files/rm.js
var mergeOptions7 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions6 = {
  recursive: false,
  cidVersion: 0,
  hashAlg: "sha2-256",
  flush: true,
  shardSplitThreshold: 1e3
};
function createRm4(context) {
  async function mfsRm(paths, opts = {}) {
    const options = mergeOptions7(defaultOptions6, opts);
    if (!Array.isArray(paths)) {
      paths = [paths];
    }
    const sources = await Promise.all(paths.map((path) => toMfsPath(context, path, options)));
    if (!sources.length) {
      throw (0, import_err_code47.default)(new Error("Please supply at least one path to remove"), "ERR_INVALID_PARAMS");
    }
    sources.forEach((source) => {
      if (source.path === "/") {
        throw (0, import_err_code47.default)(new Error("Cannot delete root"), "ERR_INVALID_PARAMS");
      }
    });
    for (const source of sources) {
      await removePath(context, source.path, options);
    }
  }
  return withTimeoutOption(mfsRm);
}
var removePath = async (context, path, options) => {
  const mfsPath = await toMfsPath(context, path, options);
  const trail = await toTrail(context, mfsPath.mfsPath);
  const child = trail[trail.length - 1];
  trail.pop();
  const parent2 = trail[trail.length - 1];
  if (!parent2) {
    throw (0, import_err_code47.default)(new Error(`${path} does not exist`), "ERR_NOT_FOUND");
  }
  if (child.type === "directory" && !options.recursive) {
    throw (0, import_err_code47.default)(new Error(`${path} is a directory, use -r to remove directories`), "ERR_WAS_DIR");
  }
  const { cid } = await removeLink(context, {
    parentCid: parent2.cid,
    name: child.name,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent2.cid = cid;
  const newRootCid = await updateTree(context, trail, options);
  await updateMfsRoot(context, newRootCid, options);
};

// node_modules/ipfs-core/esm/src/components/files/chmod.js
var mergeOptions8 = merge_options_default.bind({ ignoreUndefined: true });
var log31 = (0, import_debug31.default)("ipfs:mfs:touch");
var defaultOptions7 = {
  flush: true,
  shardSplitThreshold: 1e3,
  hashAlg: "sha2-256",
  cidVersion: 0,
  recursive: false
};
function calculateModification(mode, originalMode, isDirectory2) {
  let modification = 0;
  if (mode.includes("x") || mode.includes("X") && (isDirectory2 || (originalMode & 1 || originalMode & 8 || originalMode & 64))) {
    modification += 1;
  }
  if (mode.includes("w")) {
    modification += 2;
  }
  if (mode.includes("r")) {
    modification += 4;
  }
  return modification;
}
function calculateUGO(references, modification) {
  let ugo = 0;
  if (references.includes("u")) {
    ugo += modification << 6;
  }
  if (references.includes("g")) {
    ugo += modification << 3;
  }
  if (references.includes("o")) {
    ugo += modification;
  }
  return ugo;
}
function calculateSpecial(references, mode, modification) {
  if (mode.includes("t")) {
    modification += parseInt("1000", 8);
  }
  if (mode.includes("s")) {
    if (references.includes("u")) {
      modification += parseInt("4000", 8);
    }
    if (references.includes("g")) {
      modification += parseInt("2000", 8);
    }
  }
  return modification;
}
function parseSymbolicMode(input, originalMode, isDirectory2) {
  if (!originalMode) {
    originalMode = 0;
  }
  const match = input.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);
  if (!match) {
    throw new Error(`Invalid file mode: ${input}`);
  }
  let [, references, operator, mode] = match;
  if (references === "a" || !references) {
    references = "ugo";
  }
  let modification = calculateModification(mode, originalMode, isDirectory2);
  modification = calculateUGO(references, modification);
  modification = calculateSpecial(references, mode, modification);
  if (operator === "=") {
    if (references.includes("u")) {
      originalMode = originalMode & parseInt("7077", 8);
      originalMode = originalMode | modification;
    }
    if (references.includes("g")) {
      originalMode = originalMode & parseInt("7707", 8);
      originalMode = originalMode | modification;
    }
    if (references.includes("o")) {
      originalMode = originalMode & parseInt("7770", 8);
      originalMode = originalMode | modification;
    }
    return originalMode;
  }
  if (operator === "+") {
    return modification | originalMode;
  }
  if (operator === "-") {
    return modification ^ originalMode;
  }
  return originalMode;
}
function calculateMode(mode, metadata) {
  if (mode instanceof String || typeof mode === "string") {
    const strMode = `${mode}`;
    if (strMode.match(/^\d+$/g)) {
      mode = parseInt(strMode, 8);
    } else {
      mode = 0 + strMode.split(",").reduce((curr, acc) => {
        return parseSymbolicMode(acc, curr, metadata.isDirectory());
      }, metadata.mode || 0);
    }
  }
  return mode;
}
function createChmod(context) {
  async function mfsChmod(path, mode, options = {}) {
    const opts = mergeOptions8(defaultOptions7, options);
    log31(`Fetching stats for ${path}`);
    const { cid, mfsDirectory, name: name10 } = await toMfsPath(context, path, opts);
    if (cid.code !== code) {
      throw (0, import_err_code48.default)(new Error(`${path} was not a UnixFS node`), "ERR_NOT_UNIXFS");
    }
    if (opts.recursive) {
      const root = await (0, import_it_pipe5.pipe)(async function* () {
        for await (const entry of recursive(cid, context.repo.blocks)) {
          if (entry.type !== "file" && entry.type !== "directory") {
            throw (0, import_err_code48.default)(new Error(`${path} was not a UnixFS node`), "ERR_NOT_UNIXFS");
          }
          entry.unixfs.mode = calculateMode(mode, entry.unixfs);
          const node2 = prepare({
            Data: entry.unixfs.marshal(),
            Links: entry.node.Links
          });
          yield {
            path: entry.path,
            content: node2
          };
        }
      }, (source) => importer(source, context.repo.blocks, {
        ...opts,
        pin: false,
        dagBuilder: async function* (source2, block2, opts2) {
          for await (const entry of source2) {
            yield async function() {
              const node2 = entry.content;
              const buf3 = encode3(node2);
              const cid2 = await persist2(buf3, block2, opts2);
              if (!node2.Data) {
                throw (0, import_err_code48.default)(new Error(`${cid2} had no data`), "ERR_INVALID_NODE");
              }
              const unixfs = UnixFS.unmarshal(node2.Data);
              return {
                cid: cid2,
                size: buf3.length,
                path: entry.path,
                unixfs
              };
            };
          }
        }
      }), (nodes) => (0, import_it_last8.default)(nodes));
      if (!root) {
        throw (0, import_err_code48.default)(new Error(`Could not chmod ${path}`), "ERR_COULD_NOT_CHMOD");
      }
      await createRm4(context)(path, opts);
      await createCp(context)(`/ipfs/${root.cid}`, path, opts);
      return;
    }
    const block = await context.repo.blocks.get(cid);
    const node = decode5(block);
    if (!node.Data) {
      throw (0, import_err_code48.default)(new Error(`${cid} had no data`), "ERR_INVALID_NODE");
    }
    const metadata = UnixFS.unmarshal(node.Data);
    metadata.mode = calculateMode(mode, metadata);
    const updatedBlock = encode3({
      Data: metadata.marshal(),
      Links: node.Links
    });
    const hashAlg = opts.hashAlg || defaultOptions7.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    const hash2 = await hasher.digest(updatedBlock);
    const updatedCid = CID.create(opts.cidVersion, code, hash2);
    if (opts.flush) {
      await context.repo.blocks.put(updatedCid, updatedBlock);
    }
    const trail = await toTrail(context, mfsDirectory);
    const parent2 = trail[trail.length - 1];
    const parentCid = CID.decode(parent2.cid.bytes);
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = decode5(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: name10,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: opts.flush,
      hashAlg,
      cidVersion: cid.version,
      shardSplitThreshold: Infinity
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, opts);
    await updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption(mfsChmod);
}

// node_modules/ipfs-core/esm/src/components/files/flush.js
init_globals();
var mergeOptions9 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions8 = {};
function createFlush(context) {
  async function mfsFlush(path, options = {}) {
    options = mergeOptions9(defaultOptions8, options);
    const { cid } = await createStat3(context)(path, options);
    return cid;
  }
  return withTimeoutOption(mfsFlush);
}

// node_modules/ipfs-core/esm/src/components/files/mv.js
init_globals();
var mergeOptions10 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions9 = {
  parents: false,
  flush: true,
  cidVersion: 0,
  hashAlg: "sha2-256",
  shardSplitThreshold: 1e3
};
function createMv(context) {
  async function mfsMv(from5, to, options = {}) {
    const opts = mergeOptions10(defaultOptions9, options);
    await createCp(context)(from5, to, opts);
    await createRm4(context)(from5, {
      ...opts,
      recursive: true
    });
  }
  return withTimeoutOption(mfsMv);
}

// node_modules/ipfs-core/esm/src/components/files/touch.js
init_globals();
var import_debug32 = __toESM(require_browser2(), 1);
var import_err_code49 = __toESM(require_err_code(), 1);
init_cid();
var mergeOptions11 = merge_options_default.bind({ ignoreUndefined: true });
var log32 = (0, import_debug32.default)("ipfs:mfs:touch");
var defaultOptions10 = {
  flush: true,
  shardSplitThreshold: 1e3,
  cidVersion: 0,
  hashAlg: "sha2-256"
};
function createTouch(context) {
  async function mfsTouch(path, options = {}) {
    const settings = mergeOptions11(defaultOptions10, options);
    settings.mtime = settings.mtime || new Date();
    log32(`Touching ${path} mtime: ${settings.mtime}`);
    const { cid, mfsDirectory, name: name10, exists } = await toMfsPath(context, path, settings);
    const hashAlg = options.hashAlg || defaultOptions10.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    let updatedBlock;
    let updatedCid;
    let cidVersion = settings.cidVersion;
    if (!exists) {
      const metadata = new UnixFS({
        type: "file",
        mtime: settings.mtime
      });
      updatedBlock = encode3({
        Data: metadata.marshal(),
        Links: []
      });
      const hash2 = await hasher.digest(updatedBlock);
      updatedCid = CID.create(settings.cidVersion, code, hash2);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    } else {
      if (cid.code !== code) {
        throw (0, import_err_code49.default)(new Error(`${path} was not a UnixFS node`), "ERR_NOT_UNIXFS");
      }
      cidVersion = cid.version;
      const block = await context.repo.blocks.get(cid);
      const node = decode5(block);
      if (!node.Data) {
        throw (0, import_err_code49.default)(new Error(`${path} had no data`), "ERR_INVALID_NODE");
      }
      const metadata = UnixFS.unmarshal(node.Data);
      metadata.mtime = settings.mtime;
      updatedBlock = encode3({
        Data: metadata.marshal(),
        Links: node.Links
      });
      const hash2 = await hasher.digest(updatedBlock);
      updatedCid = CID.create(settings.cidVersion, code, hash2);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    }
    const trail = await toTrail(context, mfsDirectory);
    const parent2 = trail[trail.length - 1];
    const parentCid = parent2.cid;
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = decode5(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: name10,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: settings.flush,
      shardSplitThreshold: settings.shardSplitThreshold,
      hashAlg: settings.hashAlg,
      cidVersion
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, settings);
    await updateMfsRoot(context, newRootCid, settings);
  }
  return withTimeoutOption(mfsTouch);
}

// node_modules/ipfs-core/esm/src/components/files/read.js
init_globals();
var import_err_code50 = __toESM(require_err_code(), 1);
var mergeOptions12 = merge_options_default.bind({ ignoreUndefined: true });
var defaultOptions11 = {
  offset: 0,
  length: Infinity
};
function createRead(context) {
  function mfsRead(path, options = {}) {
    options = mergeOptions12(defaultOptions11, options);
    return {
      [Symbol.asyncIterator]: async function* read3() {
        const mfsPath = await toMfsPath(context, path, options);
        const result = await exporter(mfsPath.mfsPath, context.repo.blocks);
        if (result.type !== "file") {
          throw (0, import_err_code50.default)(new Error(`${path} was not a file`), "ERR_NOT_FILE");
        }
        if (!result.content) {
          throw (0, import_err_code50.default)(new Error(`Could not load content stream from ${path}`), "ERR_NO_CONTENT");
        }
        for await (const buf3 of result.content({
          offset: options.offset,
          length: options.length
        })) {
          yield buf3;
        }
      }
    };
  }
  return withTimeoutOption(mfsRead);
}

// node_modules/ipfs-core/esm/src/components/files/write.js
init_globals();
var import_debug34 = __toESM(require_browser2(), 1);

// node_modules/ipfs-core/esm/src/components/files/utils/to-async-iterator.js
init_globals();
var import_err_code51 = __toESM(require_err_code(), 1);
var import_debug33 = __toESM(require_browser2(), 1);
init_from_string();
var log33 = (0, import_debug33.default)("ipfs:mfs:utils:to-async-iterator");
function toAsyncIterator(content) {
  if (!content) {
    throw (0, import_err_code51.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
  }
  if (typeof content === "string" || content instanceof String) {
    log33("Content was a string");
    content = fromString3(content.toString());
  }
  if (content.length) {
    log33("Content was array-like");
    return {
      [Symbol.asyncIterator]: function* bufferContent() {
        yield content;
      }
    };
  }
  if (content[Symbol.asyncIterator]) {
    log33("Content was an async iterator");
    return content;
  }
  if (content[Symbol.iterator]) {
    log33("Content was an iterator");
    return content;
  }
  if (global.Blob && content instanceof global.Blob) {
    log33("Content was an HTML5 Blob");
    let index = 0;
    const iterator = {
      next: () => {
        if (index > content.size) {
          return { done: true };
        }
        return new Promise((resolve11, reject) => {
          const chunk = content.slice(index, MFS_MAX_CHUNK_SIZE);
          index += MFS_MAX_CHUNK_SIZE;
          const reader = new global.FileReader();
          const handleLoad = (ev) => {
            reader.removeEventListener("loadend", handleLoad, false);
            if (ev.error) {
              return reject(ev.error);
            }
            resolve11({
              done: false,
              value: new Uint8Array(reader.result)
            });
          };
          reader.addEventListener("loadend", handleLoad);
          reader.readAsArrayBuffer(chunk);
        });
      }
    };
    return {
      [Symbol.asyncIterator]: () => {
        return iterator;
      }
    };
  }
  throw (0, import_err_code51.default)(new Error(`Don't know how to convert ${content} into an async iterator`), "ERR_INVALID_PARAMS");
}

// node_modules/ipfs-core/esm/src/components/files/write.js
var import_err_code52 = __toESM(require_err_code(), 1);
var import_it_last9 = __toESM(require_it_last(), 1);
var mergeOptions13 = merge_options_default.bind({ ignoreUndefined: true });
var log34 = (0, import_debug34.default)("ipfs:mfs:write");
var defaultOptions12 = {
  offset: 0,
  length: Infinity,
  create: false,
  truncate: false,
  rawLeaves: false,
  reduceSingleLeafToSelf: false,
  cidVersion: 0,
  hashAlg: "sha2-256",
  parents: false,
  progress: (bytes2, path) => {
  },
  strategy: "trickle",
  flush: true,
  leafType: "raw",
  shardSplitThreshold: 1e3
};
function createWrite(context) {
  async function mfsWrite(path, content, opts = {}) {
    const options = mergeOptions13(defaultOptions12, opts);
    let source;
    let destination;
    let parent2;
    log34("Reading source, destination and parent");
    await createLock().readLock(async () => {
      source = await toAsyncIterator(content);
      destination = await toMfsPath(context, path, options);
      parent2 = await toMfsPath(context, destination.mfsDirectory, options);
    })();
    log34("Read source, destination and parent");
    if (!options.parents && !parent2.exists) {
      throw (0, import_err_code52.default)(new Error("directory does not exist"), "ERR_NO_EXIST");
    }
    if (source == null) {
      throw (0, import_err_code52.default)(new Error("could not create source"), "ERR_NO_SOURCE");
    }
    if (destination == null) {
      throw (0, import_err_code52.default)(new Error("could not create destination"), "ERR_NO_DESTINATION");
    }
    if (!options.create && !destination.exists) {
      throw (0, import_err_code52.default)(new Error("file does not exist"), "ERR_NO_EXIST");
    }
    if (destination.entryType !== "file") {
      throw (0, import_err_code52.default)(new Error("not a file"), "ERR_NOT_A_FILE");
    }
    return updateOrImport(context, path, source, destination, options);
  }
  return withTimeoutOption(mfsWrite);
}
var updateOrImport = async (context, path, source, destination, options) => {
  const child = await write(context, source, destination, options);
  await createLock().writeLock(async () => {
    const pathComponents = toPathComponents3(path);
    const fileName = pathComponents.pop();
    if (fileName == null) {
      throw (0, import_err_code52.default)(new Error("source does not exist"), "ERR_NO_EXIST");
    }
    let parentExists = false;
    try {
      await createStat3(context)(`/${pathComponents.join("/")}`, options);
      parentExists = true;
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
    }
    if (!parentExists) {
      await createMkdir(context)(`/${pathComponents.join("/")}`, options);
    }
    const updatedPath = await toMfsPath(context, path, options);
    const trail = await toTrail(context, updatedPath.mfsDirectory);
    const parent2 = trail[trail.length - 1];
    if (!parent2) {
      throw (0, import_err_code52.default)(new Error("directory does not exist"), "ERR_NO_EXIST");
    }
    if (!parent2.type || !parent2.type.includes("directory")) {
      throw (0, import_err_code52.default)(new Error(`cannot write to ${parent2.name}: Not a directory`), "ERR_NOT_A_DIRECTORY");
    }
    const parentBlock = await context.repo.blocks.get(parent2.cid);
    const parentNode = decode5(parentBlock);
    const result = await addLink(context, {
      parent: parentNode,
      name: fileName,
      cid: child.cid,
      size: child.size,
      flush: options.flush,
      shardSplitThreshold: options.shardSplitThreshold,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion
    });
    parent2.cid = result.cid;
    const newRootCid = await updateTree(context, trail, options);
    await updateMfsRoot(context, newRootCid, options);
  })();
};
var write = async (context, source, destination, options) => {
  if (destination.exists) {
    log34(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`);
  } else {
    log34(`Writing file offset ${options.offset} length ${options.length}`);
  }
  const sources = [];
  if (options.offset > 0) {
    if (destination.unixfs) {
      log34(`Writing first ${options.offset} bytes of original file`);
      sources.push(() => {
        return destination.content({
          offset: 0,
          length: options.offset
        });
      });
      if (destination.unixfs.fileSize() < options.offset) {
        const extra = options.offset - destination.unixfs.fileSize();
        log34(`Writing zeros for extra ${extra} bytes`);
        sources.push(asyncZeroes(extra));
      }
    } else {
      log34(`Writing zeros for first ${options.offset} bytes`);
      sources.push(asyncZeroes(options.offset));
    }
  }
  sources.push(limitAsyncStreamBytes(source, options.length));
  const content = countBytesStreamed(catAsyncIterators(sources), (bytesWritten) => {
    if (destination.unixfs && !options.truncate) {
      const fileSize = destination.unixfs.fileSize();
      if (fileSize > bytesWritten) {
        log34(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`);
        return destination.content({ offset: bytesWritten });
      } else {
        log34("Not writing last bytes from original file");
      }
    }
    return {
      [Symbol.asyncIterator]: async function* () {
      }
    };
  });
  let mode;
  if (options.mode !== void 0 && options.mode !== null) {
    mode = parseMode(options.mode);
  } else if (destination && destination.unixfs) {
    mode = destination.unixfs.mode;
  }
  let mtime;
  if (options.mtime != null) {
    mtime = parseMtime(options.mtime);
  } else if (destination && destination.unixfs) {
    mtime = destination.unixfs.mtime;
  }
  const hasher = await context.hashers.getHasher(options.hashAlg);
  const result = await (0, import_it_last9.default)(importer([{
    content,
    mode,
    mtime
  }], context.repo.blocks, {
    progress: options.progress,
    hasher,
    cidVersion: options.cidVersion,
    strategy: options.strategy,
    rawLeaves: options.rawLeaves,
    reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,
    leafType: options.leafType
  }));
  if (!result) {
    throw (0, import_err_code52.default)(new Error(`cannot write to ${parent.name}`), "ERR_COULD_NOT_WRITE");
  }
  log34(`Wrote ${result.cid}`);
  return {
    cid: result.cid,
    size: result.size
  };
};
var limitAsyncStreamBytes = (stream, limit) => {
  return async function* _limitAsyncStreamBytes() {
    let emitted = 0;
    for await (const buf3 of stream) {
      emitted += buf3.length;
      if (emitted > limit) {
        yield buf3.slice(0, limit - emitted);
        return;
      }
      yield buf3;
    }
  };
};
var asyncZeroes = (count, chunkSize2 = MFS_MAX_CHUNK_SIZE) => {
  const buf3 = new Uint8Array(chunkSize2);
  async function* _asyncZeroes() {
    while (true) {
      yield buf3.slice();
    }
  }
  return limitAsyncStreamBytes(_asyncZeroes(), count);
};
var catAsyncIterators = async function* (sources) {
  for (let i = 0; i < sources.length; i++) {
    yield* sources[i]();
  }
};
var countBytesStreamed = async function* (source, notify) {
  let wrote = 0;
  for await (const buf3 of source) {
    wrote += buf3.length;
    yield buf3;
  }
  for await (const buf3 of notify(wrote)) {
    wrote += buf3.length;
    yield buf3;
  }
};

// node_modules/ipfs-core/esm/src/components/files/ls.js
init_globals();
var import_it_map7 = __toESM(require_it_map(), 1);
var toOutput = (fsEntry) => {
  const output = {
    cid: fsEntry.cid,
    name: fsEntry.name,
    type: fsEntry.type === "directory" ? "directory" : "file",
    size: fsEntry.size
  };
  if (fsEntry.type === "file" || fsEntry.type === "directory") {
    output.mode = fsEntry.unixfs.mode;
    output.mtime = fsEntry.unixfs.mtime;
  }
  return output;
};
function createLs3(context) {
  async function* mfsLs(path, options = {}) {
    const mfsPath = await toMfsPath(context, path, options);
    const fsEntry = await exporter(mfsPath.mfsPath, context.repo.blocks);
    if (fsEntry.type === "directory") {
      yield* (0, import_it_map7.default)(fsEntry.content(options), toOutput);
      return;
    }
    yield toOutput(fsEntry);
  }
  return withTimeoutOption(mfsLs);
}

// node_modules/ipfs-core/esm/src/components/files/index.js
var readOperations = { stat: createStat3 };
var writeOperations = {
  chmod: createChmod,
  cp: createCp,
  flush: createFlush,
  mkdir: createMkdir,
  mv: createMv,
  rm: createRm4,
  touch: createTouch
};
var unwrappedOperations = {
  write: createWrite,
  read: createRead,
  ls: createLs3
};
var wrap = ({ options, mfs, operations, lock: lock3 }) => {
  Object.keys(operations).forEach((key) => {
    mfs[key] = lock3(operations[key](options));
  });
};
var defaultOptions13 = {
  repoOwner: true,
  repo: null
};
function createMfs(options) {
  const { repoOwner } = Object.assign({}, defaultOptions13 || {}, options);
  const lock3 = createLock(repoOwner);
  const readLock = (operation) => {
    return lock3.readLock(operation);
  };
  const writeLock = (operation) => {
    return lock3.writeLock(operation);
  };
  const mfs = {};
  wrap({
    options,
    mfs,
    operations: readOperations,
    lock: readLock
  });
  wrap({
    options,
    mfs,
    operations: writeOperations,
    lock: writeLock
  });
  Object.keys(unwrappedOperations).forEach((key) => {
    mfs[key] = unwrappedOperations[key](options);
  });
  return mfs;
}
function createFiles({
  repo,
  preload: preload2,
  hashers,
  options: constructorOptions
}) {
  const methods = createMfs({
    repo,
    repoOwner: Boolean(constructorOptions.repoOwner),
    hashers
  });
  const withPreload = (fn) => {
    const wrapped = (...args) => {
      const paths = args.filter((arg) => import_is_ipfs4.default.ipfsPath(arg) || import_is_ipfs4.default.cid(arg));
      if (paths.length) {
        const options = args[args.length - 1];
        if (options && options.preload !== false) {
          paths.forEach((path) => preload2(path));
        }
      }
      return fn(...args);
    };
    return wrapped;
  };
  return {
    ...methods,
    chmod: methods.chmod,
    cp: withPreload(methods.cp),
    mkdir: methods.mkdir,
    stat: withPreload(methods.stat),
    rm: methods.rm,
    read: withPreload(methods.read),
    touch: methods.touch,
    write: methods.write,
    mv: withPreload(methods.mv),
    flush: methods.flush,
    ls: withPreload(async function* (...args) {
      for await (const file of methods.ls(...args)) {
        yield {
          ...file,
          size: file.size || 0
        };
      }
    })
  };
}

// node_modules/ipfs-core/esm/src/components/key/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/key/export.js
init_globals();
function createExport2({ keychain }) {
  const exportKey = (name10, password) => keychain.exportKey(name10, password);
  return withTimeoutOption(exportKey);
}

// node_modules/ipfs-core/esm/src/components/key/gen.js
init_globals();
var DEFAULT_KEY_TYPE = "ed25519";
var DEFAULT_KEY_SIZE = 2048;
function createGen({ keychain }) {
  const gen = (name10, options = {
    type: DEFAULT_KEY_TYPE,
    size: DEFAULT_KEY_SIZE
  }) => {
    return keychain.createKey(name10, options.type || DEFAULT_KEY_TYPE, options.size || DEFAULT_KEY_SIZE);
  };
  return withTimeoutOption(gen);
}

// node_modules/ipfs-core/esm/src/components/key/import.js
init_globals();
function createImport2({ keychain }) {
  const importKey = (name10, pem, password) => {
    return keychain.importKey(name10, pem, password);
  };
  return withTimeoutOption(importKey);
}

// node_modules/ipfs-core/esm/src/components/key/info.js
init_globals();
function createInfo({ keychain }) {
  const info = (name10) => keychain.findKeyByName(name10);
  return withTimeoutOption(info);
}

// node_modules/ipfs-core/esm/src/components/key/list.js
init_globals();
function createList2({ keychain }) {
  const list = () => keychain.listKeys();
  return withTimeoutOption(list);
}

// node_modules/ipfs-core/esm/src/components/key/rename.js
init_globals();
function createRename({ keychain }) {
  const rename = async (oldName, newName) => {
    const key = await keychain.renameKey(oldName, newName);
    return {
      was: oldName,
      now: key.name,
      id: key.id,
      overwrite: false
    };
  };
  return withTimeoutOption(rename);
}

// node_modules/ipfs-core/esm/src/components/key/rm.js
init_globals();
function createRm5({ keychain }) {
  const rm = (name10) => keychain.removeKey(name10);
  return withTimeoutOption(rm);
}

// node_modules/ipfs-core/esm/src/components/key/index.js
var KeyAPI = class {
  constructor({ keychain }) {
    this.gen = createGen({ keychain });
    this.list = createList2({ keychain });
    this.rm = createRm5({ keychain });
    this.rename = createRename({ keychain });
    this.export = createExport2({ keychain });
    this.import = createImport2({ keychain });
    this.info = createInfo({ keychain });
  }
};

// node_modules/ipfs-core/esm/src/components/object/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/object/data.js
init_globals();

// node_modules/ipfs-core/esm/src/components/object/get.js
init_globals();
function createGet4({ repo, preload: preload2 }) {
  async function get6(cid, options = {}) {
    if (options.preload !== false) {
      preload2(cid);
    }
    const block = await repo.blocks.get(cid, options);
    return decode5(block);
  }
  return withTimeoutOption(get6);
}

// node_modules/ipfs-core/esm/src/components/object/data.js
function createData({ repo, preload: preload2 }) {
  const get6 = createGet4({
    repo,
    preload: preload2
  });
  async function data(multihash, options = {}) {
    const node = await get6(multihash, options);
    return node.Data || new Uint8Array(0);
  }
  return withTimeoutOption(data);
}

// node_modules/ipfs-core/esm/src/components/object/links.js
init_globals();
init_raw();
init_cid();
function findLinks(node, links3 = []) {
  for (const key in node) {
    const val = node[key];
    if (key === "/" && Object.keys(node).length === 1) {
      try {
        links3.push({
          Name: "",
          Tsize: 0,
          Hash: CID.parse(val)
        });
        continue;
      } catch (_) {
      }
    }
    const cid = CID.asCID(val);
    if (cid) {
      links3.push({
        Name: "",
        Tsize: 0,
        Hash: cid
      });
      continue;
    }
    if (Array.isArray(val)) {
      findLinks(val, links3);
    }
    if (val && typeof val === "object") {
      findLinks(val, links3);
    }
  }
  return links3;
}
function createLinks({ repo, codecs: codecs2 }) {
  async function links3(cid, options = {}) {
    const codec = await codecs2.getCodec(cid.code);
    const block = await repo.blocks.get(cid, options);
    const node = codec.decode(block);
    switch (cid.code) {
      case code6:
        return [];
      case code:
        return node.Links;
      case code2:
      case code3:
        return findLinks(node);
      default:
        throw new Error(`Cannot resolve links from codec ${cid.code}`);
    }
  }
  return withTimeoutOption(links3);
}

// node_modules/ipfs-core/esm/src/components/object/new.js
init_globals();
init_sha2_browser();
init_cid();
function createNew({ repo, preload: preload2 }) {
  async function _new(options = {}) {
    let data;
    if (options.template) {
      if (options.template === "unixfs-dir") {
        data = new UnixFS({ type: "directory" }).marshal();
      } else {
        throw new Error("unknown template");
      }
    }
    const buf3 = encode3({
      Data: data,
      Links: []
    });
    const hash2 = await sha256.digest(buf3);
    const cid = CID.createV0(hash2);
    await repo.blocks.put(cid, buf3, { signal: options.signal });
    if (options.preload !== false) {
      preload2(cid);
    }
    return cid;
  }
  return withTimeoutOption(_new);
}

// node_modules/ipfs-core/esm/src/components/object/put.js
init_globals();
init_cid();
init_sha2_browser();
function createPut3({ repo, preload: preload2 }) {
  async function put(obj, options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      const buf3 = encode3(obj);
      const hash2 = await sha256.digest(buf3);
      const cid = CID.createV1(code, hash2);
      await repo.blocks.put(cid, buf3, { signal: options.signal });
      if (options.preload !== false) {
        preload2(cid);
      }
      if (options.pin) {
        await repo.pins.pinRecursively(cid, { signal: options.signal });
      }
      return cid;
    } finally {
      release();
    }
  }
  return withTimeoutOption(put);
}

// node_modules/ipfs-core/esm/src/components/object/stat.js
init_globals();
function createStat4({ repo, preload: preload2 }) {
  const get6 = createGet4({
    repo,
    preload: preload2
  });
  async function stat(cid, options = {}) {
    const node = await get6(cid, options);
    const serialized = encode3(node);
    const blockSize = serialized.length;
    const linkLength = node.Links.reduce((a, l) => a + (l.Tsize || 0), 0);
    return {
      Hash: cid,
      NumLinks: node.Links.length,
      BlockSize: blockSize,
      LinksSize: blockSize - (node.Data || []).length,
      DataSize: (node.Data || []).length,
      CumulativeSize: blockSize + linkLength
    };
  }
  return withTimeoutOption(stat);
}

// node_modules/ipfs-core/esm/src/components/object/patch/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/object/patch/add-link.js
init_globals();
function createAddLink({ repo, preload: preload2 }) {
  const get6 = createGet4({
    repo,
    preload: preload2
  });
  const put = createPut3({
    repo,
    preload: preload2
  });
  async function addLink2(cid, link, options = {}) {
    const node = await get6(cid, options);
    return put({
      ...node,
      Links: node.Links.concat([link])
    }, options);
  }
  return withTimeoutOption(addLink2);
}

// node_modules/ipfs-core/esm/src/components/object/patch/append-data.js
init_globals();
init_concat();
function createAppendData({ repo, preload: preload2 }) {
  const get6 = createGet4({
    repo,
    preload: preload2
  });
  const put = createPut3({
    repo,
    preload: preload2
  });
  async function appendData(cid, data, options = {}) {
    const node = await get6(cid, options);
    const newData = concat2([
      node.Data || [],
      data
    ]);
    return put({
      ...node,
      Data: newData
    }, options);
  }
  return withTimeoutOption(appendData);
}

// node_modules/ipfs-core/esm/src/components/object/patch/rm-link.js
init_globals();
function createRmLink({ repo, preload: preload2 }) {
  const get6 = createGet4({
    repo,
    preload: preload2
  });
  const put = createPut3({
    repo,
    preload: preload2
  });
  async function rmLink(cid, link, options = {}) {
    const node = await get6(cid, options);
    const name10 = (typeof link === "string" ? link : link.Name) || "";
    node.Links = node.Links.filter((l) => l.Name !== name10);
    return put(node, options);
  }
  return withTimeoutOption(rmLink);
}

// node_modules/ipfs-core/esm/src/components/object/patch/set-data.js
init_globals();
function createSetData({ repo, preload: preload2 }) {
  const get6 = createGet4({
    repo,
    preload: preload2
  });
  const put = createPut3({
    repo,
    preload: preload2
  });
  async function setData(cid, data, options = {}) {
    const node = await get6(cid, options);
    return put({
      ...node,
      Data: data
    }, options);
  }
  return withTimeoutOption(setData);
}

// node_modules/ipfs-core/esm/src/components/object/patch/index.js
var ObjectPatchAPI = class {
  constructor({ repo, preload: preload2 }) {
    this.addLink = createAddLink({
      repo,
      preload: preload2
    });
    this.appendData = createAppendData({
      repo,
      preload: preload2
    });
    this.rmLink = createRmLink({
      repo,
      preload: preload2
    });
    this.setData = createSetData({
      repo,
      preload: preload2
    });
  }
};

// node_modules/ipfs-core/esm/src/components/object/index.js
var ObjectAPI = class {
  constructor({ repo, codecs: codecs2, preload: preload2 }) {
    this.data = createData({
      repo,
      preload: preload2
    });
    this.get = createGet4({
      repo,
      preload: preload2
    });
    this.links = createLinks({
      repo,
      codecs: codecs2
    });
    this.new = createNew({
      repo,
      preload: preload2
    });
    this.put = createPut3({
      repo,
      preload: preload2
    });
    this.stat = createStat4({
      repo,
      preload: preload2
    });
    this.patch = new ObjectPatchAPI({
      repo,
      preload: preload2
    });
  }
};

// node_modules/ipfs-core/esm/src/components/repo/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/repo/gc.js
init_globals();
var import_debug35 = __toESM(require_browser2(), 1);
var log35 = (0, import_debug35.default)("ipfs:repo:gc");
function createGc({ repo, hashers }) {
  async function* gc2(options = {}) {
    const start = Date.now();
    let mfsRootCid;
    try {
      mfsRootCid = await loadMfsRoot({
        repo,
        hashers
      }, options);
      await repo.pins.pinRecursively(mfsRootCid);
      yield* repo.gc();
    } finally {
      if (mfsRootCid) {
        await repo.pins.unpin(mfsRootCid);
      }
    }
    log35(`Complete (${Date.now() - start}ms)`);
  }
  return withTimeoutOption(gc2);
}

// node_modules/ipfs-core/esm/src/components/repo/stat.js
init_globals();
function createStat5({ repo }) {
  async function stat(options = {}) {
    const stats = await repo.stat();
    return {
      numObjects: BigInt(stats.numObjects.toString()),
      repoSize: BigInt(stats.repoSize.toString()),
      repoPath: stats.repoPath,
      version: `${stats.version}`,
      storageMax: BigInt(stats.storageMax.toString())
    };
  }
  return withTimeoutOption(stat);
}

// node_modules/ipfs-core/esm/src/components/repo/version.js
init_globals();

// node_modules/ipfs-repo/esm/src/constants.js
init_globals();
var repoVersion = 12;

// node_modules/ipfs-core/esm/src/components/repo/version.js
function createVersion2({ repo }) {
  async function version4(options = {}) {
    try {
      await repo._checkInitialized(options);
    } catch (err) {
      const match = [
        /Key not found in database \[\/version\]/,
        /ENOENT/,
        /repo is not initialized yet/
      ].some((m) => {
        return m.test(err.message);
      });
      if (match) {
        return repoVersion;
      }
      throw err;
    }
    return repo.version.get();
  }
  return withTimeoutOption(version4);
}

// node_modules/ipfs-core/esm/src/components/repo/index.js
var RepoAPI = class {
  constructor({ repo, hashers }) {
    this.gc = createGc({
      repo,
      hashers
    });
    this.stat = createStat5({ repo });
    this.version = createVersion2({ repo });
    this.setApiAddr = (addr) => repo.apiAddr.set(addr);
  }
};

// node_modules/ipfs-core/esm/src/components/stats/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/stats/bw.js
init_globals();
var import_err_code53 = __toESM(require_err_code(), 1);
var import_peer_id10 = __toESM(require_src5(), 1);
function getBandwidthStats(libp2p, opts) {
  let stats;
  if (!libp2p.metrics) {
    stats = void 0;
  } else if (opts.peer) {
    stats = libp2p.metrics.forPeer(import_peer_id10.default.parse(opts.peer));
  } else if (opts.proto) {
    stats = libp2p.metrics.forProtocol(opts.proto);
  } else {
    stats = libp2p.metrics.global;
  }
  if (!stats) {
    return {
      totalIn: BigInt(0),
      totalOut: BigInt(0),
      rateIn: 0,
      rateOut: 0
    };
  }
  const { movingAverages, snapshot } = stats;
  return {
    totalIn: BigInt(snapshot.dataReceived.integerValue().toString()),
    totalOut: BigInt(snapshot.dataSent.integerValue().toString()),
    rateIn: movingAverages.dataReceived[6e4].movingAverage() / 60,
    rateOut: movingAverages.dataSent[6e4].movingAverage() / 60
  };
}
function createBw({ network }) {
  const bw = async function* (options = {}) {
    const { libp2p } = await network.use(options);
    if (!options.poll) {
      yield getBandwidthStats(libp2p, options);
      return;
    }
    const interval = options.interval || 1e3;
    let ms = -1;
    try {
      ms = typeof interval === "string" ? parse_duration_default(interval) || -1 : interval;
      if (!ms || ms < 0)
        throw new Error("invalid duration");
    } catch (err) {
      throw (0, import_err_code53.default)(err, "ERR_INVALID_POLL_INTERVAL");
    }
    let timeoutId;
    try {
      while (true) {
        yield getBandwidthStats(libp2p, options);
        await new Promise((resolve11) => {
          timeoutId = setTimeout(resolve11, ms);
        });
      }
    } finally {
      clearTimeout(timeoutId);
    }
  };
  return withTimeoutOption(bw);
}

// node_modules/ipfs-core/esm/src/components/stats/index.js
var StatsAPI = class {
  constructor({ repo, network }) {
    this.repo = createStat5({ repo });
    this.bw = createBw({ network });
    this.bitswap = createStat({ network });
  }
};

// node_modules/ipfs-core/esm/src/components/storage.js
init_globals();
var import_debug47 = __toESM(require_browser2(), 1);

// node_modules/ipfs-core-config/esm/src/repo.browser.js
init_globals();

// node_modules/ipfs-repo/esm/src/index.js
init_globals();
var import_just_safe_get2 = __toESM(require_just_safe_get(), 1);
var import_debug44 = __toESM(require_browser2(), 1);
var import_err_code59 = __toESM(require_err_code(), 1);

// node_modules/ipfs-repo-migrations/esm/src/index.js
init_globals();

// node_modules/ipfs-repo-migrations/esm/migrations/index.js
init_globals();

// node_modules/ipfs-repo-migrations/esm/migrations/migration-8/index.js
init_globals();
init_cid();
init_key();
var import_debug36 = __toESM(require_browser2(), 1);
var import_it_length = __toESM(require_it_length(), 1);
init_base32();
init_raw();
init_digest();
var log36 = (0, import_debug36.default)("ipfs:repo:migrator:migration-8");
function unwrap(blockstore) {
  if (blockstore.child) {
    return unwrap(blockstore.child);
  }
  return blockstore;
}
function keyToMultihash(key) {
  try {
    const buf3 = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const multihash = CID.decode(buf3).multihash.bytes;
    const multihashStr = base32.encode(multihash).slice(1).toUpperCase();
    return new Key(`/${multihashStr}`, false);
  } catch (err) {
    return key;
  }
}
function keyToCid(key) {
  try {
    const buf3 = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const digest3 = decode3(buf3);
    const multihash = base32.encode(CID.createV1(code6, digest3).bytes).slice(1);
    return new Key(`/${multihash.toUpperCase()}`, false);
  } catch {
    return key;
  }
}
async function process2(backends, onProgress, keyFunction) {
  const blockstore = backends.blocks;
  await blockstore.open();
  const unwrapped = unwrap(blockstore);
  const blockCount = await (0, import_it_length.default)(unwrapped.queryKeys({
    filters: [(key) => {
      const newKey = keyFunction(key);
      return newKey.toString() !== key.toString();
    }]
  }));
  try {
    let counter = 0;
    for await (const block of unwrapped.query({})) {
      const newKey = keyFunction(block.key);
      if (newKey.toString() !== block.key.toString()) {
        counter += 1;
        log36(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key));
        await unwrapped.delete(block.key);
        await unwrapped.put(newKey, block.value);
        onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);
      }
    }
  } finally {
    await blockstore.close();
  }
}
var migration = {
  version: 8,
  description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",
  migrate: (backends, onProgress = () => {
  }) => {
    return process2(backends, onProgress, keyToMultihash);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process2(backends, onProgress, keyToCid);
  }
};

// node_modules/ipfs-repo-migrations/esm/migrations/migration-9/index.js
init_globals();
init_cid();
init_cborg();

// node_modules/ipfs-repo-migrations/esm/migrations/migration-9/pin-set.js
init_globals();
init_cid();

// node_modules/ipfs-repo-migrations/esm/migrations/migration-9/pin.js
init_globals();
var import_minimal3 = __toESM(require_minimal2(), 1);
var $Reader3 = import_minimal3.default.Reader;
var $Writer3 = import_minimal3.default.Writer;
var $util3 = import_minimal3.default.util;
var $root3 = import_minimal3.default.roots["default"] || (import_minimal3.default.roots["default"] = {});
var ipfs = $root3.ipfs = (() => {
  const ipfs2 = {};
  ipfs2.pin = function() {
    const pin = {};
    pin.Set = function() {
      function Set2(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Set2.prototype.version = 0;
      Set2.prototype.fanout = 0;
      Set2.prototype.seed = 0;
      Set2.encode = function encode19(m, w) {
        if (!w)
          w = $Writer3.create();
        if (m.version != null && Object.hasOwnProperty.call(m, "version"))
          w.uint32(8).uint32(m.version);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(16).uint32(m.fanout);
        if (m.seed != null && Object.hasOwnProperty.call(m, "seed"))
          w.uint32(29).fixed32(m.seed);
        return w;
      };
      Set2.decode = function decode22(r, l) {
        if (!(r instanceof $Reader3))
          r = $Reader3.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root3.ipfs.pin.Set();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.version = r.uint32();
              break;
            case 2:
              m.fanout = r.uint32();
              break;
            case 3:
              m.seed = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Set2.fromObject = function fromObject(d) {
        if (d instanceof $root3.ipfs.pin.Set)
          return d;
        var m = new $root3.ipfs.pin.Set();
        if (d.version != null) {
          m.version = d.version >>> 0;
        }
        if (d.fanout != null) {
          m.fanout = d.fanout >>> 0;
        }
        if (d.seed != null) {
          m.seed = d.seed >>> 0;
        }
        return m;
      };
      Set2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.version = 0;
          d.fanout = 0;
          d.seed = 0;
        }
        if (m.version != null && m.hasOwnProperty("version")) {
          d.version = m.version;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          d.fanout = m.fanout;
        }
        if (m.seed != null && m.hasOwnProperty("seed")) {
          d.seed = m.seed;
        }
        return d;
      };
      Set2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal3.default.util.toJSONOptions);
      };
      return Set2;
    }();
    return pin;
  }();
  return ipfs2;
})();

// node_modules/ipfs-repo-migrations/esm/migrations/migration-9/pin-set.js
var import_fnv1a = __toESM(require_fnv1a(), 1);
var import_varint4 = __toESM(require_varint(), 1);

// node_modules/ipfs-repo-migrations/esm/migrations/migration-9/utils.js
init_globals();
init_key();
init_base32();
init_cid();
var PIN_DS_KEY = new Key("/local/pins");
var DEFAULT_FANOUT = 256;
var MAX_ITEMS = 8192;
var EMPTY_KEY = CID.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n");
var PinTypes2 = {
  direct: "direct",
  recursive: "recursive"
};
function cidToKey(cid) {
  return new Key(`/${base32.encode(cid.multihash.bytes).toUpperCase().substring(1)}`);
}

// node_modules/ipfs-repo-migrations/esm/migrations/migration-9/pin-set.js
init_concat();
init_compare();
init_to_string();
init_from_string();
init_sha2_browser();
var PinSet = ipfs.pin.Set;
function readHeader2(rootNode) {
  const rootData = rootNode.Data;
  if (!rootData) {
    throw new Error("No data present");
  }
  const hdrLength = import_varint4.default.decode(rootData);
  const vBytes = import_varint4.default.decode.bytes;
  if (vBytes <= 0) {
    throw new Error("Invalid Set header length");
  }
  if (vBytes + hdrLength > rootData.length) {
    throw new Error("Impossibly large set header length");
  }
  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);
  const header = PinSet.toObject(PinSet.decode(hdrSlice), {
    defaults: false,
    arrays: true,
    longs: Number,
    objects: false
  });
  if (header.version !== 1) {
    throw new Error(`Unsupported Set version: ${header.version}`);
  }
  if (header.fanout > rootNode.Links.length) {
    throw new Error("Impossibly large fanout");
  }
  return {
    header,
    data: rootData.slice(hdrLength + vBytes)
  };
}
function hash(seed, key) {
  const buffer3 = new Uint8Array(4);
  const dataView3 = new DataView(buffer3.buffer);
  dataView3.setUint32(0, seed, true);
  const encodedKey = fromString3(key.toString());
  const data = concat2([
    buffer3,
    encodedKey
  ], buffer3.byteLength + encodedKey.byteLength);
  return (0, import_fnv1a.default)(toString3(data));
}
async function* walkItems(blockstore, node) {
  const pbh = readHeader2(node);
  let idx = 0;
  for (const link of node.Links) {
    if (idx < pbh.header.fanout) {
      const linkHash = link.Hash;
      if (!EMPTY_KEY.equals(linkHash)) {
        const buf3 = await blockstore.get(linkHash);
        const node2 = decode5(buf3);
        yield* walkItems(blockstore, node2);
      }
    } else {
      yield link.Hash;
    }
    idx++;
  }
}
async function* loadSet(blockstore, rootNode, name10) {
  const link = rootNode.Links.find((l) => l.Name === name10);
  if (!link) {
    throw new Error("No link found with name " + name10);
  }
  const buf3 = await blockstore.get(link.Hash);
  const node = decode5(buf3);
  yield* walkItems(blockstore, node);
}
function storeItems(blockstore, items) {
  return storePins(items, 0);
  async function storePins(pins, depth) {
    const pbHeader = PinSet.encode({
      version: 1,
      fanout: DEFAULT_FANOUT,
      seed: depth
    }).finish();
    const header = import_varint4.default.encode(pbHeader.length);
    const headerBuf = concat2([
      header,
      pbHeader
    ]);
    const fanoutLinks = [];
    for (let i = 0; i < DEFAULT_FANOUT; i++) {
      fanoutLinks.push({
        Name: "",
        Tsize: 1,
        Hash: EMPTY_KEY
      });
    }
    if (pins.length <= MAX_ITEMS) {
      const nodes = pins.map((item) => {
        return {
          link: {
            Name: "",
            Tsize: 1,
            Hash: item.key
          },
          data: item.data || new Uint8Array()
        };
      }).sort((a, b) => {
        return compare2(a.link.Hash.bytes, b.link.Hash.bytes);
      });
      const rootLinks = fanoutLinks.concat(nodes.map((item) => item.link));
      const rootData = concat2([
        headerBuf,
        ...nodes.map((item) => item.data)
      ]);
      return {
        Data: rootData,
        Links: rootLinks
      };
    } else {
      const bins = pins.reduce((bins2, pin) => {
        const n = hash(depth, pin.key) % DEFAULT_FANOUT;
        bins2[n] = n in bins2 ? bins2[n].concat([pin]) : [pin];
        return bins2;
      }, []);
      let idx = 0;
      for (const bin of bins) {
        const child = await storePins(bin, depth + 1);
        await storeChild(child, idx);
        idx++;
      }
      return {
        Data: headerBuf,
        Links: fanoutLinks
      };
    }
    async function storeChild(child, binIdx) {
      const buf3 = encode3(child);
      const digest3 = await sha256.digest(buf3);
      const cid = CID.createV0(digest3);
      await blockstore.put(cid, buf3);
      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf3.length;
      fanoutLinks[binIdx] = {
        Name: "",
        Tsize: size,
        Hash: cid
      };
    }
  }
}
async function storeSet(blockstore, type, cids) {
  const rootNode = await storeItems(blockstore, cids.map((cid2) => {
    return { key: cid2 };
  }));
  const buf3 = encode3(rootNode);
  const digest3 = await sha256.digest(buf3);
  const cid = CID.createV0(digest3);
  await blockstore.put(cid, buf3);
  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf3.length;
  return {
    Name: type,
    Tsize: size,
    Hash: cid
  };
}

// node_modules/ipfs-repo-migrations/esm/migrations/migration-9/index.js
var import_it_length2 = __toESM(require_it_length(), 1);
init_sha2_browser();
init_digest();
init_base32();
async function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {
  if (!await datastore.has(PIN_DS_KEY)) {
    return;
  }
  const mh = await datastore.get(PIN_DS_KEY);
  const cid = CID.decode(mh);
  const pinRootBuf = await blockstore.get(cid);
  const pinRoot = decode5(pinRootBuf);
  let counter = 0;
  const pinCount = await (0, import_it_length2.default)(loadSet(blockstore, pinRoot, PinTypes2.recursive)) + await (0, import_it_length2.default)(loadSet(blockstore, pinRoot, PinTypes2.direct));
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes2.recursive)) {
    counter++;
    const pin = { depth: Infinity };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode4(pin));
    onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid2}`);
  }
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes2.direct)) {
    counter++;
    const pin = { depth: 0 };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode4(pin));
    onProgress(counter / pinCount * 100, `Migrated direct pin ${cid2}`);
  }
  await blockstore.delete(cid);
  await datastore.delete(PIN_DS_KEY);
}
async function pinsToDAG(blockstore, datastore, pinstore, onProgress) {
  const recursivePins = [];
  const directPins = [];
  let counter = 0;
  const pinCount = await (0, import_it_length2.default)(pinstore.queryKeys({}));
  for await (const { key, value } of pinstore.query({})) {
    counter++;
    const pin = decode6(value);
    const cid2 = CID.create(pin.version || 0, pin.codec || code, decode3(base32.decode("b" + key.toString().toLowerCase().split("/").pop())));
    if (pin.depth === 0) {
      onProgress(counter / pinCount * 100, `Reverted direct pin ${cid2}`);
      directPins.push(cid2);
    } else {
      onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid2}`);
      recursivePins.push(cid2);
    }
  }
  onProgress(100, "Updating pin root");
  const pinRoot = {
    Links: [
      await storeSet(blockstore, PinTypes2.direct, directPins),
      await storeSet(blockstore, PinTypes2.recursive, recursivePins)
    ]
  };
  const buf3 = encode3(pinRoot);
  const digest3 = await sha256.digest(buf3);
  const cid = CID.createV0(digest3);
  await blockstore.put(cid, buf3);
  await datastore.put(PIN_DS_KEY, cid.bytes);
}
async function process3(backends, onProgress, fn) {
  const blockstore = backends.blocks;
  const datastore = backends.datastore;
  const pinstore = backends.pins;
  await blockstore.open();
  await datastore.open();
  await pinstore.open();
  try {
    await fn(blockstore, datastore, pinstore, onProgress);
  } finally {
    await pinstore.close();
    await datastore.close();
    await blockstore.close();
  }
}
var migration2 = {
  version: 9,
  description: "Migrates pins to datastore",
  migrate: (backends, onProgress = () => {
  }) => {
    return process3(backends, onProgress, pinsToDatastore);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process3(backends, onProgress, pinsToDAG);
  }
};

// node_modules/ipfs-repo-migrations/esm/migrations/migration-10/index.js
init_globals();

// node_modules/ipfs-repo-migrations/esm/src/utils.js
init_globals();
init_key();
init_errors();
var CONFIG_KEY = new Key("/config");
var VERSION_KEY = new Key("/version");
function findLevelJs(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
async function hasWithFallback(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve11, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve11(Boolean(req.result));
    };
  });
}
async function getWithFallback(key, get6, has, store) {
  if (await has(key)) {
    return get6(key);
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    throw notFoundError();
  }
  return new Promise((resolve11, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve11(req.result);
      }
      reject(notFoundError());
    };
  });
}
function wrapStore(store) {
  const originalGet = store.get.bind(store);
  const originalHas = store.has.bind(store);
  store.get = (key) => getWithFallback(key, originalGet, originalHas, store);
  store.has = (key) => hasWithFallback(key, originalHas, store);
  return store;
}
function wrapBackends(backends) {
  return {
    ...backends,
    root: wrapStore(backends.root),
    datastore: wrapStore(backends.datastore),
    pins: wrapStore(backends.pins),
    keys: wrapStore(backends.keys)
  };
}

// node_modules/ipfs-repo-migrations/esm/migrations/migration-10/index.js
init_from_string();
init_to_string();
async function keysToBinary(name10, store, onProgress = () => {
}) {
  const db = findLevelJs(store);
  if (!db) {
    onProgress(`${name10} did not need an upgrade`);
    return;
  }
  onProgress(`Upgrading ${name10}`);
  const upgrade = (key, value) => {
    return [
      {
        type: "del",
        key
      },
      {
        type: "put",
        key: fromString3(key),
        value
      }
    ];
  };
  await withEach(db, upgrade);
}
async function keysToStrings(name10, store, onProgress = () => {
}) {
  const db = findLevelJs(store);
  if (!db) {
    onProgress(`${name10} did not need a downgrade`);
    return;
  }
  onProgress(`Downgrading ${name10}`);
  const downgrade = (key, value) => {
    return [
      {
        type: "del",
        key
      },
      {
        type: "put",
        key: toString3(key),
        value
      }
    ];
  };
  await withEach(db, downgrade);
}
function unwrap2(store) {
  if (store.child) {
    return unwrap2(store.child);
  }
  return store;
}
async function process4(backends, onProgress, fn) {
  const datastores = Object.entries(backends).map(([key, backend]) => ({
    key,
    backend: unwrap2(backend)
  })).filter(({ key, backend }) => backend.constructor.name === "LevelDatastore").map(({ key, backend }) => ({
    name: key,
    store: backend
  }));
  onProgress(0, `Migrating ${datastores.length} dbs`);
  let migrated = 0;
  const progress = (message) => {
    onProgress(Math.round(migrated / datastores.length * 100), message);
  };
  for (const { name: name10, store } of datastores) {
    await store.open();
    try {
      await fn(name10, store, progress);
    } finally {
      migrated++;
      await store.close();
    }
  }
  onProgress(100, `Migrated ${datastores.length} dbs`);
}
var migration3 = {
  version: 10,
  description: "Migrates datastore-level keys to binary",
  migrate: (backends, onProgress = () => {
  }) => {
    return process4(backends, onProgress, keysToBinary);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process4(backends, onProgress, keysToStrings);
  }
};
function withEach(db, fn) {
  function batch3(operations, next) {
    const store = db.store("readwrite");
    const transaction = store.transaction;
    let index = 0;
    let error;
    transaction.onabort = () => next(error || transaction.error || new Error("aborted by user"));
    transaction.oncomplete = () => next();
    function loop() {
      const op = operations[index++];
      const key = op.key;
      let req;
      try {
        req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
      } catch (err) {
        error = err;
        transaction.abort();
        return;
      }
      if (index < operations.length) {
        req.onsuccess = loop;
      }
    }
    loop();
  }
  return new Promise((resolve11, reject) => {
    const it = db.iterator();
    const id = (data) => data;
    it._deserializeKey = it._deserializeValue = id;
    next();
    function next() {
      const handleNext = (err, key, value) => {
        if (err || key === void 0) {
          const handleEnd = (err2) => {
            if (err2) {
              reject(err2);
              return;
            }
            resolve11();
          };
          it.end(handleEnd);
          return;
        }
        batch3(fn(key, value), next);
      };
      it.next(handleNext);
    }
  });
}

// node_modules/ipfs-repo-migrations/esm/migrations/migration-11/index.js
init_globals();
init_key();
var MFS_ROOT_KEY2 = new Key("/local/filesroot");
async function storeMfsRootInDatastore(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.root.has(MFS_ROOT_KEY2)) {
    const root = await backends.root.get(MFS_ROOT_KEY2);
    await backends.datastore.put(MFS_ROOT_KEY2, root);
    await backends.root.delete(MFS_ROOT_KEY2);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo datastore");
}
async function storeMfsRootInRoot(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo root datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.datastore.has(MFS_ROOT_KEY2)) {
    const root = await backends.datastore.get(MFS_ROOT_KEY2);
    await backends.root.put(MFS_ROOT_KEY2, root);
    await backends.datastore.delete(MFS_ROOT_KEY2);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo root datastore");
}
var migration4 = {
  version: 11,
  description: "Store mfs root in the datastore",
  migrate: storeMfsRootInDatastore,
  revert: storeMfsRootInRoot
};

// node_modules/ipfs-repo-migrations/esm/migrations/migration-12/index.js
init_globals();
var import_minimal9 = __toESM(require_minimal2(), 1);
init_key();

// node_modules/ipfs-repo-migrations/esm/migrations/migration-12/pb/proto-book.js
init_globals();
var import_minimal4 = __toESM(require_minimal2(), 1);
var $Reader4 = import_minimal4.default.Reader;
var $Writer4 = import_minimal4.default.Writer;
var $util4 = import_minimal4.default.util;
var $root4 = import_minimal4.default.roots["default"] || (import_minimal4.default.roots["default"] = {});
var Protocols = $root4.Protocols = (() => {
  function Protocols2(p) {
    this.protocols = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Protocols2.prototype.protocols = $util4.emptyArray;
  Protocols2.encode = function encode19(m, w) {
    if (!w)
      w = $Writer4.create();
    if (m.protocols != null && m.protocols.length) {
      for (var i = 0; i < m.protocols.length; ++i)
        w.uint32(10).string(m.protocols[i]);
    }
    return w;
  };
  Protocols2.decode = function decode22(r, l) {
    if (!(r instanceof $Reader4))
      r = $Reader4.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Protocols();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Protocols2.fromObject = function fromObject(d) {
    if (d instanceof $root4.Protocols)
      return d;
    var m = new $root4.Protocols();
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Protocols.protocols: array expected");
      m.protocols = [];
      for (var i = 0; i < d.protocols.length; ++i) {
        m.protocols[i] = String(d.protocols[i]);
      }
    }
    return m;
  };
  Protocols2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.protocols = [];
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    return d;
  };
  Protocols2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
  };
  return Protocols2;
})();

// node_modules/ipfs-repo-migrations/esm/migrations/migration-12/pb/address-book.js
init_globals();
var import_minimal5 = __toESM(require_minimal2(), 1);
var $Reader5 = import_minimal5.default.Reader;
var $Writer5 = import_minimal5.default.Writer;
var $util5 = import_minimal5.default.util;
var $root5 = import_minimal5.default.roots["default"] || (import_minimal5.default.roots["default"] = {});
var Addresses = $root5.Addresses = (() => {
  function Addresses2(p) {
    this.addrs = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Addresses2.prototype.addrs = $util5.emptyArray;
  Addresses2.prototype.certifiedRecord = null;
  Addresses2.encode = function encode19(m, w) {
    if (!w)
      w = $Writer5.create();
    if (m.addrs != null && m.addrs.length) {
      for (var i = 0; i < m.addrs.length; ++i)
        $root5.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();
    }
    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, "certifiedRecord"))
      $root5.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();
    return w;
  };
  Addresses2.decode = function decode22(r, l) {
    if (!(r instanceof $Reader5))
      r = $Reader5.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Addresses();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addrs && m.addrs.length))
            m.addrs = [];
          m.addrs.push($root5.Addresses.Address.decode(r, r.uint32()));
          break;
        case 2:
          m.certifiedRecord = $root5.Addresses.CertifiedRecord.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Addresses2.fromObject = function fromObject(d) {
    if (d instanceof $root5.Addresses)
      return d;
    var m = new $root5.Addresses();
    if (d.addrs) {
      if (!Array.isArray(d.addrs))
        throw TypeError(".Addresses.addrs: array expected");
      m.addrs = [];
      for (var i = 0; i < d.addrs.length; ++i) {
        if (typeof d.addrs[i] !== "object")
          throw TypeError(".Addresses.addrs: object expected");
        m.addrs[i] = $root5.Addresses.Address.fromObject(d.addrs[i]);
      }
    }
    if (d.certifiedRecord != null) {
      if (typeof d.certifiedRecord !== "object")
        throw TypeError(".Addresses.certifiedRecord: object expected");
      m.certifiedRecord = $root5.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);
    }
    return m;
  };
  Addresses2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addrs = [];
    }
    if (o.defaults) {
      d.certifiedRecord = null;
    }
    if (m.addrs && m.addrs.length) {
      d.addrs = [];
      for (var j = 0; j < m.addrs.length; ++j) {
        d.addrs[j] = $root5.Addresses.Address.toObject(m.addrs[j], o);
      }
    }
    if (m.certifiedRecord != null && m.hasOwnProperty("certifiedRecord")) {
      d.certifiedRecord = $root5.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);
    }
    return d;
  };
  Addresses2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal5.default.util.toJSONOptions);
  };
  Addresses2.Address = function() {
    function Address2(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    Address2.prototype.multiaddr = $util5.newBuffer([]);
    Address2.prototype.isCertified = null;
    let $oneOfFields;
    Object.defineProperty(Address2.prototype, "_isCertified", {
      get: $util5.oneOfGetter($oneOfFields = ["isCertified"]),
      set: $util5.oneOfSetter($oneOfFields)
    });
    Address2.encode = function encode19(m, w) {
      if (!w)
        w = $Writer5.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
        w.uint32(16).bool(m.isCertified);
      return w;
    };
    Address2.decode = function decode22(r, l) {
      if (!(r instanceof $Reader5))
        r = $Reader5.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Addresses.Address();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          case 2:
            m.isCertified = r.bool();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Address2.fromObject = function fromObject(d) {
      if (d instanceof $root5.Addresses.Address)
        return d;
      var m = new $root5.Addresses.Address();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util5.base64.decode(d.multiaddr, m.multiaddr = $util5.newBuffer($util5.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      if (d.isCertified != null) {
        m.isCertified = Boolean(d.isCertified);
      }
      return m;
    };
    Address2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util5.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util5.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
        d.isCertified = m.isCertified;
        if (o.oneofs)
          d._isCertified = "isCertified";
      }
      return d;
    };
    Address2.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal5.default.util.toJSONOptions);
    };
    return Address2;
  }();
  Addresses2.CertifiedRecord = function() {
    function CertifiedRecord(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    CertifiedRecord.prototype.seq = $util5.Long ? $util5.Long.fromBits(0, 0, true) : 0;
    CertifiedRecord.prototype.raw = $util5.newBuffer([]);
    CertifiedRecord.encode = function encode19(m, w) {
      if (!w)
        w = $Writer5.create();
      if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
        w.uint32(8).uint64(m.seq);
      if (m.raw != null && Object.hasOwnProperty.call(m, "raw"))
        w.uint32(18).bytes(m.raw);
      return w;
    };
    CertifiedRecord.decode = function decode22(r, l) {
      if (!(r instanceof $Reader5))
        r = $Reader5.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Addresses.CertifiedRecord();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.seq = r.uint64();
            break;
          case 2:
            m.raw = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    CertifiedRecord.fromObject = function fromObject(d) {
      if (d instanceof $root5.Addresses.CertifiedRecord)
        return d;
      var m = new $root5.Addresses.CertifiedRecord();
      if (d.seq != null) {
        if ($util5.Long)
          (m.seq = $util5.Long.fromValue(d.seq)).unsigned = true;
        else if (typeof d.seq === "string")
          m.seq = parseInt(d.seq, 10);
        else if (typeof d.seq === "number")
          m.seq = d.seq;
        else if (typeof d.seq === "object")
          m.seq = new $util5.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
      }
      if (d.raw != null) {
        if (typeof d.raw === "string")
          $util5.base64.decode(d.raw, m.raw = $util5.newBuffer($util5.base64.length(d.raw)), 0);
        else if (d.raw.length)
          m.raw = d.raw;
      }
      return m;
    };
    CertifiedRecord.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if ($util5.Long) {
          var n = new $util5.Long(0, 0, true);
          d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
        } else
          d.seq = o.longs === String ? "0" : 0;
        if (o.bytes === String)
          d.raw = "";
        else {
          d.raw = [];
          if (o.bytes !== Array)
            d.raw = $util5.newBuffer(d.raw);
        }
      }
      if (m.seq != null && m.hasOwnProperty("seq")) {
        if (typeof m.seq === "number")
          d.seq = o.longs === String ? String(m.seq) : m.seq;
        else
          d.seq = o.longs === String ? $util5.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util5.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
      }
      if (m.raw != null && m.hasOwnProperty("raw")) {
        d.raw = o.bytes === String ? $util5.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;
      }
      return d;
    };
    CertifiedRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal5.default.util.toJSONOptions);
    };
    return CertifiedRecord;
  }();
  return Addresses2;
})();

// node_modules/ipfs-repo-migrations/esm/migrations/migration-12/pb/peer.js
init_globals();
var import_minimal6 = __toESM(require_minimal2(), 1);
var $Reader6 = import_minimal6.default.Reader;
var $Writer6 = import_minimal6.default.Writer;
var $util6 = import_minimal6.default.util;
var $root6 = import_minimal6.default.roots["default"] || (import_minimal6.default.roots["default"] = {});
var Peer2 = $root6.Peer = (() => {
  function Peer3(p) {
    this.addresses = [];
    this.protocols = [];
    this.metadata = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Peer3.prototype.addresses = $util6.emptyArray;
  Peer3.prototype.protocols = $util6.emptyArray;
  Peer3.prototype.metadata = $util6.emptyArray;
  Peer3.prototype.pubKey = null;
  Peer3.prototype.peerRecordEnvelope = null;
  let $oneOfFields;
  Object.defineProperty(Peer3.prototype, "_pubKey", {
    get: $util6.oneOfGetter($oneOfFields = ["pubKey"]),
    set: $util6.oneOfSetter($oneOfFields)
  });
  Object.defineProperty(Peer3.prototype, "_peerRecordEnvelope", {
    get: $util6.oneOfGetter($oneOfFields = ["peerRecordEnvelope"]),
    set: $util6.oneOfSetter($oneOfFields)
  });
  Peer3.encode = function encode19(m, w) {
    if (!w)
      w = $Writer6.create();
    if (m.addresses != null && m.addresses.length) {
      for (var i = 0; i < m.addresses.length; ++i)
        $root6.Address.encode(m.addresses[i], w.uint32(10).fork()).ldelim();
    }
    if (m.protocols != null && m.protocols.length) {
      for (var i = 0; i < m.protocols.length; ++i)
        w.uint32(18).string(m.protocols[i]);
    }
    if (m.metadata != null && m.metadata.length) {
      for (var i = 0; i < m.metadata.length; ++i)
        $root6.Metadata.encode(m.metadata[i], w.uint32(26).fork()).ldelim();
    }
    if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
      w.uint32(34).bytes(m.pubKey);
    if (m.peerRecordEnvelope != null && Object.hasOwnProperty.call(m, "peerRecordEnvelope"))
      w.uint32(42).bytes(m.peerRecordEnvelope);
    return w;
  };
  Peer3.decode = function decode22(r, l) {
    if (!(r instanceof $Reader6))
      r = $Reader6.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root6.Peer();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root6.Address.decode(r, r.uint32()));
          break;
        case 2:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        case 3:
          if (!(m.metadata && m.metadata.length))
            m.metadata = [];
          m.metadata.push($root6.Metadata.decode(r, r.uint32()));
          break;
        case 4:
          m.pubKey = r.bytes();
          break;
        case 5:
          m.peerRecordEnvelope = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Peer3.fromObject = function fromObject(d) {
    if (d instanceof $root6.Peer)
      return d;
    var m = new $root6.Peer();
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".Peer.addresses: array expected");
      m.addresses = [];
      for (var i = 0; i < d.addresses.length; ++i) {
        if (typeof d.addresses[i] !== "object")
          throw TypeError(".Peer.addresses: object expected");
        m.addresses[i] = $root6.Address.fromObject(d.addresses[i]);
      }
    }
    if (d.protocols) {
      if (!Array.isArray(d.protocols))
        throw TypeError(".Peer.protocols: array expected");
      m.protocols = [];
      for (var i = 0; i < d.protocols.length; ++i) {
        m.protocols[i] = String(d.protocols[i]);
      }
    }
    if (d.metadata) {
      if (!Array.isArray(d.metadata))
        throw TypeError(".Peer.metadata: array expected");
      m.metadata = [];
      for (var i = 0; i < d.metadata.length; ++i) {
        if (typeof d.metadata[i] !== "object")
          throw TypeError(".Peer.metadata: object expected");
        m.metadata[i] = $root6.Metadata.fromObject(d.metadata[i]);
      }
    }
    if (d.pubKey != null) {
      if (typeof d.pubKey === "string")
        $util6.base64.decode(d.pubKey, m.pubKey = $util6.newBuffer($util6.base64.length(d.pubKey)), 0);
      else if (d.pubKey.length)
        m.pubKey = d.pubKey;
    }
    if (d.peerRecordEnvelope != null) {
      if (typeof d.peerRecordEnvelope === "string")
        $util6.base64.decode(d.peerRecordEnvelope, m.peerRecordEnvelope = $util6.newBuffer($util6.base64.length(d.peerRecordEnvelope)), 0);
      else if (d.peerRecordEnvelope.length)
        m.peerRecordEnvelope = d.peerRecordEnvelope;
    }
    return m;
  };
  Peer3.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
      d.protocols = [];
      d.metadata = [];
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root6.Address.toObject(m.addresses[j], o);
      }
    }
    if (m.protocols && m.protocols.length) {
      d.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d.protocols[j] = m.protocols[j];
      }
    }
    if (m.metadata && m.metadata.length) {
      d.metadata = [];
      for (var j = 0; j < m.metadata.length; ++j) {
        d.metadata[j] = $root6.Metadata.toObject(m.metadata[j], o);
      }
    }
    if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
      d.pubKey = o.bytes === String ? $util6.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
      if (o.oneofs)
        d._pubKey = "pubKey";
    }
    if (m.peerRecordEnvelope != null && m.hasOwnProperty("peerRecordEnvelope")) {
      d.peerRecordEnvelope = o.bytes === String ? $util6.base64.encode(m.peerRecordEnvelope, 0, m.peerRecordEnvelope.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerRecordEnvelope) : m.peerRecordEnvelope;
      if (o.oneofs)
        d._peerRecordEnvelope = "peerRecordEnvelope";
    }
    return d;
  };
  Peer3.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
  };
  return Peer3;
})();
var Address = $root6.Address = (() => {
  function Address2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Address2.prototype.multiaddr = $util6.newBuffer([]);
  Address2.prototype.isCertified = null;
  let $oneOfFields;
  Object.defineProperty(Address2.prototype, "_isCertified", {
    get: $util6.oneOfGetter($oneOfFields = ["isCertified"]),
    set: $util6.oneOfSetter($oneOfFields)
  });
  Address2.encode = function encode19(m, w) {
    if (!w)
      w = $Writer6.create();
    if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
      w.uint32(10).bytes(m.multiaddr);
    if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
      w.uint32(16).bool(m.isCertified);
    return w;
  };
  Address2.decode = function decode22(r, l) {
    if (!(r instanceof $Reader6))
      r = $Reader6.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root6.Address();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.multiaddr = r.bytes();
          break;
        case 2:
          m.isCertified = r.bool();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Address2.fromObject = function fromObject(d) {
    if (d instanceof $root6.Address)
      return d;
    var m = new $root6.Address();
    if (d.multiaddr != null) {
      if (typeof d.multiaddr === "string")
        $util6.base64.decode(d.multiaddr, m.multiaddr = $util6.newBuffer($util6.base64.length(d.multiaddr)), 0);
      else if (d.multiaddr.length)
        m.multiaddr = d.multiaddr;
    }
    if (d.isCertified != null) {
      m.isCertified = Boolean(d.isCertified);
    }
    return m;
  };
  Address2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.multiaddr = "";
      else {
        d.multiaddr = [];
        if (o.bytes !== Array)
          d.multiaddr = $util6.newBuffer(d.multiaddr);
      }
    }
    if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
      d.multiaddr = o.bytes === String ? $util6.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
    }
    if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
      d.isCertified = m.isCertified;
      if (o.oneofs)
        d._isCertified = "isCertified";
    }
    return d;
  };
  Address2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
  };
  return Address2;
})();
var Metadata2 = $root6.Metadata = (() => {
  function Metadata4(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Metadata4.prototype.key = "";
  Metadata4.prototype.value = $util6.newBuffer([]);
  Metadata4.encode = function encode19(m, w) {
    if (!w)
      w = $Writer6.create();
    if (m.key != null && Object.hasOwnProperty.call(m, "key"))
      w.uint32(10).string(m.key);
    if (m.value != null && Object.hasOwnProperty.call(m, "value"))
      w.uint32(18).bytes(m.value);
    return w;
  };
  Metadata4.decode = function decode22(r, l) {
    if (!(r instanceof $Reader6))
      r = $Reader6.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root6.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.key = r.string();
          break;
        case 2:
          m.value = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata4.fromObject = function fromObject(d) {
    if (d instanceof $root6.Metadata)
      return d;
    var m = new $root6.Metadata();
    if (d.key != null) {
      m.key = String(d.key);
    }
    if (d.value != null) {
      if (typeof d.value === "string")
        $util6.base64.decode(d.value, m.value = $util6.newBuffer($util6.base64.length(d.value)), 0);
      else if (d.value.length)
        m.value = d.value;
    }
    return m;
  };
  Metadata4.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      d.key = "";
      if (o.bytes === String)
        d.value = "";
      else {
        d.value = [];
        if (o.bytes !== Array)
          d.value = $util6.newBuffer(d.value);
      }
    }
    if (m.key != null && m.hasOwnProperty("key")) {
      d.key = m.key;
    }
    if (m.value != null && m.hasOwnProperty("value")) {
      d.value = o.bytes === String ? $util6.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
    }
    return d;
  };
  Metadata4.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal6.default.util.toJSONOptions);
  };
  return Metadata4;
})();

// node_modules/ipfs-repo-migrations/esm/migrations/migration-12/pb/envelope.js
init_globals();
var import_minimal7 = __toESM(require_minimal2(), 1);
var $Reader7 = import_minimal7.default.Reader;
var $Writer7 = import_minimal7.default.Writer;
var $util7 = import_minimal7.default.util;
var $root7 = import_minimal7.default.roots["default"] || (import_minimal7.default.roots["default"] = {});
var Envelope = $root7.Envelope = (() => {
  function Envelope2(p) {
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Envelope2.prototype.publicKey = $util7.newBuffer([]);
  Envelope2.prototype.payloadType = $util7.newBuffer([]);
  Envelope2.prototype.payload = $util7.newBuffer([]);
  Envelope2.prototype.signature = $util7.newBuffer([]);
  Envelope2.encode = function encode19(m, w) {
    if (!w)
      w = $Writer7.create();
    if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
      w.uint32(10).bytes(m.publicKey);
    if (m.payloadType != null && Object.hasOwnProperty.call(m, "payloadType"))
      w.uint32(18).bytes(m.payloadType);
    if (m.payload != null && Object.hasOwnProperty.call(m, "payload"))
      w.uint32(26).bytes(m.payload);
    if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
      w.uint32(42).bytes(m.signature);
    return w;
  };
  Envelope2.decode = function decode22(r, l) {
    if (!(r instanceof $Reader7))
      r = $Reader7.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root7.Envelope();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.publicKey = r.bytes();
          break;
        case 2:
          m.payloadType = r.bytes();
          break;
        case 3:
          m.payload = r.bytes();
          break;
        case 5:
          m.signature = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Envelope2.fromObject = function fromObject(d) {
    if (d instanceof $root7.Envelope)
      return d;
    var m = new $root7.Envelope();
    if (d.publicKey != null) {
      if (typeof d.publicKey === "string")
        $util7.base64.decode(d.publicKey, m.publicKey = $util7.newBuffer($util7.base64.length(d.publicKey)), 0);
      else if (d.publicKey.length)
        m.publicKey = d.publicKey;
    }
    if (d.payloadType != null) {
      if (typeof d.payloadType === "string")
        $util7.base64.decode(d.payloadType, m.payloadType = $util7.newBuffer($util7.base64.length(d.payloadType)), 0);
      else if (d.payloadType.length)
        m.payloadType = d.payloadType;
    }
    if (d.payload != null) {
      if (typeof d.payload === "string")
        $util7.base64.decode(d.payload, m.payload = $util7.newBuffer($util7.base64.length(d.payload)), 0);
      else if (d.payload.length)
        m.payload = d.payload;
    }
    if (d.signature != null) {
      if (typeof d.signature === "string")
        $util7.base64.decode(d.signature, m.signature = $util7.newBuffer($util7.base64.length(d.signature)), 0);
      else if (d.signature.length)
        m.signature = d.signature;
    }
    return m;
  };
  Envelope2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.publicKey = "";
      else {
        d.publicKey = [];
        if (o.bytes !== Array)
          d.publicKey = $util7.newBuffer(d.publicKey);
      }
      if (o.bytes === String)
        d.payloadType = "";
      else {
        d.payloadType = [];
        if (o.bytes !== Array)
          d.payloadType = $util7.newBuffer(d.payloadType);
      }
      if (o.bytes === String)
        d.payload = "";
      else {
        d.payload = [];
        if (o.bytes !== Array)
          d.payload = $util7.newBuffer(d.payload);
      }
      if (o.bytes === String)
        d.signature = "";
      else {
        d.signature = [];
        if (o.bytes !== Array)
          d.signature = $util7.newBuffer(d.signature);
      }
    }
    if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
      d.publicKey = o.bytes === String ? $util7.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
    }
    if (m.payloadType != null && m.hasOwnProperty("payloadType")) {
      d.payloadType = o.bytes === String ? $util7.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
    }
    if (m.payload != null && m.hasOwnProperty("payload")) {
      d.payload = o.bytes === String ? $util7.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
    }
    if (m.signature != null && m.hasOwnProperty("signature")) {
      d.signature = o.bytes === String ? $util7.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
    }
    return d;
  };
  Envelope2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal7.default.util.toJSONOptions);
  };
  return Envelope2;
})();

// node_modules/ipfs-repo-migrations/esm/migrations/migration-12/pb/peer-record.js
init_globals();
var import_minimal8 = __toESM(require_minimal2(), 1);
var $Reader8 = import_minimal8.default.Reader;
var $Writer8 = import_minimal8.default.Writer;
var $util8 = import_minimal8.default.util;
var $root8 = import_minimal8.default.roots["default"] || (import_minimal8.default.roots["default"] = {});
var PeerRecord = $root8.PeerRecord = (() => {
  function PeerRecord2(p) {
    this.addresses = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  PeerRecord2.prototype.peerId = $util8.newBuffer([]);
  PeerRecord2.prototype.seq = $util8.Long ? $util8.Long.fromBits(0, 0, true) : 0;
  PeerRecord2.prototype.addresses = $util8.emptyArray;
  PeerRecord2.encode = function encode19(m, w) {
    if (!w)
      w = $Writer8.create();
    if (m.peerId != null && Object.hasOwnProperty.call(m, "peerId"))
      w.uint32(10).bytes(m.peerId);
    if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
      w.uint32(16).uint64(m.seq);
    if (m.addresses != null && m.addresses.length) {
      for (var i = 0; i < m.addresses.length; ++i)
        $root8.PeerRecord.AddressInfo.encode(m.addresses[i], w.uint32(26).fork()).ldelim();
    }
    return w;
  };
  PeerRecord2.decode = function decode22(r, l) {
    if (!(r instanceof $Reader8))
      r = $Reader8.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root8.PeerRecord();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.peerId = r.bytes();
          break;
        case 2:
          m.seq = r.uint64();
          break;
        case 3:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root8.PeerRecord.AddressInfo.decode(r, r.uint32()));
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  PeerRecord2.fromObject = function fromObject(d) {
    if (d instanceof $root8.PeerRecord)
      return d;
    var m = new $root8.PeerRecord();
    if (d.peerId != null) {
      if (typeof d.peerId === "string")
        $util8.base64.decode(d.peerId, m.peerId = $util8.newBuffer($util8.base64.length(d.peerId)), 0);
      else if (d.peerId.length)
        m.peerId = d.peerId;
    }
    if (d.seq != null) {
      if ($util8.Long)
        (m.seq = $util8.Long.fromValue(d.seq)).unsigned = true;
      else if (typeof d.seq === "string")
        m.seq = parseInt(d.seq, 10);
      else if (typeof d.seq === "number")
        m.seq = d.seq;
      else if (typeof d.seq === "object")
        m.seq = new $util8.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
    }
    if (d.addresses) {
      if (!Array.isArray(d.addresses))
        throw TypeError(".PeerRecord.addresses: array expected");
      m.addresses = [];
      for (var i = 0; i < d.addresses.length; ++i) {
        if (typeof d.addresses[i] !== "object")
          throw TypeError(".PeerRecord.addresses: object expected");
        m.addresses[i] = $root8.PeerRecord.AddressInfo.fromObject(d.addresses[i]);
      }
    }
    return m;
  };
  PeerRecord2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addresses = [];
    }
    if (o.defaults) {
      if (o.bytes === String)
        d.peerId = "";
      else {
        d.peerId = [];
        if (o.bytes !== Array)
          d.peerId = $util8.newBuffer(d.peerId);
      }
      if ($util8.Long) {
        var n = new $util8.Long(0, 0, true);
        d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d.seq = o.longs === String ? "0" : 0;
    }
    if (m.peerId != null && m.hasOwnProperty("peerId")) {
      d.peerId = o.bytes === String ? $util8.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;
    }
    if (m.seq != null && m.hasOwnProperty("seq")) {
      if (typeof m.seq === "number")
        d.seq = o.longs === String ? String(m.seq) : m.seq;
      else
        d.seq = o.longs === String ? $util8.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util8.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
    }
    if (m.addresses && m.addresses.length) {
      d.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d.addresses[j] = $root8.PeerRecord.AddressInfo.toObject(m.addresses[j], o);
      }
    }
    return d;
  };
  PeerRecord2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal8.default.util.toJSONOptions);
  };
  PeerRecord2.AddressInfo = function() {
    function AddressInfo(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    AddressInfo.prototype.multiaddr = $util8.newBuffer([]);
    AddressInfo.encode = function encode19(m, w) {
      if (!w)
        w = $Writer8.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      return w;
    };
    AddressInfo.decode = function decode22(r, l) {
      if (!(r instanceof $Reader8))
        r = $Reader8.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root8.PeerRecord.AddressInfo();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    AddressInfo.fromObject = function fromObject(d) {
      if (d instanceof $root8.PeerRecord.AddressInfo)
        return d;
      var m = new $root8.PeerRecord.AddressInfo();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === "string")
          $util8.base64.decode(d.multiaddr, m.multiaddr = $util8.newBuffer($util8.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      return m;
    };
    AddressInfo.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = "";
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util8.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d.multiaddr = o.bytes === String ? $util8.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      return d;
    };
    AddressInfo.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal8.default.util.toJSONOptions);
    };
    return AddressInfo;
  }();
  return PeerRecord2;
})();

// node_modules/ipfs-repo-migrations/esm/migrations/migration-12/index.js
var import_multiaddr5 = __toESM(require_src(), 1);
import_minimal9.default.util.Long = void 0;
import_minimal9.default.configure();
async function storePeerUnderSingleDatastoreKey(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a single datastore key");
  await backends.datastore.open();
  const peers = {};
  const keys2 = [];
  for await (const { key, value } of backends.datastore.query({ prefix: "/peers" })) {
    keys2.push(key);
    const keyStr = key.toString();
    const [_, prefix, type, peerId, metadataKey] = keyStr.split("/");
    if (prefix !== "peers") {
      continue;
    }
    if (![
      "protos",
      "addrs",
      "metadata",
      "keys"
    ].includes(type)) {
      continue;
    }
    if (!peerId) {
      continue;
    }
    peers[peerId] = peers[peerId] || {
      addresses: [],
      protocols: [],
      metadata: []
    };
    if (type === "protos") {
      const protos = Protocols.decode(value);
      peers[peerId].protocols = protos.protocols.sort();
    } else if (type === "addrs") {
      const addrs = Addresses.decode(value);
      peers[peerId].addresses = addrs.addrs.sort((a, b) => {
        return new import_multiaddr5.Multiaddr(a.multiaddr).toString().localeCompare(new import_multiaddr5.Multiaddr(b.multiaddr).toString());
      });
      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {
        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;
      }
    } else if (type === "metadata") {
      peers[peerId].metadata.push({
        key: metadataKey,
        value
      });
    } else if (type === "keys") {
      peers[peerId].pubKey = value;
    }
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys2) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const peerId of Object.keys(peers)) {
    const peer = peers[peerId];
    peer.metadata = peer.metadata.sort((a, b) => a.key.localeCompare(b.key));
    const data = Peer2.encode(peer).finish();
    await backends.datastore.put(new Key(`/peers/${peerId}`), data);
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under a single datastore key");
}
async function storePeerUnderMultipleDatastoreKeys(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a multiple datastore keys");
  await backends.datastore.open();
  const peers = {};
  const keys2 = [];
  for await (const { key, value } of backends.datastore.query({ prefix: "/peers" })) {
    keys2.push(key);
    const keyStr = key.toString();
    const [_, _prefix, peerId] = keyStr.split("/");
    peers[peerId] = Peer2.decode(value);
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys2) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const [peerId, peer] of Object.entries(peers)) {
    if (peer.protocols && peer.protocols.length > 0) {
      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({ protocols: peer.protocols }).finish());
    }
    if (peer.addresses && peer.addresses.length > 0) {
      const peerRecordEnvelope = peer.peerRecordEnvelope;
      let certifiedRecord;
      if (peerRecordEnvelope) {
        const envelope = Envelope.decode(peerRecordEnvelope);
        const record = PeerRecord.decode(envelope.payload);
        certifiedRecord = {
          raw: peerRecordEnvelope,
          seq: record.seq
        };
      }
      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({
        addrs: peer.addresses,
        certifiedRecord
      }).finish());
    }
    if (peer.metadata && peer.metadata.length > 0) {
      for (const { key, value } of peer.metadata) {
        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value);
      }
    }
    if (peer.pubKey) {
      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey);
    }
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under multiple datastore keys");
}
var migration5 = {
  version: 12,
  description: "Store each peerstore peer under a single datastore key",
  migrate: storePeerUnderSingleDatastoreKey,
  revert: storePeerUnderMultipleDatastoreKeys
};

// node_modules/ipfs-repo-migrations/esm/migrations/index.js
var emptyMigration = {
  description: "Empty migration.",
  migrate: () => {
  },
  revert: () => {
  },
  empty: true
};
var migrations_default = [
  Object.assign({ version: 1 }, emptyMigration),
  Object.assign({ version: 2 }, emptyMigration),
  Object.assign({ version: 3 }, emptyMigration),
  Object.assign({ version: 4 }, emptyMigration),
  Object.assign({ version: 5 }, emptyMigration),
  Object.assign({ version: 6 }, emptyMigration),
  Object.assign({ version: 7 }, emptyMigration),
  migration,
  migration2,
  migration3,
  migration4,
  migration5
];

// node_modules/ipfs-repo-migrations/esm/src/repo/version.js
init_globals();

// node_modules/ipfs-repo-migrations/esm/src/repo/init.js
init_globals();
var import_debug37 = __toESM(require_browser2(), 1);

// node_modules/ipfs-repo-migrations/esm/src/errors.js
var errors_exports3 = {};
__export(errors_exports3, {
  InvalidValueError: () => InvalidValueError,
  MissingRepoOptionsError: () => MissingRepoOptionsError,
  NonReversibleMigrationError: () => NonReversibleMigrationError,
  NotInitializedRepoError: () => NotInitializedRepoError,
  RequiredParameterError: () => RequiredParameterError
});
init_globals();
var NonReversibleMigrationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NonReversibleMigrationError";
    this.code = NonReversibleMigrationError.code;
    this.message = message;
  }
};
NonReversibleMigrationError.code = "ERR_NON_REVERSIBLE_MIGRATION";
var NotInitializedRepoError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NotInitializedRepoError";
    this.code = NotInitializedRepoError.code;
    this.message = message;
  }
};
NotInitializedRepoError.code = "ERR_NOT_INITIALIZED_REPO";
var RequiredParameterError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "RequiredParameterError";
    this.code = RequiredParameterError.code;
    this.message = message;
  }
};
RequiredParameterError.code = "ERR_REQUIRED_PARAMETER";
var InvalidValueError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidValueError";
    this.code = InvalidValueError.code;
    this.message = message;
  }
};
InvalidValueError.code = "ERR_INVALID_VALUE";
var MissingRepoOptionsError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "MissingRepoOptionsError";
    this.code = MissingRepoOptionsError.code;
    this.message = message;
  }
};
MissingRepoOptionsError.code = "ERR_MISSING_REPO_OPTIONS";

// node_modules/ipfs-repo-migrations/esm/src/repo/init.js
var log37 = (0, import_debug37.default)("ipfs:repo:migrator:repo:init");
async function isRepoInitialized(backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const root = backends.root;
  try {
    await root.open();
    const versionCheck = await root.has(VERSION_KEY);
    const configCheck = await root.has(CONFIG_KEY);
    if (!versionCheck || !configCheck) {
      log37(`Version entry present: ${versionCheck}`);
      log37(`Config entry present: ${configCheck}`);
      return false;
    }
    return true;
  } catch (e) {
    log37("While checking if repo is initialized error was thrown: " + e.message);
    return false;
  } finally {
    if (root !== void 0) {
      try {
        await root.close();
      } catch {
      }
    }
  }
}

// node_modules/ipfs-repo-migrations/esm/src/repo/version.js
init_from_string();
init_to_string();
async function getVersion(backends) {
  if (!await isRepoInitialized(backends)) {
    throw new NotInitializedRepoError("Repo is not initialized!");
  }
  const store = backends.root;
  await store.open();
  try {
    return parseInt(toString3(await store.get(VERSION_KEY)));
  } finally {
    await store.close();
  }
}
async function setVersion(version4, backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const store = backends.root;
  await store.open();
  await store.put(VERSION_KEY, fromString3(String(version4)));
  await store.close();
}

// node_modules/ipfs-repo-migrations/esm/src/index.js
var import_debug38 = __toESM(require_browser2(), 1);
var log38 = (0, import_debug38.default)("ipfs:repo:migrator");
function getLatestMigrationVersion(migrations) {
  migrations = migrations || migrations_default;
  if (!Array.isArray(migrations) || migrations.length === 0) {
    return 0;
  }
  return migrations[migrations.length - 1].version;
}
async function migrate(path, backends, repoOptions, toVersion, { ignoreLock = false, onProgress, isDryRun = false, migrations }) {
  migrations = migrations || migrations_default;
  if (!path) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("toVersion argument is required!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log38("Nothing to migrate.");
    return;
  }
  if (currentVersion > toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);
  }
  verifyAvailableMigrations(migrations, currentVersion, toVersion);
  let lock3;
  if (!isDryRun && !ignoreLock) {
    lock3 = await repoOptions.repoLock.lock(path);
  }
  try {
    for (const migration6 of migrations) {
      if (toVersion !== void 0 && migration6.version > toVersion) {
        break;
      }
      if (migration6.version <= currentVersion) {
        continue;
      }
      log38(`Migrating version ${migration6.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message) => onProgress(migration6.version, percent.toFixed(2), message);
          }
          await migration6.migrate(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyMigratedVersion = migration6.version - 1;
        log38(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);
        await setVersion(lastSuccessfullyMigratedVersion, backends);
        throw new Error(`During migration to version ${migration6.version} exception was raised: ${e.stack || e.message || e}`);
      }
      log38(`Migrating to version ${migration6.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion || getLatestMigrationVersion(migrations), backends);
    }
    log38("Repo successfully migrated", toVersion !== void 0 ? `to version ${toVersion}!` : "to latest version!");
  } finally {
    if (!isDryRun && !ignoreLock && lock3) {
      await lock3.close();
    }
  }
}
async function revert(path, backends, repoOptions, toVersion, { ignoreLock = false, onProgress, isDryRun = false, migrations }) {
  migrations = migrations || migrations_default;
  if (!path) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log38("Nothing to revert.");
    return;
  }
  if (currentVersion < toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);
  }
  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);
  let lock3;
  if (!isDryRun && !ignoreLock) {
    lock3 = await repoOptions.repoLock.lock(path);
  }
  log38(`Reverting from version ${currentVersion} to ${toVersion}`);
  try {
    const reversedMigrationArray = migrations.slice().reverse();
    for (const migration6 of reversedMigrationArray) {
      if (migration6.version <= toVersion) {
        break;
      }
      if (migration6.version > currentVersion) {
        continue;
      }
      log38(`Reverting migration version ${migration6.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message) => onProgress(migration6.version, percent.toFixed(2), message);
          }
          await migration6.revert(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyRevertedVersion = migration6.version;
        log38(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);
        await setVersion(lastSuccessfullyRevertedVersion, backends);
        e.message = `During reversion to version ${migration6.version} exception was raised: ${e.message}`;
        throw e;
      }
      log38(`Reverting to version ${migration6.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion, backends);
    }
    log38(`All migrations successfully reverted to version ${toVersion}!`);
  } finally {
    if (!isDryRun && !ignoreLock && lock3) {
      await lock3.close();
    }
  }
}
function verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {
  let migrationCounter = 0;
  for (const migration6 of migrations) {
    if (migration6.version > toVersion) {
      break;
    }
    if (migration6.version > fromVersion) {
      if (checkReversibility && !migration6.revert) {
        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration6.version} is not reversible. Cancelling reversion.`);
      }
      migrationCounter++;
    }
  }
  if (migrationCounter !== toVersion - fromVersion) {
    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);
  }
}
var errors = errors_exports3;

// node_modules/ipfs-repo/esm/src/index.js
var import_bytes9 = __toESM(require_bytes(), 1);

// node_modules/ipfs-repo/esm/src/version.js
init_globals();
init_key();
var import_debug39 = __toESM(require_browser2(), 1);
init_to_string();
init_from_string();

// node_modules/ipfs-repo/esm/src/utils/level.js
init_globals();

// node_modules/ipfs-repo/esm/src/errors.js
init_globals();
var LockExistsError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "LockExistsError";
    this.code = LockExistsError.code;
  }
};
LockExistsError.code = "ERR_LOCK_EXISTS";
var NotFoundError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NotFoundError";
    this.code = NotFoundError.code;
  }
};
NotFoundError.code = "ERR_NOT_FOUND";
var InvalidRepoVersionError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidRepoVersionError";
    this.code = InvalidRepoVersionError.code;
  }
};
InvalidRepoVersionError.code = "ERR_INVALID_REPO_VERSION";
var ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED";
var ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN";
var ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED";

// node_modules/ipfs-repo/esm/src/utils/level.js
async function hasWithFallback2(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs2(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve11, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve11(Boolean(req.result));
    };
  });
}
async function getWithFallback2(key, get6, has, store) {
  if (await has(key)) {
    return get6(key);
  }
  const levelJs = findLevelJs2(store);
  if (!levelJs) {
    throw new NotFoundError();
  }
  return new Promise((resolve11, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve11(req.result);
      }
      reject(new NotFoundError());
    };
  });
}
function findLevelJs2(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}

// node_modules/ipfs-repo/esm/src/version.js
var log39 = (0, import_debug39.default)("ipfs:repo:version");
var versionKey = new Key("version");
function version2(store) {
  return {
    async exists() {
      return hasWithFallback2(versionKey, store.has.bind(store), store);
    },
    async get() {
      const buf3 = await getWithFallback2(versionKey, store.get.bind(store), store.has.bind(store), store);
      return parseInt(toString3(buf3), 10);
    },
    set(version4) {
      return store.put(versionKey, fromString3(String(version4)));
    },
    async check(expected) {
      const version4 = await this.get();
      log39("comparing version: %s and %s", version4, expected);
      const compatibleVersion = version4 === 6 && expected === 7 || expected === 6 && version4 === 7;
      return version4 === expected || compatibleVersion;
    }
  };
}

// node_modules/ipfs-repo/esm/src/config.js
init_globals();
init_key();
var import_p_queue3 = __toESM(require_dist(), 1);
var import_just_safe_get = __toESM(require_just_safe_get(), 1);
var import_just_safe_set2 = __toESM(require_just_safe_set(), 1);
var import_err_code54 = __toESM(require_err_code(), 1);
init_to_string();
init_from_string();
var Queue3 = import_p_queue3.default.default ? import_p_queue3.default.default : import_p_queue3.default;
var configKey = new Key("config");
function config(store) {
  const setQueue = new Queue3({ concurrency: 1 });
  const configStore = {
    async getAll(options = {}) {
      const encodedValue = await getWithFallback2(configKey, store.get.bind(store), store.has.bind(store), store);
      return JSON.parse(toString3(encodedValue));
    },
    async get(key, options = {}) {
      if (key == null) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      const config2 = await this.getAll(options);
      const value = (0, import_just_safe_get.default)(config2, key);
      if (value === void 0) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      return value;
    },
    set(key, value, options = {}) {
      if (typeof key !== "string" && !(key instanceof String)) {
        throw (0, import_err_code54.default)(new Error("Invalid key type: " + typeof key), "ERR_INVALID_KEY");
      }
      if (value === void 0 || value instanceof Uint8Array) {
        throw (0, import_err_code54.default)(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key,
        value
      }, options.signal));
    },
    replace(value, options = {}) {
      if (!value || value instanceof Uint8Array) {
        throw (0, import_err_code54.default)(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key: void 0,
        value
      }, options.signal));
    },
    async exists() {
      return hasWithFallback2(configKey, store.has.bind(store), store);
    }
  };
  return configStore;
  async function _maybeDoSet(m, signal) {
    if (signal && signal.aborted) {
      return;
    }
    const key = m.key;
    const value = m.value;
    if (key) {
      const config2 = await configStore.getAll();
      if (typeof config2 === "object" && config2 !== null) {
        (0, import_just_safe_set2.default)(config2, key, value);
      }
      return _saveAll(config2);
    }
    return _saveAll(value);
  }
  function _saveAll(config2) {
    const buf3 = fromString3(JSON.stringify(config2, null, 2));
    return store.put(configKey, buf3);
  }
}

// node_modules/ipfs-repo/esm/src/spec.js
init_globals();
init_src2();
var import_sort_keys = __toESM(require_sort_keys(), 1);
init_to_string();
init_from_string();
var specKey = new Key("datastore_spec");
function spec(store) {
  return {
    exists() {
      return store.has(specKey);
    },
    async get() {
      const buf3 = await store.get(specKey);
      return JSON.parse(toString3(buf3));
    },
    async set(spec2) {
      return store.put(specKey, fromString3(JSON.stringify((0, import_sort_keys.default)(spec2, { deep: true }))));
    }
  };
}

// node_modules/ipfs-repo/esm/src/api-addr.js
init_globals();
init_key();
init_from_string();
var apiFile = new Key("api");
function apiAddr(store) {
  return {
    async get() {
      const value = await store.get(apiFile);
      return value && value.toString();
    },
    set(value) {
      return store.put(apiFile, fromString3(value.toString()));
    },
    delete() {
      return store.delete(apiFile);
    }
  };
}

// node_modules/ipfs-repo/esm/src/idstore.js
init_globals();
var import_it_filter4 = __toESM(require_it_filter(), 1);
var import_it_pushable2 = __toESM(require_it_pushable(), 1);
var import_it_drain6 = __toESM(require_it_drain(), 1);
init_cid();
var import_err_code55 = __toESM(require_err_code(), 1);
init_identity();
function createIdStore(store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      const extracted = extractContents(cid);
      if (extracted.isIdentity) {
        return Promise.resolve(extracted.digest);
      }
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      for await (const cid of cids) {
        yield this.get(cid, options);
      }
    },
    async put(cid, buf3, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return;
      }
      await store.put(cid, buf3, options);
    },
    async *putMany(pairs, options) {
      const output = (0, import_it_pushable2.default)();
      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
      runner(async () => {
        try {
          await (0, import_it_drain6.default)(store.putMany(async function* () {
            for await (const { key, value } of pairs) {
              if (!extractContents(key).isIdentity) {
                yield {
                  key,
                  value
                };
              }
              output.push({
                key,
                value
              });
            }
          }()));
          output.end();
        } catch (err) {
          output.end(err);
        }
      });
      yield* output;
    },
    has(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve(true);
      }
      return store.has(cid, options);
    },
    delete(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve();
      }
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany((0, import_it_filter4.default)(cids, (cid) => !extractContents(cid).isIdentity), options);
    },
    batch() {
      const batch3 = store.batch();
      return {
        put(cid, buf3) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch3.put(cid, buf3);
        },
        delete(cid) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch3.delete(cid);
        },
        commit: (options) => {
          return batch3.commit(options);
        }
      };
    }
  };
}
function extractContents(k) {
  const cid = CID.asCID(k);
  if (cid == null) {
    throw (0, import_err_code55.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  if (cid.multihash.code !== identity.code) {
    return { isIdentity: false };
  }
  return {
    isIdentity: true,
    digest: cid.multihash.digest
  };
}

// node_modules/ipfs-repo/esm/src/default-options.js
init_globals();

// node_modules/ipfs-repo/esm/src/locks/memory.js
init_globals();
var import_debug40 = __toESM(require_browser2(), 1);
var log40 = (0, import_debug40.default)("ipfs:repo:lock:memory");
var lockFile = "repo.lock";
var LOCKS = {};
async function lock2(dir) {
  const file = dir + "/" + lockFile;
  log40("locking %s", file);
  if (LOCKS[file] === true) {
    throw new LockExistsError(`Lock already being held for file: ${file}`);
  }
  LOCKS[file] = true;
  const closer = {
    async close() {
      if (LOCKS[file]) {
        delete LOCKS[file];
      }
    }
  };
  return closer;
}
async function locked(dir) {
  const file = dir + "/" + lockFile;
  log40(`checking lock: ${file}`);
  return Boolean(LOCKS[file]);
}
var MemoryLock = {
  lock: lock2,
  locked
};

// node_modules/ipfs-repo/esm/src/default-options.js
var default_options_default = {
  autoMigrate: true,
  onMigrationProgress: () => {
  },
  repoOwner: true,
  repoLock: MemoryLock
};

// node_modules/ipfs-repo/esm/src/default-datastore.js
init_globals();
var default_datastore_default = {
  Spec: {
    type: "mount",
    mounts: [
      {
        mountpoint: "/blocks",
        type: "measure",
        prefix: "flatfs.datastore",
        child: {
          type: "flatfs",
          path: "blocks",
          sync: true,
          shardFunc: "/repo/flatfs/shard/v1/next-to-last/2"
        }
      },
      {
        mountpoint: "/",
        type: "measure",
        prefix: "leveldb.datastore",
        child: {
          type: "levelds",
          path: "datastore",
          compression: "none"
        }
      }
    ]
  }
};

// node_modules/ipfs-repo/esm/src/pin-manager.js
init_globals();
init_cid();
var import_err_code57 = __toESM(require_err_code(), 1);
var import_debug42 = __toESM(require_browser2(), 1);
var import_it_first2 = __toESM(require_it_first(), 1);
init_cborg();

// node_modules/ipfs-repo/esm/src/utils/blockstore.js
init_globals();
init_key();
init_src();
init_raw();
var import_err_code56 = __toESM(require_err_code(), 1);
init_base32();
init_digest();
function cidToKey2(c) {
  const cid = CID.asCID(c);
  if (cid == null) {
    throw (0, import_err_code56.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  const encoded = base32.encode(cid.multihash.bytes);
  return new Key("/" + encoded.slice(1).toUpperCase(), false);
}
function keyToMultihash2(key) {
  return decode3(base32.decode(`b${key.toString().toLowerCase().substring(1)}`));
}

// node_modules/ipfs-repo/esm/src/utils/walk-dag.js
init_globals();
var import_debug41 = __toESM(require_browser2(), 1);
var log41 = (0, import_debug41.default)("ipfs:repo:utils:walk-dag");
async function* walkDag(cid, blockstore, loadCodec, options) {
  try {
    const bytes2 = await blockstore.get(cid, options);
    const codec = await loadCodec(cid.code);
    const block = createUnsafe({
      bytes: bytes2,
      cid,
      codec
    });
    for (const [, childCid] of block.links()) {
      yield childCid;
      yield* walkDag(childCid, blockstore, loadCodec, options);
    }
  } catch (err) {
    log41("Could not walk DAG for CID", cid.toString(), err);
    throw err;
  }
}

// node_modules/ipfs-repo/esm/src/pin-manager.js
function invalidPinTypeErr(type) {
  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;
  return (0, import_err_code57.default)(new Error(errMsg), "ERR_INVALID_PIN_TYPE");
}
var PinManager = class {
  constructor({ pinstore, blockstore, loadCodec }) {
    this.pinstore = pinstore;
    this.blockstore = blockstore;
    this.loadCodec = loadCodec;
    this.log = (0, import_debug42.default)("ipfs:repo:pin");
    this.directPins = /* @__PURE__ */ new Set();
    this.recursivePins = /* @__PURE__ */ new Set();
  }
  async pinDirectly(cid, options = {}) {
    await this.blockstore.get(cid, options);
    const pin = { depth: 0 };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    return this.pinstore.put(cidToKey2(cid), encode4(pin));
  }
  unpin(cid, options) {
    return this.pinstore.delete(cidToKey2(cid), options);
  }
  async pinRecursively(cid, options = {}) {
    await this.fetchCompleteDag(cid, options);
    const pin = { depth: Infinity };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    await this.pinstore.put(cidToKey2(cid), encode4(pin));
  }
  async *directKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode6(entry2.value);
        return pin.depth === 0;
      }]
    })) {
      const pin = decode6(entry.value);
      const version4 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code;
      const multihash = keyToMultihash2(entry.key);
      yield {
        cid: CID.create(version4, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *recursiveKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode6(entry2.value);
        return pin.depth === Infinity;
      }]
    })) {
      const pin = decode6(entry.value);
      const version4 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code;
      const multihash = keyToMultihash2(entry.key);
      yield {
        cid: CID.create(version4, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *indirectKeys(options) {
    for await (const { cid } of this.recursiveKeys()) {
      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {
        const types3 = [PinTypes.recursive];
        const result = await this.isPinnedWithType(childCid, types3);
        if (result.pinned) {
          continue;
        }
        yield childCid;
      }
    }
  }
  async isPinnedWithType(cid, types3, options) {
    if (!Array.isArray(types3)) {
      types3 = [types3];
    }
    const all6 = types3.includes(PinTypes.all);
    const direct = types3.includes(PinTypes.direct);
    const recursive3 = types3.includes(PinTypes.recursive);
    const indirect = types3.includes(PinTypes.indirect);
    if (recursive3 || direct || all6) {
      const result = await (0, import_it_first2.default)(this.pinstore.query({
        prefix: cidToKey2(cid).toString(),
        filters: [(entry) => {
          if (all6) {
            return true;
          }
          const pin = decode6(entry.value);
          return types3.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);
        }],
        limit: 1
      }));
      if (result) {
        const pin = decode6(result.value);
        return {
          cid,
          pinned: true,
          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,
          metadata: pin.metadata
        };
      }
    }
    const self2 = this;
    async function* findChild(key, source) {
      for await (const { cid: parentCid } of source) {
        for await (const childCid of walkDag(parentCid, self2.blockstore, self2.loadCodec)) {
          if (childCid.equals(key)) {
            yield parentCid;
            return;
          }
        }
      }
    }
    if (all6 || indirect) {
      const parentCid = await (0, import_it_first2.default)(findChild(cid, this.recursiveKeys()));
      if (parentCid) {
        return {
          cid,
          pinned: true,
          reason: PinTypes.indirect,
          parent: parentCid
        };
      }
    }
    return {
      cid,
      pinned: false
    };
  }
  async fetchCompleteDag(cid, options) {
    const seen = /* @__PURE__ */ new Set();
    const walkDag2 = async (cid2, options2) => {
      if (seen.has(cid2.toString())) {
        return;
      }
      seen.add(cid2.toString());
      const bytes2 = await this.blockstore.get(cid2, options2);
      const codec = await this.loadCodec(cid2.code);
      const block = createUnsafe({
        bytes: bytes2,
        cid: cid2,
        codec
      });
      await Promise.all([...block.links()].map(([, childCid]) => walkDag2(childCid, options2)));
    };
    await walkDag2(cid, options);
  }
  static checkPinType(type) {
    if (typeof type !== "string" || !Object.keys(PinTypes).includes(type)) {
      throw invalidPinTypeErr(type);
    }
    return true;
  }
};

// node_modules/ipfs-repo/esm/src/pinned-blockstore.js
init_globals();
var import_it_map8 = __toESM(require_it_map(), 1);
var import_err_code58 = __toESM(require_err_code(), 1);
function createPinnedBlockstore(pins, store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      yield* store.getMany(cids, options);
    },
    async put(cid, buf3, options) {
      await store.put(cid, buf3, options);
    },
    async *putMany(pairs, options) {
      yield* store.putMany(pairs, options);
    },
    has(cid, options) {
      return store.has(cid, options);
    },
    async delete(cid, options) {
      await ensureNotPinned(cid, pins);
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany((0, import_it_map8.default)(cids, async (cid) => {
        await ensureNotPinned(cid, pins);
        return cid;
      }), options);
    },
    batch() {
      return store.batch();
    }
  };
}
async function ensureNotPinned(cid, pins) {
  const { pinned, reason } = await pins.isPinnedWithType(cid, PinTypes.all);
  if (pinned) {
    throw (0, import_err_code58.default)(new Error(`pinned: ${reason}`), "ERR_BLOCK_PINNED");
  }
}

// node_modules/ipfs-repo/esm/src/index.js
var import_mortice2 = __toESM(require_lib6(), 1);

// node_modules/ipfs-repo/esm/src/gc.js
init_globals();
init_cid();
var import_debug43 = __toESM(require_browser2(), 1);
init_errors();
var import_it_parallel_batch3 = __toESM(require_it_parallel_batch(), 1);
var import_it_pipe6 = __toESM(require_it_pipe(), 1);
var import_it_merge2 = __toESM(require_it_merge(), 1);
var import_it_map9 = __toESM(require_it_map(), 1);
var import_it_filter5 = __toESM(require_it_filter(), 1);
init_key();
init_base32();
var log42 = (0, import_debug43.default)("ipfs:repo:gc");
var ERR_NOT_FOUND4 = notFoundError().code;
var BLOCK_RM_CONCURRENCY2 = 256;
var MFS_ROOT_KEY3 = new Key("/local/filesroot");
function gc({ gcLock, pins, blockstore, root, loadCodec }) {
  async function* gc2() {
    const start = Date.now();
    log42("Creating set of marked blocks");
    const release = await gcLock.writeLock();
    try {
      const markedSet = await createMarkedSet({
        pins,
        blockstore,
        root,
        loadCodec
      });
      const blockKeys = blockstore.queryKeys({});
      yield* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys);
      log42(`Complete (${Date.now() - start}ms)`);
    } finally {
      release();
    }
  }
  return gc2;
}
async function createMarkedSet({ pins, blockstore, loadCodec, root }) {
  const mfsSource = async function* () {
    let mh;
    try {
      mh = await root.get(MFS_ROOT_KEY3);
    } catch (err) {
      if (err.code === ERR_NOT_FOUND4) {
        log42("No blocks in MFS");
        return;
      }
      throw err;
    }
    const rootCid = CID.decode(mh);
    yield rootCid;
    yield* walkDag(rootCid, blockstore, loadCodec);
  }();
  const pinsSource = (0, import_it_merge2.default)((0, import_it_map9.default)(pins.recursiveKeys(), ({ cid }) => cid), pins.indirectKeys(), (0, import_it_map9.default)(pins.directKeys(), ({ cid }) => cid), mfsSource);
  const output = /* @__PURE__ */ new Set();
  for await (const cid of (0, import_it_merge2.default)(pinsSource, mfsSource)) {
    output.add(base32.encode(cid.multihash.bytes));
  }
  return output;
}
async function* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys) {
  let blocksCount = 0;
  let removedBlocksCount = 0;
  const removeBlock = async (cid) => {
    return async function remove() {
      blocksCount++;
      try {
        const b32 = base32.encode(cid.multihash.bytes);
        if (markedSet.has(b32)) {
          return null;
        }
        try {
          await blockstore.delete(cid);
          removedBlocksCount++;
        } catch (err) {
          return { err: new Error(`Could not delete block with CID ${cid}: ${err.message}`) };
        }
        return { cid };
      } catch (err) {
        const msg = `Could delete block with CID ${cid}`;
        log42(msg, err);
        return { err: new Error(msg + `: ${err.message}`) };
      }
    };
  };
  yield* (0, import_it_pipe6.pipe)((0, import_it_parallel_batch3.default)((0, import_it_map9.default)(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY2), (source) => (0, import_it_filter5.default)(source, Boolean));
  log42(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. Deleted ${removedBlocksCount} blocks.`);
}

// node_modules/ipfs-repo/esm/src/index.js
var log43 = (0, import_debug44.default)("ipfs:repo");
var noLimit = Number.MAX_SAFE_INTEGER;
var AUTO_MIGRATE_CONFIG_KEY = "repoAutoMigrate";
var Repo = class {
  constructor(path, loadCodec, backends, options) {
    if (typeof path !== "string") {
      throw new Error("missing repo path");
    }
    if (typeof loadCodec !== "function") {
      throw new Error("missing codec loader");
    }
    this.options = merge_options_default(default_options_default, options);
    this.closed = true;
    this.path = path;
    this.root = backends.root;
    this.datastore = backends.datastore;
    this.keys = backends.keys;
    const blockstore = backends.blocks;
    const pinstore = backends.pins;
    this.pins = new PinManager({
      pinstore,
      blockstore,
      loadCodec
    });
    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore);
    this.blocks = createIdStore(pinnedBlockstore);
    this.version = version2(this.root);
    this.config = config(this.root);
    this.spec = spec(this.root);
    this.apiAddr = apiAddr(this.root);
    this.gcLock = (0, import_mortice2.default)(path, { singleProcess: this.options.repoOwner !== false });
    this.gc = gc({
      gcLock: this.gcLock,
      pins: this.pins,
      blockstore: this.blocks,
      root: this.root,
      loadCodec
    });
  }
  async init(config2) {
    log43("initializing at: %s", this.path);
    await this._openRoot();
    await this.config.replace(buildConfig(config2));
    await this.spec.set(buildDatastoreSpec(config2));
    await this.version.set(repoVersion);
  }
  async isInitialized() {
    if (!this.closed) {
      return true;
    }
    try {
      await this._openRoot();
      await this._checkInitialized();
      await this.root.close();
      return true;
    } catch (err) {
      return false;
    }
  }
  async open() {
    if (!this.closed) {
      throw (0, import_err_code59.default)(new Error("repo is already open"), ERR_REPO_ALREADY_OPEN);
    }
    log43("opening at: %s", this.path);
    try {
      await this._openRoot();
      await this._checkInitialized();
      this._lockfile = await this._openLock();
      log43("acquired repo.lock");
      const isCompatible = await this.version.check(repoVersion);
      if (!isCompatible) {
        if (await this._isAutoMigrationEnabled()) {
          await this._migrate(repoVersion, {
            root: this.root,
            datastore: this.datastore,
            pins: this.pins.pinstore,
            blocks: this.pins.blockstore,
            keys: this.keys
          });
        } else {
          throw new InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
        }
      }
      log43("creating datastore");
      await this.datastore.open();
      log43("creating blocks");
      await this.blocks.open();
      log43("creating keystore");
      await this.keys.open();
      log43("creating pins");
      await this.pins.pinstore.open();
      this.closed = false;
      log43("all opened");
    } catch (err) {
      if (this._lockfile) {
        try {
          await this._closeLock();
          this._lockfile = null;
        } catch (err2) {
          log43("error removing lock", err2);
        }
      }
      throw err;
    }
  }
  async _openRoot() {
    try {
      await this.root.open();
    } catch (err) {
      if (err.message !== "Already open") {
        throw err;
      }
    }
  }
  async _openLock() {
    const lockfile = await this.options.repoLock.lock(this.path);
    if (typeof lockfile.close !== "function") {
      throw (0, import_err_code59.default)(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
    }
    return lockfile;
  }
  _closeLock() {
    return this._lockfile && this._lockfile.close();
  }
  async _checkInitialized() {
    log43("init check");
    let config2;
    try {
      [config2] = await Promise.all([
        this.config.exists(),
        this.spec.exists(),
        this.version.exists()
      ]);
    } catch (err) {
      if (err.code === "ERR_NOT_FOUND") {
        throw (0, import_err_code59.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, { path: this.path });
      }
      throw err;
    }
    if (!config2) {
      throw (0, import_err_code59.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, { path: this.path });
    }
  }
  async close() {
    if (this.closed) {
      throw (0, import_err_code59.default)(new Error("repo is already closed"), ERR_REPO_ALREADY_CLOSED);
    }
    log43("closing at: %s", this.path);
    try {
      await this.apiAddr.delete();
    } catch (err) {
      if (err.code !== ERR_REPO_NOT_INITIALIZED && !err.message.startsWith("ENOENT")) {
        throw err;
      }
    }
    await Promise.all([
      this.root,
      this.blocks,
      this.keys,
      this.datastore,
      this.pins.pinstore
    ].map((store) => store && store.close()));
    log43("unlocking");
    this.closed = true;
    await this._closeLock();
  }
  exists() {
    return this.version.exists();
  }
  async stat() {
    if (this.datastore && this.keys) {
      const [storageMax, blocks, version4, datastore, keys2] = await Promise.all([
        this._storageMaxStat(),
        this._blockStat(),
        this.version.get(),
        getSize(this.datastore),
        getSize(this.keys)
      ]);
      const size = blocks.size + datastore + keys2;
      return {
        repoPath: this.path,
        storageMax,
        version: version4,
        numObjects: blocks.count,
        repoSize: size
      };
    }
    throw (0, import_err_code59.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, { path: this.path });
  }
  async _isAutoMigrationEnabled() {
    if (this.options.autoMigrate !== void 0) {
      return this.options.autoMigrate;
    }
    let autoMigrateConfig;
    try {
      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);
    } catch (e) {
      if (e.code === NotFoundError.code) {
        autoMigrateConfig = true;
      } else {
        throw e;
      }
    }
    return autoMigrateConfig;
  }
  async _migrate(toVersion, backends) {
    const currentRepoVersion = await this.version.get();
    if (currentRepoVersion > toVersion) {
      log43(`reverting to version ${toVersion}`);
      return revert(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    } else {
      log43(`migrating to version ${toVersion}`);
      return migrate(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    }
  }
  async _storageMaxStat() {
    try {
      const max = await this.config.get("Datastore.StorageMax");
      return BigInt((0, import_bytes9.default)(max));
    } catch (err) {
      return BigInt(noLimit);
    }
  }
  async _blockStat() {
    let count = BigInt(0);
    let size = BigInt(0);
    if (this.blocks) {
      for await (const { key, value } of this.blocks.query({})) {
        count += BigInt(1);
        size += BigInt(value.byteLength);
        size += BigInt(key.bytes.byteLength);
      }
    }
    return {
      count,
      size
    };
  }
};
async function getSize(datastore) {
  let sum = BigInt(0);
  for await (const block of datastore.query({})) {
    sum += BigInt(block.value.byteLength);
    sum += BigInt(block.key.uint8Array().byteLength);
  }
  return sum;
}
function createRepo(path, loadCodec, backends, options) {
  return new Repo(path, loadCodec, backends, options);
}
function buildConfig(_config) {
  _config.Datastore = Object.assign({}, default_datastore_default, (0, import_just_safe_get2.default)(_config, "datastore"));
  return _config;
}
function buildDatastoreSpec(_config) {
  const spec2 = {
    ...default_datastore_default.Spec,
    ...(0, import_just_safe_get2.default)(_config, "Datastore.Spec")
  };
  return {
    type: spec2.type,
    mounts: spec2.mounts.map((mounting) => ({
      mountpoint: mounting.mountpoint,
      type: mounting.child.type,
      path: mounting.child.path,
      shardFunc: mounting.child.shardFunc
    }))
  };
}

// node_modules/ipfs-core-config/node_modules/datastore-level/esm/src/index.js
init_globals();
init_src2();
init_src3();
var import_it_filter6 = __toESM(require_it_filter(), 1);
var import_it_map10 = __toESM(require_it_map(), 1);
var import_it_take3 = __toESM(require_it_take(), 1);
var import_it_sort = __toESM(require_it_sort(), 1);
var import_level3 = __toESM(require_browser6(), 1);
var LevelDatastore = class extends BaseDatastore {
  constructor(path, opts) {
    super();
    this.path = path;
    this.opts = opts;
    if (opts && opts.db) {
      this.database = opts.db;
      delete opts.db;
    } else {
      this.database = import_level3.default;
    }
  }
  _initDb() {
    return new Promise((resolve11, reject) => {
      this.db = this.database(this.path, {
        ...this.opts,
        valueEncoding: "binary",
        compression: false
      }, (err) => {
        if (err) {
          return reject(err);
        }
        resolve11(this.db);
      });
    });
  }
  async open() {
    try {
      if (this.db) {
        await this.db.open();
      } else {
        this.db = await this._initDb();
      }
    } catch (err) {
      throw Errors.dbOpenFailedError(err);
    }
  }
  async put(key, value) {
    try {
      await this.db.put(key.toString(), value);
    } catch (err) {
      throw Errors.dbWriteFailedError(err);
    }
  }
  async get(key) {
    let data;
    try {
      data = await this.db.get(key.toString());
    } catch (err) {
      if (err.notFound)
        throw Errors.notFoundError(err);
      throw Errors.dbWriteFailedError(err);
    }
    return data;
  }
  async has(key) {
    try {
      await this.db.get(key.toString());
    } catch (err) {
      if (err.notFound)
        return false;
      throw err;
    }
    return true;
  }
  async delete(key) {
    try {
      await this.db.del(key.toString());
    } catch (err) {
      throw Errors.dbDeleteFailedError(err);
    }
  }
  close() {
    return this.db && this.db.close();
  }
  batch() {
    const ops = [];
    return {
      put: (key, value) => {
        ops.push({
          type: "put",
          key: key.toString(),
          value
        });
      },
      delete: (key) => {
        ops.push({
          type: "del",
          key: key.toString()
        });
      },
      commit: () => {
        return this.db.batch(ops);
      }
    };
  }
  query(q) {
    let it = this._query({
      values: true,
      prefix: q.prefix
    });
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter6.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => (0, import_it_sort.default)(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i = 0;
      it = (0, import_it_filter6.default)(it, () => i++ >= offset);
    }
    if (limit) {
      it = (0, import_it_take3.default)(it, limit);
    }
    return it;
  }
  queryKeys(q) {
    let it = (0, import_it_map10.default)(this._query({
      values: false,
      prefix: q.prefix
    }), ({ key }) => key);
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter6.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => (0, import_it_sort.default)(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i = 0;
      it = (0, import_it_filter6.default)(it, () => i++ >= offset);
    }
    if (limit) {
      it = (0, import_it_take3.default)(it, limit);
    }
    return it;
  }
  _query(opts) {
    const iteratorOpts = {
      keys: true,
      keyAsBuffer: true,
      values: opts.values
    };
    if (opts.prefix != null) {
      const prefix = opts.prefix.toString();
      iteratorOpts.gte = prefix;
      iteratorOpts.lt = prefix + "\xFF";
    }
    return levelIteratorToIterator(this.db.iterator(iteratorOpts));
  }
};
function levelIteratorToIterator(li) {
  return {
    [Symbol.asyncIterator]() {
      return {
        next: () => new Promise((resolve11, reject) => {
          li.next((err, key, value) => {
            if (err)
              return reject(err);
            if (key == null) {
              return li.end((err2) => {
                if (err2)
                  return reject(err2);
                resolve11({
                  done: true,
                  value: void 0
                });
              });
            }
            resolve11({
              done: false,
              value: {
                key: new Key(key, false),
                value
              }
            });
          });
        }),
        return: () => new Promise((resolve11, reject) => {
          li.end((err) => {
            if (err)
              return reject(err);
            resolve11({
              done: true,
              value: void 0
            });
          });
        })
      };
    }
  };
}

// node_modules/blockstore-datastore-adapter/esm/src/index.js
init_globals();
var import_it_drain8 = __toESM(require_it_drain(), 1);
var import_it_pushable3 = __toESM(require_it_pushable(), 1);
init_key();
init_cid();
init_raw();
init_digest();
init_base32();
init_base58();
var import_err_code60 = __toESM(require_err_code(), 1);

// node_modules/blockstore-core/esm/src/base.js
init_globals();
var import_it_drain7 = __toESM(require_it_drain(), 1);
var import_it_filter7 = __toESM(require_it_filter(), 1);
var import_it_take4 = __toESM(require_it_take(), 1);
var import_it_all4 = __toESM(require_it_all(), 1);
var sortAll2 = (iterable, sorter) => {
  return async function* () {
    const values2 = await (0, import_it_all4.default)(iterable);
    yield* values2.sort(sorter);
  }();
};
var BaseBlockstore = class {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield {
        key,
        value
      };
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({
          key,
          value
        });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await (0, import_it_drain7.default)(this.putMany(puts, options));
        puts = [];
        await (0, import_it_drain7.default)(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter7.default)(it, (e) => e.key.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter7.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter7.default)(it, () => i++ >= (q.offset || 0));
    }
    if (q.limit != null) {
      it = (0, import_it_take4.default)(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter7.default)(it, (cid) => cid.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter7.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter7.default)(it, () => i++ >= q.offset);
    }
    if (q.limit != null) {
      it = (0, import_it_take4.default)(it, q.limit);
    }
    return it;
  }
};

// node_modules/blockstore-datastore-adapter/esm/src/index.js
function cidToKey3(cid) {
  const c = CID.asCID(cid);
  if (!c) {
    throw (0, import_err_code60.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  return new Key("/" + base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false);
}
function keyToCid2(key) {
  return CID.createV1(code6, decode3(base32.decode("b" + key.toString().slice(1).toLowerCase())));
}
function convertPrefix(prefix) {
  const firstChar = prefix.substring(0, 1);
  if (firstChar === "/") {
    return convertPrefix(prefix.substring(1));
  }
  let decoder;
  if (firstChar.toLowerCase() === "b") {
    decoder = (input) => base32.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar.toLowerCase() === "c") {
    decoder = (input) => base32pad.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar === "z") {
    decoder = (input) => base58btc.decode(input).subarray(2);
  } else if (firstChar === "Q") {
    decoder = (input) => base58btc.decode("z" + input);
  } else {
    decoder = (input) => base32.decode("b" + input.toLowerCase()).subarray(2);
  }
  let bytes2;
  for (let i = 1; i < prefix.length; i++) {
    try {
      bytes2 = decoder(prefix.substring(0, i));
    } catch (err) {
      if (err.message !== "Unexpected end of data") {
        throw err;
      }
    }
  }
  let str = "/C";
  if (bytes2) {
    str = `/${base32.encode(bytes2).slice(1, -1).toUpperCase() || "C"}`;
  }
  return str;
}
function convertQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map((filter10) => (pair) => {
      return filter10({
        key: keyToCid2(pair.key),
        value: pair.value
      });
    }) : void 0,
    orders: query.orders ? query.orders.map((order) => (a, b) => {
      return order({
        key: keyToCid2(a.key),
        value: a.value
      }, {
        key: keyToCid2(b.key),
        value: b.value
      });
    }) : void 0
  };
}
function convertKeyQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map((filter10) => (key) => {
      return filter10(keyToCid2(key));
    }) : void 0,
    orders: query.orders ? query.orders.map((order) => (a, b) => {
      return order(keyToCid2(a), keyToCid2(b));
    }) : void 0
  };
}
var BlockstoreDatastoreAdapter = class extends BaseBlockstore {
  constructor(datastore) {
    super();
    this.child = datastore;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  async *query(query, options) {
    for await (const { key, value } of this.child.query(convertQuery(query), options)) {
      yield {
        key: keyToCid2(key),
        value
      };
    }
  }
  async *queryKeys(query, options) {
    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {
      yield keyToCid2(key);
    }
  }
  async get(cid, options) {
    return this.child.get(cidToKey3(cid), options);
  }
  async *getMany(cids, options) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  async put(cid, value, options) {
    await this.child.put(cidToKey3(cid), value, options);
  }
  async *putMany(blocks, options) {
    const output = (0, import_it_pushable3.default)();
    const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
    runner(async () => {
      try {
        const store = this.child;
        await (0, import_it_drain8.default)(this.child.putMany(async function* () {
          for await (const block of blocks) {
            const key = cidToKey3(block.key);
            const exists = await store.has(key, options);
            if (!exists) {
              yield {
                key,
                value: block.value
              };
            }
            output.push(block);
          }
        }()));
        output.end();
      } catch (err) {
        output.end(err);
      }
    });
    yield* output;
  }
  has(cid, options) {
    return this.child.has(cidToKey3(cid), options);
  }
  delete(cid, options) {
    return this.child.delete(cidToKey3(cid), options);
  }
  deleteMany(cids, options) {
    const out = (0, import_it_pushable3.default)();
    (0, import_it_drain8.default)(this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cidToKey3(cid);
        out.push(cid);
      }
      out.end();
    }(), options)).catch((err) => {
      out.end(err);
    });
    return out;
  }
};

// node_modules/ipfs-core-config/esm/src/repo.browser.js
function createRepo2(print, codecs2, options) {
  const repoPath = options.path || "ipfs";
  return createRepo(repoPath, (codeOrName) => codecs2.getCodec(codeOrName), {
    root: new LevelDatastore(repoPath, {
      prefix: "",
      version: 2
    }),
    blocks: new BlockstoreDatastoreAdapter(new LevelDatastore(`${repoPath}/blocks`, {
      prefix: "",
      version: 2
    })),
    datastore: new LevelDatastore(`${repoPath}/datastore`, {
      prefix: "",
      version: 2
    }),
    keys: new LevelDatastore(`${repoPath}/keys`, {
      prefix: "",
      version: 2
    }),
    pins: new LevelDatastore(`${repoPath}/pins`, {
      prefix: "",
      version: 2
    })
  }, {
    autoMigrate: options.autoMigrate,
    onMigrationProgress: options.onMigrationProgress || print,
    repoLock: MemoryLock
  });
}

// node_modules/ipfs-core/esm/src/components/storage.js
init_from_string();
init_to_string();
var import_peer_id11 = __toESM(require_src5(), 1);

// node_modules/ipfs-core/esm/src/components/libp2p.js
init_globals();
var import_dlv2 = __toESM(require_dlv_umd(), 1);
var import_err_code68 = __toESM(require_err_code(), 1);

// node_modules/ipfs-core-config/esm/src/libp2p-pubsub-routers.browser.js
init_globals();
var import_libp2p_gossipsub = __toESM(require_src12(), 1);
var routers = { gossipsub: import_libp2p_gossipsub.default };

// node_modules/ipfs-core/esm/src/components/libp2p.js
var import_libp2p_delegated_peer_routing = __toESM(require_src13(), 1);
var import_libp2p_delegated_content_routing = __toESM(require_src14(), 1);

// node_modules/ipfs-http-client/esm/src/index.js
init_globals();

// node_modules/ipfs-core-utils/esm/src/multibases.js
init_globals();
var LOAD_BASE = (name10) => Promise.reject(new Error(`No base found for "${name10}"`));
var Multibases = class {
  constructor(options) {
    this._basesByName = {};
    this._basesByPrefix = {};
    this._loadBase = options.loadBase || LOAD_BASE;
    for (const base4 of options.bases) {
      this.addBase(base4);
    }
  }
  addBase(base4) {
    if (this._basesByName[base4.name] || this._basesByPrefix[base4.prefix]) {
      throw new Error(`Codec already exists for codec "${base4.name}"`);
    }
    this._basesByName[base4.name] = base4;
    this._basesByPrefix[base4.prefix] = base4;
  }
  removeBase(base4) {
    delete this._basesByName[base4.name];
    delete this._basesByPrefix[base4.prefix];
  }
  async getBase(nameOrPrefix) {
    if (this._basesByName[nameOrPrefix]) {
      return this._basesByName[nameOrPrefix];
    }
    if (this._basesByPrefix[nameOrPrefix]) {
      return this._basesByPrefix[nameOrPrefix];
    }
    const base4 = await this._loadBase(nameOrPrefix);
    if (this._basesByName[base4.name] == null && this._basesByPrefix[base4.prefix] == null) {
      this.addBase(base4);
    }
    return base4;
  }
  listBases() {
    return Object.values(this._basesByName);
  }
};

// node_modules/ipfs-core-utils/esm/src/multicodecs.js
init_globals();
var LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`));
var Multicodecs = class {
  constructor(options) {
    this._codecsByName = {};
    this._codecsByCode = {};
    this._loadCodec = options.loadCodec || LOAD_CODEC;
    for (const codec of options.codecs) {
      this.addCodec(codec);
    }
  }
  addCodec(codec) {
    if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
      throw new Error(`Resolver already exists for codec "${codec.name}"`);
    }
    this._codecsByName[codec.name] = codec;
    this._codecsByCode[codec.code] = codec;
  }
  removeCodec(codec) {
    delete this._codecsByName[codec.name];
    delete this._codecsByCode[codec.code];
  }
  async getCodec(code13) {
    const table = typeof code13 === "string" ? this._codecsByName : this._codecsByCode;
    if (table[code13]) {
      return table[code13];
    }
    const codec = await this._loadCodec(code13);
    if (table[code13] == null) {
      this.addCodec(codec);
    }
    return codec;
  }
  listCodecs() {
    return Object.values(this._codecsByName);
  }
};

// node_modules/ipfs-core-utils/esm/src/multihashes.js
init_globals();
var LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
var Multihashes = class {
  constructor(options) {
    this._hashersByName = {};
    this._hashersByCode = {};
    this._loadHasher = options.loadHasher || LOAD_HASHER;
    for (const hasher of options.hashers) {
      this.addHasher(hasher);
    }
  }
  addHasher(hasher) {
    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
      throw new Error(`Resolver already exists for codec "${hasher.name}"`);
    }
    this._hashersByName[hasher.name] = hasher;
    this._hashersByCode[hasher.code] = hasher;
  }
  removeHasher(hasher) {
    delete this._hashersByName[hasher.name];
    delete this._hashersByCode[hasher.code];
  }
  async getHasher(code13) {
    const table = typeof code13 === "string" ? this._hashersByName : this._hashersByCode;
    if (table[code13]) {
      return table[code13];
    }
    const hasher = await this._loadHasher(code13);
    if (table[code13] == null) {
      this.addHasher(hasher);
    }
    return hasher;
  }
  listHashers() {
    return Object.values(this._hashersByName);
  }
};

// node_modules/ipfs-http-client/node_modules/@ipld/dag-cbor/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  code: () => code8,
  decode: () => decode14,
  encode: () => encode13,
  name: () => name8
});
init_globals();
init_cborg();
init_cid();
var CID_CBOR_TAG4 = 42;
function cidEncoder5(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG4),
    new Token(Type.bytes, bytes2)
  ];
}
function undefinedEncoder5() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder5(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions5 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder5,
    undefined: undefinedEncoder5,
    number: numberEncoder5
  }
};
function cidDecoder4(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
var decodeOptions5 = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions5.tags[CID_CBOR_TAG4] = cidDecoder4;
var name8 = "dag-cbor";
var code8 = 113;
var encode13 = (node) => encode4(node, encodeOptions5);
var decode14 = (data) => decode6(data, decodeOptions5);

// node_modules/ipfs-http-client/esm/src/index.js
var dagJOSE = __toESM(require_lib(), 1);
init_identity();
init_basics();

// node_modules/ipfs-http-client/esm/src/bitswap/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/bitswap/wantlist.js
init_globals();
init_cid();

// node_modules/ipfs-http-client/esm/src/lib/configure.js
init_globals();

// node_modules/ipfs-http-client/esm/src/lib/core.js
init_globals();
var import_multiaddr7 = __toESM(require_src(), 1);
var import_env = __toESM(require_env(), 1);
var import_debug45 = __toESM(require_browser2(), 1);
var import_http3 = __toESM(require_http(), 1);

// node_modules/ipfs-core-utils/esm/src/to-url-string.js
init_globals();
var import_multiaddr6 = __toESM(require_src(), 1);
var import_multiaddr_to_uri2 = __toESM(require_multiaddr_to_uri(), 1);
function toUrlString(url) {
  try {
    url = (0, import_multiaddr_to_uri2.default)(new import_multiaddr6.Multiaddr(url));
  } catch (err) {
  }
  url = url.toString();
  return url;
}

// node_modules/ipfs-core-utils/esm/src/agent.browser.js
init_globals();
var agent_browser_default = () => {
};

// node_modules/ipfs-http-client/esm/src/lib/core.js
var log44 = (0, import_debug45.default)("ipfs-http-client:lib:error-handler");
var merge3 = merge_options_default.bind({ ignoreUndefined: true });
var DEFAULT_PROTOCOL = import_env.isBrowser || import_env.isWebWorker ? location.protocol : "http";
var DEFAULT_HOST = import_env.isBrowser || import_env.isWebWorker ? location.hostname : "localhost";
var DEFAULT_PORT = import_env.isBrowser || import_env.isWebWorker ? location.port : "5001";
var normalizeOptions = (options = {}) => {
  let url;
  let opts = {};
  let agent;
  if (typeof options === "string" || import_multiaddr7.Multiaddr.isMultiaddr(options)) {
    url = new URL(toUrlString(options));
  } else if (options instanceof URL) {
    url = options;
  } else if (typeof options.url === "string" || import_multiaddr7.Multiaddr.isMultiaddr(options.url)) {
    url = new URL(toUrlString(options.url));
    opts = options;
  } else if (options.url instanceof URL) {
    url = options.url;
    opts = options;
  } else {
    opts = options || {};
    const protocol = (opts.protocol || DEFAULT_PROTOCOL).replace(":", "");
    const host = (opts.host || DEFAULT_HOST).split(":")[0];
    const port = opts.port || DEFAULT_PORT;
    url = new URL(`${protocol}://${host}:${port}`);
  }
  if (opts.apiPath) {
    url.pathname = opts.apiPath;
  } else if (url.pathname === "/" || url.pathname === void 0) {
    url.pathname = "api/v0";
  }
  if (import_env.isNode) {
    const Agent = agent_browser_default(url);
    agent = opts.agent || new Agent({
      keepAlive: true,
      maxSockets: 6
    });
  }
  return {
    ...opts,
    host: url.host,
    protocol: url.protocol.replace(":", ""),
    port: Number(url.port),
    apiPath: url.pathname,
    url,
    agent
  };
};
var errorHandler = async (response) => {
  let msg;
  try {
    if ((response.headers.get("Content-Type") || "").startsWith("application/json")) {
      const data = await response.json();
      log44(data);
      msg = data.Message || data.message;
    } else {
      msg = await response.text();
    }
  } catch (err) {
    log44("Failed to parse error response", err);
    msg = err.message;
  }
  let error = new import_http3.default.HTTPError(response);
  if (msg) {
    if (msg.includes("deadline has elapsed")) {
      error = new import_http3.default.TimeoutError();
    }
    if (msg && msg.includes("context deadline exceeded")) {
      error = new import_http3.default.TimeoutError();
    }
  }
  if (msg && msg.includes("request timed out")) {
    error = new import_http3.default.TimeoutError();
  }
  if (msg) {
    error.message = msg;
  }
  throw error;
};
var KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
var kebabCase = (str) => {
  return str.replace(KEBAB_REGEX, function(match) {
    return "-" + match.toLowerCase();
  });
};
var parseTimeout = (value) => {
  return typeof value === "string" ? parse_duration_default(value) : value;
};
var Client = class extends import_http3.default {
  constructor(options = {}) {
    const opts = normalizeOptions(options);
    super({
      timeout: parseTimeout(opts.timeout || 0) || void 0,
      headers: opts.headers,
      base: `${opts.url}`,
      handleError: errorHandler,
      transformSearchParams: (search) => {
        const out = new URLSearchParams();
        for (const [key, value] of search) {
          if (value !== "undefined" && value !== "null" && key !== "signal") {
            out.append(kebabCase(key), value);
          }
          if (key === "timeout" && !isNaN(value)) {
            out.append(kebabCase(key), value);
          }
        }
        return out;
      },
      agent: opts.agent
    });
    delete this.get;
    delete this.put;
    delete this.delete;
    delete this.options;
    const fetch = this.fetch;
    this.fetch = (resource, options2 = {}) => {
      if (typeof resource === "string" && !resource.startsWith("/")) {
        resource = `${opts.url}/${resource}`;
      }
      return fetch.call(this, resource, merge3(options2, { method: "POST" }));
    };
  }
};
var HTTPError = import_http3.default.HTTPError;

// node_modules/ipfs-http-client/esm/src/lib/configure.js
var configure = (fn) => {
  return (options) => {
    return fn(new Client(options), options);
  };
};

// node_modules/ipfs-http-client/esm/src/lib/to-url-search-params.js
init_globals();

// node_modules/ipfs-http-client/esm/src/lib/mode-to-string.js
init_globals();
function modeToString(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}

// node_modules/ipfs-http-client/esm/src/lib/parse-mtime.js
init_globals();
var import_err_code61 = __toESM(require_err_code(), 1);
function parseMtime2(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code61.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}

// node_modules/ipfs-http-client/esm/src/lib/to-url-search-params.js
function toUrlSearchParams({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    };
  }
  if (hashAlg) {
    options.hash = hashAlg;
  }
  if (mtime != null) {
    mtime = parseMtime2(mtime);
    options.mtime = mtime.secs;
    options.mtimeNsecs = mtime.nsecs;
  }
  if (mode != null) {
    options.mode = modeToString(mode);
  }
  if (options.timeout && !isNaN(options.timeout)) {
    options.timeout = `${options.timeout}ms`;
  }
  if (arg === void 0 || arg === null) {
    arg = [];
  } else if (!Array.isArray(arg)) {
    arg = [arg];
  }
  const urlSearchParams = new URLSearchParams(options);
  arg.forEach((arg2) => urlSearchParams.append("arg", arg2));
  return urlSearchParams;
}

// node_modules/ipfs-http-client/esm/src/bitswap/wantlist.js
var createWantlist2 = configure((api) => {
  async function wantlist(options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID.parse(k["/"]));
  }
  return wantlist;
});

// node_modules/ipfs-http-client/esm/src/bitswap/wantlist-for-peer.js
init_globals();
init_cid();
var createWantlistForPeer2 = configure((api) => {
  async function wantlistForPeer(peerId, options = {}) {
    const res = await (await api.post("bitswap/wantlist", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        peer: peerId.toString()
      }),
      headers: options.headers
    })).json();
    return (res.Keys || []).map((k) => CID.parse(k["/"]));
  }
  return wantlistForPeer;
});

// node_modules/ipfs-http-client/esm/src/bitswap/stat.js
init_globals();
init_cid();
var createStat6 = configure((api) => {
  async function stat(options = {}) {
    const res = await api.post("bitswap/stat", {
      searchParams: toUrlSearchParams(options),
      signal: options.signal,
      headers: options.headers
    });
    return toCoreInterface(await res.json());
  }
  return stat;
});
function toCoreInterface(res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map((k) => CID.parse(k["/"])),
    peers: res.Peers || [],
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  };
}

// node_modules/ipfs-http-client/esm/src/bitswap/unwant.js
init_globals();
var createUnwant2 = configure((api) => {
  async function unwant(cid, options = {}) {
    const res = await api.post("bitswap/unwant", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return res.json();
  }
  return unwant;
});

// node_modules/ipfs-http-client/esm/src/bitswap/index.js
function createBitswap(config2) {
  return {
    wantlist: createWantlist2(config2),
    wantlistForPeer: createWantlistForPeer2(config2),
    unwant: createUnwant2(config2),
    stat: createStat6(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/block/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/block/get.js
init_globals();
var createGet5 = configure((api) => {
  async function get6(cid, options = {}) {
    const res = await api.post("block/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    return new Uint8Array(await res.arrayBuffer());
  }
  return get6;
});

// node_modules/ipfs-http-client/esm/src/block/put.js
init_globals();
init_cid();

// node_modules/ipfs-core-utils/esm/src/multipart-request.browser.js
init_globals();

// node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.browser.js
init_globals();

// node_modules/ipfs-core-utils/esm/src/files/normalise-content.browser.js
init_globals();
var import_err_code62 = __toESM(require_err_code(), 1);
var import_it_peekable5 = __toESM(require_it_peekable(), 1);
var import_browser_readablestream_to_it4 = __toESM(require_browser_readablestream_to_it(), 1);
var import_it_all5 = __toESM(require_it_all(), 1);
async function normaliseContent2(input) {
  if (isBytes(input)) {
    return new Blob([input]);
  }
  if (typeof input === "string" || input instanceof String) {
    return new Blob([input.toString()]);
  }
  if (isBlob(input)) {
    return input;
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it4.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable5.default)(input);
    const { value, done } = await peekable.peek();
    if (done) {
      return itToBlob(peekable);
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return new Blob([Uint8Array.from(await (0, import_it_all5.default)(peekable))]);
    }
    if (isBytes(value) || typeof value === "string" || value instanceof String) {
      return itToBlob(peekable);
    }
  }
  throw (0, import_err_code62.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
async function itToBlob(stream) {
  const parts = [];
  for await (const chunk of stream) {
    parts.push(chunk);
  }
  return new Blob(parts);
}

// node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.browser.js
function normaliseInput4(input) {
  return normaliseCandidateMultiple(input, normaliseContent2, true);
}

// node_modules/ipfs-core-utils/esm/src/mode-to-string.js
init_globals();
function modeToString2(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}

// node_modules/ipfs-core-utils/esm/src/multipart-request.browser.js
async function multipartRequest(source, abortController, headers = {}) {
  const parts = [];
  const formData = new FormData();
  let index = 0;
  let total = 0;
  for await (const { content, path, mode, mtime } of normaliseInput4(source)) {
    let fileSuffix = "";
    const type = content ? "file" : "dir";
    if (index > 0) {
      fileSuffix = `-${index}`;
    }
    let fieldName = type + fileSuffix;
    const qs = [];
    if (mode !== null && mode !== void 0) {
      qs.push(`mode=${modeToString2(mode)}`);
    }
    if (mtime != null) {
      const { secs, nsecs } = mtime;
      qs.push(`mtime=${secs}`);
      if (nsecs != null) {
        qs.push(`mtime-nsecs=${nsecs}`);
      }
    }
    if (qs.length) {
      fieldName = `${fieldName}?${qs.join("&")}`;
    }
    if (content) {
      formData.set(fieldName, content, path != null ? encodeURIComponent(path) : void 0);
      const end = total + content.size;
      parts.push({
        name: path,
        start: total,
        end
      });
      total = end;
    } else if (path != null) {
      formData.set(fieldName, new File([""], encodeURIComponent(path), { type: "application/x-directory" }));
    } else {
      throw new Error("path or content or both must be set");
    }
    index++;
  }
  return {
    total,
    parts,
    headers,
    body: formData
  };
}

// node_modules/ipfs-http-client/esm/src/lib/abort-signal.js
init_globals();
var import_any_signal3 = __toESM(require_any_signal(), 1);
function filter8(signals) {
  return signals.filter(Boolean);
}
function abortSignal(...signals) {
  return (0, import_any_signal3.anySignal)(filter8(signals));
}

// node_modules/ipfs-http-client/esm/src/block/put.js
var createPut4 = configure((api) => {
  async function put(data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    let res;
    try {
      const response = await api.post("block/put", {
        signal,
        searchParams: toUrlSearchParams(options),
        ...await multipartRequest([data], controller, options.headers)
      });
      res = await response.json();
    } catch (err) {
      if (options.format === "dag-pb") {
        return put(data, {
          ...options,
          format: "protobuf"
        });
      } else if (options.format === "dag-cbor") {
        return put(data, {
          ...options,
          format: "cbor"
        });
      }
      throw err;
    }
    return CID.parse(res.Key);
  }
  return put;
});

// node_modules/ipfs-http-client/esm/src/block/rm.js
init_globals();
init_cid();
var createRm6 = configure((api) => {
  async function* rm(cid, options = {}) {
    if (!Array.isArray(cid)) {
      cid = [cid];
    }
    const res = await api.post("block/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.map((cid2) => cid2.toString()),
        "stream-channels": true,
        ...options
      }),
      headers: options.headers
    });
    for await (const removed of res.ndjson()) {
      yield toCoreInterface2(removed);
    }
  }
  return rm;
});
function toCoreInterface2(removed) {
  const out = { cid: CID.parse(removed.Hash) };
  if (removed.Error) {
    out.error = new Error(removed.Error);
  }
  return out;
}

// node_modules/ipfs-http-client/esm/src/block/stat.js
init_globals();
init_cid();
var createStat7 = configure((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("block/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      cid: CID.parse(data.Key),
      size: data.Size
    };
  }
  return stat;
});

// node_modules/ipfs-http-client/esm/src/block/index.js
function createBlock(config2) {
  return {
    get: createGet5(config2),
    put: createPut4(config2),
    rm: createRm6(config2),
    stat: createStat7(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/bootstrap/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/bootstrap/add.js
init_globals();
var import_multiaddr8 = __toESM(require_src(), 1);
var createAdd4 = configure((api) => {
  async function add(addr, options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => new import_multiaddr8.Multiaddr(ma)) };
  }
  return add;
});

// node_modules/ipfs-http-client/esm/src/bootstrap/clear.js
init_globals();
var import_multiaddr9 = __toESM(require_src(), 1);
var createClear2 = configure((api) => {
  async function clear(options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        all: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => new import_multiaddr9.Multiaddr(ma)) };
  }
  return clear;
});

// node_modules/ipfs-http-client/esm/src/bootstrap/list.js
init_globals();
var import_multiaddr10 = __toESM(require_src(), 1);
var createList3 = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("bootstrap/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => new import_multiaddr10.Multiaddr(ma)) };
  }
  return list;
});

// node_modules/ipfs-http-client/esm/src/bootstrap/reset.js
init_globals();
var import_multiaddr11 = __toESM(require_src(), 1);
var createReset2 = configure((api) => {
  async function reset(options = {}) {
    const res = await api.post("bootstrap/add", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        default: true
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => new import_multiaddr11.Multiaddr(ma)) };
  }
  return reset;
});

// node_modules/ipfs-http-client/esm/src/bootstrap/rm.js
init_globals();
var import_multiaddr12 = __toESM(require_src(), 1);
var createRm7 = configure((api) => {
  async function rm(addr, options = {}) {
    const res = await api.post("bootstrap/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return { Peers: Peers.map((ma) => new import_multiaddr12.Multiaddr(ma)) };
  }
  return rm;
});

// node_modules/ipfs-http-client/esm/src/bootstrap/index.js
function createBootstrap(config2) {
  return {
    add: createAdd4(config2),
    clear: createClear2(config2),
    list: createList3(config2),
    reset: createReset2(config2),
    rm: createRm7(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/config/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/config/profiles/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/config/profiles/apply.js
init_globals();
var createApply = configure((api) => {
  async function apply(profile, options = {}) {
    const res = await api.post("config/profile/apply", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: profile,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      original: data.OldCfg,
      updated: data.NewCfg
    };
  }
  return apply;
});

// node_modules/ipfs-http-client/esm/src/config/profiles/list.js
init_globals();

// node_modules/ipfs-http-client/esm/src/lib/object-to-camel.js
init_globals();
function objectToCamel(obj) {
  if (obj == null) {
    return obj;
  }
  const caps = /^[A-Z]+$/;
  const output = {};
  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) {
      camelObj[k.toLowerCase()] = obj[k];
    } else if (caps.test(k[0])) {
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k];
    } else {
      camelObj[k] = obj[k];
    }
    return camelObj;
  }, output);
}

// node_modules/ipfs-http-client/esm/src/config/profiles/list.js
var createList4 = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("config/profile/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.map((profile) => objectToCamel(profile));
  }
  return list;
});

// node_modules/ipfs-http-client/esm/src/config/profiles/index.js
function createProfiles(config2) {
  return {
    apply: createApply(config2),
    list: createList4(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/config/get.js
init_globals();
var createGet6 = configure((api) => {
  const get6 = async (key, options = {}) => {
    if (!key) {
      throw new Error("key argument is required");
    }
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: key,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Value;
  };
  return get6;
});

// node_modules/ipfs-http-client/esm/src/config/get-all.js
init_globals();
var createGetAll = configure((api) => {
  const getAll = async (options = {}) => {
    const res = await api.post("config/show", {
      signal: options.signal,
      searchParams: toUrlSearchParams({ ...options }),
      headers: options.headers
    });
    const data = await res.json();
    return data;
  };
  return getAll;
});

// node_modules/ipfs-http-client/esm/src/config/replace.js
init_globals();
init_from_string();
var createReplace = configure((api) => {
  const replace = async (config2, options = {}) => {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("config/replace", {
      signal,
      searchParams: toUrlSearchParams(options),
      ...await multipartRequest([fromString3(JSON.stringify(config2))], controller, options.headers)
    });
    await res.text();
  };
  return replace;
});

// node_modules/ipfs-http-client/esm/src/config/set.js
init_globals();
var createSet = configure((api) => {
  const set2 = async (key, value, options = {}) => {
    if (typeof key !== "string") {
      throw new Error("Invalid key type");
    }
    const params = {
      ...options,
      ...encodeParam(key, value)
    };
    const res = await api.post("config", {
      signal: options.signal,
      searchParams: toUrlSearchParams(params),
      headers: options.headers
    });
    await res.text();
  };
  return set2;
});
var encodeParam = (key, value) => {
  switch (typeof value) {
    case "boolean":
      return {
        arg: [
          key,
          value.toString()
        ],
        bool: true
      };
    case "string":
      return {
        arg: [
          key,
          value
        ]
      };
    default:
      return {
        arg: [
          key,
          JSON.stringify(value)
        ],
        json: true
      };
  }
};

// node_modules/ipfs-http-client/esm/src/config/index.js
function createConfig2(config2) {
  return {
    getAll: createGetAll(config2),
    get: createGet6(config2),
    set: createSet(config2),
    replace: createReplace(config2),
    profiles: createProfiles(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/dag/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/dag/export.js
init_globals();
var createExport3 = configure((api) => {
  async function* dagExport(root, options = {}) {
    const res = await api.post("dag/export", {
      signal: options.signal,
      searchParams: toUrlSearchParams({ arg: root.toString() }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return dagExport;
});

// node_modules/ipfs-http-client/esm/src/dag/get.js
init_globals();

// node_modules/ipfs-http-client/esm/src/lib/resolve.js
init_globals();
init_cid();
var import_err_code63 = __toESM(require_err_code(), 1);
async function* resolve6(cid, path, codecs2, getBlock, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await getBlock(cid2, options);
    return codec.decode(block);
  };
  const parts = path.split("/").filter(Boolean);
  let value = await load(cid);
  let lastCid = cid;
  while (parts.length) {
    const key = parts.shift();
    if (!key) {
      throw (0, import_err_code63.default)(new Error(`Could not resolve path "${path}"`), "ERR_INVALID_PATH");
    }
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      value = value[key];
      yield {
        value,
        remainderPath: parts.join("/")
      };
    } else {
      throw (0, import_err_code63.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    const cid2 = CID.asCID(value);
    if (cid2) {
      lastCid = cid2;
      value = await load(value);
    }
  }
  yield {
    value,
    remainderPath: ""
  };
}

// node_modules/ipfs-http-client/esm/src/dag/get.js
var import_it_first3 = __toESM(require_it_first(), 1);
var import_it_last10 = __toESM(require_it_last(), 1);
var import_err_code64 = __toESM(require_err_code(), 1);
var createGet7 = (codecs2, options) => {
  const fn = configure((api, opts) => {
    const getBlock = createGet5(opts);
    const get6 = async (cid, options2 = {}) => {
      if (options2.path) {
        const entry = options2.localResolve ? await (0, import_it_first3.default)(resolve6(cid, options2.path, codecs2, getBlock, options2)) : await (0, import_it_last10.default)(resolve6(cid, options2.path, codecs2, getBlock, options2));
        const result = entry;
        if (!result) {
          throw (0, import_err_code64.default)(new Error("Not found"), "ERR_NOT_FOUND");
        }
        return result;
      }
      const codec = await codecs2.getCodec(cid.code);
      const block = await getBlock(cid, options2);
      const node = codec.decode(block);
      return {
        value: node,
        remainderPath: ""
      };
    };
    return get6;
  });
  return fn(options);
};

// node_modules/ipfs-http-client/esm/src/dag/import.js
init_globals();
init_cid();
var createImport3 = configure((api) => {
  async function* dagImport(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body } = await multipartRequest(source, controller, options.headers);
    const res = await api.post("dag/import", {
      signal,
      headers,
      body,
      searchParams: toUrlSearchParams({ "pin-roots": options.pinRoots })
    });
    for await (const { Root: Root2 } of res.ndjson()) {
      if (Root2 !== void 0) {
        const {
          Cid: { "/": Cid },
          PinErrorMsg
        } = Root2;
        yield {
          root: {
            cid: CID.parse(Cid),
            pinErrorMsg: PinErrorMsg
          }
        };
      }
    }
  }
  return dagImport;
});

// node_modules/ipfs-http-client/esm/src/dag/put.js
init_globals();
init_cid();
var createPut5 = (codecs2, options) => {
  const fn = configure((api) => {
    const put = async (dagNode, options2 = {}) => {
      const settings = {
        storeCodec: "dag-cbor",
        hashAlg: "sha2-256",
        ...options2
      };
      let serialized;
      if (settings.inputCodec) {
        if (!(dagNode instanceof Uint8Array)) {
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        }
        serialized = dagNode;
      } else {
        const storeCodec = await codecs2.getCodec(settings.storeCodec);
        serialized = storeCodec.encode(dagNode);
        settings.inputCodec = settings.storeCodec;
      }
      const controller = new AbortController();
      const signal = abortSignal(controller.signal, settings.signal);
      const res = await api.post("dag/put", {
        timeout: settings.timeout,
        signal,
        searchParams: toUrlSearchParams(settings),
        ...await multipartRequest([serialized], controller, settings.headers)
      });
      const data = await res.json();
      return CID.parse(data.Cid["/"]);
    };
    return put;
  });
  return fn(options);
};

// node_modules/ipfs-http-client/esm/src/dag/resolve.js
init_globals();
init_cid();
var createResolve4 = configure((api) => {
  const resolve11 = async (ipfsPath2, options = {}) => {
    const res = await api.post("dag/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${ipfsPath2}${options.path ? `/${options.path}`.replace(/\/[/]+/g, "/") : ""}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      cid: CID.parse(data.Cid["/"]),
      remainderPath: data.RemPath
    };
  };
  return resolve11;
});

// node_modules/ipfs-http-client/esm/src/dag/index.js
function createDag(codecs2, config2) {
  return {
    export: createExport3(config2),
    get: createGet7(codecs2, config2),
    import: createImport3(config2),
    put: createPut5(codecs2, config2),
    resolve: createResolve4(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/dht/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/dht/find-peer.js
init_globals();

// node_modules/ipfs-http-client/esm/src/dht/map-event.js
init_globals();
init_from_string();

// node_modules/ipfs-http-client/esm/src/dht/response-types.js
init_globals();
var SendingQuery = 0;
var PeerResponse = 1;
var FinalPeer = 2;
var QueryError = 3;
var Provider = 4;
var Value = 5;
var AddingPeer = 6;
var DialingPeer = 7;

// node_modules/ipfs-http-client/esm/src/dht/map-event.js
var import_multiaddr13 = __toESM(require_src(), 1);
var mapEvent = (event) => {
  if (event.Type === SendingQuery) {
    return {
      to: event.ID,
      name: "SENDING_QUERY",
      type: event.Type
    };
  }
  if (event.Type === PeerResponse) {
    return {
      from: event.ID,
      name: "PEER_RESPONSE",
      type: event.Type,
      messageType: 0,
      messageName: "PUT_VALUE",
      closer: (event.Responses || []).map(({ ID, Addrs }) => ({
        id: ID,
        multiaddrs: Addrs.map((addr) => new import_multiaddr13.Multiaddr(addr))
      })),
      providers: (event.Responses || []).map(({ ID, Addrs }) => ({
        id: ID,
        multiaddrs: Addrs.map((addr) => new import_multiaddr13.Multiaddr(addr))
      }))
    };
  }
  if (event.Type === FinalPeer) {
    let peer = {
      id: event.ID,
      multiaddrs: []
    };
    if (event.Responses && event.Responses.length) {
      peer = {
        id: event.Responses[0].ID,
        multiaddrs: event.Responses[0].Addrs.map((addr) => new import_multiaddr13.Multiaddr(addr))
      };
    }
    return {
      from: event.ID,
      name: "FINAL_PEER",
      type: event.Type,
      peer
    };
  }
  if (event.Type === QueryError) {
    return {
      from: event.ID,
      name: "QUERY_ERROR",
      type: event.Type,
      error: new Error(event.Extra)
    };
  }
  if (event.Type === Provider) {
    return {
      from: event.ID,
      name: "PROVIDER",
      type: event.Type,
      providers: event.Responses.map(({ ID, Addrs }) => ({
        id: ID,
        multiaddrs: Addrs.map((addr) => new import_multiaddr13.Multiaddr(addr))
      }))
    };
  }
  if (event.Type === Value) {
    return {
      from: event.ID,
      name: "VALUE",
      type: event.Type,
      value: fromString3(event.Extra, "base64pad")
    };
  }
  if (event.Type === AddingPeer) {
    const peers = event.Responses.map(({ ID }) => ID);
    if (!peers.length) {
      throw new Error("No peer found");
    }
    return {
      name: "ADDING_PEER",
      type: event.Type,
      peer: peers[0]
    };
  }
  if (event.Type === DialingPeer) {
    return {
      name: "DIALING_PEER",
      type: event.Type,
      peer: event.ID
    };
  }
  throw new Error("Unknown DHT event type");
};

// node_modules/ipfs-http-client/esm/src/dht/find-peer.js
var createFindPeer = configure((api) => {
  async function* findPeer2(peerId, options = {}) {
    const res = await api.post("dht/findpeer", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId,
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findPeer2;
});

// node_modules/ipfs-http-client/esm/src/dht/find-provs.js
init_globals();
var createFindProvs = configure((api) => {
  async function* findProvs(cid, options = {}) {
    const res = await api.post("dht/findprovs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cid.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return findProvs;
});

// node_modules/ipfs-http-client/esm/src/dht/get.js
init_globals();
init_to_string();
var createGet8 = configure((api) => {
  async function* get6(key, options = {}) {
    const res = await api.post("dht/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: key instanceof Uint8Array ? toString3(key) : key.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return get6;
});

// node_modules/ipfs-http-client/esm/src/dht/provide.js
init_globals();
var createProvide = configure((api) => {
  async function* provide(cids, options = { recursive: false }) {
    const cidArr = Array.isArray(cids) ? cids : [cids];
    const res = await api.post("dht/provide", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: cidArr.map((cid) => cid.toString()),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return provide;
});

// node_modules/ipfs-http-client/esm/src/dht/put.js
init_globals();
init_to_string();
var createPut6 = configure((api) => {
  async function* put(key, value, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("dht/put", {
      signal,
      searchParams: toUrlSearchParams({
        arg: key instanceof Uint8Array ? toString3(key) : key.toString(),
        ...options
      }),
      ...await multipartRequest([value], controller, options.headers)
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return put;
});

// node_modules/ipfs-http-client/esm/src/dht/query.js
init_globals();
var createQuery = configure((api) => {
  async function* query(peerId, options = {}) {
    const res = await api.post("dht/query", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: peerId.toString(),
        ...options
      }),
      headers: options.headers
    });
    for await (const event of res.ndjson()) {
      yield mapEvent(event);
    }
  }
  return query;
});

// node_modules/ipfs-http-client/esm/src/dht/index.js
function createDht(config2) {
  return {
    findPeer: createFindPeer(config2),
    findProvs: createFindProvs(config2),
    get: createGet8(config2),
    provide: createProvide(config2),
    put: createPut6(config2),
    query: createQuery(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/diag/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/diag/cmds.js
init_globals();
var createCmds = configure((api) => {
  async function cmds(options = {}) {
    const res = await api.post("diag/cmds", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return cmds;
});

// node_modules/ipfs-http-client/esm/src/diag/net.js
init_globals();
var createNet = configure((api) => {
  async function net(options = {}) {
    const res = await api.post("diag/net", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return net;
});

// node_modules/ipfs-http-client/esm/src/diag/sys.js
init_globals();
var createSys = configure((api) => {
  async function sys(options = {}) {
    const res = await api.post("diag/sys", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  }
  return sys;
});

// node_modules/ipfs-http-client/esm/src/diag/index.js
function createDiag(config2) {
  return {
    cmds: createCmds(config2),
    net: createNet(config2),
    sys: createSys(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/files/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/files/chmod.js
init_globals();
var createChmod2 = configure((api) => {
  async function chmod(path, mode, options = {}) {
    const res = await api.post("files/chmod", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        mode,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return chmod;
});

// node_modules/ipfs-http-client/esm/src/files/cp.js
init_globals();
init_cid();
var createCp2 = configure((api) => {
  async function cp(sources, destination, options = {}) {
    const sourceArr = Array.isArray(sources) ? sources : [sources];
    const res = await api.post("files/cp", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sourceArr.concat(destination).map((src3) => CID.asCID(src3) ? `/ipfs/${src3}` : src3),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return cp;
});

// node_modules/ipfs-http-client/esm/src/files/flush.js
init_globals();
init_cid();
var createFlush2 = configure((api) => {
  async function flush3(path, options = {}) {
    if (!path || typeof path !== "string") {
      throw new Error("ipfs.files.flush requires a path");
    }
    const res = await api.post("files/flush", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return CID.parse(data.Cid);
  }
  return flush3;
});

// node_modules/ipfs-http-client/esm/src/files/ls.js
init_globals();
init_cid();

// node_modules/ipfs-http-client/esm/src/lib/object-to-camel-with-metadata.js
init_globals();
function objectToCamelWithMetadata(entry) {
  const file = objectToCamel(entry);
  if (Object.prototype.hasOwnProperty.call(file, "mode")) {
    file.mode = parseInt(file.mode, 8);
  }
  if (Object.prototype.hasOwnProperty.call(file, "mtime")) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    };
    delete file.mtimeNsecs;
  }
  return file;
}

// node_modules/ipfs-http-client/esm/src/files/ls.js
var createLs4 = configure((api) => {
  async function* ls(path, options = {}) {
    if (!path) {
      throw new Error("ipfs.files.ls requires a path");
    }
    const res = await api.post("files/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: CID.asCID(path) ? `/ipfs/${path}` : path,
        long: true,
        ...options,
        stream: true
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      if ("Entries" in result) {
        for (const entry of result.Entries || []) {
          yield toCoreInterface3(objectToCamelWithMetadata(entry));
        }
      } else {
        yield toCoreInterface3(objectToCamelWithMetadata(result));
      }
    }
  }
  return ls;
});
function toCoreInterface3(entry) {
  if (entry.hash) {
    entry.cid = CID.parse(entry.hash);
  }
  delete entry.hash;
  entry.type = entry.type === 1 ? "directory" : "file";
  return entry;
}

// node_modules/ipfs-http-client/esm/src/files/mkdir.js
init_globals();
var createMkdir2 = configure((api) => {
  async function mkdir(path, options = {}) {
    const res = await api.post("files/mkdir", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mkdir;
});

// node_modules/ipfs-http-client/esm/src/files/mv.js
init_globals();
var createMv2 = configure((api) => {
  async function mv(sources, destination, options = {}) {
    if (!Array.isArray(sources)) {
      sources = [sources];
    }
    const res = await api.post("files/mv", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: sources.concat(destination),
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return mv;
});

// node_modules/ipfs-http-client/esm/src/files/read.js
init_globals();
var import_source = __toESM(require_source(), 1);
var createRead2 = configure((api) => {
  async function* read3(path, options = {}) {
    const res = await api.post("files/read", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        count: options.length,
        ...options
      }),
      headers: options.headers
    });
    yield* (0, import_source.default)(res.body);
  }
  return read3;
});

// node_modules/ipfs-http-client/esm/src/files/rm.js
init_globals();
var import_http4 = __toESM(require_http(), 1);
var createRm8 = configure((api) => {
  async function rm(path, options = {}) {
    const res = await api.post("files/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const body = await res.text();
    if (body !== "") {
      const error = new import_http4.default.HTTPError(res);
      error.message = body;
      throw error;
    }
  }
  return rm;
});

// node_modules/ipfs-http-client/esm/src/files/stat.js
init_globals();
init_cid();
var createStat8 = configure((api) => {
  async function stat(path, options = {}) {
    const res = await api.post("files/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    data.WithLocality = data.WithLocality || false;
    return toCoreInterface4(objectToCamelWithMetadata(data));
  }
  return stat;
});
function toCoreInterface4(entry) {
  entry.cid = CID.parse(entry.hash);
  delete entry.hash;
  return entry;
}

// node_modules/ipfs-http-client/esm/src/files/touch.js
init_globals();
var createTouch2 = configure((api) => {
  async function touch(path, options = {}) {
    const res = await api.post("files/touch", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    await res.text();
  }
  return touch;
});

// node_modules/ipfs-http-client/esm/src/files/write.js
init_globals();
var createWrite2 = configure((api) => {
  async function write2(path, input, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("files/write", {
      signal,
      searchParams: toUrlSearchParams({
        arg: path,
        streamChannels: true,
        count: options.length,
        ...options
      }),
      ...await multipartRequest([{
        content: input,
        path: "arg",
        mode: modeToString(options.mode),
        mtime: parseMtime2(options.mtime)
      }], controller, options.headers)
    });
    await res.text();
  }
  return write2;
});

// node_modules/ipfs-http-client/esm/src/files/index.js
function createFiles2(config2) {
  return {
    chmod: createChmod2(config2),
    cp: createCp2(config2),
    flush: createFlush2(config2),
    ls: createLs4(config2),
    mkdir: createMkdir2(config2),
    mv: createMv2(config2),
    read: createRead2(config2),
    rm: createRm8(config2),
    stat: createStat8(config2),
    touch: createTouch2(config2),
    write: createWrite2(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/key/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/key/export.js
init_globals();
var import_err_code65 = __toESM(require_err_code(), 1);
var createExport4 = configure((api) => {
  const exportKey = async (name10, password, options = {}) => {
    throw (0, import_err_code65.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return exportKey;
});

// node_modules/ipfs-http-client/esm/src/key/gen.js
init_globals();
var createGen2 = configure((api) => {
  async function gen(name10, options = {
    type: "rsa",
    size: 2048
  }) {
    const res = await api.post("key/gen", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name10,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return gen;
});

// node_modules/ipfs-http-client/esm/src/key/import.js
init_globals();
var createImport4 = configure((api) => {
  async function importKey(name10, pem, password, options = {}) {
    const res = await api.post("key/import", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name10,
        pem,
        password,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data);
  }
  return importKey;
});

// node_modules/ipfs-http-client/esm/src/key/info.js
init_globals();
var import_err_code66 = __toESM(require_err_code(), 1);
var createInfo2 = configure((api) => {
  const info = async (name10, options = {}) => {
    throw (0, import_err_code66.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return info;
});

// node_modules/ipfs-http-client/esm/src/key/list.js
init_globals();
var createList5 = configure((api) => {
  async function list(options = {}) {
    const res = await api.post("key/list", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Keys || []).map((k) => objectToCamel(k));
  }
  return list;
});

// node_modules/ipfs-http-client/esm/src/key/rename.js
init_globals();
var createRename2 = configure((api) => {
  async function rename(oldName, newName, options = {}) {
    const res = await api.post("key/rename", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          oldName,
          newName
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return rename;
});

// node_modules/ipfs-http-client/esm/src/key/rm.js
init_globals();
var createRm9 = configure((api) => {
  async function rm(name10, options = {}) {
    const res = await api.post("key/rm", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name10,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return objectToCamel(data.Keys[0]);
  }
  return rm;
});

// node_modules/ipfs-http-client/esm/src/key/index.js
function createKey(config2) {
  return {
    export: createExport4(config2),
    gen: createGen2(config2),
    import: createImport4(config2),
    info: createInfo2(config2),
    list: createList5(config2),
    rename: createRename2(config2),
    rm: createRm9(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/log/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/log/level.js
init_globals();
var createLevel = configure((api) => {
  async function level(subsystem, level2, options = {}) {
    const res = await api.post("log/level", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          subsystem,
          level2
        ],
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return level;
});

// node_modules/ipfs-http-client/esm/src/log/ls.js
init_globals();
var createLs5 = configure((api) => {
  async function ls(options = {}) {
    const res = await api.post("log/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings;
  }
  return ls;
});

// node_modules/ipfs-http-client/esm/src/log/tail.js
init_globals();
var createTail = configure((api) => {
  async function* tail(options = {}) {
    const res = await api.post("log/tail", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return tail;
});

// node_modules/ipfs-http-client/esm/src/log/index.js
function createLog(config2) {
  return {
    level: createLevel(config2),
    ls: createLs5(config2),
    tail: createTail(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/name/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/name/publish.js
init_globals();
var createPublish2 = configure((api) => {
  async function publish(path, options = {}) {
    const res = await api.post("name/publish", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${path}`,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return publish;
});

// node_modules/ipfs-http-client/esm/src/name/resolve.js
init_globals();
var createResolve5 = configure((api) => {
  async function* resolve11(path, options = {}) {
    const res = await api.post("name/resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        stream: true,
        ...options
      }),
      headers: options.headers
    });
    for await (const result of res.ndjson()) {
      yield result.Path;
    }
  }
  return resolve11;
});

// node_modules/ipfs-http-client/esm/src/name/pubsub/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/name/pubsub/cancel.js
init_globals();
var createCancel2 = configure((api) => {
  async function cancel(name10, options = {}) {
    const res = await api.post("name/pubsub/cancel", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: name10,
        ...options
      }),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return cancel;
});

// node_modules/ipfs-http-client/esm/src/name/pubsub/state.js
init_globals();
var createState2 = configure((api) => {
  async function state(options = {}) {
    const res = await api.post("name/pubsub/state", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return state;
});

// node_modules/ipfs-http-client/esm/src/name/pubsub/subs.js
init_globals();
var createSubs2 = configure((api) => {
  async function subs(options = {}) {
    const res = await api.post("name/pubsub/subs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return data.Strings || [];
  }
  return subs;
});

// node_modules/ipfs-http-client/esm/src/name/pubsub/index.js
function createPubsub(config2) {
  return {
    cancel: createCancel2(config2),
    state: createState2(config2),
    subs: createSubs2(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/name/index.js
function createName(config2) {
  return {
    publish: createPublish2(config2),
    resolve: createResolve5(config2),
    pubsub: createPubsub(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/object/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/object/data.js
init_globals();
init_cid();
var createData2 = configure((api) => {
  async function data(cid, options = {}) {
    const res = await api.post("object/data", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data2 = await res.arrayBuffer();
    return new Uint8Array(data2, 0, data2.byteLength);
  }
  return data;
});

// node_modules/ipfs-http-client/esm/src/object/get.js
init_globals();
init_cid();
init_from_string();
var createGet9 = configure((api) => {
  async function get6(cid, options = {}) {
    const res = await api.post("object/get", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        dataEncoding: "base64",
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return {
      Data: fromString3(data.Data, "base64pad"),
      Links: (data.Links || []).map((link) => ({
        Name: link.Name,
        Hash: CID.parse(link.Hash),
        Tsize: link.Size
      }))
    };
  }
  return get6;
});

// node_modules/ipfs-http-client/esm/src/object/links.js
init_globals();
init_cid();
var createLinks2 = configure((api) => {
  async function links3(cid, options = {}) {
    const res = await api.post("object/links", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return (data.Links || []).map((l) => ({
      Name: l.Name,
      Tsize: l.Size,
      Hash: CID.parse(l.Hash)
    }));
  }
  return links3;
});

// node_modules/ipfs-http-client/esm/src/object/new.js
init_globals();
init_cid();
var createNew2 = configure((api) => {
  async function newObject(options = {}) {
    const res = await api.post("object/new", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.template,
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return newObject;
});

// node_modules/ipfs-http-client/esm/src/object/put.js
init_globals();
var createPut7 = (codecs2, options) => {
  const fn = configure((api) => {
    const dagPut = createPut5(codecs2, options);
    async function put(obj, options2 = {}) {
      return dagPut(obj, {
        ...options2,
        storeCodec: "dag-pb",
        hashAlg: "sha2-256",
        version: 1
      });
    }
    return put;
  });
  return fn(options);
};

// node_modules/ipfs-http-client/esm/src/object/stat.js
init_globals();
init_cid();
var createStat9 = configure((api) => {
  async function stat(cid, options = {}) {
    const res = await api.post("object/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      headers: options.headers
    });
    const output = await res.json();
    return {
      ...output,
      Hash: CID.parse(output.Hash)
    };
  }
  return stat;
});

// node_modules/ipfs-http-client/esm/src/object/patch/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/object/patch/add-link.js
init_globals();
init_cid();
var createAddLink2 = configure((api) => {
  async function addLink2(cid, dLink, options = {}) {
    const res = await api.post("object/patch/add-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          dLink.Name || dLink.name || "",
          (dLink.Hash || dLink.cid || "").toString() || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return addLink2;
});

// node_modules/ipfs-http-client/esm/src/object/patch/append-data.js
init_globals();
init_cid();
var createAppendData2 = configure((api) => {
  async function appendData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/append-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: `${cid}`,
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return appendData;
});

// node_modules/ipfs-http-client/esm/src/object/patch/rm-link.js
init_globals();
init_cid();
var createRmLink2 = configure((api) => {
  async function rmLink(cid, dLink, options = {}) {
    const res = await api.post("object/patch/rm-link", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: [
          `${cid}`,
          dLink.Name || dLink.name || null
        ],
        ...options
      }),
      headers: options.headers
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return rmLink;
});

// node_modules/ipfs-http-client/esm/src/object/patch/set-data.js
init_globals();
init_cid();
var createSetData2 = configure((api) => {
  async function setData(cid, data, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("object/patch/set-data", {
      signal,
      searchParams: toUrlSearchParams({
        arg: [`${cid}`],
        ...options
      }),
      ...await multipartRequest([data], controller, options.headers)
    });
    const { Hash } = await res.json();
    return CID.parse(Hash);
  }
  return setData;
});

// node_modules/ipfs-http-client/esm/src/object/patch/index.js
function createPatch(config2) {
  return {
    addLink: createAddLink2(config2),
    appendData: createAppendData2(config2),
    rmLink: createRmLink2(config2),
    setData: createSetData2(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/object/index.js
function createObject(codecs2, config2) {
  return {
    data: createData2(config2),
    get: createGet9(config2),
    links: createLinks2(config2),
    new: createNew2(config2),
    put: createPut7(codecs2, config2),
    stat: createStat9(config2),
    patch: createPatch(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/pin/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/pin/add-all.js
init_globals();
init_cid();
var createAddAll3 = configure((api) => {
  async function* addAll(source, options = {}) {
    for await (const { path, recursive: recursive3, metadata } of normaliseInput(source)) {
      const res = await api.post("pin/add", {
        signal: options.signal,
        searchParams: toUrlSearchParams({
          ...options,
          arg: path,
          recursive: recursive3,
          metadata: metadata ? JSON.stringify(metadata) : void 0,
          stream: true
        }),
        headers: options.headers
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          for (const cid of pin.Pins) {
            yield CID.parse(cid);
          }
          continue;
        }
        yield CID.parse(pin);
      }
    }
  }
  return addAll;
});

// node_modules/ipfs-http-client/esm/src/pin/add.js
init_globals();
var import_it_last11 = __toESM(require_it_last(), 1);
function createAdd5(config2) {
  const all6 = createAddAll3(config2);
  return configure(() => {
    async function add(path, options = {}) {
      return (0, import_it_last11.default)(all6([{
        path,
        ...options
      }], options));
    }
    return add;
  })(config2);
}

// node_modules/ipfs-http-client/esm/src/pin/ls.js
init_globals();
init_cid();
function toPin3(type, cid, metadata) {
  const pin = {
    type,
    cid: CID.parse(cid)
  };
  if (metadata) {
    pin.metadata = metadata;
  }
  return pin;
}
var createLs6 = configure((api) => {
  async function* ls(options = {}) {
    let paths = [];
    if (options.paths) {
      paths = Array.isArray(options.paths) ? options.paths : [options.paths];
    }
    const res = await api.post("pin/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        ...options,
        arg: paths.map((path) => `${path}`),
        stream: true
      }),
      headers: options.headers
    });
    for await (const pin of res.ndjson()) {
      if (pin.Keys) {
        for (const cid of Object.keys(pin.Keys)) {
          yield toPin3(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata);
        }
        return;
      }
      yield toPin3(pin.Type, pin.Cid, pin.Metadata);
    }
  }
  return ls;
});

// node_modules/ipfs-http-client/esm/src/pin/rm-all.js
init_globals();
init_cid();
var createRmAll2 = configure((api) => {
  async function* rmAll(source, options = {}) {
    for await (const { path, recursive: recursive3 } of normaliseInput(source)) {
      const searchParams = new URLSearchParams(options.searchParams);
      searchParams.append("arg", `${path}`);
      if (recursive3 != null)
        searchParams.set("recursive", String(recursive3));
      const res = await api.post("pin/rm", {
        signal: options.signal,
        headers: options.headers,
        searchParams: toUrlSearchParams({
          ...options,
          arg: `${path}`,
          recursive: recursive3
        })
      });
      for await (const pin of res.ndjson()) {
        if (pin.Pins) {
          yield* pin.Pins.map((cid) => CID.parse(cid));
          continue;
        }
        yield CID.parse(pin);
      }
    }
  }
  return rmAll;
});

// node_modules/ipfs-http-client/esm/src/pin/rm.js
init_globals();
var import_it_last12 = __toESM(require_it_last(), 1);
var createRm10 = (config2) => {
  const all6 = createRmAll2(config2);
  return configure(() => {
    async function rm(path, options = {}) {
      return (0, import_it_last12.default)(all6([{
        path,
        ...options
      }], options));
    }
    return rm;
  })(config2);
};

// node_modules/ipfs-http-client/esm/src/pin/remote/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/pin/remote/add.js
init_globals();

// node_modules/ipfs-http-client/esm/src/pin/remote/utils.js
init_globals();
init_cid();
var decodePin = ({
  Name: name10,
  Status: status,
  Cid: cid
}) => {
  return {
    cid: CID.parse(cid),
    name: name10,
    status
  };
};
var encodeService = (service) => {
  if (typeof service === "string" && service !== "") {
    return service;
  } else {
    throw new TypeError("service name must be passed");
  }
};
var encodeCID2 = (cid) => {
  if (CID.asCID(cid)) {
    return cid.toString();
  } else {
    throw new TypeError(`CID instance expected instead of ${typeof cid}`);
  }
};
var encodeQuery = ({ service, cid, name: name10, status, all: all6 }) => {
  const query = toUrlSearchParams({
    service: encodeService(service),
    name: name10,
    force: all6 ? true : void 0
  });
  if (cid) {
    for (const value of cid) {
      query.append("cid", encodeCID2(value));
    }
  }
  if (status) {
    for (const value of status) {
      query.append("status", value);
    }
  }
  return query;
};
var encodeAddParams = ({ cid, service, background, name: name10, origins }) => {
  const params = toUrlSearchParams({
    arg: encodeCID2(cid),
    service: encodeService(service),
    name: name10,
    background: background ? true : void 0
  });
  if (origins) {
    for (const origin of origins) {
      params.append("origin", origin.toString());
    }
  }
  return params;
};

// node_modules/ipfs-http-client/esm/src/pin/remote/add.js
function createAdd6(client) {
  async function add(cid, { timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/add", {
      timeout,
      signal,
      headers,
      searchParams: encodeAddParams({
        cid,
        ...query
      })
    });
    return decodePin(await response.json());
  }
  return add;
}

// node_modules/ipfs-http-client/esm/src/pin/remote/ls.js
init_globals();
function createLs7(client) {
  async function* ls({ timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/ls", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery(query)
    });
    for await (const pin of response.ndjson()) {
      yield decodePin(pin);
    }
  }
  return ls;
}

// node_modules/ipfs-http-client/esm/src/pin/remote/rm.js
init_globals();
function createRm11(client) {
  async function rm({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: false
      })
    });
  }
  return rm;
}

// node_modules/ipfs-http-client/esm/src/pin/remote/rm-all.js
init_globals();
function createRmAll3(client) {
  async function rmAll({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: true
      })
    });
  }
  return rmAll;
}

// node_modules/ipfs-http-client/esm/src/pin/remote/service/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/pin/remote/service/add.js
init_globals();

// node_modules/ipfs-http-client/esm/src/pin/remote/service/utils.js
init_globals();
function encodeEndpoint(url) {
  const href = String(url);
  if (href === "undefined") {
    throw Error("endpoint is required");
  }
  return href[href.length - 1] === "/" ? href.slice(0, -1) : href;
}
function decodeRemoteService(json) {
  return {
    service: json.Service,
    endpoint: new URL(json.ApiEndpoint),
    ...json.Stat && { stat: decodeStat(json.Stat) }
  };
}
function decodeStat(json) {
  switch (json.Status) {
    case "valid": {
      const { Pinning, Pinned, Queued, Failed } = json.PinCount;
      return {
        status: "valid",
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      };
    }
    case "invalid": {
      return { status: "invalid" };
    }
    default: {
      return { status: json.Status };
    }
  }
}

// node_modules/ipfs-http-client/esm/src/pin/remote/service/add.js
function createAdd7(client) {
  async function add(name10, options) {
    const { endpoint, key, headers, timeout, signal } = options;
    await client.post("pin/remote/service/add", {
      timeout,
      signal,
      searchParams: toUrlSearchParams({
        arg: [
          name10,
          encodeEndpoint(endpoint),
          key
        ]
      }),
      headers
    });
  }
  return add;
}

// node_modules/ipfs-http-client/esm/src/pin/remote/service/ls.js
init_globals();
function createLs8(client) {
  async function ls(options = {}) {
    const { stat, headers, timeout, signal } = options;
    const response = await client.post("pin/remote/service/ls", {
      timeout,
      signal,
      headers,
      searchParams: stat === true ? toUrlSearchParams({ stat }) : void 0
    });
    const { RemoteServices } = await response.json();
    return RemoteServices.map(decodeRemoteService);
  }
  return ls;
}

// node_modules/ipfs-http-client/esm/src/pin/remote/service/rm.js
init_globals();
function createRm12(client) {
  async function rm(name10, options = {}) {
    await client.post("pin/remote/service/rm", {
      signal: options.signal,
      headers: options.headers,
      searchParams: toUrlSearchParams({ arg: name10 })
    });
  }
  return rm;
}

// node_modules/ipfs-http-client/esm/src/pin/remote/service/index.js
function createService(config2) {
  const client = new Client(config2);
  return {
    add: createAdd7(client),
    ls: createLs8(client),
    rm: createRm12(client)
  };
}

// node_modules/ipfs-http-client/esm/src/pin/remote/index.js
function createRemote(config2) {
  const client = new Client(config2);
  return {
    add: createAdd6(client),
    ls: createLs7(client),
    rm: createRm11(client),
    rmAll: createRmAll3(client),
    service: createService(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/pin/index.js
function createPin(config2) {
  return {
    addAll: createAddAll3(config2),
    add: createAdd5(config2),
    ls: createLs6(config2),
    rmAll: createRmAll2(config2),
    rm: createRm10(config2),
    remote: createRemote(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/pubsub/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/pubsub/ls.js
init_globals();

// node_modules/ipfs-http-client/esm/src/lib/http-rpc-wire-format.js
init_globals();
init_from_string();
init_to_string();
init_base64();
var rpcArrayToTextArray = (strings) => {
  if (Array.isArray(strings)) {
    return strings.map(rpcToText);
  }
  return strings;
};
var rpcToText = (mb) => toString3(rpcToBytes(mb));
var rpcToBytes = (mb) => base64url.decode(mb);
var textToUrlSafeRpc = (text) => base64url.encode(fromString3(text));

// node_modules/ipfs-http-client/esm/src/pubsub/ls.js
var createLs9 = configure((api) => {
  async function ls(options = {}) {
    const { Strings } = await (await api.post("pubsub/ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return rpcArrayToTextArray(Strings) || [];
  }
  return ls;
});

// node_modules/ipfs-http-client/esm/src/pubsub/peers.js
init_globals();
var createPeers = configure((api) => {
  async function peers(topic, options = {}) {
    const res = await api.post("pubsub/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: textToUrlSafeRpc(topic),
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return peers;
});

// node_modules/ipfs-http-client/esm/src/pubsub/publish.js
init_globals();
var createPublish3 = configure((api) => {
  async function publish(topic, data, options = {}) {
    const searchParams = toUrlSearchParams({
      arg: textToUrlSafeRpc(topic),
      ...options
    });
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const res = await api.post("pubsub/pub", {
      signal,
      searchParams,
      ...await multipartRequest([data], controller, options.headers)
    });
    await res.text();
  }
  return publish;
});

// node_modules/ipfs-http-client/esm/src/pubsub/subscribe.js
init_globals();
var import_debug46 = __toESM(require_browser2(), 1);
var log45 = (0, import_debug46.default)("ipfs-http-client:pubsub:subscribe");
var createSubscribe = (options, subsTracker) => {
  return configure((api) => {
    async function subscribe(topic, handler, options2 = {}) {
      options2.signal = subsTracker.subscribe(topic, handler, options2.signal);
      let done;
      let fail;
      const result = new Promise((resolve11, reject) => {
        done = resolve11;
        fail = reject;
      });
      const ffWorkaround = setTimeout(() => done(), 1e3);
      api.post("pubsub/sub", {
        signal: options2.signal,
        searchParams: toUrlSearchParams({
          arg: textToUrlSafeRpc(topic),
          ...options2
        }),
        headers: options2.headers
      }).catch((err) => {
        subsTracker.unsubscribe(topic, handler);
        fail(err);
      }).then((response) => {
        clearTimeout(ffWorkaround);
        if (!response) {
          return;
        }
        readMessages(response, {
          onMessage: handler,
          onEnd: () => subsTracker.unsubscribe(topic, handler),
          onError: options2.onError
        });
        done();
      });
      return result;
    }
    return subscribe;
  })(options);
};
async function readMessages(response, { onMessage, onEnd, onError }) {
  onError = onError || log45;
  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue;
        }
        onMessage({
          from: msg.from,
          data: rpcToBytes(msg.data),
          seqno: rpcToBytes(msg.seqno),
          topicIDs: rpcArrayToTextArray(msg.topicIDs)
        });
      } catch (err) {
        err.message = `Failed to parse pubsub message: ${err.message}`;
        onError(err, false, msg);
      }
    }
  } catch (err) {
    if (!isAbortError(err)) {
      onError(err, true);
    }
  } finally {
    onEnd();
  }
}
var isAbortError = (error) => {
  switch (error.type) {
    case "aborted":
      return true;
    case "abort":
      return true;
    default:
      return error.name === "AbortError";
  }
};

// node_modules/ipfs-http-client/esm/src/pubsub/unsubscribe.js
init_globals();
var createUnsubscribe = (options, subsTracker) => {
  async function unsubscribe(topic, handler) {
    subsTracker.unsubscribe(topic, handler);
  }
  return unsubscribe;
};

// node_modules/ipfs-http-client/esm/src/pubsub/subscription-tracker.js
init_globals();
var SubscriptionTracker = class {
  constructor() {
    this._subs = /* @__PURE__ */ new Map();
  }
  subscribe(topic, handler, signal) {
    const topicSubs = this._subs.get(topic) || [];
    if (topicSubs.find((s) => s.handler === handler)) {
      throw new Error(`Already subscribed to ${topic} with this handler`);
    }
    const controller = new AbortController();
    this._subs.set(topic, [{
      handler,
      controller
    }].concat(topicSubs));
    if (signal) {
      signal.addEventListener("abort", () => this.unsubscribe(topic, handler));
    }
    return controller.signal;
  }
  unsubscribe(topic, handler) {
    const subs = this._subs.get(topic) || [];
    let unsubs;
    if (handler) {
      this._subs.set(topic, subs.filter((s) => s.handler !== handler));
      unsubs = subs.filter((s) => s.handler === handler);
    } else {
      this._subs.set(topic, []);
      unsubs = subs;
    }
    if (!(this._subs.get(topic) || []).length) {
      this._subs.delete(topic);
    }
    unsubs.forEach((s) => s.controller.abort());
  }
};

// node_modules/ipfs-http-client/esm/src/pubsub/index.js
function createPubsub2(config2) {
  const subscriptionTracker = new SubscriptionTracker();
  return {
    ls: createLs9(config2),
    peers: createPeers(config2),
    publish: createPublish3(config2),
    subscribe: createSubscribe(config2, subscriptionTracker),
    unsubscribe: createUnsubscribe(config2, subscriptionTracker)
  };
}

// node_modules/ipfs-http-client/esm/src/refs/index.js
init_globals();
init_cid();

// node_modules/ipfs-http-client/esm/src/refs/local.js
init_globals();
var createLocal2 = configure((api) => {
  async function* refsLocal(options = {}) {
    const res = await api.post("refs/local", {
      signal: options.signal,
      transform: objectToCamel,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    yield* res.ndjson();
  }
  return refsLocal;
});

// node_modules/ipfs-http-client/esm/src/refs/index.js
var createRefs2 = configure((api, opts) => {
  const refs = async function* (args, options = {}) {
    const argsArr = Array.isArray(args) ? args : [args];
    const res = await api.post("refs", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: argsArr.map((arg) => `${arg instanceof Uint8Array ? CID.decode(arg) : arg}`),
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  };
  return Object.assign(refs, { local: createLocal2(opts) });
});

// node_modules/ipfs-http-client/esm/src/repo/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/repo/gc.js
init_globals();
init_cid();
var createGc2 = configure((api) => {
  async function* gc2(options = {}) {
    const res = await api.post("repo/gc", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (res2) => {
        return {
          err: res2.Error ? new Error(res2.Error) : null,
          cid: (res2.Key || {})["/"] ? CID.parse(res2.Key["/"]) : null
        };
      }
    });
    yield* res.ndjson();
  }
  return gc2;
});

// node_modules/ipfs-http-client/esm/src/repo/stat.js
init_globals();
var createStat10 = configure((api) => {
  async function stat(options = {}) {
    const res = await api.post("repo/stat", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const data = await res.json();
    return {
      numObjects: BigInt(data.NumObjects),
      repoSize: BigInt(data.RepoSize),
      repoPath: data.RepoPath,
      version: data.Version,
      storageMax: BigInt(data.StorageMax)
    };
  }
  return stat;
});

// node_modules/ipfs-http-client/esm/src/repo/version.js
init_globals();
var createVersion3 = configure((api) => {
  async function version4(options = {}) {
    const res = await (await api.post("repo/version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    })).json();
    return res.Version;
  }
  return version4;
});

// node_modules/ipfs-http-client/esm/src/repo/index.js
function createRepo3(config2) {
  return {
    gc: createGc2(config2),
    stat: createStat10(config2),
    version: createVersion3(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/stats/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/stats/bw.js
init_globals();
var createBw2 = configure((api) => {
  async function* bw(options = {}) {
    const res = await api.post("stats/bw", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers,
      transform: (stats) => ({
        totalIn: BigInt(stats.TotalIn),
        totalOut: BigInt(stats.TotalOut),
        rateIn: parseFloat(stats.RateIn),
        rateOut: parseFloat(stats.RateOut)
      })
    });
    yield* res.ndjson();
  }
  return bw;
});

// node_modules/ipfs-http-client/esm/src/stats/index.js
function createStats(config2) {
  return {
    bitswap: createStat6(config2),
    repo: createStat10(config2),
    bw: createBw2(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/swarm/index.js
init_globals();

// node_modules/ipfs-http-client/esm/src/swarm/addrs.js
init_globals();
var import_multiaddr14 = __toESM(require_src(), 1);
var createAddrs = configure((api) => {
  async function addrs(options = {}) {
    const res = await api.post("swarm/addrs", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Addrs } = await res.json();
    return Object.keys(Addrs).map((id) => ({
      id,
      addrs: (Addrs[id] || []).map((a) => new import_multiaddr14.Multiaddr(a))
    }));
  }
  return addrs;
});

// node_modules/ipfs-http-client/esm/src/swarm/connect.js
init_globals();
var createConnect = configure((api) => {
  async function connect(addr, options = {}) {
    const res = await api.post("swarm/connect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return connect;
});

// node_modules/ipfs-http-client/esm/src/swarm/disconnect.js
init_globals();
var createDisconnect = configure((api) => {
  async function disconnect(addr, options = {}) {
    const res = await api.post("swarm/disconnect", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: addr,
        ...options
      }),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return Strings || [];
  }
  return disconnect;
});

// node_modules/ipfs-http-client/esm/src/swarm/local-addrs.js
init_globals();
var import_multiaddr15 = __toESM(require_src(), 1);
var createLocalAddrs = configure((api) => {
  async function localAddrs(options = {}) {
    const res = await api.post("swarm/addrs/local", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Strings } = await res.json();
    return (Strings || []).map((a) => new import_multiaddr15.Multiaddr(a));
  }
  return localAddrs;
});

// node_modules/ipfs-http-client/esm/src/swarm/peers.js
init_globals();
var import_multiaddr16 = __toESM(require_src(), 1);
var createPeers2 = configure((api) => {
  async function peers(options = {}) {
    const res = await api.post("swarm/peers", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    const { Peers } = await res.json();
    return (Peers || []).map((peer) => {
      return {
        addr: new import_multiaddr16.Multiaddr(peer.Addr),
        peer: peer.Peer,
        muxer: peer.Muxer,
        latency: peer.Latency,
        streams: peer.Streams,
        direction: peer.Direction == null ? void 0 : peer.Direction === 0 ? "inbound" : "outbound"
      };
    });
  }
  return peers;
});

// node_modules/ipfs-http-client/esm/src/swarm/index.js
function createSwarm(config2) {
  return {
    addrs: createAddrs(config2),
    connect: createConnect(config2),
    disconnect: createDisconnect(config2),
    localAddrs: createLocalAddrs(config2),
    peers: createPeers2(config2)
  };
}

// node_modules/ipfs-http-client/esm/src/add.js
init_globals();

// node_modules/ipfs-http-client/esm/src/add-all.js
init_globals();
init_cid();
var createAddAll4 = configure((api) => {
  async function* addAll(source, options = {}) {
    const controller = new AbortController();
    const signal = abortSignal(controller.signal, options.signal);
    const { headers, body, total, parts } = await multipartRequest(source, controller, options.headers);
    const [progressFn, onUploadProgress] = typeof options.progress === "function" ? createProgressHandler(total, parts, options.progress) : [
      void 0,
      void 0
    ];
    const res = await api.post("add", {
      searchParams: toUrlSearchParams({
        "stream-channels": true,
        ...options,
        progress: Boolean(progressFn)
      }),
      onUploadProgress,
      signal,
      headers,
      body
    });
    for await (let file of res.ndjson()) {
      file = objectToCamel(file);
      if (file.hash !== void 0) {
        yield toCoreInterface5(file);
      } else if (progressFn) {
        progressFn(file.bytes || 0, file.name);
      }
    }
  }
  return addAll;
});
var createProgressHandler = (total, parts, progress) => parts ? [
  void 0,
  createOnUploadProgress(total, parts, progress)
] : [
  progress,
  void 0
];
var createOnUploadProgress = (size, parts, progress) => {
  let index = 0;
  const count = parts.length;
  return ({ loaded, total }) => {
    const position = Math.floor(loaded / total * size);
    while (index < count) {
      const { start, end, name: name10 } = parts[index];
      if (position < end) {
        progress(position - start, name10);
        break;
      } else {
        progress(end - start, name10);
        index += 1;
      }
    }
  };
};
function toCoreInterface5({ name: name10, hash: hash2, size, mode, mtime, mtimeNsecs }) {
  const output = {
    path: name10,
    cid: CID.parse(hash2),
    size: parseInt(size)
  };
  if (mode != null) {
    output.mode = parseInt(mode, 8);
  }
  if (mtime != null) {
    output.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    };
  }
  return output;
}

// node_modules/ipfs-http-client/esm/src/add.js
var import_it_last13 = __toESM(require_it_last(), 1);
function createAdd8(options) {
  const all6 = createAddAll4(options);
  return configure(() => {
    async function add(input, options2 = {}) {
      return await (0, import_it_last13.default)(all6(normaliseInput2(input), options2));
    }
    return add;
  })(options);
}

// node_modules/ipfs-http-client/esm/src/cat.js
init_globals();
var createCat2 = configure((api) => {
  async function* cat(path, options = {}) {
    const res = await api.post("cat", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path.toString(),
        ...options
      }),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return cat;
});

// node_modules/ipfs-http-client/esm/src/commands.js
init_globals();
var createCommands = configure((api) => {
  const commands = async (options = {}) => {
    const res = await api.post("commands", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return res.json();
  };
  return commands;
});

// node_modules/ipfs-http-client/esm/src/dns.js
init_globals();
var createDns2 = configure((api) => {
  const dns = async (domain, options = {}) => {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: domain,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    return data.Path;
  };
  return dns;
});

// node_modules/ipfs-http-client/esm/src/get-endpoint-config.js
init_globals();
var createGetEndpointConfig = configure((api) => {
  return () => {
    const url = new URL(api.opts.base || "");
    return {
      host: url.hostname,
      port: url.port,
      protocol: url.protocol,
      pathname: url.pathname,
      "api-path": url.pathname
    };
  };
});

// node_modules/ipfs-http-client/esm/src/get.js
init_globals();
init_cid();
var createGet10 = configure((api) => {
  async function* get6(path, options = {}) {
    const opts = {
      arg: `${path instanceof Uint8Array ? CID.decode(path) : path}`,
      ...options
    };
    if (opts.compressionLevel) {
      opts["compression-level"] = opts.compressionLevel;
      delete opts.compressionLevel;
    }
    const res = await api.post("get", {
      signal: options.signal,
      searchParams: toUrlSearchParams(opts),
      headers: options.headers
    });
    yield* res.iterator();
  }
  return get6;
});

// node_modules/ipfs-http-client/esm/src/id.js
init_globals();
var import_multiaddr17 = __toESM(require_src(), 1);
var createId2 = configure((api) => {
  async function id(options = {}) {
    const res = await api.post("id", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: options.peerId ? options.peerId.toString() : void 0,
        ...options
      }),
      headers: options.headers
    });
    const data = await res.json();
    const output = { ...objectToCamel(data) };
    if (output.addresses) {
      output.addresses = output.addresses.map((ma) => new import_multiaddr17.Multiaddr(ma));
    }
    return output;
  }
  return id;
});

// node_modules/ipfs-http-client/esm/src/is-online.js
init_globals();
var createIsOnline2 = (options) => {
  const id = createId2(options);
  async function isOnline(options2 = {}) {
    const res = await id(options2);
    return Boolean(res && res.addresses && res.addresses.length);
  }
  return isOnline;
};

// node_modules/ipfs-http-client/esm/src/ls.js
init_globals();
init_cid();
var createLs10 = configure((api, opts) => {
  async function* ls(path, options = {}) {
    const pathStr = `${path instanceof Uint8Array ? CID.decode(path) : path}`;
    async function mapLink(link) {
      let hash2 = link.Hash;
      if (hash2.includes("/")) {
        const ipfsPath2 = hash2.startsWith("/ipfs/") ? hash2 : `/ipfs/${hash2}`;
        const stats = await createStat8(opts)(ipfsPath2);
        hash2 = stats.cid;
      } else {
        hash2 = CID.parse(hash2);
      }
      const entry = {
        name: link.Name,
        path: pathStr + (link.Name ? `/${link.Name}` : ""),
        size: link.Size,
        cid: hash2,
        type: typeOf(link)
      };
      if (link.Mode) {
        entry.mode = parseInt(link.Mode, 8);
      }
      if (link.Mtime !== void 0 && link.Mtime !== null) {
        entry.mtime = { secs: link.Mtime };
        if (link.MtimeNsecs !== void 0 && link.MtimeNsecs !== null) {
          entry.mtime.nsecs = link.MtimeNsecs;
        }
      }
      return entry;
    }
    const res = await api.post("ls", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: pathStr,
        ...options
      }),
      headers: options.headers
    });
    for await (let result of res.ndjson()) {
      result = result.Objects;
      if (!result) {
        throw new Error("expected .Objects in results");
      }
      result = result[0];
      if (!result) {
        throw new Error("expected one array in results.Objects");
      }
      const links3 = result.Links;
      if (!Array.isArray(links3)) {
        throw new Error("expected one array in results.Objects[0].Links");
      }
      if (!links3.length) {
        yield mapLink(result);
        return;
      }
      yield* links3.map(mapLink);
    }
  }
  return ls;
});
function typeOf(link) {
  switch (link.Type) {
    case 1:
    case 5:
      return "dir";
    case 2:
      return "file";
    default:
      return "file";
  }
}

// node_modules/ipfs-http-client/esm/src/mount.js
init_globals();
var createMount = configure((api) => {
  async function mount(options = {}) {
    const res = await api.post("dns", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return objectToCamel(await res.json());
  }
  return mount;
});

// node_modules/ipfs-http-client/esm/src/ping.js
init_globals();
var createPing = configure((api) => {
  async function* ping(peerId, options = {}) {
    const res = await api.post("ping", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: `${peerId}`,
        ...options
      }),
      headers: options.headers,
      transform: objectToCamel
    });
    yield* res.ndjson();
  }
  return ping;
});

// node_modules/ipfs-http-client/esm/src/resolve.js
init_globals();
var createResolve6 = configure((api) => {
  async function resolve11(path, options = {}) {
    const res = await api.post("resolve", {
      signal: options.signal,
      searchParams: toUrlSearchParams({
        arg: path,
        ...options
      }),
      headers: options.headers
    });
    const { Path } = await res.json();
    return Path;
  }
  return resolve11;
});

// node_modules/ipfs-http-client/esm/src/start.js
init_globals();
var import_err_code67 = __toESM(require_err_code(), 1);
var createStart2 = configure((api) => {
  const start = async (options = {}) => {
    throw (0, import_err_code67.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
  };
  return start;
});

// node_modules/ipfs-http-client/esm/src/stop.js
init_globals();
var createStop2 = configure((api) => {
  async function stop(options = {}) {
    const res = await api.post("shutdown", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    await res.text();
  }
  return stop;
});

// node_modules/ipfs-http-client/esm/src/version.js
init_globals();
var createVersion4 = configure((api) => {
  async function version4(options = {}) {
    const res = await api.post("version", {
      signal: options.signal,
      searchParams: toUrlSearchParams(options),
      headers: options.headers
    });
    return {
      ...objectToCamel(await res.json()),
      "ipfs-http-client": "1.0.0"
    };
  }
  return version4;
});

// node_modules/ipfs-http-client/esm/src/index.js
var import_glob_source = __toESM(require_glob_source(), 1);
init_cid();
var import_multiaddr18 = __toESM(require_src(), 1);
var import_url_source = __toESM(require_url_source(), 1);
function create5(options = {}) {
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const multibaseCodecs = Object.values(bases);
  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base4) => multibaseCodecs.push(base4));
  const multibases = new Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  });
  const blockCodecs = Object.values(codecs);
  [
    src_exports2,
    esm_exports4,
    esm_exports2,
    dagJOSE,
    id
  ].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const multihashHashers = Object.values(hashes);
  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
  const multihashes = new Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  });
  const client = {
    add: createAdd8(options),
    addAll: createAddAll4(options),
    bitswap: createBitswap(options),
    block: createBlock(options),
    bootstrap: createBootstrap(options),
    cat: createCat2(options),
    commands: createCommands(options),
    config: createConfig2(options),
    dag: createDag(multicodecs, options),
    dht: createDht(options),
    diag: createDiag(options),
    dns: createDns2(options),
    files: createFiles2(options),
    get: createGet10(options),
    getEndpointConfig: createGetEndpointConfig(options),
    id: createId2(options),
    isOnline: createIsOnline2(options),
    key: createKey(options),
    log: createLog(options),
    ls: createLs10(options),
    mount: createMount(options),
    name: createName(options),
    object: createObject(multicodecs, options),
    pin: createPin(options),
    ping: createPing(options),
    pubsub: createPubsub2(options),
    refs: createRefs2(options),
    repo: createRepo3(options),
    resolve: createResolve6(options),
    start: createStart2(options),
    stats: createStats(options),
    stop: createStop2(options),
    swarm: createSwarm(options),
    version: createVersion4(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  };
  return client;
}

// node_modules/ipfs-core/esm/src/components/libp2p.js
var import_multiaddr19 = __toESM(require_src(), 1);

// node_modules/ipfs-core-config/esm/src/libp2p.browser.js
init_globals();
var import_libp2p_websockets = __toESM(require_src15(), 1);
var import_libp2p_webrtc_star = __toESM(require_src16(), 1);
var import_libp2p_mplex = __toESM(require_src17(), 1);
var import_libp2p_noise = __toESM(require_src20(), 1);
var import_libp2p_kad_dht = __toESM(require_src21(), 1);
var import_libp2p_gossipsub2 = __toESM(require_src12(), 1);

// node_modules/ipfs-core-config/esm/src/utils/ipns.js
init_globals();
var validator2 = { func: (key, record) => validator.validate(record, key) };
function selector(_k, records) {
  return validator.select(records[0], records[1]);
}

// node_modules/ipfs-core-config/esm/src/libp2p.browser.js
function libp2pConfig() {
  const options = {
    dialer: {
      maxParallelDials: 150,
      maxDialsPerPeer: 4,
      dialTimeout: 1e4
    },
    modules: {
      transport: [
        import_libp2p_websockets.default,
        import_libp2p_webrtc_star.default
      ],
      streamMuxer: [import_libp2p_mplex.default],
      connEncryption: [import_libp2p_noise.NOISE],
      peerDiscovery: [],
      dht: import_libp2p_kad_dht.default,
      pubsub: import_libp2p_gossipsub2.default
    },
    config: {
      peerDiscovery: {
        autoDial: true,
        bootstrap: { enabled: true },
        webRTCStar: { enabled: true }
      },
      dht: {
        kBucketSize: 20,
        enabled: true,
        clientMode: true,
        validators: { ipns: validator2 },
        selectors: { ipns: selector }
      },
      pubsub: {
        enabled: true,
        emitSelf: true
      },
      nat: { enabled: false }
    },
    metrics: { enabled: true },
    peerStore: { persistence: true }
  };
  return options;
}

// node_modules/ipfs-core/esm/src/components/libp2p.js
var import_libp2p_bootstrap = __toESM(require_src22(), 1);
var import_libp2p2 = __toESM(require_src27(), 1);
var mergeOptions14 = merge_options_default.bind({ ignoreUndefined: true });
function createLibp2p({ options = {}, peerId, multiaddrs = [], repo, keychainConfig = {}, config: config2 = {} }) {
  const { datastore, keys: keys2 } = repo;
  const libp2pOptions = getLibp2pOptions({
    options,
    config: config2,
    datastore,
    keys: keys2,
    keychainConfig,
    peerId,
    multiaddrs
  });
  if (typeof options.libp2p === "function") {
    return options.libp2p({
      libp2pOptions,
      options,
      config: config2,
      datastore,
      peerId
    });
  }
  return import_libp2p2.default.create(libp2pOptions);
}
function getLibp2pOptions({ options, config: config2, datastore, keys: keys2, keychainConfig, peerId, multiaddrs }) {
  const getPubsubRouter = () => {
    const router = (0, import_dlv2.default)(config2, "Pubsub.Router") || "gossipsub";
    if (!routers[router]) {
      throw (0, import_err_code68.default)(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), "ERR_NOT_SUPPORTED");
    }
    return routers[router];
  };
  const libp2pDefaults = {
    datastore,
    peerId,
    modules: {}
  };
  const libp2pOptions = {
    modules: {
      pubsub: getPubsubRouter(),
      contentRouting: [],
      peerRouting: []
    },
    config: {
      peerDiscovery: {
        mdns: { enabled: (0, import_dlv2.default)(options, "config.Discovery.MDNS.Enabled", (0, import_dlv2.default)(config2, "Discovery.MDNS.Enabled", true)) },
        webRTCStar: { enabled: (0, import_dlv2.default)(options, "config.Discovery.webRTCStar.Enabled", (0, import_dlv2.default)(config2, "Discovery.webRTCStar.Enabled", true)) },
        bootstrap: { list: (0, import_dlv2.default)(options, "config.Bootstrap", (0, import_dlv2.default)(config2, "Bootstrap", [])) }
      },
      relay: {
        enabled: (0, import_dlv2.default)(options, "relay.enabled", (0, import_dlv2.default)(config2, "relay.enabled", true)),
        hop: {
          enabled: (0, import_dlv2.default)(options, "relay.hop.enabled", (0, import_dlv2.default)(config2, "relay.hop.enabled", false)),
          active: (0, import_dlv2.default)(options, "relay.hop.active", (0, import_dlv2.default)(config2, "relay.hop.active", false))
        }
      },
      dht: {
        enabled: (0, import_dlv2.default)(config2, "Routing.Type", "dhtclient") !== "none",
        clientMode: (0, import_dlv2.default)(config2, "Routing.Type", "dht") !== "dhtserver",
        kBucketSize: (0, import_dlv2.default)(options, "dht.kBucketSize", 20),
        validators: { ipns: validator }
      },
      pubsub: { enabled: (0, import_dlv2.default)(options, "config.Pubsub.Enabled", (0, import_dlv2.default)(config2, "Pubsub.Enabled", true)) },
      nat: { enabled: !(0, import_dlv2.default)(config2, "Swarm.DisableNatPortMap", false) }
    },
    addresses: {
      listen: multiaddrs.map((ma) => ma.toString()),
      announce: (0, import_dlv2.default)(options, "addresses.announce", (0, import_dlv2.default)(config2, "Addresses.Announce", [])),
      noAnnounce: (0, import_dlv2.default)(options, "addresses.noAnnounce", (0, import_dlv2.default)(config2, "Addresses.NoAnnounce", []))
    },
    connectionManager: (0, import_dlv2.default)(options, "connectionManager", {
      maxConnections: (0, import_dlv2.default)(options, "config.Swarm.ConnMgr.HighWater", (0, import_dlv2.default)(config2, "Swarm.ConnMgr.HighWater")),
      minConnections: (0, import_dlv2.default)(options, "config.Swarm.ConnMgr.LowWater", (0, import_dlv2.default)(config2, "Swarm.ConnMgr.LowWater"))
    }),
    keychain: {
      datastore: keys2,
      ...keychainConfig
    },
    host: { agentVersion: `js-ipfs/${ipfsCore}` }
  };
  let constructorOptions = (0, import_dlv2.default)(options, "libp2p", void 0);
  if (typeof constructorOptions === "function") {
    constructorOptions = void 0;
  }
  const libp2pConfig2 = mergeOptions14(libp2pDefaults, libp2pConfig(), libp2pOptions, constructorOptions);
  const bootstrapList = (0, import_dlv2.default)(libp2pConfig2, "config.peerDiscovery.bootstrap.list", []);
  if (bootstrapList.length > 0) {
    libp2pConfig2.modules.peerDiscovery.push(import_libp2p_bootstrap.default);
  }
  const delegateHosts = (0, import_dlv2.default)(options, "config.Addresses.Delegates", (0, import_dlv2.default)(config2, "Addresses.Delegates", []));
  if (delegateHosts.length > 0) {
    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];
    const delegateAddr = new import_multiaddr19.Multiaddr(delegateString).toOptions();
    const delegateApiOptions = {
      host: delegateAddr.host,
      protocol: parseInt(delegateAddr.port) === 443 ? "https" : "http",
      port: delegateAddr.port
    };
    const delegateHttpClient = create5(delegateApiOptions);
    libp2pOptions.modules.contentRouting = libp2pOptions.modules.contentRouting || [];
    libp2pOptions.modules.contentRouting.push(new import_libp2p_delegated_content_routing.default(peerId, delegateHttpClient));
    libp2pOptions.modules.peerRouting = libp2pOptions.modules.peerRouting || [];
    libp2pOptions.modules.peerRouting.push(new import_libp2p_delegated_peer_routing.default(delegateHttpClient));
  }
  return libp2pConfig2;
}

// node_modules/ipfs-core/esm/src/components/storage.js
var mergeOptions15 = merge_options_default.bind({ ignoreUndefined: true });
var log46 = (0, import_debug47.default)("ipfs:components:peer:storage");
var Storage = class {
  constructor(peerId, keychain, repo, print, isNew) {
    this.print = print;
    this.peerId = peerId;
    this.keychain = keychain;
    this.repo = repo;
    this.print = print;
    this.isNew = isNew;
  }
  static async start(print, codecs2, options) {
    const {
      repoAutoMigrate,
      repo: inputRepo,
      onMigrationProgress
    } = options;
    const repo = typeof inputRepo === "string" || inputRepo == null ? createRepo2(print, codecs2, {
      path: inputRepo,
      autoMigrate: repoAutoMigrate,
      onMigrationProgress
    }) : inputRepo;
    const { peerId, keychain, isNew } = await loadRepo(print, repo, options);
    return new Storage(peerId, keychain, repo, print, isNew);
  }
};
var loadRepo = async (print, repo, options) => {
  if (!repo.closed) {
    return {
      ...await configureRepo(repo, options),
      isNew: false
    };
  }
  try {
    await repo.open();
    return {
      ...await configureRepo(repo, options),
      isNew: false
    };
  } catch (err) {
    if (err.code !== ERR_REPO_NOT_INITIALIZED) {
      throw err;
    }
    if (options.init && options.init.allowNew === false) {
      throw new NotEnabledError("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");
    }
    return {
      ...await initRepo(print, repo, options),
      isNew: true
    };
  }
};
var initRepo = async (print, repo, options) => {
  const initOptions = options.init || {};
  const exists = await repo.exists();
  log46("repo exists?", exists);
  if (exists === true) {
    throw new Error("repo already exists");
  }
  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);
  const identity5 = peerIdToIdentity(peerId);
  log46("peer identity: %s", identity5.PeerID);
  const config2 = {
    ...mergeOptions15(applyProfiles(config_browser_default(), initOptions.profiles), options.config),
    Identity: identity5
  };
  await repo.init(config2);
  await repo.open();
  log46("repo opened");
  const keychainConfig = { pass: options.pass };
  try {
    keychainConfig.dek = await repo.config.get("Keychain.DEK");
  } catch (err) {
    if (err.code !== "ERR_NOT_FOUND") {
      throw err;
    }
  }
  const libp2p = await createLibp2p({
    options: void 0,
    multiaddrs: void 0,
    peerId,
    repo,
    config: config2,
    keychainConfig
  });
  if (libp2p.keychain && libp2p.keychain.opts) {
    await libp2p.loadKeychain();
    await repo.config.set("Keychain", { DEK: libp2p.keychain.opts.dek });
  }
  return {
    peerId,
    keychain: libp2p.keychain
  };
};
var decodePeerId = (peerId) => {
  log46("using user-supplied private-key");
  return typeof peerId === "object" ? peerId : import_peer_id11.default.createFromPrivKey(fromString3(peerId, "base64pad"));
};
var initPeerId = (print, { algorithm = "Ed25519", bits = 2048 }) => {
  print("generating %s keypair...", algorithm);
  return import_peer_id11.default.create({
    keyType: algorithm,
    bits
  });
};
var peerIdToIdentity = (peerId) => ({
  PeerID: peerId.toB58String(),
  PrivKey: toString3(peerId.privKey.bytes, "base64pad")
});
var configureRepo = async (repo, options) => {
  const config2 = options.config;
  const profiles2 = options.init && options.init.profiles || [];
  const pass = options.pass;
  const original = await repo.config.getAll();
  const changed = mergeConfigs(applyProfiles(original, profiles2), config2);
  if (original !== changed) {
    await repo.config.replace(changed);
  }
  if (!changed.Identity || !changed.Identity.PrivKey) {
    throw new NotInitializedError("No private key was found in the config, please intialize the repo");
  }
  const peerId = await import_peer_id11.default.createFromPrivKey(changed.Identity.PrivKey);
  const libp2p = await createLibp2p({
    options: void 0,
    multiaddrs: void 0,
    peerId,
    repo,
    config: changed,
    keychainConfig: {
      pass,
      ...changed.Keychain
    }
  });
  if (libp2p.keychain) {
    await libp2p.loadKeychain();
  }
  return {
    peerId,
    keychain: libp2p.keychain
  };
};
var mergeConfigs = (config2, changes) => changes ? mergeOptions15(config2, changes) : config2;
var applyProfiles = (config2, profiles2) => {
  return (profiles2 || []).reduce((config3, name10) => {
    const profile = profiles[name10];
    if (!profile) {
      throw new Error(`Could not find profile with name '${name10}'`);
    }
    log46("applying profile %s", name10);
    return profile.transform(config3);
  }, config2);
};

// node_modules/ipfs-core/esm/src/components/network.js
init_globals();

// node_modules/ipfs-bitswap/esm/src/index.js
init_globals();

// node_modules/ipfs-bitswap/esm/src/bitswap.js
init_globals();

// node_modules/ipfs-bitswap/esm/src/want-manager/index.js
init_globals();

// node_modules/ipfs-bitswap/esm/src/message/index.js
init_globals();
init_cid();
init_sha2_browser();
init_base58();
var import_varint_decoder = __toESM(require_src28(), 1);

// node_modules/ipfs-bitswap/esm/src/utils/varint-encoder.js
init_globals();
var varint5 = __toESM(require_varint(), 1);
function varintEncoder(buf3) {
  let out = new Uint8Array(buf3.reduce((acc, curr) => {
    return acc + varint5.default.encodingLength(curr);
  }, 0));
  let offset = 0;
  for (const num of buf3) {
    out = varint5.encode(num, out, offset);
    offset += varint5.default.encodingLength(num);
  }
  return out;
}
var varint_encoder_default = varintEncoder;

// node_modules/ipfs-bitswap/esm/src/utils/index.js
init_globals();
var import_debug48 = __toESM(require_browser2(), 1);
init_equals();

// node_modules/ipfs-bitswap/esm/src/message/entry.js
init_globals();

// node_modules/ipfs-bitswap/esm/src/wantlist/index.js
init_globals();

// node_modules/ipfs-bitswap/esm/src/wantlist/entry.js
init_globals();
init_base58();
var WantListEntry = class {
  constructor(cid, priority, wantType) {
    this._refCounter = 1;
    this.cid = cid;
    this.priority = priority || 1;
    this.wantType = wantType;
  }
  inc() {
    this._refCounter += 1;
  }
  dec() {
    this._refCounter = Math.max(0, this._refCounter - 1);
  }
  hasRefs() {
    return this._refCounter > 0;
  }
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc);
    return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`;
  }
  equals(other) {
    return this._refCounter === other._refCounter && this.cid.equals(other.cid) && this.priority === other.priority && this.wantType === other.wantType;
  }
};

// node_modules/ipfs-bitswap/esm/src/wantlist/index.js
init_base58();

// node_modules/ipfs-bitswap/esm/src/message/message.js
init_globals();
var import_minimal10 = __toESM(require_minimal2(), 1);
var $Reader9 = import_minimal10.default.Reader;
var $Writer9 = import_minimal10.default.Writer;
var $util9 = import_minimal10.default.util;
var $root9 = import_minimal10.default.roots["ipfs-bitswap"] || (import_minimal10.default.roots["ipfs-bitswap"] = {});
var Message = $root9.Message = (() => {
  function Message2(p) {
    this.blocks = [];
    this.payload = [];
    this.blockPresences = [];
    if (p) {
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
    }
  }
  Message2.prototype.wantlist = null;
  Message2.prototype.blocks = $util9.emptyArray;
  Message2.prototype.payload = $util9.emptyArray;
  Message2.prototype.blockPresences = $util9.emptyArray;
  Message2.prototype.pendingBytes = 0;
  Message2.encode = function encode19(m, w) {
    if (!w)
      w = $Writer9.create();
    if (m.wantlist != null && Object.hasOwnProperty.call(m, "wantlist"))
      $root9.Message.Wantlist.encode(m.wantlist, w.uint32(10).fork()).ldelim();
    if (m.blocks != null && m.blocks.length) {
      for (var i = 0; i < m.blocks.length; ++i)
        w.uint32(18).bytes(m.blocks[i]);
    }
    if (m.payload != null && m.payload.length) {
      for (var i = 0; i < m.payload.length; ++i)
        $root9.Message.Block.encode(m.payload[i], w.uint32(26).fork()).ldelim();
    }
    if (m.blockPresences != null && m.blockPresences.length) {
      for (var i = 0; i < m.blockPresences.length; ++i)
        $root9.Message.BlockPresence.encode(m.blockPresences[i], w.uint32(34).fork()).ldelim();
    }
    if (m.pendingBytes != null && Object.hasOwnProperty.call(m, "pendingBytes"))
      w.uint32(40).int32(m.pendingBytes);
    return w;
  };
  Message2.decode = function decode22(r, l) {
    if (!(r instanceof $Reader9))
      r = $Reader9.create(r);
    var c = l === void 0 ? r.len : r.pos + l, m = new $root9.Message();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.wantlist = $root9.Message.Wantlist.decode(r, r.uint32());
          break;
        case 2:
          if (!(m.blocks && m.blocks.length))
            m.blocks = [];
          m.blocks.push(r.bytes());
          break;
        case 3:
          if (!(m.payload && m.payload.length))
            m.payload = [];
          m.payload.push($root9.Message.Block.decode(r, r.uint32()));
          break;
        case 4:
          if (!(m.blockPresences && m.blockPresences.length))
            m.blockPresences = [];
          m.blockPresences.push($root9.Message.BlockPresence.decode(r, r.uint32()));
          break;
        case 5:
          m.pendingBytes = r.int32();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Message2.fromObject = function fromObject(d) {
    if (d instanceof $root9.Message)
      return d;
    var m = new $root9.Message();
    if (d.wantlist != null) {
      if (typeof d.wantlist !== "object")
        throw TypeError(".Message.wantlist: object expected");
      m.wantlist = $root9.Message.Wantlist.fromObject(d.wantlist);
    }
    if (d.blocks) {
      if (!Array.isArray(d.blocks))
        throw TypeError(".Message.blocks: array expected");
      m.blocks = [];
      for (var i = 0; i < d.blocks.length; ++i) {
        if (typeof d.blocks[i] === "string")
          $util9.base64.decode(d.blocks[i], m.blocks[i] = $util9.newBuffer($util9.base64.length(d.blocks[i])), 0);
        else if (d.blocks[i].length)
          m.blocks[i] = d.blocks[i];
      }
    }
    if (d.payload) {
      if (!Array.isArray(d.payload))
        throw TypeError(".Message.payload: array expected");
      m.payload = [];
      for (var i = 0; i < d.payload.length; ++i) {
        if (typeof d.payload[i] !== "object")
          throw TypeError(".Message.payload: object expected");
        m.payload[i] = $root9.Message.Block.fromObject(d.payload[i]);
      }
    }
    if (d.blockPresences) {
      if (!Array.isArray(d.blockPresences))
        throw TypeError(".Message.blockPresences: array expected");
      m.blockPresences = [];
      for (var i = 0; i < d.blockPresences.length; ++i) {
        if (typeof d.blockPresences[i] !== "object")
          throw TypeError(".Message.blockPresences: object expected");
        m.blockPresences[i] = $root9.Message.BlockPresence.fromObject(d.blockPresences[i]);
      }
    }
    if (d.pendingBytes != null) {
      m.pendingBytes = d.pendingBytes | 0;
    }
    return m;
  };
  Message2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocks = [];
      d.payload = [];
      d.blockPresences = [];
    }
    if (o.defaults) {
      d.wantlist = null;
      d.pendingBytes = 0;
    }
    if (m.wantlist != null && m.hasOwnProperty("wantlist")) {
      d.wantlist = $root9.Message.Wantlist.toObject(m.wantlist, o);
    }
    if (m.blocks && m.blocks.length) {
      d.blocks = [];
      for (var j = 0; j < m.blocks.length; ++j) {
        d.blocks[j] = o.bytes === String ? $util9.base64.encode(m.blocks[j], 0, m.blocks[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.blocks[j]) : m.blocks[j];
      }
    }
    if (m.payload && m.payload.length) {
      d.payload = [];
      for (var j = 0; j < m.payload.length; ++j) {
        d.payload[j] = $root9.Message.Block.toObject(m.payload[j], o);
      }
    }
    if (m.blockPresences && m.blockPresences.length) {
      d.blockPresences = [];
      for (var j = 0; j < m.blockPresences.length; ++j) {
        d.blockPresences[j] = $root9.Message.BlockPresence.toObject(m.blockPresences[j], o);
      }
    }
    if (m.pendingBytes != null && m.hasOwnProperty("pendingBytes")) {
      d.pendingBytes = m.pendingBytes;
    }
    return d;
  };
  Message2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, import_minimal10.default.util.toJSONOptions);
  };
  Message2.Wantlist = function() {
    function Wantlist2(p) {
      this.entries = [];
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    Wantlist2.prototype.entries = $util9.emptyArray;
    Wantlist2.prototype.full = false;
    Wantlist2.encode = function encode19(m, w) {
      if (!w)
        w = $Writer9.create();
      if (m.entries != null && m.entries.length) {
        for (var i = 0; i < m.entries.length; ++i)
          $root9.Message.Wantlist.Entry.encode(m.entries[i], w.uint32(10).fork()).ldelim();
      }
      if (m.full != null && Object.hasOwnProperty.call(m, "full"))
        w.uint32(16).bool(m.full);
      return w;
    };
    Wantlist2.decode = function decode22(r, l) {
      if (!(r instanceof $Reader9))
        r = $Reader9.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root9.Message.Wantlist();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            if (!(m.entries && m.entries.length))
              m.entries = [];
            m.entries.push($root9.Message.Wantlist.Entry.decode(r, r.uint32()));
            break;
          case 2:
            m.full = r.bool();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Wantlist2.fromObject = function fromObject(d) {
      if (d instanceof $root9.Message.Wantlist)
        return d;
      var m = new $root9.Message.Wantlist();
      if (d.entries) {
        if (!Array.isArray(d.entries))
          throw TypeError(".Message.Wantlist.entries: array expected");
        m.entries = [];
        for (var i = 0; i < d.entries.length; ++i) {
          if (typeof d.entries[i] !== "object")
            throw TypeError(".Message.Wantlist.entries: object expected");
          m.entries[i] = $root9.Message.Wantlist.Entry.fromObject(d.entries[i]);
        }
      }
      if (d.full != null) {
        m.full = Boolean(d.full);
      }
      return m;
    };
    Wantlist2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.arrays || o.defaults) {
        d.entries = [];
      }
      if (o.defaults) {
        d.full = false;
      }
      if (m.entries && m.entries.length) {
        d.entries = [];
        for (var j = 0; j < m.entries.length; ++j) {
          d.entries[j] = $root9.Message.Wantlist.Entry.toObject(m.entries[j], o);
        }
      }
      if (m.full != null && m.hasOwnProperty("full")) {
        d.full = m.full;
      }
      return d;
    };
    Wantlist2.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal10.default.util.toJSONOptions);
    };
    Wantlist2.WantType = function() {
      const valuesById = {}, values2 = Object.create(valuesById);
      values2[valuesById[0] = "Block"] = 0;
      values2[valuesById[1] = "Have"] = 1;
      return values2;
    }();
    Wantlist2.Entry = function() {
      function Entry(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Entry.prototype.block = $util9.newBuffer([]);
      Entry.prototype.priority = 0;
      Entry.prototype.cancel = false;
      Entry.prototype.wantType = 0;
      Entry.prototype.sendDontHave = false;
      Entry.encode = function encode19(m, w) {
        if (!w)
          w = $Writer9.create();
        if (m.block != null && Object.hasOwnProperty.call(m, "block"))
          w.uint32(10).bytes(m.block);
        if (m.priority != null && Object.hasOwnProperty.call(m, "priority"))
          w.uint32(16).int32(m.priority);
        if (m.cancel != null && Object.hasOwnProperty.call(m, "cancel"))
          w.uint32(24).bool(m.cancel);
        if (m.wantType != null && Object.hasOwnProperty.call(m, "wantType"))
          w.uint32(32).int32(m.wantType);
        if (m.sendDontHave != null && Object.hasOwnProperty.call(m, "sendDontHave"))
          w.uint32(40).bool(m.sendDontHave);
        return w;
      };
      Entry.decode = function decode22(r, l) {
        if (!(r instanceof $Reader9))
          r = $Reader9.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root9.Message.Wantlist.Entry();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.block = r.bytes();
              break;
            case 2:
              m.priority = r.int32();
              break;
            case 3:
              m.cancel = r.bool();
              break;
            case 4:
              m.wantType = r.int32();
              break;
            case 5:
              m.sendDontHave = r.bool();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Entry.fromObject = function fromObject(d) {
        if (d instanceof $root9.Message.Wantlist.Entry)
          return d;
        var m = new $root9.Message.Wantlist.Entry();
        if (d.block != null) {
          if (typeof d.block === "string")
            $util9.base64.decode(d.block, m.block = $util9.newBuffer($util9.base64.length(d.block)), 0);
          else if (d.block.length)
            m.block = d.block;
        }
        if (d.priority != null) {
          m.priority = d.priority | 0;
        }
        if (d.cancel != null) {
          m.cancel = Boolean(d.cancel);
        }
        switch (d.wantType) {
          case "Block":
          case 0:
            m.wantType = 0;
            break;
          case "Have":
          case 1:
            m.wantType = 1;
            break;
        }
        if (d.sendDontHave != null) {
          m.sendDontHave = Boolean(d.sendDontHave);
        }
        return m;
      };
      Entry.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.block = "";
          else {
            d.block = [];
            if (o.bytes !== Array)
              d.block = $util9.newBuffer(d.block);
          }
          d.priority = 0;
          d.cancel = false;
          d.wantType = o.enums === String ? "Block" : 0;
          d.sendDontHave = false;
        }
        if (m.block != null && m.hasOwnProperty("block")) {
          d.block = o.bytes === String ? $util9.base64.encode(m.block, 0, m.block.length) : o.bytes === Array ? Array.prototype.slice.call(m.block) : m.block;
        }
        if (m.priority != null && m.hasOwnProperty("priority")) {
          d.priority = m.priority;
        }
        if (m.cancel != null && m.hasOwnProperty("cancel")) {
          d.cancel = m.cancel;
        }
        if (m.wantType != null && m.hasOwnProperty("wantType")) {
          d.wantType = o.enums === String ? $root9.Message.Wantlist.WantType[m.wantType] : m.wantType;
        }
        if (m.sendDontHave != null && m.hasOwnProperty("sendDontHave")) {
          d.sendDontHave = m.sendDontHave;
        }
        return d;
      };
      Entry.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal10.default.util.toJSONOptions);
      };
      return Entry;
    }();
    return Wantlist2;
  }();
  Message2.Block = function() {
    function Block2(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    Block2.prototype.prefix = $util9.newBuffer([]);
    Block2.prototype.data = $util9.newBuffer([]);
    Block2.encode = function encode19(m, w) {
      if (!w)
        w = $Writer9.create();
      if (m.prefix != null && Object.hasOwnProperty.call(m, "prefix"))
        w.uint32(10).bytes(m.prefix);
      if (m.data != null && Object.hasOwnProperty.call(m, "data"))
        w.uint32(18).bytes(m.data);
      return w;
    };
    Block2.decode = function decode22(r, l) {
      if (!(r instanceof $Reader9))
        r = $Reader9.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root9.Message.Block();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.prefix = r.bytes();
            break;
          case 2:
            m.data = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Block2.fromObject = function fromObject(d) {
      if (d instanceof $root9.Message.Block)
        return d;
      var m = new $root9.Message.Block();
      if (d.prefix != null) {
        if (typeof d.prefix === "string")
          $util9.base64.decode(d.prefix, m.prefix = $util9.newBuffer($util9.base64.length(d.prefix)), 0);
        else if (d.prefix.length)
          m.prefix = d.prefix;
      }
      if (d.data != null) {
        if (typeof d.data === "string")
          $util9.base64.decode(d.data, m.data = $util9.newBuffer($util9.base64.length(d.data)), 0);
        else if (d.data.length)
          m.data = d.data;
      }
      return m;
    };
    Block2.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.prefix = "";
        else {
          d.prefix = [];
          if (o.bytes !== Array)
            d.prefix = $util9.newBuffer(d.prefix);
        }
        if (o.bytes === String)
          d.data = "";
        else {
          d.data = [];
          if (o.bytes !== Array)
            d.data = $util9.newBuffer(d.data);
        }
      }
      if (m.prefix != null && m.hasOwnProperty("prefix")) {
        d.prefix = o.bytes === String ? $util9.base64.encode(m.prefix, 0, m.prefix.length) : o.bytes === Array ? Array.prototype.slice.call(m.prefix) : m.prefix;
      }
      if (m.data != null && m.hasOwnProperty("data")) {
        d.data = o.bytes === String ? $util9.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
      }
      return d;
    };
    Block2.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal10.default.util.toJSONOptions);
    };
    return Block2;
  }();
  Message2.BlockPresenceType = function() {
    const valuesById = {}, values2 = Object.create(valuesById);
    values2[valuesById[0] = "Have"] = 0;
    values2[valuesById[1] = "DontHave"] = 1;
    return values2;
  }();
  Message2.BlockPresence = function() {
    function BlockPresence(p) {
      if (p) {
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
      }
    }
    BlockPresence.prototype.cid = $util9.newBuffer([]);
    BlockPresence.prototype.type = 0;
    BlockPresence.encode = function encode19(m, w) {
      if (!w)
        w = $Writer9.create();
      if (m.cid != null && Object.hasOwnProperty.call(m, "cid"))
        w.uint32(10).bytes(m.cid);
      if (m.type != null && Object.hasOwnProperty.call(m, "type"))
        w.uint32(16).int32(m.type);
      return w;
    };
    BlockPresence.decode = function decode22(r, l) {
      if (!(r instanceof $Reader9))
        r = $Reader9.create(r);
      var c = l === void 0 ? r.len : r.pos + l, m = new $root9.Message.BlockPresence();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.cid = r.bytes();
            break;
          case 2:
            m.type = r.int32();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    BlockPresence.fromObject = function fromObject(d) {
      if (d instanceof $root9.Message.BlockPresence)
        return d;
      var m = new $root9.Message.BlockPresence();
      if (d.cid != null) {
        if (typeof d.cid === "string")
          $util9.base64.decode(d.cid, m.cid = $util9.newBuffer($util9.base64.length(d.cid)), 0);
        else if (d.cid.length)
          m.cid = d.cid;
      }
      switch (d.type) {
        case "Have":
        case 0:
          m.type = 0;
          break;
        case "DontHave":
        case 1:
          m.type = 1;
          break;
      }
      return m;
    };
    BlockPresence.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.cid = "";
        else {
          d.cid = [];
          if (o.bytes !== Array)
            d.cid = $util9.newBuffer(d.cid);
        }
        d.type = o.enums === String ? "Have" : 0;
      }
      if (m.cid != null && m.hasOwnProperty("cid")) {
        d.cid = o.bytes === String ? $util9.base64.encode(m.cid, 0, m.cid.length) : o.bytes === Array ? Array.prototype.slice.call(m.cid) : m.cid;
      }
      if (m.type != null && m.hasOwnProperty("type")) {
        d.type = o.enums === String ? $root9.Message.BlockPresenceType[m.type] : m.type;
      }
      return d;
    };
    BlockPresence.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, import_minimal10.default.util.toJSONOptions);
    };
    return BlockPresence;
  }();
  return Message2;
})();

// node_modules/ipfs-bitswap/esm/src/wantlist/index.js
var import_tracked_map = __toESM(require_tracked_map(), 1);
var WantType = {
  Block: Message.Wantlist.WantType.Block,
  Have: Message.Wantlist.WantType.Have
};
var sortBy = (fn, list) => {
  return Array.prototype.slice.call(list, 0).sort((a, b) => {
    const aa = fn(a);
    const bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
};
var Wantlist = class {
  constructor(stats, libp2p) {
    this.set = libp2p ? (0, import_tracked_map.default)({
      system: "ipfs",
      component: "bitswap",
      metric: "wantlist",
      metrics: libp2p.metrics
    }) : /* @__PURE__ */ new Map();
    this._stats = stats;
  }
  get length() {
    return this.set.size;
  }
  add(cid, priority, wantType) {
    const cidStr = cid.toString(base58btc);
    const entry = this.set.get(cidStr);
    if (entry) {
      entry.inc();
      entry.priority = priority;
      if (entry.wantType === WantType.Have && wantType === WantType.Block) {
        entry.wantType = wantType;
      }
    } else {
      this.set.set(cidStr, new WantListEntry(cid, priority, wantType));
      if (this._stats) {
        this._stats.push(null, "wantListSize", 1);
      }
    }
  }
  remove(cid) {
    const cidStr = cid.toString(base58btc);
    const entry = this.set.get(cidStr);
    if (!entry) {
      return;
    }
    entry.dec();
    if (entry.hasRefs()) {
      return;
    }
    this.set.delete(cidStr);
    if (this._stats) {
      this._stats.push(null, "wantListSize", -1);
    }
  }
  removeForce(cidStr) {
    if (this.set.has(cidStr)) {
      this.set.delete(cidStr);
    }
  }
  forEach(fn) {
    return this.set.forEach(fn);
  }
  entries() {
    return this.set.entries();
  }
  sortedEntries() {
    return new Map(sortBy((o) => o[1].key, Array.from(this.set.entries())));
  }
  contains(cid) {
    const cidStr = cid.toString(base58btc);
    return this.set.has(cidStr);
  }
  get(cid) {
    const cidStr = cid.toString(base58btc);
    return this.set.get(cidStr);
  }
};
Wantlist.Entry = WantListEntry;

// node_modules/ipfs-bitswap/esm/src/message/entry.js
init_base58();
var WantlistEntry = Wantlist.Entry;
var BitswapMessageEntry = class {
  constructor(cid, priority, wantType, cancel, sendDontHave) {
    this.entry = new WantlistEntry(cid, priority, wantType);
    this.cancel = Boolean(cancel);
    this.sendDontHave = Boolean(sendDontHave);
  }
  get cid() {
    return this.entry.cid;
  }
  set cid(cid) {
    this.entry.cid = cid;
  }
  get priority() {
    return this.entry.priority;
  }
  set priority(val) {
    this.entry.priority = val;
  }
  get wantType() {
    return this.entry.wantType;
  }
  set wantType(val) {
    this.entry.wantType = val;
  }
  get [Symbol.toStringTag]() {
    const cidStr = this.cid.toString(base58btc);
    return `BitswapMessageEntry ${cidStr} <cancel: ${this.cancel}, priority: ${this.priority}>`;
  }
  equals(other) {
    return this.cancel === other.cancel && this.sendDontHave === other.sendDontHave && this.wantType === other.wantType && this.entry.equals(other.entry);
  }
};

// node_modules/ipfs-bitswap/esm/src/utils/index.js
var logger = (id, subsystem) => {
  const name10 = ["bitswap"];
  if (subsystem) {
    name10.push(subsystem);
  }
  if (id) {
    name10.push(`${id.toB58String().slice(0, 8)}`);
  }
  return Object.assign((0, import_debug48.default)(name10.join(":")), { error: (0, import_debug48.default)(name10.concat(["error"]).join(":")) });
};
var isMapEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, valueA] of a) {
    const valueB = b.get(key);
    if (valueB === void 0) {
      return false;
    }
    if (valueA instanceof Uint8Array && valueB instanceof Uint8Array && !equals3(valueA, valueB)) {
      return false;
    }
    if (valueA instanceof BitswapMessageEntry && valueB instanceof BitswapMessageEntry && !valueA.equals(valueB)) {
      return false;
    }
  }
  return true;
};

// node_modules/ipfs-bitswap/esm/src/message/index.js
var import_err_code69 = __toESM(require_err_code(), 1);
var BitswapMessage = class {
  constructor(full) {
    this.full = full;
    this.wantlist = /* @__PURE__ */ new Map();
    this.blocks = /* @__PURE__ */ new Map();
    this.blockPresences = /* @__PURE__ */ new Map();
    this.pendingBytes = 0;
  }
  get empty() {
    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;
  }
  addEntry(cid, priority, wantType, cancel, sendDontHave) {
    if (wantType == null) {
      wantType = BitswapMessage.WantType.Block;
    }
    const cidStr = cid.toString(base58btc);
    const entry = this.wantlist.get(cidStr);
    if (entry) {
      if (entry.wantType === wantType) {
        entry.priority = priority;
      }
      if (cancel) {
        entry.cancel = Boolean(cancel);
      }
      if (sendDontHave) {
        entry.sendDontHave = Boolean(sendDontHave);
      }
      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {
        entry.wantType = wantType;
      }
    } else {
      this.wantlist.set(cidStr, new BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));
    }
  }
  addBlock(cid, block) {
    const cidStr = cid.toString(base58btc);
    this.blocks.set(cidStr, block);
  }
  addHave(cid) {
    const cidStr = cid.toString(base58btc);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);
    }
  }
  addDontHave(cid) {
    const cidStr = cid.toString(base58btc);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);
    }
  }
  cancel(cid) {
    const cidStr = cid.toString(base58btc);
    this.wantlist.delete(cidStr);
    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);
  }
  setPendingBytes(size) {
    this.pendingBytes = size;
  }
  serializeToBitswap100() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            cancel: Boolean(entry.cancel)
          };
        }),
        full: this.full ? true : void 0
      },
      blocks: Array.from(this.blocks.values())
    };
    return Message.encode(msg).finish();
  }
  serializeToBitswap110() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map((entry) => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            wantType: entry.wantType,
            cancel: Boolean(entry.cancel),
            sendDontHave: Boolean(entry.sendDontHave)
          };
        }),
        full: this.full ? true : void 0
      },
      blockPresences: [],
      payload: [],
      pendingBytes: this.pendingBytes
    };
    for (const [cidStr, data] of this.blocks.entries()) {
      const cid = CID.parse(cidStr);
      const version4 = cid.version;
      const codec = cid.code;
      const multihash = cid.multihash.code;
      const digestLength = cid.multihash.digest.length;
      const prefix = varint_encoder_default([
        version4,
        codec,
        multihash,
        digestLength
      ]);
      msg.payload.push(new Message.Block({
        prefix,
        data
      }));
    }
    for (const [cidStr, bpType] of this.blockPresences) {
      msg.blockPresences.push(new Message.BlockPresence({
        cid: CID.parse(cidStr).bytes,
        type: bpType
      }));
    }
    if (this.pendingBytes > 0) {
      msg.pendingBytes = this.pendingBytes;
    }
    return Message.encode(msg).finish();
  }
  equals(other) {
    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || !isMapEqual(this.blockPresences, other.blockPresences)) {
      return false;
    }
    return true;
  }
  get [Symbol.toStringTag]() {
    const list = Array.from(this.wantlist.keys());
    const blocks = Array.from(this.blocks.keys());
    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;
  }
};
BitswapMessage.deserialize = async (raw, hashLoader) => {
  const decoded = Message.decode(raw);
  const isFull = decoded.wantlist && decoded.wantlist.full || false;
  const msg = new BitswapMessage(isFull);
  if (decoded.wantlist && decoded.wantlist.entries) {
    decoded.wantlist.entries.forEach((entry) => {
      if (!entry.block) {
        return;
      }
      const cid = CID.decode(entry.block);
      msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));
    });
  }
  if (decoded.blockPresences) {
    decoded.blockPresences.forEach((blockPresence) => {
      if (!blockPresence.cid) {
        return;
      }
      const cid = CID.decode(blockPresence.cid);
      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {
        msg.addHave(cid);
      } else {
        msg.addDontHave(cid);
      }
    });
  }
  if (decoded.blocks.length > 0) {
    await Promise.all(decoded.blocks.map(async (b) => {
      const hash2 = await sha256.digest(b);
      const cid = CID.createV0(hash2);
      msg.addBlock(cid, b);
    }));
    return msg;
  }
  if (decoded.payload.length > 0) {
    await Promise.all(decoded.payload.map(async (p) => {
      if (!p.prefix || !p.data) {
        return;
      }
      const values2 = (0, import_varint_decoder.default)(p.prefix);
      const cidVersion = values2[0];
      const multicodec = values2[1];
      const hashAlg = values2[2];
      const hasher = hashAlg === sha256.code ? sha256 : hashLoader && await hashLoader.getHasher(hashAlg);
      if (!hasher) {
        throw (0, import_err_code69.default)(new Error("Unknown hash algorithm"), "ERR_UNKNOWN_HASH_ALG");
      }
      const hash2 = await hasher.digest(p.data);
      const cid = CID.create(cidVersion, multicodec, hash2);
      msg.addBlock(cid, p.data);
    }));
    msg.setPendingBytes(decoded.pendingBytes);
    return msg;
  }
  return msg;
};
BitswapMessage.blockPresenceSize = (cid) => {
  return cid.bytes.length + 1;
};
BitswapMessage.Entry = BitswapMessageEntry;
BitswapMessage.WantType = {
  Block: Message.Wantlist.WantType.Block,
  Have: Message.Wantlist.WantType.Have
};
BitswapMessage.BlockPresenceType = {
  Have: Message.BlockPresenceType.Have,
  DontHave: Message.BlockPresenceType.DontHave
};

// node_modules/ipfs-bitswap/esm/src/constants.js
init_globals();
var SECOND = 1e3;
var maxProvidersPerRequest = 3;
var providerRequestTimeout = 10 * SECOND;
var hasBlockTimeout = 15 * SECOND;
var provideTimeout = 15 * SECOND;
var kMaxPriority = Math.pow(2, 31) - 1;
var maxListeners = 1e3;
var wantlistSendDebounceMs = 1;

// node_modules/ipfs-bitswap/esm/src/want-manager/msg-queue.js
init_globals();
var import_just_debounce_it = __toESM(require_just_debounce_it(), 1);
var MsgQueue = class {
  constructor(selfPeerId, otherPeerId, network) {
    this.peerId = otherPeerId;
    this.network = network;
    this.refcnt = 1;
    this._entries = [];
    this._log = logger(selfPeerId, "msgqueue");
    this.sendEntries = (0, import_just_debounce_it.default)(this._sendEntries.bind(this), wantlistSendDebounceMs);
  }
  addMessage(msg) {
    if (msg.empty) {
      return;
    }
    this.send(msg);
  }
  addEntries(entries2) {
    this._entries = this._entries.concat(entries2);
    this.sendEntries();
  }
  _sendEntries() {
    if (!this._entries.length) {
      return;
    }
    const msg = new BitswapMessage(false);
    this._entries.forEach((entry) => {
      if (entry.cancel) {
        msg.cancel(entry.cid);
      } else {
        msg.addEntry(entry.cid, entry.priority);
      }
    });
    this._entries = [];
    this.addMessage(msg);
  }
  async send(msg) {
    try {
      await this.network.connectTo(this.peerId);
    } catch (err) {
      this._log.error("cant connect to peer %s: %s", this.peerId.toB58String(), err.message);
      return;
    }
    this._log("sending message to peer %s", this.peerId.toB58String());
    this.network.sendMessage(this.peerId, msg).catch((err) => {
      this._log.error("send error: %s", err.message);
    });
  }
};

// node_modules/ipfs-bitswap/esm/src/want-manager/index.js
init_base58();
var import_tracked_map2 = __toESM(require_tracked_map(), 1);
var WantManager = class {
  constructor(peerId, network, stats, libp2p) {
    this.peers = (0, import_tracked_map2.default)({
      system: "ipfs",
      component: "bitswap",
      metric: "want-manager-peers",
      metrics: libp2p.metrics
    });
    this.wantlist = new Wantlist(stats, libp2p);
    this.network = network;
    this._stats = stats;
    this._peerId = peerId;
    this._log = logger(peerId, "want");
  }
  _addEntries(cids, cancel, force) {
    const entries2 = cids.map((cid, i) => {
      return new BitswapMessage.Entry(cid, kMaxPriority - i, BitswapMessage.WantType.Block, cancel);
    });
    entries2.forEach((e) => {
      if (e.cancel) {
        if (force) {
          this.wantlist.removeForce(e.cid.toString(base58btc));
        } else {
          this.wantlist.remove(e.cid);
        }
      } else {
        this._log("adding to wl");
        this.wantlist.add(e.cid, e.priority);
      }
    });
    for (const p of this.peers.values()) {
      p.addEntries(entries2);
    }
  }
  _startPeerHandler(peerId) {
    let mq = this.peers.get(peerId.toB58String());
    if (mq) {
      mq.refcnt++;
      return;
    }
    mq = new MsgQueue(this._peerId, peerId, this.network);
    const fullwantlist = new BitswapMessage(true);
    for (const entry of this.wantlist.entries()) {
      fullwantlist.addEntry(entry[1].cid, entry[1].priority);
    }
    mq.addMessage(fullwantlist);
    this.peers.set(peerId.toB58String(), mq);
    return mq;
  }
  _stopPeerHandler(peerId) {
    const mq = this.peers.get(peerId.toB58String());
    if (!mq) {
      return;
    }
    mq.refcnt--;
    if (mq.refcnt > 0) {
      return;
    }
    this.peers.delete(peerId.toB58String());
  }
  wantBlocks(cids, options = {}) {
    this._addEntries(cids, false);
    if (options && options.signal) {
      options.signal.addEventListener("abort", () => {
        this.cancelWants(cids);
      });
    }
  }
  unwantBlocks(cids) {
    this._log("unwant blocks: %s", cids.length);
    this._addEntries(cids, true, true);
  }
  cancelWants(cids) {
    this._log("cancel wants: %s", cids.length);
    this._addEntries(cids, true);
  }
  connectedPeers() {
    return Array.from(this.peers.keys());
  }
  connected(peerId) {
    this._startPeerHandler(peerId);
  }
  disconnected(peerId) {
    this._stopPeerHandler(peerId);
  }
  start() {
  }
  stop() {
    this.peers.forEach((mq) => this.disconnected(mq.peerId));
  }
};

// node_modules/ipfs-bitswap/esm/src/network.js
init_globals();
var import_it_length_prefixed = __toESM(require_src11(), 1);
var import_it_pipe7 = __toESM(require_it_pipe(), 1);
var import_multicodec_topology = __toESM(require_multicodec_topology(), 1);
var BITSWAP100 = "/ipfs/bitswap/1.0.0";
var BITSWAP110 = "/ipfs/bitswap/1.1.0";
var BITSWAP120 = "/ipfs/bitswap/1.2.0";
var Network = class {
  constructor(libp2p, bitswap, stats, options = {}) {
    this._log = logger(libp2p.peerId, "network");
    this._libp2p = libp2p;
    this._bitswap = bitswap;
    this._protocols = [BITSWAP100];
    if (!options.b100Only) {
      this._protocols.unshift(BITSWAP110);
      this._protocols.unshift(BITSWAP120);
    }
    this._stats = stats;
    this._running = false;
    this._onPeerConnect = this._onPeerConnect.bind(this);
    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);
    this._onConnection = this._onConnection.bind(this);
    this._hashLoader = options.hashLoader;
  }
  async start() {
    this._running = true;
    await this._libp2p.handle(this._protocols, this._onConnection);
    const topology = new import_multicodec_topology.default({
      multicodecs: this._protocols,
      handlers: {
        onConnect: this._onPeerConnect,
        onDisconnect: this._onPeerDisconnect
      }
    });
    this._registrarId = await this._libp2p.registrar.register(topology);
    for await (const peer of this._libp2p.peerStore.getPeers()) {
      const conn = this._libp2p.connectionManager.get(peer.id);
      conn && this._onPeerConnect(conn.remotePeer);
    }
  }
  async stop() {
    this._running = false;
    await this._libp2p.unhandle(this._protocols);
    if (this._registrarId != null) {
      this._libp2p.registrar.unregister(this._registrarId);
    }
  }
  async _onConnection({ protocol, stream, connection }) {
    if (!this._running) {
      return;
    }
    this._log("incoming new bitswap %s connection from %s", protocol, connection.remotePeer.toB58String());
    try {
      await (0, import_it_pipe7.pipe)(stream, import_it_length_prefixed.default.decode(), async (source) => {
        for await (const data of source) {
          try {
            const message = await BitswapMessage.deserialize(data.slice(), this._hashLoader);
            await this._bitswap._receiveMessage(connection.remotePeer, message);
          } catch (err) {
            this._bitswap._receiveError(err);
            break;
          }
        }
      });
    } catch (err) {
      this._log(err);
    }
  }
  _onPeerConnect(peerId) {
    this._bitswap._onPeerConnected(peerId);
  }
  _onPeerDisconnect(peerId) {
    this._bitswap._onPeerDisconnected(peerId);
  }
  findProviders(cid, maxProviders, options = {}) {
    return this._libp2p.contentRouting.findProviders(cid, {
      timeout: providerRequestTimeout,
      maxNumProviders: maxProviders
    });
  }
  async findAndConnect(cid, options) {
    const connectAttempts = [];
    for await (const provider of this.findProviders(cid, maxProvidersPerRequest, options)) {
      this._log(`connecting to provider ${provider.id}`);
      connectAttempts.push(this.connectTo(provider.id, options).catch((err) => {
        this._log.error(err);
      }));
    }
    await Promise.all(connectAttempts);
  }
  async provide(cid, options) {
    await this._libp2p.contentRouting.provide(cid, options);
  }
  async sendMessage(peer, msg) {
    if (!this._running)
      throw new Error("network isn't running");
    const stringId = peer.toB58String();
    this._log("sendMessage to %s", stringId, msg);
    const connection = await this._libp2p.dial(peer);
    const { stream, protocol } = await connection.newStream([
      BITSWAP120,
      BITSWAP110,
      BITSWAP100
    ]);
    let serialized;
    switch (protocol) {
      case BITSWAP100:
        serialized = msg.serializeToBitswap100();
        break;
      case BITSWAP110:
      case BITSWAP120:
        serialized = msg.serializeToBitswap110();
        break;
      default:
        throw new Error("Unknown protocol: " + protocol);
    }
    writeMessage(stream, serialized, this._log);
    this._updateSentStats(peer, msg.blocks);
  }
  async connectTo(peer, options) {
    if (!this._running) {
      throw new Error("network isn't running");
    }
    return this._libp2p.dial(peer, options);
  }
  _updateSentStats(peer, blocks) {
    const peerId = peer.toB58String();
    if (this._stats) {
      for (const block of blocks.values()) {
        this._stats.push(peerId, "dataSent", block.length);
      }
      this._stats.push(peerId, "blocksSent", blocks.size);
    }
  }
};
async function writeMessage(stream, msg, log48) {
  try {
    await (0, import_it_pipe7.pipe)([msg], import_it_length_prefixed.default.encode(), stream);
  } catch (err) {
    log48(err);
  }
}

// node_modules/ipfs-bitswap/esm/src/decision-engine/index.js
init_globals();
init_cid();
init_base58();

// node_modules/ipfs-bitswap/esm/src/decision-engine/ledger.js
init_globals();
var Ledger = class {
  constructor(peerId) {
    this.partner = peerId;
    this.wantlist = new Wantlist();
    this.exchangeCount = 0;
    this.sentToPeer = /* @__PURE__ */ new Map();
    this.accounting = {
      bytesSent: 0,
      bytesRecv: 0
    };
  }
  sentBytes(n) {
    this.exchangeCount++;
    this.lastExchange = new Date().getTime();
    this.accounting.bytesSent += n;
  }
  receivedBytes(n) {
    this.exchangeCount++;
    this.lastExchange = new Date().getTime();
    this.accounting.bytesRecv += n;
  }
  wants(cid, priority, wantType) {
    this.wantlist.add(cid, priority, wantType);
  }
  cancelWant(cid) {
    this.wantlist.remove(cid);
  }
  wantlistContains(cid) {
    return this.wantlist.get(cid);
  }
  debtRatio() {
    return this.accounting.bytesSent / (this.accounting.bytesRecv + 1);
  }
};

// node_modules/ipfs-bitswap/esm/src/decision-engine/req-queue.js
init_globals();

// node_modules/ipfs-bitswap/esm/src/utils/sorted-map.js
init_globals();
var SortedMap = class extends Map {
  constructor(entries2, cmp) {
    super();
    this._cmp = cmp || this._defaultSort;
    this._keys = [];
    for (const [k, v] of entries2 || []) {
      this.set(k, v);
    }
  }
  update(i) {
    if (i < 0 || i >= this._keys.length) {
      return;
    }
    const k = this._keys[i];
    this._keys.splice(i, 1);
    const newIdx = this._find(k);
    this._keys.splice(newIdx, 0, k);
  }
  set(k, v) {
    if (this.has(k)) {
      const i2 = this.indexOf(k);
      this._keys.splice(i2, 1);
    }
    super.set(k, v);
    const i = this._find(k);
    this._keys.splice(i, 0, k);
    return this;
  }
  clear() {
    super.clear();
    this._keys = [];
  }
  delete(k) {
    if (!this.has(k)) {
      return false;
    }
    const i = this.indexOf(k);
    this._keys.splice(i, 1);
    return super.delete(k);
  }
  indexOf(k) {
    if (!this.has(k)) {
      return -1;
    }
    const i = this._find(k);
    if (this._keys[i] === k) {
      return i;
    }
    for (let j = 1; j < this._keys.length; j++) {
      if (this._keys[i + j] === k)
        return i + j;
      if (this._keys[i - j] === k)
        return i - j;
    }
    return -1;
  }
  _find(k) {
    let lower = 0;
    let upper = this._keys.length;
    while (lower < upper) {
      const pivot = lower + upper >>> 1;
      const cmp = this._kCmp(this._keys[pivot], k);
      if (cmp < 0) {
        lower = pivot + 1;
      } else if (cmp > 0) {
        upper = pivot;
      } else {
        return pivot;
      }
    }
    return lower;
  }
  *keys() {
    for (const k of this._keys) {
      yield k;
    }
    return void 0;
  }
  *values() {
    for (const k of this._keys) {
      yield this.get(k);
    }
    return void 0;
  }
  *entries() {
    for (const k of this._keys) {
      yield [
        k,
        this.get(k)
      ];
    }
    return void 0;
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
  forEach(cb, thisArg) {
    if (!cb) {
      return;
    }
    for (const k of this._keys) {
      cb.apply(thisArg, [[
        k,
        this.get(k)
      ]]);
    }
  }
  _defaultSort(a, b) {
    if (a[0] < b[0])
      return -1;
    if (b[0] < a[0])
      return 1;
    return 0;
  }
  _kCmp(a, b) {
    return this._cmp([
      a,
      this.get(a)
    ], [
      b,
      this.get(b)
    ]);
  }
};

// node_modules/ipfs-bitswap/esm/src/decision-engine/req-queue.js
var DefaultTaskMerger = {
  hasNewInfo() {
    return false;
  },
  merge() {
  }
};
var RequestQueue = class {
  constructor(taskMerger = DefaultTaskMerger) {
    this._taskMerger = taskMerger;
    this._byPeer = new SortedMap([], PeerTasks.compare);
  }
  pushTasks(peerId, tasks) {
    let peerTasks = this._byPeer.get(peerId.toB58String());
    if (!peerTasks) {
      peerTasks = new PeerTasks(peerId, this._taskMerger);
    }
    peerTasks.pushTasks(tasks);
    this._byPeer.set(peerId.toB58String(), peerTasks);
  }
  popTasks(targetMinBytes) {
    const peerTasks = this._head();
    if (peerTasks === void 0) {
      return {
        tasks: [],
        pendingSize: 0
      };
    }
    const { tasks, pendingSize } = peerTasks.popTasks(targetMinBytes);
    if (tasks.length === 0) {
      return {
        tasks,
        pendingSize
      };
    }
    const peerId = peerTasks.peerId;
    if (peerTasks.isIdle()) {
      this._byPeer.delete(peerId.toB58String());
    } else {
      this._byPeer.update(0);
    }
    return {
      peerId,
      tasks,
      pendingSize
    };
  }
  _head() {
    if (this._byPeer.size === 0) {
      return void 0;
    }
    for (const [, v] of this._byPeer) {
      return v;
    }
    return void 0;
  }
  remove(topic, peerId) {
    const peerTasks = this._byPeer.get(peerId.toB58String());
    peerTasks && peerTasks.remove(topic);
  }
  tasksDone(peerId, tasks) {
    const peerTasks = this._byPeer.get(peerId.toB58String());
    if (!peerTasks) {
      return;
    }
    const i = this._byPeer.indexOf(peerId.toB58String());
    for (const task of tasks) {
      peerTasks.taskDone(task);
    }
    this._byPeer.update(i);
  }
};
var PeerTasks = class {
  constructor(peerId, taskMerger) {
    this.peerId = peerId;
    this._taskMerger = taskMerger;
    this._activeTotalSize = 0;
    this._pending = new PendingTasks();
    this._active = /* @__PURE__ */ new Set();
  }
  pushTasks(tasks) {
    for (const t of tasks) {
      this._pushTask(t);
    }
  }
  _pushTask(task) {
    if (!this._taskHasMoreInfoThanActiveTasks(task)) {
      return;
    }
    const existingTask = this._pending.get(task.topic);
    if (existingTask) {
      if (task.priority > existingTask.priority) {
        this._pending.updatePriority(task.topic, task.priority);
      }
      this._taskMerger.merge(task, existingTask);
      return;
    }
    this._pending.add(task);
  }
  _taskHasMoreInfoThanActiveTasks(task) {
    const tasksWithTopic = [];
    for (const activeTask of this._active) {
      if (activeTask.topic === task.topic) {
        tasksWithTopic.push(activeTask);
      }
    }
    if (tasksWithTopic.length === 0) {
      return true;
    }
    return this._taskMerger.hasNewInfo(task, tasksWithTopic);
  }
  popTasks(targetMinBytes) {
    let size = 0;
    const tasks = [];
    const pendingTasks = this._pending.tasks();
    for (let i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {
      const task = pendingTasks[i];
      tasks.push(task);
      size += task.size;
      this._pending.delete(task.topic);
      this._activeTotalSize += task.size;
      this._active.add(task);
    }
    return {
      tasks,
      pendingSize: this._pending.totalSize
    };
  }
  taskDone(task) {
    if (this._active.has(task)) {
      this._activeTotalSize -= task.size;
      this._active.delete(task);
    }
  }
  remove(topic) {
    this._pending.delete(topic);
  }
  isIdle() {
    return this._pending.length === 0 && this._active.size === 0;
  }
  static compare(a, b) {
    if (a[1]._pending.length === 0) {
      return 1;
    }
    if (b[1]._pending.length === 0) {
      return -1;
    }
    if (a[1]._activeTotalSize === b[1]._activeTotalSize) {
      return b[1]._pending.length - a[1]._pending.length;
    }
    return a[1]._activeTotalSize - b[1]._activeTotalSize;
  }
};
var PendingTasks = class {
  constructor() {
    this._tasks = new SortedMap([], this._compare);
  }
  get length() {
    return this._tasks.size;
  }
  get totalSize() {
    return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0);
  }
  get(topic) {
    return (this._tasks.get(topic) || {}).task;
  }
  add(task) {
    this._tasks.set(task.topic, {
      created: Date.now(),
      task
    });
  }
  delete(topic) {
    this._tasks.delete(topic);
  }
  tasks() {
    return [...this._tasks.values()].map((i) => i.task);
  }
  updatePriority(topic, priority) {
    const obj = this._tasks.get(topic);
    if (!obj) {
      return;
    }
    const i = this._tasks.indexOf(topic);
    obj.task.priority = priority;
    this._tasks.update(i);
  }
  _compare(a, b) {
    if (a[1].task.priority === b[1].task.priority) {
      return a[1].created - b[1].created;
    }
    return b[1].task.priority - a[1].task.priority;
  }
};

// node_modules/ipfs-bitswap/esm/src/decision-engine/task-merger.js
init_globals();
var TaskMerger = {
  hasNewInfo(task, tasksWithTopic) {
    let haveBlock = false;
    let isWantBlock = false;
    for (const existing of tasksWithTopic) {
      if (existing.data.haveBlock) {
        haveBlock = true;
      }
      if (existing.data.isWantBlock) {
        isWantBlock = true;
      }
    }
    if (!isWantBlock && task.data.isWantBlock) {
      return true;
    }
    if (!haveBlock && task.data.haveBlock) {
      return true;
    }
    return false;
  },
  merge(newTask, existingTask) {
    const taskData = newTask.data;
    const existingData = existingTask.data;
    if (!existingData.haveBlock && taskData.haveBlock) {
      existingData.haveBlock = taskData.haveBlock;
      existingData.blockSize = taskData.blockSize;
    }
    if (!existingData.isWantBlock && taskData.isWantBlock) {
      existingData.isWantBlock = true;
      if (!existingData.haveBlock || taskData.haveBlock) {
        existingData.haveBlock = taskData.haveBlock;
        existingTask.size = newTask.size;
      }
    }
    if (existingData.isWantBlock && existingData.haveBlock) {
      existingTask.size = existingData.blockSize;
    }
  }
};

// node_modules/ipfs-bitswap/esm/src/decision-engine/index.js
var import_tracked_map3 = __toESM(require_tracked_map(), 1);
var WantType2 = BitswapMessage.WantType;
var TARGET_MESSAGE_SIZE = 16 * 1024;
var MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
var DecisionEngine = class {
  constructor(peerId, blockstore, network, stats, libp2p, opts = {}) {
    this._log = logger(peerId, "engine");
    this.blockstore = blockstore;
    this.network = network;
    this._stats = stats;
    this._opts = this._processOpts(opts);
    this.ledgerMap = (0, import_tracked_map3.default)({
      system: "ipfs",
      component: "bitswap",
      metric: "ledger-map",
      metrics: libp2p.metrics
    });
    this._running = false;
    this._requestQueue = new RequestQueue(TaskMerger);
  }
  _processOpts(opts) {
    return {
      maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,
      targetMessageSize: TARGET_MESSAGE_SIZE,
      ...opts
    };
  }
  _scheduleProcessTasks() {
    setTimeout(() => {
      this._processTasks();
    });
  }
  async _processTasks() {
    if (!this._running) {
      return;
    }
    const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize);
    if (tasks.length === 0) {
      return;
    }
    const msg = new BitswapMessage(false);
    msg.setPendingBytes(pendingSize);
    const blockCids = [];
    const blockTasks = /* @__PURE__ */ new Map();
    for (const task of tasks) {
      const cid = CID.parse(task.topic);
      if (task.data.haveBlock) {
        if (task.data.isWantBlock) {
          blockCids.push(cid);
          blockTasks.set(task.topic, task.data);
        } else {
          msg.addHave(cid);
        }
      } else {
        msg.addDontHave(cid);
      }
    }
    const blocks = await this._getBlocks(blockCids);
    for (const [topic, taskData] of blockTasks) {
      const cid = CID.parse(topic);
      const blk = blocks.get(topic);
      if (blk) {
        msg.addBlock(cid, blk);
      } else {
        if (taskData.sendDontHave) {
          msg.addDontHave(cid);
        }
      }
    }
    if (msg.empty) {
      peerId && this._requestQueue.tasksDone(peerId, tasks);
      this._scheduleProcessTasks();
      return;
    }
    try {
      peerId && await this.network.sendMessage(peerId, msg);
      for (const [cidStr, block] of blocks.entries()) {
        peerId && this.messageSent(peerId, CID.parse(cidStr), block);
      }
    } catch (err) {
      this._log.error(err);
    }
    peerId && this._requestQueue.tasksDone(peerId, tasks);
    this._scheduleProcessTasks();
  }
  wantlistForPeer(peerId) {
    const peerIdStr = peerId.toB58String();
    const ledger = this.ledgerMap.get(peerIdStr);
    return ledger ? ledger.wantlist.sortedEntries() : /* @__PURE__ */ new Map();
  }
  ledgerForPeer(peerId) {
    const peerIdStr = peerId.toB58String();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (!ledger) {
      return null;
    }
    return {
      peer: ledger.partner,
      value: ledger.debtRatio(),
      sent: ledger.accounting.bytesSent,
      recv: ledger.accounting.bytesRecv,
      exchanged: ledger.exchangeCount
    };
  }
  peers() {
    return Array.from(this.ledgerMap.values()).map((l) => l.partner);
  }
  receivedBlocks(blocks) {
    if (!blocks.length) {
      return;
    }
    for (const ledger of this.ledgerMap.values()) {
      for (const block of blocks) {
        const want = ledger.wantlistContains(block.cid);
        if (!want) {
          continue;
        }
        const blockSize = block.data.length;
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        this._requestQueue.pushTasks(ledger.partner, [{
          topic: want.cid.toString(base58btc),
          priority: want.priority,
          size: entrySize,
          data: {
            blockSize,
            isWantBlock,
            haveBlock: true,
            sendDontHave: false
          }
        }]);
      }
    }
    this._scheduleProcessTasks();
  }
  async messageReceived(peerId, msg) {
    const ledger = this._findOrCreate(peerId);
    if (msg.empty) {
      return;
    }
    if (msg.full) {
      ledger.wantlist = new Wantlist();
    }
    this._updateBlockAccounting(msg.blocks, ledger);
    if (msg.wantlist.size === 0) {
      this._scheduleProcessTasks();
      return;
    }
    const cancels = [];
    const wants = [];
    msg.wantlist.forEach((entry) => {
      if (entry.cancel) {
        ledger.cancelWant(entry.cid);
        cancels.push(entry.cid);
      } else {
        ledger.wants(entry.cid, entry.priority, entry.wantType);
        wants.push(entry);
      }
    });
    this._cancelWants(peerId, cancels);
    await this._addWants(peerId, wants);
    this._scheduleProcessTasks();
  }
  _cancelWants(peerId, cids) {
    for (const c of cids) {
      this._requestQueue.remove(c.toString(base58btc), peerId);
    }
  }
  async _addWants(peerId, wants) {
    const blockSizes = await this._getBlockSizes(wants.map((w) => w.cid));
    const tasks = [];
    for (const want of wants) {
      const id = want.cid.toString(base58btc);
      const blockSize = blockSizes.get(id);
      if (blockSize == null) {
        if (want.sendDontHave) {
          tasks.push({
            topic: id,
            priority: want.priority,
            size: BitswapMessage.blockPresenceSize(want.cid),
            data: {
              isWantBlock: want.wantType === WantType2.Block,
              blockSize: 0,
              haveBlock: false,
              sendDontHave: want.sendDontHave
            }
          });
        }
      } else {
        const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
        let entrySize = blockSize;
        if (!isWantBlock) {
          entrySize = BitswapMessage.blockPresenceSize(want.cid);
        }
        tasks.push({
          topic: id,
          priority: want.priority,
          size: entrySize,
          data: {
            isWantBlock,
            blockSize,
            haveBlock: true,
            sendDontHave: want.sendDontHave
          }
        });
      }
      this._requestQueue.pushTasks(peerId, tasks);
    }
  }
  _sendAsBlock(wantType, blockSize) {
    return wantType === WantType2.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;
  }
  async _getBlockSizes(cids) {
    const blocks = await this._getBlocks(cids);
    return new Map([...blocks].map(([k, v]) => [
      k,
      v.length
    ]));
  }
  async _getBlocks(cids) {
    const res = /* @__PURE__ */ new Map();
    await Promise.all(cids.map(async (cid) => {
      try {
        const block = await this.blockstore.get(cid);
        res.set(cid.toString(base58btc), block);
      } catch (e) {
        if (e.code !== "ERR_NOT_FOUND") {
          this._log.error("failed to query blockstore for %s: %s", cid, e);
        }
      }
    }));
    return res;
  }
  _updateBlockAccounting(blocksMap, ledger) {
    for (const block of blocksMap.values()) {
      this._log("got block (%s bytes)", block.length);
      ledger.receivedBytes(block.length);
    }
  }
  messageSent(peerId, cid, block) {
    const ledger = this._findOrCreate(peerId);
    ledger.sentBytes(block.length);
    ledger.wantlist.remove(cid);
  }
  numBytesSentTo(peerId) {
    return this._findOrCreate(peerId).accounting.bytesSent;
  }
  numBytesReceivedFrom(peerId) {
    return this._findOrCreate(peerId).accounting.bytesRecv;
  }
  peerDisconnected(peerId) {
    this.ledgerMap.delete(peerId.toB58String());
  }
  _findOrCreate(peerId) {
    const peerIdStr = peerId.toB58String();
    const ledger = this.ledgerMap.get(peerIdStr);
    if (ledger) {
      return ledger;
    }
    const l = new Ledger(peerId);
    this.ledgerMap.set(peerIdStr, l);
    if (this._stats) {
      this._stats.push(peerIdStr, "peerCount", 1);
    }
    return l;
  }
  start() {
    this._running = true;
  }
  stop() {
    this._running = false;
  }
};

// node_modules/ipfs-bitswap/esm/src/notifications.js
init_globals();
var import_events = __toESM(require_events(), 1);
init_to_string();
var unwantEvent = (cid) => `unwant:${toString3(cid.multihash.bytes, "base64")}`;
var blockEvent = (cid) => `block:${toString3(cid.multihash.bytes, "base64")}`;
var Notifications = class extends import_events.EventEmitter {
  constructor(peerId) {
    super();
    this.setMaxListeners(maxListeners);
    this._log = logger(peerId, "notif");
  }
  hasBlock(cid, block) {
    const event = blockEvent(cid);
    this._log(event);
    this.emit(event, block);
  }
  wantBlock(cid, options = {}) {
    if (!cid) {
      throw new Error("Not a valid cid");
    }
    const blockEvt = blockEvent(cid);
    const unwantEvt = unwantEvent(cid);
    this._log(`wantBlock:${cid}`);
    return new Promise((resolve11, reject) => {
      const onUnwant = () => {
        this.removeListener(blockEvt, onBlock);
        reject(new Error(`Block for ${cid} unwanted`));
      };
      const onBlock = (data) => {
        this.removeListener(unwantEvt, onUnwant);
        resolve11(data);
      };
      this.once(unwantEvt, onUnwant);
      this.once(blockEvt, onBlock);
      if (options && options.signal) {
        options.signal.addEventListener("abort", () => {
          this.removeListener(blockEvt, onBlock);
          this.removeListener(unwantEvt, onUnwant);
          reject(new Error(`Want for ${cid} aborted`));
        });
      }
    });
  }
  unwantBlock(cid) {
    const event = unwantEvent(cid);
    this._log(event);
    this.emit(event);
  }
};

// node_modules/ipfs-bitswap/esm/src/stats/index.js
init_globals();
var import_events3 = __toESM(require_events(), 1);

// node_modules/ipfs-bitswap/esm/src/stats/stat.js
init_globals();
var import_events2 = __toESM(require_events(), 1);
var import_moving_average = __toESM(require_moving_average(), 1);
var Stat = class extends import_events2.EventEmitter {
  constructor(initialCounters, options) {
    super();
    this._options = options;
    this._queue = [];
    this._stats = {};
    this._frequencyLastTime = Date.now();
    this._frequencyAccumulators = {};
    this._movingAverages = {};
    this._update = this._update.bind(this);
    initialCounters.forEach((key) => {
      this._stats[key] = BigInt(0);
      this._movingAverages[key] = {};
      this._options.movingAverageIntervals.forEach((interval) => {
        const ma = this._movingAverages[key][interval] = (0, import_moving_average.default)(interval);
        ma.push(this._frequencyLastTime, 0);
      });
    });
    this._enabled = this._options.enabled;
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._disabled = true;
  }
  stop() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  }
  get snapshot() {
    return Object.assign({}, this._stats);
  }
  get movingAverages() {
    return Object.assign({}, this._movingAverages);
  }
  push(counter, inc) {
    if (this._enabled) {
      this._queue.push([
        counter,
        inc,
        Date.now()
      ]);
      this._resetComputeTimeout();
    }
  }
  _resetComputeTimeout() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeout = setTimeout(this._update, this._nextTimeout());
  }
  _nextTimeout() {
    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
  }
  _update() {
    this._timeout = null;
    if (this._queue.length) {
      let last15;
      while (this._queue.length) {
        const op = last15 = this._queue.shift();
        op && this._applyOp(op);
      }
      last15 && this._updateFrequency(last15[2]);
      this.emit("update", this._stats);
    }
  }
  _updateFrequency(latestTime) {
    const timeDiff = latestTime - this._frequencyLastTime;
    if (timeDiff) {
      Object.keys(this._stats).forEach((key) => {
        this._updateFrequencyFor(key, timeDiff, latestTime);
      });
    }
    this._frequencyLastTime = latestTime;
  }
  _updateFrequencyFor(key, timeDiffMS, latestTime) {
    const count = this._frequencyAccumulators[key] || 0;
    this._frequencyAccumulators[key] = 0;
    const hz = count / timeDiffMS * 1e3;
    let movingAverages = this._movingAverages[key];
    if (!movingAverages) {
      movingAverages = this._movingAverages[key] = {};
    }
    this._options.movingAverageIntervals.forEach((movingAverageInterval) => {
      let movingAverage = movingAverages[movingAverageInterval];
      if (!movingAverage) {
        movingAverage = movingAverages[movingAverageInterval] = (0, import_moving_average.default)(movingAverageInterval);
      }
      movingAverage.push(latestTime, hz);
    });
  }
  _applyOp(op) {
    const key = op[0];
    const inc = op[1];
    if (typeof inc !== "number") {
      throw new Error(`invalid increment number: ${inc}`);
    }
    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
      this._stats[key] = BigInt(0);
    }
    this._stats[key] = BigInt(this._stats[key]) + BigInt(inc);
    if (!this._frequencyAccumulators[key]) {
      this._frequencyAccumulators[key] = 0;
    }
    this._frequencyAccumulators[key] += inc;
  }
};

// node_modules/ipfs-bitswap/esm/src/stats/index.js
var import_tracked_map4 = __toESM(require_tracked_map(), 1);
var defaultOptions14 = {
  enabled: false,
  computeThrottleTimeout: 1e3,
  computeThrottleMaxQueueSize: 1e3,
  movingAverageIntervals: [
    60 * 1e3,
    5 * 60 * 1e3,
    15 * 60 * 1e3
  ]
};
var Stats = class extends import_events3.EventEmitter {
  constructor(libp2p, initialCounters = [], _options = defaultOptions14) {
    super();
    const options = Object.assign({}, defaultOptions14, _options);
    if (typeof options.computeThrottleTimeout !== "number") {
      throw new Error("need computeThrottleTimeout");
    }
    if (typeof options.computeThrottleMaxQueueSize !== "number") {
      throw new Error("need computeThrottleMaxQueueSize");
    }
    this._initialCounters = initialCounters;
    this._options = options;
    this._enabled = this._options.enabled;
    this._global = new Stat(initialCounters, options);
    this._global.on("update", (stats) => this.emit("update", stats));
    this._peers = (0, import_tracked_map4.default)({
      system: "ipfs",
      component: "bitswap",
      metric: "stats-peers",
      metrics: libp2p.metrics
    });
  }
  enable() {
    this._enabled = true;
    this._options.enabled = true;
    this._global.enable();
  }
  disable() {
    this._enabled = false;
    this._options.enabled = false;
    this._global.disable();
  }
  stop() {
    this._enabled = false;
    this._global.stop();
    for (const peerStat of this._peers) {
      peerStat[1].stop();
    }
  }
  get snapshot() {
    return this._global.snapshot;
  }
  get movingAverages() {
    return this._global.movingAverages;
  }
  forPeer(peerId) {
    const peerIdStr = typeof peerId !== "string" && peerId.toB58String ? peerId.toB58String() : `${peerId}`;
    return this._peers.get(peerIdStr);
  }
  push(peer, counter, inc) {
    if (this._enabled) {
      this._global.push(counter, inc);
      if (peer) {
        let peerStats = this._peers.get(peer);
        if (!peerStats) {
          peerStats = new Stat(this._initialCounters, this._options);
          this._peers.set(peer, peerStats);
        }
        peerStats.push(counter, inc);
      }
    }
  }
  disconnected(peer) {
    const peerId = peer.toB58String();
    const peerStats = this._peers.get(peerId);
    if (peerStats) {
      peerStats.stop();
      this._peers.delete(peerId);
    }
  }
};

// node_modules/ipfs-bitswap/esm/src/bitswap.js
var import_any_signal4 = __toESM(require_any_signal(), 1);
init_cid();
var defaultOptions15 = {
  statsEnabled: false,
  statsComputeThrottleTimeout: 1e3,
  statsComputeThrottleMaxQueueSize: 1e3
};
var statsKeys = [
  "blocksReceived",
  "dataReceived",
  "dupBlksReceived",
  "dupDataReceived",
  "blocksSent",
  "dataSent",
  "providesBufferLength",
  "wantListLength",
  "peerCount"
];
var Bitswap = class extends BaseBlockstore {
  constructor(libp2p, blockstore, options = {}) {
    super();
    this._libp2p = libp2p;
    this._log = logger(this.peerId);
    this._options = Object.assign({}, defaultOptions15, options);
    this._stats = new Stats(libp2p, statsKeys, {
      enabled: this._options.statsEnabled,
      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,
      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize
    });
    this.network = new Network(libp2p, this, this._stats, { hashLoader: options.hashLoader });
    this.blockstore = blockstore;
    this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats, libp2p);
    this.wm = new WantManager(this.peerId, this.network, this._stats, libp2p);
    this.notifications = new Notifications(this.peerId);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  get peerId() {
    return this._libp2p.peerId;
  }
  async _receiveMessage(peerId, incoming) {
    try {
      await this.engine.messageReceived(peerId, incoming);
    } catch (err) {
      this._log("failed to receive message", incoming);
    }
    if (incoming.blocks.size === 0) {
      return;
    }
    const received = [];
    for (const [cidStr, data] of incoming.blocks.entries()) {
      const cid = CID.parse(cidStr);
      received.push({
        wasWanted: this.wm.wantlist.contains(cid),
        cid,
        data
      });
    }
    this.wm.cancelWants(received.filter(({ wasWanted }) => wasWanted).map(({ cid }) => cid));
    await Promise.all(received.map(({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)));
  }
  async _handleReceivedBlock(peerId, cid, data, wasWanted) {
    this._log("received block");
    const has = await this.blockstore.has(cid);
    this._updateReceiveCounters(peerId.toB58String(), cid, data, has);
    if (!wasWanted) {
      return;
    }
    await this.put(cid, data);
  }
  _updateReceiveCounters(peerIdStr, cid, data, exists) {
    this._stats.push(peerIdStr, "blocksReceived", 1);
    this._stats.push(peerIdStr, "dataReceived", data.length);
    if (exists) {
      this._stats.push(peerIdStr, "dupBlksReceived", 1);
      this._stats.push(peerIdStr, "dupDataReceived", data.length);
    }
  }
  _receiveError(err) {
    this._log.error("ReceiveError: %s", err.message);
  }
  _onPeerConnected(peerId) {
    this.wm.connected(peerId);
  }
  _onPeerDisconnected(peerId) {
    this.wm.disconnected(peerId);
    this.engine.peerDisconnected(peerId);
    this._stats.disconnected(peerId);
  }
  enableStats() {
    this._stats.enable();
  }
  disableStats() {
    this._stats.disable();
  }
  wantlistForPeer(peerId, _options) {
    return this.engine.wantlistForPeer(peerId);
  }
  ledgerForPeer(peerId) {
    return this.engine.ledgerForPeer(peerId);
  }
  async get(cid, options = {}) {
    const fetchFromNetwork = (cid2, options2) => {
      this.wm.wantBlocks([cid2], options2);
      return this.notifications.wantBlock(cid2, options2);
    };
    let promptedNetwork = false;
    const loadOrFetchFromNetwork = async (cid2, options2) => {
      try {
        const block2 = await this.blockstore.get(cid2, options2);
        return block2;
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
        if (!promptedNetwork) {
          promptedNetwork = true;
          this.network.findAndConnect(cid2).catch((err2) => this._log.error(err2));
        }
        return fetchFromNetwork(cid2, options2);
      }
    };
    const controller = new AbortController();
    const signal = options.signal ? (0, import_any_signal4.anySignal)([
      options.signal,
      controller.signal
    ]) : controller.signal;
    const block = await Promise.race([
      this.notifications.wantBlock(cid, { signal }),
      loadOrFetchFromNetwork(cid, { signal })
    ]);
    controller.abort();
    return block;
  }
  async *getMany(cids, options = {}) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  unwant(cids) {
    const cidsArray = Array.isArray(cids) ? cids : [cids];
    this.wm.unwantBlocks(cidsArray);
    cidsArray.forEach((cid) => this.notifications.unwantBlock(cid));
  }
  cancelWants(cids) {
    this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);
  }
  async put(cid, block, _options) {
    await this.blockstore.put(cid, block);
    this._sendHaveBlockNotifications(cid, block);
  }
  async *putMany(source, options) {
    for await (const { key, value } of this.blockstore.putMany(source, options)) {
      this._sendHaveBlockNotifications(key, value);
      yield {
        key,
        value
      };
    }
  }
  _sendHaveBlockNotifications(cid, data) {
    this.notifications.hasBlock(cid, data);
    this.engine.receivedBlocks([{
      cid,
      data
    }]);
    this.network.provide(cid).catch((err) => {
      this._log.error("Failed to provide: %s", err.message);
    });
  }
  getWantlist() {
    return this.wm.wantlist.entries();
  }
  peers() {
    return this.engine.peers();
  }
  stat() {
    return this._stats;
  }
  async start() {
    this.wm.start();
    await this.network.start();
    this.engine.start();
    this.started = true;
  }
  async stop() {
    this._stats.stop();
    this.wm.stop();
    await this.network.stop();
    this.engine.stop();
    this.started = false;
  }
  unwrap() {
    return this.blockstore;
  }
};

// node_modules/ipfs-bitswap/esm/src/index.js
var createBitswap2 = (libp2p, blockstore, options = {}) => {
  return new Bitswap(libp2p, blockstore, options);
};

// node_modules/ipfs-core/esm/src/components/network.js
var import_multiaddr20 = __toESM(require_src(), 1);
var import_err_code71 = __toESM(require_err_code(), 1);

// node_modules/ipfs-core/esm/src/block-storage.js
init_globals();

// node_modules/blockstore-core/esm/src/index.js
init_globals();

// node_modules/blockstore-core/esm/src/errors.js
var errors_exports5 = {};
__export(errors_exports5, {
  abortedError: () => abortedError2,
  notFoundError: () => notFoundError2
});
init_globals();
var import_err_code70 = __toESM(require_err_code(), 1);
function notFoundError2(err) {
  err = err || new Error("Not Found");
  return (0, import_err_code70.default)(err, "ERR_NOT_FOUND");
}
function abortedError2(err) {
  err = err || new Error("Aborted");
  return (0, import_err_code70.default)(err, "ERR_ABORTED");
}

// node_modules/blockstore-core/esm/src/memory.js
init_globals();
init_base32();
init_raw();
init_cid();
init_digest();

// node_modules/blockstore-core/esm/src/index.js
var Errors2 = { ...errors_exports5 };

// node_modules/ipfs-core/esm/src/block-storage.js
var import_it_merge3 = __toESM(require_it_merge(), 1);
var import_it_pushable4 = __toESM(require_it_pushable(), 1);
var import_it_filter8 = __toESM(require_it_filter(), 1);
var BlockStorage = class extends BaseBlockstore {
  constructor(blockstore, bitswap) {
    super();
    this.child = blockstore;
    this.bitswap = bitswap;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  unwrap() {
    return this.child;
  }
  async put(cid, block, options = {}) {
    if (await this.has(cid)) {
      return;
    }
    if (this.bitswap.isStarted()) {
      await this.bitswap.put(cid, block, options);
    } else {
      await this.child.put(cid, block, options);
    }
  }
  async *putMany(blocks, options = {}) {
    const missingBlocks = (0, import_it_filter8.default)(blocks, async ({ key }) => {
      return !await this.has(key);
    });
    if (this.bitswap.isStarted()) {
      yield* this.bitswap.putMany(missingBlocks, options);
    } else {
      yield* this.child.putMany(missingBlocks, options);
    }
  }
  async get(cid, options = {}) {
    if (!await this.has(cid) && this.bitswap.isStarted()) {
      return this.bitswap.get(cid, options);
    } else {
      return this.child.get(cid, options);
    }
  }
  async *getMany(cids, options = {}) {
    const getFromBitswap = (0, import_it_pushable4.default)();
    const getFromChild = (0, import_it_pushable4.default)();
    Promise.resolve().then(async () => {
      for await (const cid of cids) {
        if (!await this.has(cid) && this.bitswap.isStarted()) {
          getFromBitswap.push(cid);
        } else {
          getFromChild.push(cid);
        }
      }
      getFromBitswap.end();
      getFromChild.end();
    });
    yield* (0, import_it_merge3.default)(this.bitswap.getMany(getFromBitswap, options), this.child.getMany(getFromChild, options));
  }
  async delete(cid, options) {
    await this.child.delete(cid, options);
  }
  async *deleteMany(cids, options) {
    yield* this.child.deleteMany(cids, options);
  }
  async has(cid, options = {}) {
    return this.child.has(cid, options);
  }
  async *query(q, options = {}) {
    yield* this.child.query(q, options);
  }
  async *queryKeys(q, options = {}) {
    yield* this.child.queryKeys(q, options);
  }
};

// node_modules/ipfs-core/esm/src/components/network.js
var Network2 = class {
  constructor(peerId, libp2p, bitswap, repo, blockstore) {
    this.peerId = peerId;
    this.libp2p = libp2p;
    this.bitswap = bitswap;
    this.repo = repo;
    this.blockstore = blockstore;
  }
  static async start({ peerId, repo, print, hashers, options }) {
    if (repo.closed) {
      await repo.open();
    }
    const config2 = await repo.config.getAll();
    const libp2p = await createLibp2p({
      options,
      repo,
      peerId,
      multiaddrs: readAddrs(peerId, config2),
      config: config2,
      keychainConfig: void 0
    });
    if (libp2p.keychain) {
      await libp2p.loadKeychain();
    }
    await libp2p.start();
    for (const ma of libp2p.multiaddrs) {
      print(`Swarm listening on ${ma}/p2p/${peerId.toB58String()}`);
    }
    const bitswap = createBitswap2(libp2p, repo.blocks, {
      statsEnabled: true,
      hashLoader: hashers
    });
    await bitswap.start();
    const blockstore = new BlockStorage(repo.blocks, bitswap);
    repo.blocks = blockstore;
    repo.pins.blockstore = blockstore;
    return new Network2(peerId, libp2p, bitswap, repo, blockstore);
  }
  static async stop(network) {
    network.repo.blocks = network.blockstore.unwrap();
    network.repo.pins.blockstore = network.blockstore.unwrap();
    await network.bitswap.stop();
    await network.libp2p.stop();
  }
};
var readAddrs = (peerId, config2) => {
  const peerIdStr = peerId.toB58String();
  const addrs = [];
  const swarm = config2.Addresses && config2.Addresses.Swarm || [];
  for (const addr of swarm) {
    let ma = new import_multiaddr20.Multiaddr(addr);
    if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {
      throw (0, import_err_code71.default)(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"), "ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");
    }
    const maId = ma.getPeerId();
    if (maId && maId !== peerIdStr) {
      ma = ma.encapsulate(`/p2p/${peerIdStr}`);
    }
    addrs.push(ma);
  }
  return addrs;
};
var WEBSOCKET_STAR_PROTO_CODE = 479;

// node_modules/ipfs-core/esm/src/components/swarm/index.js
init_globals();

// node_modules/ipfs-core/esm/src/components/swarm/addrs.js
init_globals();
function createAddrs2({ network }) {
  async function addrs(options = {}) {
    const peers = [];
    const { libp2p } = await network.use(options);
    for await (const peer of libp2p.peerStore.getPeers()) {
      peers.push({
        id: peer.id.toB58String(),
        addrs: peer.addresses.map((mi) => mi.multiaddr)
      });
    }
    return peers;
  }
  return withTimeoutOption(addrs);
}

// node_modules/ipfs-core/esm/src/components/swarm/connect.js
init_globals();
function createConnect2({ network }) {
  async function connect(addr, options = {}) {
    const { libp2p } = await network.use(options);
    await libp2p.dial(addr, options);
  }
  return withTimeoutOption(connect);
}

// node_modules/ipfs-core/esm/src/components/swarm/disconnect.js
init_globals();
function createDisconnect2({ network }) {
  async function disconnect(addr, options = {}) {
    const { libp2p } = await network.use(options);
    await libp2p.hangUp(addr);
  }
  return withTimeoutOption(disconnect);
}

// node_modules/ipfs-core/esm/src/components/swarm/local-addrs.js
init_globals();
function createLocalAddrs2({ network }) {
  async function localAddrs(options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.multiaddrs;
  }
  return withTimeoutOption(localAddrs);
}

// node_modules/ipfs-core/esm/src/components/swarm/peers.js
init_globals();
function createPeers3({ network }) {
  async function peers(options = {}) {
    const { libp2p } = await network.use(options);
    const peers2 = [];
    for (const [peerId, connections] of libp2p.connections) {
      for (const connection of connections) {
        const peer = {
          addr: connection.remoteAddr,
          peer: peerId
        };
        if (options.verbose || options.direction) {
          peer.direction = connection.stat.direction;
        }
        if (options.verbose) {
          peer.muxer = connection.stat.multiplexer;
          peer.latency = "n/a";
          peer.streams = [];
        }
        peers2.push(peer);
      }
    }
    return peers2;
  }
  return withTimeoutOption(peers);
}

// node_modules/ipfs-core/esm/src/components/swarm/index.js
var SwarmAPI = class {
  constructor({ network }) {
    this.addrs = createAddrs2({ network });
    this.connect = createConnect2({ network });
    this.disconnect = createDisconnect2({ network });
    this.localAddrs = createLocalAddrs2({ network });
    this.peers = createPeers3({ network });
  }
};

// node_modules/ipfs-core/esm/src/components/ping.js
init_globals();
var import_peer_id12 = __toESM(require_src5(), 1);
var basePacket = {
  success: true,
  time: 0,
  text: ""
};
function createPing2({ network }) {
  async function* ping(peerId, options = {}) {
    const { libp2p } = await network.use();
    options.count = options.count || 10;
    const peer = import_peer_id12.default.createFromB58String(peerId);
    const storedPeer = await libp2p.peerStore.get(peer);
    let id = storedPeer && storedPeer.id;
    if (!id) {
      yield {
        ...basePacket,
        text: `Looking up peer ${peerId}`
      };
      const remotePeer = await libp2p.peerRouting.findPeer(peer);
      id = remotePeer && remotePeer.id;
    }
    if (!id) {
      throw new Error("Peer was not found");
    }
    yield {
      ...basePacket,
      text: `PING ${id.toB58String()}`
    };
    let packetCount = 0;
    let totalTime = 0;
    for (let i = 0; i < options.count; i++) {
      try {
        const time = await libp2p.ping(id);
        totalTime += time;
        packetCount++;
        yield {
          ...basePacket,
          time
        };
      } catch (err) {
        yield {
          ...basePacket,
          success: false,
          text: err.toString()
        };
      }
    }
    if (packetCount) {
      const average = totalTime / packetCount;
      yield {
        ...basePacket,
        text: `Average latency: ${average}ms`
      };
    }
  }
  return withTimeoutOption(ping);
}

// node_modules/ipfs-core/esm/src/components/dht.js
init_globals();
var import_peer_id13 = __toESM(require_src5(), 1);
var import_err_code72 = __toESM(require_err_code(), 1);
var import_dlv3 = __toESM(require_dlv_umd(), 1);
var import_it_map11 = __toESM(require_it_map(), 1);
init_cid();
init_base58();
init_base36();
init_concat();
init_from_string();
var IPNS_PREFIX2 = "/ipns/";
function toDHTKey(str) {
  if (str.startsWith(IPNS_PREFIX2)) {
    str = str.substring(IPNS_PREFIX2.length);
  }
  let buf3;
  if (str[0] === "1" || str[0] === "Q") {
    str = `z${str}`;
  }
  if (str[0] === "z") {
    buf3 = base58btc.decode(str);
  }
  if (str[0] === "k") {
    buf3 = base36.decode(str);
  }
  if (!buf3) {
    throw new Error("Could not parse string");
  }
  if (buf3[0] !== 1 && buf3[1] !== 114) {
    buf3 = concat2([
      [
        1,
        114
      ],
      buf3
    ]);
  }
  if (buf3.length !== 40) {
    throw new Error("Incorrect length " + buf3.length);
  }
  return concat2([
    fromString3(IPNS_PREFIX2),
    buf3.subarray(2)
  ]);
}
function mapEvent2(event) {
  if (event.name === "SENDING_QUERY") {
    return {
      type: event.type,
      name: event.name,
      to: event.to.toB58String()
    };
  }
  if (event.name === "PEER_RESPONSE") {
    return {
      type: event.type,
      name: event.name,
      messageType: event.messageType,
      messageName: event.messageName,
      closer: event.closer.map(({ id, multiaddrs }) => ({
        id: id.toB58String(),
        multiaddrs
      })),
      providers: event.providers.map(({ id, multiaddrs }) => ({
        id: id.toB58String(),
        multiaddrs
      })),
      record: event.record,
      from: event.from.toB58String()
    };
  }
  if (event.name === "FINAL_PEER") {
    return {
      type: event.type,
      name: event.name,
      from: event.from.toB58String(),
      peer: {
        id: event.peer.id.toB58String(),
        multiaddrs: event.peer.multiaddrs
      }
    };
  }
  if (event.name === "QUERY_ERROR") {
    return {
      type: event.type,
      name: event.name,
      error: event.error,
      from: event.from.toB58String()
    };
  }
  if (event.name === "PROVIDER") {
    return {
      type: event.type,
      name: event.name,
      providers: event.providers.map(({ id, multiaddrs }) => ({
        id: id.toB58String(),
        multiaddrs
      })),
      from: event.from.toB58String()
    };
  }
  if (event.name === "VALUE") {
    return {
      type: event.type,
      name: event.name,
      value: event.value,
      from: event.from.toB58String()
    };
  }
  if (event.name === "ADDING_PEER") {
    return {
      type: event.type,
      name: event.name,
      peer: event.peer.toB58String()
    };
  }
  if (event.name === "DIALING_PEER") {
    return {
      type: event.type,
      name: event.name,
      peer: event.peer.toB58String()
    };
  }
  throw (0, import_err_code72.default)(new Error("Unknown DHT event type"), "ERR_UNKNOWN_DHT_EVENT");
}
function createDht2({ network, repo, peerId }) {
  const { get: get6, put, findProvs, findPeer: findPeer2, provide, query } = {
    async *get(key, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      yield* (0, import_it_map11.default)(libp2p._dht.get(dhtKey, options), mapEvent2);
    },
    async *put(key, value, options) {
      const { libp2p } = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      yield* (0, import_it_map11.default)(libp2p._dht.put(dhtKey, value), mapEvent2);
    },
    async *findProvs(cid, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      yield* (0, import_it_map11.default)(libp2p._dht.findProviders(cid, { signal: options.signal }), mapEvent2);
    },
    async *findPeer(peerIdToFind, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      yield* (0, import_it_map11.default)(libp2p._dht.findPeer(import_peer_id13.default.parse(peerIdToFind), { signal: options.signal }), mapEvent2);
    },
    async *provide(cid, options = { recursive: false }) {
      const { libp2p } = await use(network, peerId, options);
      const hasBlock = await repo.blocks.has(cid);
      if (!hasBlock) {
        throw (0, import_err_code72.default)(new Error("block(s) not found locally, cannot provide"), "ERR_BLOCK_NOT_FOUND");
      }
      if (options.recursive) {
        throw (0, import_err_code72.default)(new Error("not implemented yet"), "ERR_NOT_IMPLEMENTED_YET");
      }
      yield* (0, import_it_map11.default)(libp2p._dht.provide(cid), mapEvent2);
    },
    async *query(peerIdToQuery, options = {}) {
      const { libp2p } = await use(network, peerId, options);
      let bytes2;
      const asCid = CID.asCID(peerIdToQuery);
      if (asCid != null) {
        bytes2 = asCid.multihash.bytes;
      } else {
        bytes2 = import_peer_id13.default.parse(peerIdToQuery.toString()).toBytes();
      }
      yield* (0, import_it_map11.default)(libp2p._dht.getClosestPeers(bytes2, options), mapEvent2);
    }
  };
  return {
    get: withTimeoutOption(get6),
    put: withTimeoutOption(put),
    findProvs: withTimeoutOption(findProvs),
    findPeer: withTimeoutOption(findPeer2),
    provide: withTimeoutOption(provide),
    query: withTimeoutOption(query)
  };
}
var use = async (network, peerId, options) => {
  const net = await network.use(options);
  if ((0, import_dlv3.default)(net.libp2p, "_config.dht.enabled", false)) {
    return net;
  } else {
    const fn = async function* () {
      yield {
        from: peerId,
        name: "QUERY_ERROR",
        type: 3,
        error: new NotEnabledError("dht not enabled")
      };
    };
    return {
      libp2p: {
        _dht: {
          get: fn,
          put: fn,
          findProvs: fn,
          findPeer: fn,
          provide: fn,
          query: fn
        }
      }
    };
  }
};

// node_modules/ipfs-core/esm/src/components/pubsub.js
init_globals();
var import_err_code73 = __toESM(require_err_code(), 1);
var import_dlv4 = __toESM(require_dlv_umd(), 1);
function createPubsub3({ network, config: config2 }) {
  const isEnabled = (0, import_dlv4.default)(config2 || {}, "Pubsub.Enabled", true);
  return {
    subscribe: isEnabled ? withTimeoutOption(subscribe) : notEnabled,
    unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,
    publish: isEnabled ? withTimeoutOption(publish) : notEnabled,
    ls: isEnabled ? withTimeoutOption(ls) : notEnabled,
    peers: isEnabled ? withTimeoutOption(peers) : notEnabled
  };
  async function subscribe(topic, handler, options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.pubsub.subscribe(topic, handler, options);
  }
  async function unsubscribe(topic, handler, options = {}) {
    const { libp2p } = await network.use(options);
    libp2p.pubsub.unsubscribe(topic, handler, options);
  }
  async function publish(topic, data, options = {}) {
    const { libp2p } = await network.use(options);
    if (!data) {
      throw (0, import_err_code73.default)(new Error('argument "data" is required'), "ERR_ARG_REQUIRED");
    }
    await libp2p.pubsub.publish(topic, data);
  }
  async function ls(options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.pubsub.getTopics();
  }
  async function peers(topic, options = {}) {
    const { libp2p } = await network.use(options);
    return libp2p.pubsub.getSubscribers(topic);
  }
}
var notEnabled = async () => {
  throw new NotEnabledError("pubsub not enabled");
};

// node_modules/ipfs-core/esm/src/components/index.js
var mergeOptions16 = merge_options_default.bind({ ignoreUndefined: true });
var log47 = Object.assign((0, import_debug49.default)("ipfs"), { error: (0, import_debug49.default)("ipfs:error") });
var IPFS = class {
  constructor({ print, storage, codecs: codecs2, options }) {
    const { peerId, repo, keychain } = storage;
    const network = Service.create(Network2);
    const preload2 = createPreloader(options.preload);
    const dns = createDns();
    const isOnline = createIsOnline({ network });
    const ipns = new IPNSAPI(options);
    const multihashHashers = Object.values(hashes);
    (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
    this.hashers = new Multihashes({
      hashers: multihashHashers,
      loadHasher: options.ipld && options.ipld.loadHasher
    });
    const multibaseCodecs = Object.values(bases);
    (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base4) => multibaseCodecs.push(base4));
    this.bases = new Multibases({
      bases: multibaseCodecs,
      loadBase: options.ipld && options.ipld.loadBase
    });
    const pin = new PinAPI({
      repo,
      codecs: codecs2
    });
    const block = new BlockAPI({
      codecs: codecs2,
      hashers: this.hashers,
      preload: preload2,
      repo
    });
    const name10 = new NameAPI({
      dns,
      ipns,
      repo,
      codecs: codecs2,
      peerId,
      isOnline,
      keychain,
      options
    });
    const resolve11 = createResolve({
      repo,
      codecs: codecs2,
      bases: this.bases,
      name: name10
    });
    const dag = new DagAPI({
      repo,
      codecs: codecs2,
      hashers: this.hashers,
      preload: preload2
    });
    const refs = Object.assign(createRefs({
      repo,
      codecs: codecs2,
      resolve: resolve11,
      preload: preload2
    }), { local: createLocal({ repo: storage.repo }) });
    const { add, addAll, cat, get: get6, ls } = new RootAPI({
      preload: preload2,
      repo,
      options: options.EXPERIMENTAL,
      hashers: this.hashers
    });
    const files = createFiles({
      repo,
      preload: preload2,
      hashers: this.hashers,
      options
    });
    const mfsPreload = createMfsPreloader({
      files,
      preload: preload2,
      options: options.preload
    });
    this.preload = preload2;
    this.name = name10;
    this.ipns = ipns;
    this.pin = pin;
    this.resolve = resolve11;
    this.block = block;
    this.refs = refs;
    this.start = createStart({
      network,
      peerId,
      repo,
      preload: preload2,
      ipns,
      mfsPreload,
      print,
      keychain,
      hashers: this.hashers,
      options
    });
    this.stop = createStop({
      network,
      preload: preload2,
      mfsPreload,
      ipns,
      repo
    });
    this.dht = createDht2({
      network,
      repo,
      peerId
    });
    this.pubsub = createPubsub3({
      network,
      config: options.config
    });
    this.dns = dns;
    this.isOnline = isOnline;
    this.id = createId({
      network,
      peerId
    });
    this.version = createVersion({ repo });
    this.bitswap = new BitswapAPI({ network });
    this.bootstrap = new BootstrapAPI({ repo });
    this.config = createConfig({ repo });
    this.ping = createPing2({ network });
    this.add = add;
    this.addAll = addAll;
    this.cat = cat;
    this.get = get6;
    this.ls = ls;
    this.dag = dag;
    this.files = files;
    this.key = new KeyAPI({ keychain });
    this.object = new ObjectAPI({
      preload: preload2,
      codecs: codecs2,
      repo
    });
    this.repo = new RepoAPI({
      repo,
      hashers: this.hashers
    });
    this.stats = new StatsAPI({
      repo,
      network
    });
    this.swarm = new SwarmAPI({ network });
    Object.defineProperty(this, "libp2p", {
      get() {
        const net = network.try();
        return net ? net.libp2p : void 0;
      }
    });
    const notImplemented = () => Promise.reject((0, import_err_code74.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED"));
    const notImplementedIter = async function* () {
      throw (0, import_err_code74.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
    };
    this.commands = notImplemented;
    this.diag = {
      cmds: notImplemented,
      net: notImplemented,
      sys: notImplemented
    };
    this.log = {
      level: notImplemented,
      ls: notImplemented,
      tail: notImplementedIter
    };
    this.mount = notImplemented;
    this.codecs = codecs2;
  }
  async init() {
    throw new AlreadyInitializedError();
  }
};
var addEmptyDir2 = async (ipfs2) => {
  const buf3 = encode3({
    Data: new UnixFS({ type: "directory" }).marshal(),
    Links: []
  });
  const cid = await ipfs2.block.put(buf3, {
    mhtype: "sha2-256",
    format: "dag-pb"
  });
  await ipfs2.pin.add(cid);
  return cid;
};
var getDefaultOptions = () => ({
  start: true,
  EXPERIMENTAL: {},
  preload: {
    enabled: !import_env2.isTest,
    addresses: [
      "/dns4/node0.preload.ipfs.io/https",
      "/dns4/node1.preload.ipfs.io/https",
      "/dns4/node2.preload.ipfs.io/https",
      "/dns4/node3.preload.ipfs.io/https"
    ]
  }
});
async function create6(options = {}) {
  options = mergeOptions16(getDefaultOptions(), options);
  const initOptions = options.init || {};
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const blockCodecs = Object.values(codecs);
  [
    src_exports2,
    esm_exports,
    esm_exports2,
    dagJOSE2,
    id
  ].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const print = options.silent ? log47 : console.log;
  log47("creating repo");
  const storage = await Storage.start(print, multicodecs, options);
  log47("getting repo config");
  const config2 = await storage.repo.config.getAll();
  const ipfs2 = new IPFS({
    storage,
    print,
    codecs: multicodecs,
    options: {
      ...options,
      config: config2
    }
  });
  log47("starting preload");
  await ipfs2.preload.start();
  log47("starting storage");
  ipfs2.ipns.startOffline(storage);
  if (storage.isNew && !initOptions.emptyRepo) {
    const cid = await addEmptyDir2(ipfs2);
    log47("adding default assets");
    await initAssets({
      addAll: ipfs2.addAll,
      print
    });
    log47("initializing IPNS keyspace");
    await ipfs2.ipns.initializeKeyspace(storage.peerId.privKey, fromString3(`/ipfs/${cid}`));
  }
  if (options.start !== false) {
    log47("starting node");
    await ipfs2.start();
  }
  return ipfs2;
}

// node_modules/ipfs-core/esm/src/index.js
var import_libp2p_crypto4 = __toESM(require_src6(), 1);
var import_is_ipfs5 = __toESM(require_src3(), 1);
var import_peer_id14 = __toESM(require_src5(), 1);
var import_glob_source2 = __toESM(require_glob_source(), 1);
var import_url_source2 = __toESM(require_url_source(), 1);
init_cid();
var import_multiaddr21 = __toESM(require_src(), 1);
var create7 = create6;
var crypto5 = import_libp2p_crypto4.default;
var isIPFS2 = import_is_ipfs5.default;
var PeerId13 = import_peer_id14.default;
var globSource = import_glob_source2.default;
var urlSource = import_url_source2.default;

// index.js
var makeIpfsFetch = require_js_ipfs_fetch();
export {
  src_exports7 as IPFS,
  makeIpfsFetch,
  src_exports as trystero
};
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * Timestamp for 64-bit time_t, nanosecond precision and strftime
 *
 * @author Yusuke Kawasaki
 * @license MIT
 * @see https://github.com/kawanet/timestamp-nano
 */
